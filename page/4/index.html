<!-- build time:Wed Aug 17 2022 14:32:47 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Tracy-xu&#39;Blog"><meta name="author" content="Tracy Xu"><meta property="og:title" content="Tracy-xu&#39;Blog"><meta property="og:description" content="Tracy-xu&#39;Blog"><meta property="og:site_name" content="Tracy-xu&#39;Blog"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><title>page - Tracy-xu&#39;Blog</title><link rel="stylesheet" href="/plugins/bootstrap/css/bootstrap.min.css" type="text/css"><link href="/plugins/font-awesome/css/font-awesome.min.css" type="text/css" rel="stylesheet"><link href="/plugins/featherlight/featherlight.min.css" type="text/css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"></head><body><div class="bg-gradient"></div><div class="bg-pattern"></div><div class="menu-bg"><div class="menu-container"><ul><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/about.html">关于我</a></li></ul></div></div><nav><a href="#menu"></a></nav><div class="container"><div class="row"><div class="col-sm-12"><header><div class="logo"><a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a><h1 id="main-title" class="title">Tracy-xu'Blog</h1></div></header><section class="main"><div class="post"><div class="post-header index"><h1 class="title"><a href="/2019/07/01/Sinopia/">NPM 私仓</a></h1><div class="post-info"><span class="date">2019-07-01</span> <span class="category"><a href="/categories/engineering/">engineering</a></span></div></div><div class="content"><p>npm 私仓可用于提高包的下载速度和保护内部代码，常见的 npm 私仓技术方案有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* npm on-site  # 缺点是收费，而且 npm 在国内访问慢</span><br><span class="line">* Git + SSH 直接引用到 GitHub 项目地址 # 缺点是不能更新（npm update），不能使用 Semver（语义化版本规范），而且 URL 不美观</span><br><span class="line">* cnpm</span><br><span class="line">* Sinopia/Verdaccio</span><br><span class="line">* Nexus</span><br></pre></td></tr></table></figure></div><a href="/2019/07/01/Sinopia/" class="read-more">Read More</a></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2019/04/25/Git-Flow/">Git Flow</a></h1><div class="post-info"><span class="date">2019-04-25</span> <span class="category"><a href="/categories/engineering/">engineering</a></span></div></div><div class="content"><p>Git 工作流（Work Flow）是一种分支管理策略。在开发人员较少，项目不复杂时，可以采用简单的工作流，比如只有一个 Master 分支，但当项目庞大，迭代周期长，多人协作，多需求并行时，就需要更加严格的 Work Flow 来管理开发、测试、发布和热修复了。在 Git 中常见的工作流有 Git Flow、GitHub Flow、GitLab Flow。</p></div><a href="/2019/04/25/Git-Flow/" class="read-more">Read More</a></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2019/04/20/Git-Commit-Message-Style-Guide/">Git Commit Message Style Guide</a></h1><div class="post-info"><span class="date">2019-04-20</span> <span class="category"><a href="/categories/engineering/">engineering</a></span></div></div><div class="content"><p>在 Git 中，我们使用 <code>git commit -m &quot;xxx&quot;</code> 来提交代码，参数 <code>-m</code> 用来指定 Commit Message（提交说明），直接执行 <code>git commit</code> 会进入编辑器模式，可提交多行说明。Commit Message 应规范化，规范化的 Commit Message 能带来很多好处：</p></div><a href="/2019/04/20/Git-Commit-Message-Style-Guide/" class="read-more">Read More</a></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2019/04/06/xxsd/">西溪湿地半日游</a></h1><div class="post-info"><span class="date">2019-04-06</span> <span class="category"><a href="/categories/jotting/">jotting</a></span></div></div><div class="content"><p><img src="/images/jotting/482317088.jpg" alt="西西湿地"><br>[图 1] 慢生活街区店前花圃 1</p></div><a href="/2019/04/06/xxsd/" class="read-more">Read More</a></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2019/04/01/Javascript-Date-Something/">记录 Date 中的两个坑</a></h1><div class="post-info"><span class="date">2019-04-01</span> <span class="category"><a href="/categories/javascript/">javascript</a></span></div></div><div class="content"><h2 id="new-Date-参数-dataString-格式问题"><a href="#new-Date-参数-dataString-格式问题" class="headerlink" title="new Date 参数 dataString 格式问题"></a>new Date 参数 dataString 格式问题</h2><p>new Date(dataString) 中，参数 dataString 必须符合 ISO 8601 标准或者 RFC 2822 标准，现代主流浏览器这两个标准都支持（IE8 只支持 RFC 2822，不支持 ISO 8601）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(&apos;2019-01-25T09:14:10.099+00:00&apos;).getTime();    // ISO 8601 标准。返回 1548407650099</span><br><span class="line">new Date(&apos;2019/01/25 09:14:10+0000&apos;).getTime();         // RFC 2822 标准。返回 1548407650000</span><br></pre></td></tr></table></figure><p>然而，在实际工作中，后台（Java）返回的是格式既不是标准的 ISO 8601 也不是标准的 RFC 2822 格式，而是 ISO 8601 和 RFC 2822 混合格式，时区使用的是 RFC 2822 格式，比如，2019-01-25T09:14:10.099+0000，这个格式只有 Chrome 支持，其他浏览器都不支持（比如 iOS WebView、IE），执行 getTime 操作会返回 NaN：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date(&apos;2019-01-25T09:14:10.099+0000&apos;).getTime();     // NaN</span><br></pre></td></tr></table></figure></div><a href="/2019/04/01/Javascript-Date-Something/" class="read-more">Read More</a></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2018/02/03/前后端分离/">前后端分离</a></h1><div class="post-info"><span class="date">2018-02-03</span> <span class="category"><a href="/categories/engineering/">engineering</a></span></div></div><div class="content"><ul><li>会话保持</li></ul><p>由于 http stateless</p><p>cookie, 持久化(storage 或者 spa state) + http header</p><p>注: cookie 是保存在客户端浏览器的，存在服务端的叫 session，为了安全 cookie 一般通过 sessionId 来保持会话</p><p>注: 会话是有有效期的，不单单后端，前端也需要做过期处理，道理跟前端需要验证接口字段一样，后端是为了安全，前端是为了更好的用户交互</p><ul><li>鉴权和权限控制</li></ul><p>路由的鉴权（前端路由和后端路由/接口，接口的鉴权由后端完成，ajax 响应拦截处 根据 http code 401 跳登录页即可，前端路由鉴权在路由拦截处根据路由的配置信息完成，noAuth 则放行，否则检查 token，判断 token 是否有效，无效则带上redirect跳登录页 ）、UI 的权限控制（其中关于菜单&lt;菜单可根据路由生成，路由配置中配置权限&gt;，其他的还有按钮…）</p><p>多角色需要做权限控制</p><p>权和权限控制的关系</p><p>​认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系。认证–&gt;授权–&gt;鉴权–&gt;权限控制</p><p>用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。</p><ul><li>前端路由和菜单</li></ul><p>路由的配置数据就可以描述一个菜单的结构以及数据，不需要单独配置菜单数据</p><p>UI 复用可通过导入复用或子路由复用</p><p>子路由在父组件的 router-view 中渲染，根路由在根 router-view 中渲染。</p><p>嵌套路由的目的是为了 UI 复用，</p></div></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2016/12/02/CSS 设计模式/">CSS 设计模式</a></h1><div class="post-info"><span class="date">2016-12-02</span> <span class="category"><a href="/categories/css/">css</a></span></div></div><div class="content"><p>大型的 CSS 项目中，往往会遇到 CSS 结构混乱、多人协作命名冲突、没有组件化无法复用…等等问题。为了解决这些问题于是引入 CSS 设计模式，用 BEM 来解决命名空间的问题，用 SMACSS 来解决代码分层问题，用 OOCSS 来解决解构复用问题。</p><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>对于 CSS 选择器的命名空间，一般的做法是通过选择器嵌套来约束命名空间，但是这种方式带来了很多问题 – 嵌套层次深不但影响了性能也导致了重度的 DOM 依赖，还有最重要的是命名冲突。</p><p>一个优秀的 CSS 命名方案，应该要解决以下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 具备 NameSpace；</span><br><span class="line">* 不能与嵌套的业务样式命名冲突；</span><br><span class="line">* 独立、对上层不过度依赖；</span><br></pre></td></tr></table></figure><p>BEM 的出现解决了上述问题。</p><p>BEM 中，B 代表 Block（Component）、E 代表 Element、M 代表 Modify。规定用 <code>__</code> 连接 E，用 <code>--</code>连接 M，用 <code>-</code> 连接单词和命名前缀。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.m-page</span><br><span class="line">.m-page__item</span><br><span class="line">.m-page__item--cur</span><br><span class="line">.m-page--center</span><br></pre></td></tr></table></figure><p>注：BEM 最多只有三层，不可能存在嵌套的 Element，比如 <code>.m-page__item__anchor--cur</code>。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS 是一个比较全面的 CSS 规范，它不但规范了命名空间，还对 CSS 进行了分层。具体到项目中，只参考它的分层。</p><h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>命名前缀用于说明 UI 类型归属，可以结合 BEM 一同使用，用于说明 Block 的类型。</p><ul><li>g-栅格</li></ul><p>简单栅格系统：用户后台 <code>g-hd</code>、<code>g-fd</code>、<code>g-bd</code>、<code>g-sd</code>、<code>g-mn</code>，前台和中间页 <code>g-head</code>、<code>g-body</code>、<code>g-foot</code>。</p><ul><li>f-原子类</li></ul><p>常用原子类：<code>f-bfc</code>、<code>f-clearfix</code>、<code>f-ellipsis</code>、<code>f-show</code>、<code>f-hide</code>、<code>f-cb</code>…。</p><p>定义原子类必须谨慎，功能性的原子类还好（<code>f-clearfix</code>、<code>f-bfc</code>），描述性的原子类必须谨慎（比如 <code>f-w100</code>）。原子类的使用场景是供后端使用的，或者前端 fix issue 时紧急使用。</p><p>原子类的缺陷：与 inline style 无异，没有做到结构与样式的分离；容易导致 class 臃肿。</p><ul><li>u-元件</li></ul><p>常用元件：<code>u-btn</code>、<code>u-ipt</code>、<code>u-select</code>、<code>u-line</code>、<code>u-link</code>…。</p><p>利用 OOCSS 来对页面元素进行抽象，是一种非常好的做法，这样可以通过继承，组合出不同的样式。但是也有导致 class 的臃肿的缺点，不过为了前者的实用性，后者的这点缺点也算不了什么。</p><ul><li>m-组件</li></ul><p>常用的 UI 组件：<code>m-tab</code>、<code>m-table</code>、<code>m-form</code>、<code>m-page</code>、<code>m-dialog</code>、<code>m-btns</code>、<code>m-select</code>、<code>m-search-box...</code>、<code>m-header</code>、<code>m-footer</code>…。</p><p>UI 的组件化也就是 HTML、CSS 的组件化。模块化、组件化的目的是封装（作用域隔离）、复用，这使得代码简洁易读易维护，按照最小组件化原则，非常有利于项目在快速迭代中的发展。</p><p>组件化原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 组件化抽象的第一原则是复用（这也是 m 与 c 最主要的区别）；</span><br><span class="line">* 各个组件独立划分，充分解耦，遵守职责单一原则；</span><br><span class="line">* 业务 m 不能与全局 m 冲突，业务 m 要带上业务前缀（比如，m-header-mall），必要时还要加上模块前缀（比如，m-title-mall-index）；</span><br></pre></td></tr></table></figure><p>自定义组件：</p><p>当组件化不满足场景时，可对 modify 进行自定义（组件不满足场景大部分是 modify 不满足）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m-page--center</span><br><span class="line">c-choiceness-stage__carousel--junior</span><br><span class="line">c-choiceness-stage__carousel--high</span><br><span class="line">c-choiceness-stage__carousel--senior</span><br></pre></td></tr></table></figure><ul><li>c-模块</li></ul><p>整个 UI 都可以被模块化，包括业务，使用 <code>c-xx</code> 来作为命名前缀（c 指代 component，表示模块，而非 custom）。</p><p>component 和 module 的区别：component 包含 module，module 是 component 的组成部分，组件一般是可高度复用，可在整个项目或者跨项目通用的，这里的 c 其实指的是不可复用的业务模块（<code>模块 - 组件 = 不可复用的业务模块</code>），主要目的是封装，不具备 m 一样的复用能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-login      # login 不能被复用，所以这里不能用 m-login</span><br></pre></td></tr></table></figure><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCSS 只是一种思想，并没有具体的规范，用 OO 的方式来对 CSS 进行解构抽象，能够达到很好的作用域封装和复用效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.u-btn .u-btn--normal .u-btn--gray</span><br><span class="line">.m-page .m-page--center</span><br><span class="line">.m-tips .m-tips--success</span><br></pre></td></tr></table></figure></div></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2016/11/20/CSS 预处理器 Sass/">CSS 预处理器 Sass</a></h1><div class="post-info"><span class="date">2016-11-20</span> <span class="category"><a href="/categories/css/">css</a></span></div></div><div class="content"><p>Sass 是一种 CSS 预处理语言。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>Sass 的编译器实现有 Ruby Sass、LibSass、Dart Sass，这 3 代编译器都不是 JavaScript 实现的（Less、Stylus 的编译器都是 JavaScript 实现的）。</p><p>Ruby Sass 是最早的 Sass 编译器，用 Ruby 实现的，因为不能被 Node 调用，社区出现了 C++ 实现的 LibSass，在前端工作流中通过 node-sass 这个 Node Bridge 来调用。node-sass 是一个 Nodejs 环境下提供的一个 Bridge，它提供了调用 LibSass 的能力。</p><p>因为 LibSass 的维护速度跟不上 CSS 和 Sass 标准，已被官方废弃，另外 node-sass 对 node 版本有要求，而且还难以安装。vue-cli 在 5.0 后也移除了 node-sass。</p><p>Dart Sass 是用 Dart 来写的 Sass 编译器，Dart 可以编译为 JavaScript，在 npm 上包名为 sass，这是编译后的纯 JavaScript 包，纯 JavaScript 版本虽然比 Dart 版本慢，但易于集成到现有的前端工作流程中。Dart Sass 代表着未来，是被官方推荐的 Sass 编译器。</p><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><p>node-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass.</p><p><a href="https://www.jianshu.com/p/d3c577209eae" target="_blank" rel="noopener">https://www.jianshu.com/p/d3c577209eae</a></p><p><a href="https://blog.csdn.net/lzfengquan/article/details/122818098" target="_blank" rel="noopener">https://blog.csdn.net/lzfengquan/article/details/122818098</a></p><p><a href="https://blog.csdn.net/weixin_45847735/article/details/122084202" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45847735/article/details/122084202</a></p><p><a href="https://developer.51cto.com/article/698854.html" target="_blank" rel="noopener">https://developer.51cto.com/article/698854.html</a></p><p><a href="https://www.jb51.net/article/180781.htm" target="_blank" rel="noopener">https://www.jb51.net/article/180781.htm</a></p><p><a href="https://blog.csdn.net/weixin_41196185/article/details/117341722" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41196185/article/details/117341722</a></p><p><a href="https://sass-lang.com/Dart" target="_blank" rel="noopener">https://sass-lang.com/Dart</a> Sass</p><p>用 Dart Sass 代替 node-sass</p><p><a href="https://blog.csdn.net/qq_36657291/article/details/121995360" target="_blank" rel="noopener">https://blog.csdn.net/qq_36657291/article/details/121995360</a></p><p>which python3<br>which node</p><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如<code>Variables(变量)</code>，<code>Mixins</code>(混合)、<code>Nested Rules(嵌套规则)</code>、<code>Functions &amp; Operations(函数和运算)</code>等功能，让 CSS 更易维护、方便制作主题、扩充。</p><p>Less可以运行在客户端(浏览器)和服务器(如Node.js)上，不过一般都是在本地预编译。Bootstrap3就是采用了Less作为CSS预处理器。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>###常用语法</p><p>略…</p><ul><li>Less中的一些注意事项：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+             # 只能用来计算，不能用于拼接字符串</span><br><span class="line">@import “”；  # 必须是双引号，必须要有分号</span><br><span class="line">.fun(@n - 1); # 运算符的前后一定要有空格，要不然会报错，当字符串使用</span><br><span class="line">.fun();       # 必须要有分号</span><br><span class="line">@&#123;name&#125;       # 变量可以用像这样的结构（类似ruby和php），嵌入到字符串中</span><br><span class="line">@icon-font-path: &quot;fonts/&quot;;  # Less定义变量不用加&quot;&quot;，如果加&quot;&quot;表示需要转义（防止编译的时候被编译）</span><br><span class="line">避免编译      # 有时候需要输出一些不正确的css语法，或者使用一些LESS不认识的专有语法（比如微软滤镜filter等），为了避免编译器报一些不必要的错误，帮我们做了一些不必要的事情。我们可以在字符串前加上一个~，加单引号/双引号，Eg:  width:~&apos;calc(100% - 35)&apos;不加的话，会被计算出结果的（其实你是想让浏览器来计算，而不是编译器来计算）。</span><br></pre></td></tr></table></figure></div></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2016/09/05/排序算法/">排序算法</a></h1><div class="post-info"><span class="date">2016-09-05</span> <span class="category"><a href="/categories/algorithms/">algorithms</a></span></div></div><div class="content"><p><a href="https://juejin.cn/post/7073640285904830471#heading-22" target="_blank" rel="noopener">https://juejin.cn/post/7073640285904830471#heading-22</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外循环，几轮冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="comment">// 共进行 arr.length 轮冒泡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="comment">// 俩俩对比，最后一个元素后面没有元素了，所以减 1，已冒泡上去的元素无需再参与，所以减 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]; <span class="comment">// distribute 交换数组位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>]));</span><br></pre></td></tr></table></figure><p>也可在原型链上扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>[j] - <span class="keyword">this</span>[j + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123; <span class="comment">// 其实就是 compareFn() &gt; 0，条件为真时，才调换位置</span></span><br><span class="line">        temp = <span class="keyword">this</span>[j];</span><br><span class="line">        <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>].bubbleSort();</span><br></pre></td></tr></table></figure></div></div><div class="post"><div class="post-header index"><h1 class="title"><a href="/2016/07/21/HTTP/">HTTP</a></h1><div class="post-info"><span class="date">2016-07-21</span> <span class="category"><a href="/categories/network/">network</a></span></div></div><div class="content"><p>get 请求传 array<br><a href="https://blog.csdn.net/weixin_39548968/article/details/113020785" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39548968/article/details/113020785</a></p></div><a href="/2016/07/21/HTTP/" class="read-more">Read More</a></div></section></div></div><div class="row"><div class="col-sm-12"><div class="wrap-pagination"><a href="/page/3/"><i class="fa fa-chevron-left" aria-hidden="true"></i> </a><a href="/page/5/"><i class="fa fa-chevron-right" aria-hidden="true"></i></a></div></div></div></div><div class="push"></div><footer class="footer-content"><div class="container"><div class="row"><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-about"><h2>About</h2><p>享受编程和技术所带来的快乐</p></div><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-categories"><h2>Categories</h2><p><a class="footer-post" href="/categories/html/">html</a> <a class="footer-post" href="/categories/scratch/">scratch</a> <a class="footer-post" href="/categories/jotting/">jotting</a> <a class="footer-post" href="/categories/algorithms/">algorithms</a></p></div><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-search"><h2>Search</h2><form class="site-search-form"><input type="text" id="local-search-input" class="st-search-input"></form><div id="local-search-result" class="local-search-result-cls"></div></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><ul class="list-inline footer-social-icons"></ul></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="footer-copyright">Copyright©Tracy-xu'Blog. All Rights Reserved.</div></div></div></div></footer><script src="/plugins/jquery-2.1.4.min.js"></script><script src="/plugins/TweenMax.min.js"></script><script src="/plugins/featherlight/featherlight.min.js"></script><script src="/js/main.js"></script></body></html><!-- rebuild by neat -->