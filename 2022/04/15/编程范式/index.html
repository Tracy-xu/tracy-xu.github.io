<!-- build time:Wed Aug 17 2022 14:44:45 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Tracy-xu&#39;Blog"><meta name="author" content="Tracy Xu"><meta property="og:title" content="编程范式"><meta property="og:description" content="Tracy-xu&#39;Blog"><meta property="og:site_name" content="Tracy-xu&#39;Blog"><meta property="og:type" content="article"><meta name="twitter:card" content="summary"><title>编程范式 - Tracy-xu&#39;Blog</title><link rel="stylesheet" href="/plugins/bootstrap/css/bootstrap.min.css" type="text/css"><link href="/plugins/font-awesome/css/font-awesome.min.css" type="text/css" rel="stylesheet"><link href="/plugins/featherlight/featherlight.min.css" type="text/css" rel="stylesheet"><link rel="stylesheet" href="/css/style.css"></head><body><div class="bg-gradient"></div><div class="bg-pattern"></div><div class="menu-bg"><div class="menu-container"><ul><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/about.html">关于我</a></li></ul></div></div><nav><a href="#menu"></a></nav><div class="container"><div class="row"><div class="col-sm-12"><header><div class="logo"><a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a></div></header><section class="main"><div class="post"><div class="post-header"><h1 class="title"><a href="/2022/04/15/编程范式/">编程范式</a></h1><div class="post-info"><span class="date">2022-04-15</span> <span class="category"><a href="/categories/pl/">pl</a></span></div></div><div class="content"><p>正交（orthogonal）</p><p>React的设计贯彻了声明式编程</p><p>编程范式：programming paradigm</p><p>命令式（Imperative），声明式（declarative programming）），这两个是对立的。</p><p>面向过程，面向对象（Object-oriented Programming 简称 OOP），函数式（functional programming 简称 FP）</p><a id="more"></a><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程范式，与命令式编程相对立。</p><p>它描述目标的性质，让计算机明白目标，而非流程。声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。而命令式编程则需要用算法来明确的指出每一步该怎么做。</p><p>在计算机科学中，声明性编程是一种编程范式，它表达了计算的逻辑而没有描述其控制流程。</p><p>来自<a href="http://en.wikipedia.org/wiki/Declarative_programming" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Declarative_programming</a></p><p>简而言之，声明性语言更简单，因为它缺乏控制流的复杂性（循环，if语句等）。</p><p>函数式编程是声明式编程的一部分</p><p><a href="https://www.zhihu.com/question/28292740/answer/40336090" target="_blank" rel="noopener">https://www.zhihu.com/question/28292740/answer/40336090</a><br><a href="https://www.zhihu.com/question/19732025" target="_blank" rel="noopener">https://www.zhihu.com/question/19732025</a><br><a href="https://zhuanlan.zhihu.com/p/85491177" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85491177</a></p><ul><li>FP</li></ul><p>不是有个 map，reduce 函数就是函数式编程。<br>不可变数据结构有么，柯里化支持吗，函数缓存有吗，隔离副作用有吗，方法可以被当成参数传递吗，尾递归优化有吗，模式匹配、函数参数收集有吗。<br>如果都没有，或者只支持其中一两个，叫个锤子的函数式编程</p><p>只能说map, reduce算是目前被大多数语言吸纳得比较广泛的FP特征</p><ul><li>OOP 与 FP 的区别</li></ul><p>OOP 和 FP 最大的区别可能是 OOP 将对象视作一等公民，而 FP 将函数视作一等公民。</p><p>但除此之外，很难说 OOP 和 FP 有什么冲突的地方，没人告诉你用了 OOP 就不能用 map、filter、reduce，<br>更何况许多编程语言同时有 OOP 和 FP 两种编程范式的特征，想写成什么样完全看心情。<br>任何允许将函数作为参数传入的语言都可以写高阶函数，任何语言也都可以写出没有副作用的函数。你要是乐意，也可以把所有循环改写成递归。</p><p>编程范式的出现是为了减少程序员的思维负担，写出适合人类理解的语言。你可以在面向对象的代码应该加入一点map, reduce来方便理解，也可以在函数式的代码里加入一些class来简化命名。如果把编程范式之间的争论变成圣战，好像用什么编程范式就得严格遵循其规则，比如用FP就从不写循环，那未免也太过分了。</p><p>目前按照我的理解，面向对象最大的问题就是其概念已经过于臃肿了。使用面向对象，你需要尝试去理解GoF的23种设计模式，去理解继承和多态，去分辨各种各样概念之间的区别还要避免误区。面向对象还搞出了UML，尝试用没人能背下来全部规则的各类图去表示各种复杂的继承关系。UML用来打个草稿或许还是个不错的工具，但还有人走火入魔要用UML生成代码，这就显得离奇了。想要掌握面向对象，你不得不与概念的海洋斗争，然后读完十几本相关领域书籍，发现自己仍旧什么也不会。</p><p>学习面向对象最幸福的时刻是当你第一次理解了什么是类，什么是继承与多态，并成功用它让自己糊成一团的过程式代码变得简单而清晰。可惜的是你并不满足于这些，你往上套了越来越多的继承，对多态的使用越来越肆无忌惮，你很快发现自己的代码又糊成了一团。</p><p>但面向对象的代码至少比起面向过程的代码可读性高了太多，并且它的结构性很强——这使得烂程序员不至于写出太烂的代码。这就是为什么还有这么多公司用Java——它是完全面向对象的，而这很大程度上保证了程序员写出了差不多的代码。面向对象的各种概念与限制使编程不那么自由，但这正是很多大型项目需要的——它不需要所有的程序员都有极高的素养，任何并不太烂的程序员都能做出一定的贡献并且不会对代码产生毁灭性的影响。Java写出的代码也许很烂，但不至于烂到无法接受。</p><p>函数式编程是不同的。它有很多概念，这些概念或许不容易理解，但它们都很扁平，至少你在学习时不会产生学习面向对象概念时那种混乱与层层嵌套的感觉。FP不需要设计模式，不需要类图，也不需要继承和多态，当你理解了函数式编程的基本概念后你可以立刻投入工作。FP很自由，你不用被各种条条框框约束也可以写出清晰的代码。但有些人理解递归尚且十分吃力，你如何让他们轻而易举地去理解高阶函数的运算？更何况FP根本不能让人写出差不多的代码，编程素养并不算高的程序员凑在一起写出的FP大型项目肯定没法看。</p><p>OOP和FP本质上都是思维模式，只是OOP更符合直觉。即使C完全不支持OOP，也可以用各种方式写出OOP的代码，而FP的思维方式更是可以用在各种语言里。</p><p>有一个很普遍的误解： 就是函数式编程和面向对象编程是对立的，其实不然这两者是正交的（不相关，没有关系，不冲突）。<br>函数式编程的函数是指数学上的函数（不是指用函数来编程）：给定输入固定的输出，没有副作用。任何语言都可以用函数式的风格，只是难易不同罢了。很多语言都支持这两种风格的编程: 比如OCaml 和 JavaScript.举一个大家熟悉的JavaScript 的例子，来自Facebook的 ImmutableJSvar Immutable = require(‘immutable’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);</span><br><span class="line">var map2 = map1.set(&apos;b&apos;, 50);</span><br><span class="line">map1.get(&apos;b&apos;); // 2</span><br><span class="line">map2.get(&apos;b&apos;); // 50</span><br></pre></td></tr></table></figure><p>可以看到其实现是函数式的: 添加对象 不会修改原来的map 但是接口是面向对象的接口</p><p>CSS 的属性互不正交，大量的依赖与耦合难以记忆。</p><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>Reactive Programming</p><p><a href="https://zhuanlan.zhihu.com/p/104024245" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104024245</a><br><a href="https://www.jianshu.com/p/36d85f8cafdd" target="_blank" rel="noopener">https://www.jianshu.com/p/36d85f8cafdd</a><br><a href="https://blog.csdn.net/weixin_39939012/article/details/82784432" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39939012/article/details/82784432</a><br><a href="https://zhuanlan.zhihu.com/p/240287653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/240287653</a></p><p><a href="http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf" target="_blank" rel="noopener">http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf</a></p><p>Reactive Extensions (Rx)</p><p>ReactiveX</p><p>Java: RxJava<br>JavaScript: RxJS<br>C#: Rx.NET<br>C#(Unity): UniRx<br>Scala: RxScala<br>Clojure: RxClojure<br>C++: RxCpp<br>Lua: RxLua<br>Ruby: Rx.rb<br>Python: RxPY<br>Groovy: RxGroovy<br>JRuby: RxJRuby<br>Kotlin: RxKotlin<br>Swift: RxSwift<br>PHP: RxPHP</p></div></div></section></div></div></div><div class="push"></div><footer class="footer-content"><div class="container"><div class="row"><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-about"><h2>About</h2><p>享受编程和技术所带来的快乐</p></div><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-categories"><h2>Categories</h2><p><a class="footer-post" href="/categories/html/">html</a> <a class="footer-post" href="/categories/scratch/">scratch</a> <a class="footer-post" href="/categories/jotting/">jotting</a> <a class="footer-post" href="/categories/pl/">pl</a></p></div><div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-search"><h2>Search</h2><form class="site-search-form"><input type="text" id="local-search-input" class="st-search-input"></form><div id="local-search-result" class="local-search-result-cls"></div></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><ul class="list-inline footer-social-icons"></ul></div></div><div class="row"><div class="col-xs-12 col-sm-12 col-md-12 col-lg-12"><div class="footer-copyright">Copyright©Tracy-xu'Blog. All Rights Reserved.</div></div></div></div></footer><script src="/plugins/jquery-2.1.4.min.js"></script><script src="/plugins/TweenMax.min.js"></script><script src="/plugins/featherlight/featherlight.min.js"></script><script src="/js/main.js"></script></body></html><!-- rebuild by neat -->