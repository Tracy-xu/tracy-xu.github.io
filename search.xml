<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Scratch 助教</title>
      <link href="/2022/03/02/Scratch-Share/"/>
      <url>/2022/03/02/Scratch-Share/</url>
      
        <content type="html"><![CDATA[<p>在这春暖花开，万物复苏之季，非常荣幸受邀参加家长助教活动，我非常赞成这项活动，也非常感谢那些助教的家长，这也是家园共育中重要的活动。</p><p>我准备的课程主题为《少儿编程》，希望通过这节课可以让孩子们对计算机、人工智能、编程有一个轮廓上的概念，知道计算机的用途，知道现阶段的人工智能和真正的人工智能区别，知道编程中最基本的流程控制 – 循环和条件判断。</p><p>本次课程分三部分，分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 计算机科普</span><br><span class="line">* Scratch 编程</span><br><span class="line">* 游戏“见缝插针”</span><br></pre></td></tr></table></figure><span id="more"></span><p>在计算机科普中，我在白板上画了一台电脑，并请孩子们回答电脑的用途，然后又画了一个人类大脑，又请孩子们回答人类大脑和电脑的异同，之后又通过 PPT 介绍了计算机的种类以及人工智能。</p><p>由于计算机的运行需要程序，便引出编程，在编程环节中介绍了基本的流程控制 – 循环和条件判断，通过列举日常生活场景“红绿灯”、“跳绳”、“水族箱”、“购物”…，让孩子们理解这两个概念，然后又使用 Scratch 中循环和判断两种积木，分别实现了水族箱和购物程序。</p><p>最后在“见缝插针”的游戏环节中，邀请了所有的孩子体验游戏，游戏是提前编写的，规则是将针插到一个旋转的把上，针尖之间没有相互触碰记一分，否则游戏结束。比赛完成后通过程序算出了最高得分，并给所有参赛小朋友奖励了小奖品。</p><p>课程中，孩子们表现都很积极，我也切身体会到时代进步了，不管是科技水平，还是家园共育水平，现在的小朋友对事物的接触和了解真的非常丰富，是我们孩时完全无法相比的。在问计算机用途时，孩子们能准确的回答出“运算”、“存储记忆“，有的小朋友甚至就已经知道了 Scratch 编程…。</p><p>编程是一门逻辑严谨，且表面枯燥的学科，虽然我是一名程序员，但是要给幼儿园小朋友讲编程，这却是一种挑战，挑战不是如何让孩子们理解什么是循环、判断，而是如何控场，在他们无精打采时提升他们的情绪，在他们情绪激昂时又让他们倾听。</p><h2 id="Attachment"><a href="#Attachment" class="headerlink" title="Attachment"></a>Attachment</h2><ul><li><a href="/rep/scratch/code/%E5%8F%98%E9%87%8F.sb3">变量</a></li><li><a href="/rep/scratch/code/1%E5%8A%A0%E5%88%B0100.sb3">循环</a></li><li><a href="/rep/scratch/code/%E8%B4%AD%E7%89%A9.sb3">判断</a></li><li><a href="/rep/scratch/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%88%97%E8%A1%A8.sb3">数据结构–队列</a></li><li><a href="/rep/scratch/code/%E6%B5%B7%E5%BA%95%E4%B8%96%E7%95%8C.sb3">综合练习–见缝插针</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> scratch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互动直播课堂前端设计</title>
      <link href="/2021/10/02/Interact-Live-Class/"/>
      <url>/2021/10/02/Interact-Live-Class/</url>
      
        <content type="html"><![CDATA[<p>作为在线教育的核心产品，课堂既要满足<strong>面对面</strong>场景，又要满足<strong>远程</strong>场景，面对面课堂作为线下课堂的补充，而远程课堂可用来替代线下课堂。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>基础版课堂，能够满足基本的直播和白板需求，适用于视频会议、白板等通用场景，加入教学功能，则适用于教学场景。</p><ul><li>基础功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 黑板</span><br><span class="line">* 截图</span><br><span class="line">* 学生列表</span><br><span class="line">* 举手</span><br><span class="line">* 授权（授权书写、语音、视频）</span><br><span class="line">* 课件（上传和预览）</span><br><span class="line">* 聊天（禁言）</span><br><span class="line">* 投票</span><br><span class="line">* 点名</span><br><span class="line">* 抽人</span><br><span class="line">* 计时器</span><br><span class="line">* 同屏</span><br><span class="line">* 直播（摄像头、桌面，rtmp、hls、flv --- http cdn，rtc）</span><br><span class="line">* 录像</span><br></pre></td></tr></table></figure><ul><li>教学功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 课本</span><br><span class="line">* 课课清作业</span><br><span class="line">* 问答（自由题型和备课题型）</span><br><span class="line">* 抢答</span><br><span class="line">* 讲解（题目、作业、问答）</span><br></pre></td></tr></table></figure><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>基本流程</li></ul><p>课外排课创建课堂，生成课堂凭证 <code>ticket</code>，凭 <code>ticket</code> 检票进入课堂，检票完成后生成 <code>stub</code> 票根，凭 <code>stub</code> 票根链接 WebSocket，登录课堂，登录成功后，返回课堂 token，正式进入课堂。</p><p>课堂成功进入后，会恢复课堂，<code>API.User.recover()</code> 接口调用成功后，会发布两个钩子事件 <code>lessonInit</code> 和 <code>lessonInited</code>，各个业务模块的 store 订阅这两个事件，取自己模块所需数据，即可恢复课堂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录课堂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; hostId &#125; = params;</span><br><span class="line">  <span class="keyword">const</span> url = process.<span class="property">env</span>.<span class="property">VUE_APP_WS_URL</span>.<span class="title function_">replace</span>(<span class="string">&#x27;&#123;hostId&#125;&#x27;</span>, hostId);</span><br><span class="line">  <span class="variable constant_">WS</span>.<span class="title function_">create</span>(url, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable constant_">WS</span>.<span class="property">instance</span>.<span class="title function_">on</span>(<span class="string">&#x27;auth_success&#x27;</span>, <span class="function">(<span class="params">rep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; token &#125; = rep.<span class="property">data</span>;</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="string">&#x27;recover&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复课堂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">recover</span>(<span class="params">&#123; dispatch &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable constant_">API</span>.<span class="property">User</span>.<span class="title function_">recover</span>();</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="string">&#x27;lessonInit&#x27;</span>, &#123; <span class="attr">lesson</span>: data &#125;, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="string">&#x27;lessonInited&#x27;</span>, &#123; &#125;, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div id="flowchart-0" class="flow-chart"></div><ul><li>WebSocket 客户端设计</li></ul><p>支持 Proise 调用，掉线重连。</p><ul><li>课堂控制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 开始上课</span><br><span class="line">* 结束上课</span><br><span class="line">* 拖堂</span><br><span class="line">* 课堂倒计时</span><br></pre></td></tr></table></figure><ul><li>同屏</li></ul><p>按同屏技术实现方式分，课堂可分为<strong>录屏课堂</strong>和<strong>指令同屏课堂</strong>，远程课堂中可使用录屏实现同屏，没有直播的面对面场景中（主控同屏端、学生、助教、游客）可使用指令同屏。</p><p>相比于录屏同屏，指令同屏实现更复杂，特别是坐标数据的适配。坐标适配前提是应用的适配，被控端按主控端的应用的比例适配，应用适配后再去适配坐标数据，需要适配的同屏数据常有：轨迹、滚动位置。</p><ul><li>恢复</li></ul><p>数据恢复的目的是为了保证业务的进行和操作的同屏，需要恢复的数据有业务数据与前端自定义数据（临时操作状态数据不需要保存恢复），业务数据（点名、抢答、授权、问答、举手…）存储在各自字段中，而前端自定义数据（指的是在后端没有业务的数据：比如，同屏数据、窗口数据…）存储在 funcs 通用字段中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 房间信息</span></span><br><span class="line">  <span class="attr">&quot;room&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 业务数据：点名、抢答、授权、问答、举手、作答器</span></span><br><span class="line">    <span class="attr">&quot;call&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grab&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;permits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quiz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;raisedCount&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 通用功能列表</span></span><br><span class="line">    <span class="attr">&quot;funcs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 房间自定义设置</span></span><br><span class="line">    <span class="attr">&quot;setup&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 房间状态</span></span><br><span class="line">    <span class="attr">&quot;states&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 个人信息</span></span><br><span class="line">  <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 业务数据：抢答、问答</span></span><br><span class="line">    <span class="attr">&quot;grab&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quiz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 个人状态</span></span><br><span class="line">    <span class="attr">&quot;states&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>角色</li></ul><p>多角色设计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 老师</span><br><span class="line">* 学生</span><br><span class="line">* 助教</span><br><span class="line">* 游客</span><br></pre></td></tr></table></figure><ul><li>黑板</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 轨迹（并发、同步、恢复、适配）</span><br><span class="line">* 图型</span><br></pre></td></tr></table></figure><ul><li>多层窗口</li></ul><p>非模态弹框被称为窗口，由于非模态的原因，需要考虑窗口的排序。</p><ul><li>授权</li></ul><p>用二进制可以很方便的表达、计算和判断多个组合的开合状态。各种权限的 feature 权值如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黑板：001 --- 1</span><br><span class="line">音频：010 --- 2</span><br><span class="line">视频：100 --- 4</span><br></pre></td></tr></table></figure><p>比如，111 表示黑板、音频、视频的权限全部被开启，000 表示权限全部被关闭。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前权限：当前权限 &amp; feature</span></span><br><span class="line"><span class="number">6</span> &amp; <span class="number">4</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> &amp; <span class="number">4</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 切换权限：当前权限 ^ feature</span></span><br><span class="line"><span class="number">6</span> ^ <span class="number">4</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="number">2</span> ^ <span class="number">4</span>; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><ul><li>问答</li></ul><p>做题组件的设计（显示、作答、讲解）。</p><ul><li>讲解</li></ul><p>讲题目、讲答案、对比讲解答案、讲报告。</p><ul><li>聊天</li></ul><p>虚拟滚动，XSS。<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">start=>start: 开始op1=>operation: 创建课堂io1=>inputoutput: 生成 roomId (课堂 ID)op2=>operation: 申请 ticket (课堂凭证)io2=>inputoutput: 生成 ticketop3=>operation: 检测凭证io3=>inputoutput: 生成 stub (票根)op4=>operation: 登录课堂 (创建 WS 链接)io5=>operation: 登录成功，生成 tokenop6=>operation: 恢复课堂op7=>operation: 开始上课op8=>operation: 结束课堂end=>end: 结束start(right)->op1(right)->io1(right)->op2(right)->io2(bottom)->op3->io3->op4->op6->op7->op8->end</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数参数的求值策略</title>
      <link href="/2020/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
      <url>/2020/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>函数参数的<a href="https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085">求值策略 Evaluation Strategy</a> 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。</p><span id="more"></span><p>按值传递（pass by value）是指在调用函数时将实参复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实参。</p><p>引用传递（pass by reference）是指在调用函数时将实参的地址直接传递到函数中，在函数中对参数所进行的修改，将影响到实参。</p><p>按值传递传递的是原始值的复制，或内存地址值的复制（比如 JS 中的共享传递，C&#x2F;C++ 中的指针传递）。按引用传递传递的是内存地址（不是内存地址值）。</p><h2 id="JavaScript-中参数的求值策略"><a href="#JavaScript-中参数的求值策略" class="headerlink" title="JavaScript 中参数的求值策略"></a>JavaScript 中参数的求值策略</h2><p>Javascript 中函数参数求值策略是按值传递。无论是值类型还是引用类型，都会在栈上创建副本（拷贝、复制），不同是，对于值类型而言，这个副本就是整个原始值的复制，对于引用类型，由于引用类型的实例在堆中，在栈上只有它的一个地址引用值，其副本也只是这个引用值的复制，而不是整个原始对象的复制，这种策略也被称为按共享传递（传递的是地址值，可通过引用来修改原始对象的属性，重新赋值则会断开对原始对象的引用，不影响原始对象），类似于 C 中的指针传递。按共享传递是按值传递的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params">num, obj</span>) &#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  obj.<span class="property">value</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 只是引用类型的副作用，不能证明是引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = new Object(); // 断开了对 greeting 的引用</span></span><br><span class="line">  <span class="comment">// obj.value = &#x27;world&#x27;; // 如果是引用传递，改变形参 obj 的属性 value，也会反映在 greeting 变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">change</span>(a, greeting);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面例子的内存模型图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">a 10               |</span><br><span class="line">greeting 0x01 ---&gt; |  0x01 hello world</span><br><span class="line">num 10             |  </span><br><span class="line">obj 0x01      ---&gt; |</span><br></pre></td></tr></table></figure><p>如果是按引用传递，直接传递第二格的内容即可，不需要有第四格。</p><h2 id="其他语言中参数的求值策略"><a href="#其他语言中参数的求值策略" class="headerlink" title="其他语言中参数的求值策略"></a>其他语言中参数的求值策略</h2><p>Java 中参数求值策略与 JavaScript 一样，都是按值传递（含共享传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByValue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">    <span class="type">TestByValue</span> <span class="variable">testByValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestByValue</span>();</span><br><span class="line">    testByValue.change(a, greeting);</span><br><span class="line">    System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(greeting.value); <span class="comment">// hello</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> num, Greeting greeting)</span> &#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    greeting.value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// greeting = new Greeting(); // 断开了对 greeting 的引用</span></span><br><span class="line">    <span class="comment">// greeting.value = &quot;world&quot;;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">javac TestByValue.java </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">java TestByValue     </span><br></pre></td></tr></table></figure><p>PHP 既支持值传递又支持引用传递，通过 &amp; 运算符（取址运算符）实现引用传递。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">&amp;<span class="variable">$num</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$num</span> = <span class="variable">$num</span> + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出１</span></span><br><span class="line"><span class="title function_ invoke__">change</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure><p>C&#x2F;C++ 支持值传递（含指针传递）， 另外 C++ 还支持引用传递，通过 &amp; 取址运算符实现引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> &amp;num2, <span class="type">int</span> *num3)</span> </span>&#123;</span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  num2 = <span class="number">22</span>;</span><br><span class="line">  *num3 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num4 = 2;</span></span><br><span class="line">  <span class="comment">// num3 = &amp;num4; // 对指针变量赋值，会断开原先的引用，不会影响外面</span></span><br><span class="line">  <span class="comment">// printf(&quot;%p\n&quot;, num3); // 外面的 c 还是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">change</span>(a, b, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1，值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22，引用传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33 或 3，指针传递</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码需使用 <code>gcc test.cpp -lstdc++ -o test</code> 作为 C++ 编译，不能使用 <code>gcc -o test test.c</code> 作为 C 编译，C 没有按引用传递，都是按值传递，通过指针传递也可实现引用传递的效果，要想通过 C 编译，需删除引用传递。</p><p>其内存图如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 1</span><br><span class="line">b/num2 2 </span><br><span class="line">c [0x7ff7b2c49920] 3</span><br><span class="line">num1 1</span><br><span class="line">num3 [0x7ff7b2c498f8] 0x7ff7b2c49920</span><br></pre></td></tr></table></figure><p>num1 的内容是复制于 a 的原值，num2 是 b 的别名，num3 的内容是 c 的地址值，*num3 指向 c 的内容。</p><p>指针传递本质上也是值传递的方式，它所传递的是一个地址值，与 JavaScript 中的共享传递一样。C&#x2F;C++ 中通过 * 指针运算符实现指针传递。</p><p>作为指针类型数据本身，其既可使用指针传递又可使用引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *&amp;p)</span> </span>&#123; <span class="comment">// int *&amp;p 表示 p 是一个整型指针的别名，int *p 则会重新分配内存，创建新指针</span></span><br><span class="line">std::cout&lt;&lt;&amp;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line">  std::cout&lt;&lt;&amp;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">change</span>(b);</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算子的求值策略"><a href="#算子的求值策略" class="headerlink" title="算子的求值策略"></a>算子的求值策略</h3><p>求值策略不但规定了函数参数的求值规则，也规定了算子的求值规则，比如赋值表达式中的 <code>=</code> 运算符。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = a; <span class="comment">// 值传递</span></span><br><span class="line">  <span class="type">int</span> *num2; <span class="comment">// 值传递中的指针传递</span></span><br><span class="line">  num2 = &amp;b;</span><br><span class="line">  <span class="type">int</span> &amp;num3 = c; <span class="comment">// 引用传递</span></span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  *num2 = <span class="number">22</span>;</span><br><span class="line">  num3 = <span class="number">33</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> num = a;</span><br><span class="line"><span class="keyword">const</span> obj = b; <span class="comment">// 值传递中的共享传递</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针和引用</title>
      <link href="/2020/01/15/Pointer-Reference/"/>
      <url>/2020/01/15/Pointer-Reference/</url>
      
        <content type="html"><![CDATA[<p>指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> *p1;</span><br><span class="line">  <span class="type">int</span> **p2;</span><br><span class="line"></span><br><span class="line">  p1 = &amp;a; <span class="comment">// 指针 p1 指向 a</span></span><br><span class="line">  p2 = &amp;p1; <span class="comment">// 指针 p2 指向指针 p1，即 p2 的内容为 p1 的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **p2); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：定义指针时，<code>*</code> 两边的空格可以选择，<code>int* ptr</code> 与 <code>int *ptr</code> <code>int*ptr</code> 意义一样，另外，<code>int</code> 整型，<code>int*</code> 表示指向「整型」的指针，<code>int**</code> 表示指向「指向整型的指针」的指针。</p><p>指针与引用的区别：指针指向一块内存，它的内容是所指内存的地址，而引用是某块内存的别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="type">int</span> *p = &amp;a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p); <span class="comment">// 0x7ff7b2a82920</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p, &amp;a); <span class="comment">// 0x7ff7b2a82928 0x7ff7b2a82928</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="type">int</span> &amp;b = a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, &amp;a, &amp;b); <span class="comment">// 0x7ff7b2e77928 0x7ff7b2e77928</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于 C 不支持引用传递，上述代码需以 C++ 编译运行。</p>]]></content>
      
      
      <categories>
          
          <category> pl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EditorConfig-ESlint-Prettier</title>
      <link href="/2019/11/10/EditorConfig-ESlint-Prettier/"/>
      <url>/2019/11/10/EditorConfig-ESlint-Prettier/</url>
      
        <content type="html"><![CDATA[<h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p><a href="https://editorconfig.org/">EditorConfig</a> 是编辑器&#x2F;IDE 配置工具，需要编辑器&#x2F;IDE 支持，在 VSCode 上可通过 EditorConfig for VS Code 插件支持。</p><span id="more"></span><p>.editorconfig 配置：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>indent_style</td><td>缩进风格，tab、space</td></tr><tr><td>indent_size</td><td>缩进为 space 时，缩进的字符数</td></tr><tr><td>tab_width</td><td>缩进为 tab 时，缩进的宽度</td></tr><tr><td>end_of_line</td><td>换行符类型，lf、cr、crlf</td></tr><tr><td>charset</td><td>文件的 charset，latin1、utf-8、utf-8-bom、utf-16be、utf-16le</td></tr><tr><td>trim_trailing_whitespace</td><td>是否将行位空格自动删除</td></tr><tr><td>insert_final_newline</td><td>是否使文件以一个空白行结尾</td></tr><tr><td>root</td><td>表示是最顶层的配置文件，发现值为 true 时，才会停止查找 .editorconfig 文件</td></tr></tbody></table><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h2><p>JavaScript 作为一门动态弱类型语言，没有静态类型检测且允许隐式类型转换，虽然语法简洁自由，但是失去编译器的静态检测也带来了代码质量问题，另外 JavaScript 在设计上存在一些糟粕，比如 var、eval、++&#x2F;–、with…，为保证代码质量，对代码进行类型、风格、语法和逻辑静态检测是非常重要的。</p><p>类型的检测可交由 TypeScript，风格和语法的检测则需要使用 linter。</p><p>对代码风格、语法规则和逻辑进行静态检测，目的是为了统一代码风格和避免语法和逻辑错误。最早的 JavaScript 代码检测工具是 JSLint，由 Douglas Crockford 开发，其规则不可配置，JSHint 继承自 JSLint，支持规则的可配置性，ESLint 是一个基于 AST 的 lint，由 Nicholas C. Zakas 开发，支持规则的可配置性、自定义插件和自定义解析器。</p><p>ESlint 提供自定义解析器和插件，极大的丰富了其适用范围，不但能 lint 各版本标准的 ES 语法，还能 lint 实验性和非标准语法（比如 Flow 和 TypeScript），这种设计使得他能快速的响应变化。</p><p>ESLint 的默认解析器和核心规则仅支持标准的 ECMAScript 语法，不支持 Babel 提供的实验性（例如新功能）和非标准（例如Flow或TypeScript类型）语法（Babel 的生态已经超出了 ES 标准）。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>常见内置的规则有：</p><p>语法规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no-undef</span><br><span class="line">no-const-assign</span><br><span class="line">require-await</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for-direction 无限循环</span><br></pre></td></tr></table></figure><p>推荐建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eqeqeq</span><br><span class="line">no-var</span><br><span class="line">no-unused-vars</span><br></pre></td></tr></table></figure><p>代码风格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max-len</span><br><span class="line">no-mixed-spaces-and-tabs</span><br><span class="line">keyword-spacing</span><br><span class="line">comma-style</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><ul><li>Espree</li></ul><p>ESlint 使用解析器（parser）将代码解析成抽象语法树 (AST)，然后通过 AST 来分析代码。默认 AST 解析器为 <a href="https://github.com/eslint/espree">Espree</a>，只支持标准 ES 语法和 JSX，不支持 Babel 提供的实验性和非标准（例如 Flow、TypeScript）语法。</p><ul><li>@babel&#x2F;eslint-parser</li></ul><p>@babel&#x2F;eslint-parser（babel-eslint） 是 Babel 源代码的解析器。</p><ul><li>@typescript-eslint&#x2F;parser</li></ul><p>2019 年 TypeScript 官方配套的 TS 代码检测工具 TSLint 被弃用后，TypeScript 提供了此解析器用于将 TypeScript AST 转换成为 ESTree AST，使得 ESLint 能支持 TypeScript。</p><p>TypeScript Compiler 转化出来的 AST 与 ESLint 的 AST（ESTree，AST 的某一种规范）不兼容，@typescript-eslint&#x2F;parser 会读取 ESLint 的配置，并调用 @typescript-eslint&#x2F;typescript-estree 包用 TypeScript Compiler 将 TypeScript 的 sourcecode 转换为 TypeScript AST，然后将 TypeScript AST 转换为 ESTree。</p><p>TypeScript 中使用 ESlint 有两种方案 @typescript-eslint&#x2F;parser 和 @babel&#x2F;eslint-parser。</p><p>@typescript-eslint&#x2F;parser 解析器下，ESlint 能校验 TS 语法，但是 Babel 生态下的新特性将不会被解析，会被误判为 Error。@babel&#x2F;eslint-parser 解析器下，ESLint 不会校验任何的 TS 语法，而是将 TS 特性消除掉后基于 JS 的规则校验，要想在此方案下校验 TS 语法，可以用 VSCode，VSCode 对 TS 的支持非常友好，它会自动的提示 TS 错误，也可以额外的开启一个进程，用 tsc 检测 TS 语法。</p><ul><li>vue-eslint-parser</li></ul><p><a href="https://github.com/vuejs/vue-eslint-parser">vue-eslint-parser</a> 被用来解析 .vue 文件中的 <code>&lt;template&gt;</code>，配套 <a href="https://eslint.vuejs.org/">eslint-plugin-vue</a> 插件和<a href="https://eslint.vuejs.org/rules/">规则集</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Plugins 插件用来为 ESlint 新增自定义检测规则，比如自定义 React、Vue、TypeScript 的检测规则，命名规则为 eslint-plugin-xxx 或 @scopeName&#x2F;eslint-plugin。</p><p>常用的插件有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@babel/eslint-plugin（eslint-plugin-babel）为 @babel/eslint-parser 的配套 babel 源码规则</span><br><span class="line">eslint-plugin-react 为 ESLint 添加了一系列特定于 React 的规则</span><br><span class="line">@typescript-eslint/eslint-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot; // eslint-plugin-react，eslint-plugin- 的前缀可以省略</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注：plugins 只是指定规则，规则的开启还需要通过 rules 或 extends。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#x27;eslint-plugin-react/jsx-boolean-value&#x27;: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &#x27;eslint-plugin-react/recommended&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &quot;plugin:react/recommended&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>plugin 中的规则会对指定的 AST 节点做出校验，confings 字段可配置规则，一般的插件会自带两种最佳实践配置 all 以及 recommened。自定义 plugin 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  meta: &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      description: &#x27;一个方法的参数最大数量不能超过3个&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function (context) &#123;</span><br><span class="line">    function getFunctionParamsLoc(node) &#123;</span><br><span class="line">      const paramsLength = node.params.length;</span><br><span class="line">      return &#123;</span><br><span class="line">        start: node.params[0].loc.start,</span><br><span class="line">        end: node.params[paramsLength - 1].loc.end,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      FunctionDeclaration: (node) =&gt; &#123;</span><br><span class="line">        if (node?.params?.length &gt; 3) &#123;</span><br><span class="line">          context.report(&#123;</span><br><span class="line">            loc: getFunctionParamsLoc(node),</span><br><span class="line">            node,</span><br><span class="line">            message: &#x27;一个方法的参数最大数量不能超过3个&#x27;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>env</li></ul><p>env 用来指定环境，设定能够解析的全局变量。不同环境下，存在不同的全局变量，如果代码运行在浏览器上，那 window 就是全局变量，在 nodejs 上，那 process 就是全局变量。如果不配置环境，ESLint 在遇到这些变量的时候，会认为这些变量没有定义，触发 no-undef 规则。</p><p>官网的 <a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments">Specifying Environments</a> 上列出了 ESLint 能配置的全部环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">browser - 浏览器环境中的全局变量</span><br><span class="line">node - Node.js 全局变量和 Node.js 作用域</span><br><span class="line">es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>globals</li></ul><p>globals 也是用来设定能够解析的自定义全局变量的，作用跟 env 类似。比如 env 没有微信小程序环境，这是可通过 globals 单个配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">globals: &#123;</span><br><span class="line">  wx: true, // true 表示该变量为 writeable，而 false 表示 readonly</span><br><span class="line">  App: true,</span><br><span class="line">  Page: true,</span><br><span class="line">  Component: true,</span><br><span class="line">  getApp: true,</span><br><span class="line">  getCurrentPages: true,</span><br><span class="line">  Behavior: true,</span><br><span class="line">  global: true,</span><br><span class="line">  __wxConfig: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rules</li></ul><p>rules 用来配置规则。ESLint 中的规则很多，但是默认都不会开启，需要在 rules 中设定这些规则开关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">off 或 0：关闭规则</span><br><span class="line">warn 或 1：开启规则（warn 级别的错误）</span><br><span class="line">error 或 2：开启规则（error 级别的错误）</span><br></pre></td></tr></table></figure><ul><li>extends</li></ul><p>rules 逐条配置规则非常繁琐，因此 ESLint 设计了 extends 这个字段，用于继承别的已经配置好的的规则。在不加入任何插件的情况下，extends 可以配置为 <code>eslint: recommended</code> 或 <code>eslint: all</code>，recommended 是 ESLint 官方推荐的配置（即带对勾标记的规则），校验的规则比较少，eslint: all 则会开启全部的规则校验。</p><p>extends 扩展支持三种类型的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;eslint: recommended&quot;, // all</span><br><span class="line">    &quot;eslint-config-standard&quot;, //  eslint-config-airbnb、@vue/eslint-config-airbnb，可缩写为 standard、airbnb、@vue/airbnb</span><br><span class="line">    &quot;plugin: react/recommended&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eslint: xxx</code> 是 ESLint 官方配置包，一共有两个配置项 <code>recommended</code>、<code>all</code>。</p><p><code>eslint-config-xxx</code> <code>@scopeName/eslint-config-xxx</code> 是第三方 npm 配置包，可以简写 <code>xxx</code> 或 <code>@scopeName/xxx</code>，常用的有 <a href="https://github.com/standard/eslint-config-standard">eslint-config-standard</a>、<a href="https://github.com/airbnb/javascript">eslint-config-airbnb</a>、<a href="https://github.com/vuejs/eslint-config-airbnb">@vue&#x2F;eslint-config-airbnb</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  rules: &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plugin: xxx</code> 是插件内自带的配置包，也可以直接在 plugins 属性中进行设置，常用的有 <a href="https://github.com/jsx-eslint/eslint-plugin-react">eslint-plugin-react</a> 规则自带两种配置方案 all 以及 recommened。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configs: &#123;</span><br><span class="line">    config1: &#123;</span><br><span class="line">      plugins: [&#x27;myplugin&#x27;],</span><br><span class="line">      rules: &#123;</span><br><span class="line">        &quot;myplugin/rule1&quot;: &quot;error&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    rule1: &#123;</span><br><span class="line">      create: function (context) &#123;</span><br><span class="line">        // rule implementation ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends 是一个数组，可以配置多组规则，每个配置继承它前面的配置。实际开发中，我们会继承一些优秀的 ESLint 方案，比如 airbnb</p><ul><li>plugins</li></ul><p>见上面插件。</p><h3 id="与-VSCode-集成"><a href="#与-VSCode-集成" class="headerlink" title="与 VSCode 集成"></a>与 VSCode 集成</h3><p>ESlint npm 包是 Nodejs cli 工具，需要执行命令行才能 lint，而且 lint 信息只显示在命令行中，在 VSCode 中可通过 VSCode ESLint 插件（插件不是必需的）将 ESlint 集成至 VSCode，该插件会在项目启动的时候起一个后台任务，读取项目本地的 ESlint 配置，实时的检测代码，带来更直观的开发体验。</p><h2 id="Perttier"><a href="#Perttier" class="headerlink" title="Perttier"></a>Perttier</h2><p>ESlint 是代码检测工具，虽然 –fix 参数具有修复能力，能自动修复 max-len、no-mixed-spaces-and-tabs、keyword-spacing…等风格问题，但不能完全代替代码格式化工具，特别是换行，以下两段代码在 ESlint 中都是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123;a, b, c&#125; = obj;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">a,</span><br><span class="line">  b,</span><br><span class="line">  c,</span><br><span class="line">&#125; = obj;</span><br></pre></td></tr></table></figure><p>Prettier 代码格式化工具，能保证代码风格的完全一致，其不但能格式化 JS，还能格式化 HTML、CSS、JSON、VUE、Angular、TypeScript、JSX…。</p><p>.prettierrc.js 配置说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 单行代码字符数限制</span><br><span class="line">  printWidth: 80, </span><br><span class="line">  // tab缩进大小,默认为2</span><br><span class="line">  tabWidth: 4,</span><br><span class="line">  // 使用tab缩进，默认false</span><br><span class="line">  useTabs: false,</span><br><span class="line">  // 使用分号, 默认true</span><br><span class="line">  semi: false,</span><br><span class="line">  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)</span><br><span class="line">  singleQuote: false,</span><br><span class="line">  //仅仅当必须的时候才会加上双引号</span><br><span class="line">  quoteProps: &#x27;as-needed&#x27;,</span><br><span class="line">  // 行尾逗号,默认none,可选 none|es5|all</span><br><span class="line">  // es5 包括es5中的数组、对象</span><br><span class="line">  // all 包括函数对象等所有可选</span><br><span class="line">  trailingComma: &#x27;all&#x27;,</span><br><span class="line">  // 对象中的空格 默认true</span><br><span class="line">  // true: &#123; foo: bar &#125;</span><br><span class="line">  // false: &#123;foo: bar&#125;</span><br><span class="line">  bracketSpacing: true,</span><br><span class="line">  // JSX标签闭合位置 默认false</span><br><span class="line">  // false: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125;</span><br><span class="line">  //       &gt;</span><br><span class="line">  // true: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125; &gt;</span><br><span class="line">  jsxBracketSameLine: false,</span><br><span class="line">  // 箭头函数参数括号 默认avoid 可选 avoid| always</span><br><span class="line">  // avoid 能省略括号的时候就省略 例如x =&gt; x</span><br><span class="line">  // always 总是有括号</span><br><span class="line">  arrowParens: &#x27;avoid&#x27;,</span><br><span class="line">  // vue template 中的结束标签结尾尖括号掉到了下一行</span><br><span class="line">  htmlWhitespaceSensitivity: &#x27;ignore&#x27;, </span><br><span class="line">  // .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span><br><span class="line">  vueIndentScriptAndStyle: false,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Prettier 和 ESlint 一起使用时，如果二者的格式化规则不一致会造成冲突，需要使用 eslint-config-prettier 来关闭 ESLint 中与 Prettier 冲突的规则，代码的格式化完全交给 Prettier。另外，还可通过 eslint-plugin-prettier 插件，将 Prettier 作为规则在 ESlint 中使用。</p><p>跟 ESlint 一样，Prettier 既可通过 npm 包，以工程化自动化方式使用，也可在 VSCode 中通过插件使用。</p><p>注：其实 VSCode 默认的代码格式化工具挺好用的。</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端开发规范</title>
      <link href="/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>代码规范的可通过文档约定和 CodeRevice，但这主观性太强，不容易落地，最理想的方式还是在工程化层面，借助灵活配置的工具，工程化自动化的解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ESLint + Prettier: JavaScript/TypeScript/VUE/React 代码规范</span><br><span class="line">Stylelint: CSS 代码规范</span><br><span class="line">Editorconfig: 编辑器配置工具</span><br><span class="line">Prettier: 代码格式化工具</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h2><p>Git 工作流规范（Husky + Commitlint + Lint-staged），提交规范（Commitizen）</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 类型系统</title>
      <link href="/2019/07/26/JavaScript-Type-System/"/>
      <url>/2019/07/26/JavaScript-Type-System/</url>
      
        <content type="html"><![CDATA[<p>类型动静态强调的是静态类型检测，类型强弱强调的是隐式类型转换，JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">42</span>; <span class="comment">// foo 是 number</span></span><br><span class="line">foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// foo 是 string</span></span><br><span class="line">foo = <span class="literal">true</span>;  <span class="comment">// foo 是 boolean</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// number 转成了 string</span></span><br><span class="line">!!<span class="number">1</span>; <span class="comment">// number 转成了 boolean</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 中一共有 8 种内置（Built-In）数据类型。</p><h3 id="原始类型（Primitive-types）"><a href="#原始类型（Primitive-types）" class="headerlink" title="原始类型（Primitive types）"></a>原始类型（Primitive types）</h3><p>原始类型也被称为基本类型，表示不能再细分下去的类型，具有原子性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* string: 一串表示文本值的字符序列</span><br><span class="line">* number: 整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）</span><br><span class="line">* boolean: 包含两个值 true 和 false</span><br><span class="line">* null: 只包含一个值 null</span><br><span class="line">* undefined: 只包含一个值 undefined</span><br><span class="line">* symbol: 一种实例是唯一且不可改变的数据类型</span><br><span class="line">* bigInt</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于这些类型被存储在栈内存中，也被称为值类型。又由于这些类型的值是不可变的，又被称为不可变类型，原始类型是不可变的，没有任何方法可以直接改变其值，只会生成新的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">foo.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line">foo.<span class="title function_">toLowerCase</span>(<span class="number">1</span>);</span><br><span class="line">foo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);  <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈内存原始空间中的值并没有改变，只是开辟了一块新空间，将变量名指向新的空间</span></span><br><span class="line">foo += <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>内存模型图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">&#x27;hello&#x27;            |</span><br><span class="line">foo &#x27;hello world&#x27;  |</span><br></pre></td></tr></table></figure><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* object</span><br></pre></td></tr></table></figure><p>声明一个对象通常有以下几种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;; <span class="comment">// 字面量形式，推荐</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// new 调用</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>(); <span class="comment">// 与 new 调用相同</span></span><br><span class="line">cosnt foo = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 空对象</span></span><br></pre></td></tr></table></figure><p>由于 <code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>… 这些对象都是 <code>Object</code> 对象的子类，所以全部归类为 object 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>按内存分配方式，由于对象类型被存储在堆内存中，也被称为引用类型。又由于值是可变的，又被称为可变类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = foo;</span><br><span class="line">foo.<span class="property">msg</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">bar; <span class="comment">// &#123;msg: &#x27;hello world&#x27;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">foo[foo.<span class="property">length</span>] = foo.<span class="property">length</span> + <span class="number">1</span>; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">foo.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">foo.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>内存模型图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）      |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">foo 0x01 ---&gt;   |  0x01 hello world</span><br><span class="line">bar 0x01 ---&gt;   |</span><br></pre></td></tr></table></figure><ul><li>包装对象</li></ul><p>string、number、boolean 这三种原始类型值在引用属性和方法时，会通过调用 <code>new String()</code>、<code>new Number()</code> 和 <code>new Boolean()</code> 的方式自动转换成对象，也就是原始类型的“包装对象（Wapper object）”，一旦引用结束，便会销毁这个临时的包装对象。</p><p>不是所有的原始类型都有包装对象，null 和 undefined 就没有包装对象，访问它们的属性会报类型错误。</p><p>“JavaScript 中一切皆是对象”这是一个错误的论断，原始类型的 string、number、boolean 会转化为对应的包装对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;seymoe&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;seymoe&#x27;</span>); <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">String</span>(<span class="string">&#x27;seymoe&#x27;</span>); <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>注：<code>Number</code>、<code>String</code> 和 <code>Boolean</code> 如果不作为构造函数调用（即调用时不加 <code>new</code>），常常用于将任意类型的值转为数值、字符串和布尔值。</p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符被用来检测数据的类型，其返回一个表示数据类型的字符串，它能检测除 <code>null</code> 和值为 <code>function</code> 的 <code>object</code> 类型外的所有类型。</p><p>null 由于历史设计失误，typeof 返回了 object（如果从类 Java 语言的角度理解），而 function 由于很特殊（构造函数）typeof 特殊处理返回了 function，</p><p><code>typeof</code> 不能检测除 function 外的 object 子类型，如果想要检测子类型，则需要使用 <code>instanceof</code> 或 <code>Object.prototype.toString</code> 方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">(<span class="function">()=&gt;</span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 用来检测类型有缺陷，首先它会检测整个原型链，另外，它不能在 iframe 中跨页面检测，因为不在同一个 <code>window</code> 对象下，原型链无法关联。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>[].__proto__ === Array.prototype</code>，而又 <code>Array</code> 属于 <code>Object</code> 子类型，即 <code>Array.prototype.__proto__ === Object.prototype</code>，最终 <code>[].__proto__.__proto__ === Object.prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="title function_">foo</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iframe</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data <span class="keyword">instanceof</span> <span class="title class_">Array</span>);  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>data</code> 时的 <code>Array</code> 跟 iframe 里的 <code>Array</code> 属于不同的 <code>window</code> 对象下，不是同一个类。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>终极解决方案，不但能检测基本类型，还能检测 object 子类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>); <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>()); <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">BigInt</span>(<span class="number">2</span>)) <span class="comment">// &quot;[object BigInt]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;); <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>());</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// &#x27;[object Math]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Set</span>()); <span class="comment">// &#x27;[object Set]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakSet</span>()); <span class="comment">// &#x27;[object WeakSet]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Map</span>()); <span class="comment">// &#x27;[object Map]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakMap</span>()); <span class="comment">// &#x27;[object WeakMap]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>将值从一种类型转换为另一种类型被称为类型转换，JavaScript 中类型转换都属于强制类型转换，其又分为隐式强制类型转换和显式强制类型转换。参考 <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md">《You Dont Know JS》</a>。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> + <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + [<span class="string">&#x27;hello&#x27;</span>, <span class="number">1</span>]; <span class="comment">// 1hello,1</span></span><br><span class="line">&#123;&#125; + []; <span class="comment">// 0</span></span><br><span class="line">[] + &#123;&#125;; <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + &#123;&#125;; <span class="comment">// 2[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + obj; <span class="comment">// 2hello</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>;</span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> + <span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line">[] == ![];</span><br><span class="line">[<span class="literal">undefined</span>] == <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ul><li>toString</li></ul><p>基础类型强制转为 string 类型在规范中明确说明了，也比较符合直觉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">1</span>); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;hello&#x27;</span>)); <span class="comment">// &quot;Symbol(hello)&quot;</span></span><br></pre></td></tr></table></figure><p>object 类型在强制转换为 string 类型的时候，调用的是该类型原型上的 <code>toString</code> 方法，而 object 的各个子类型基本都重写了 <code>toString</code> 方法，所以在进行 <code>toString</code> 操作的时候表现有差异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="regexp">/reg/g</span>); <span class="comment">// &quot;/reg/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">toString</span>(); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="title class_">String</span>(arr); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写toString</span></span><br><span class="line">arr.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">String</span>(arr); <span class="comment">// &quot;1/2&quot;</span></span><br></pre></td></tr></table></figure><ul><li>toNumber</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;42&#x27;</span>); <span class="comment">// 42</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;123px&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">false</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">null</span>);  <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM 私仓</title>
      <link href="/2019/07/01/Sinopia/"/>
      <url>/2019/07/01/Sinopia/</url>
      
        <content type="html"><![CDATA[<p>npm 私仓可用于提高包的下载速度和保护内部代码，常见的 npm 私仓技术方案有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* npm on-site  # 缺点是收费，而且 npm 在国内访问慢</span><br><span class="line">* Git + SSH 直接引用到 GitHub 项目地址 # 缺点是不能更新（npm update），不能使用 Semver（语义化版本规范），而且 URL 不美观</span><br><span class="line">* cnpm</span><br><span class="line">* Sinopia/Verdaccio</span><br><span class="line">* Nexus</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Sinopia-x2F-Verdaccio"><a href="#Sinopia-x2F-Verdaccio" class="headerlink" title="Sinopia&#x2F;Verdaccio"></a>Sinopia&#x2F;Verdaccio</h2><p>Sinopia 是一个零配置的私有的带缓存功能的 npm 包管理工具。使用 Sinopia，不用安装 CouchDB 或 MYSQL 之类的数据库，Sinopia 有自己的迷你数据库，如果要下载的包不存在，它将自动去你配置的 npm 地址上去下载，而且硬盘中只缓存你现在过的包，以节省空间。</p><p>Sinopia 特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 不同步拉取 npm 库，占据大量硬盘，没有硬盘被撑爆的问题</span><br><span class="line">* 安装配置极其简单，不需要数据库</span><br><span class="line">* 支持配置上游 Registry 配置，一次拉取即缓存</span><br><span class="line">* 支持 Forever 及 Pm2 守护进程管理</span><br></pre></td></tr></table></figure><p>注意：由于 Sinopia 已经没人维护了，推荐使用 <a href="https://github.com/verdaccio/verdaccio">Verdaccio</a>，Verdaccio 是 Sinopia 的 Fork，安装配置基本和 Sinopia 一致。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Sinopia 前，首先要确保已经安装 Node，Linux 下安装 Node 参考具体章节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sinopia -g</span><br></pre></td></tr></table></figure><p>Sinopia 目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 程序安装目录（全局安装目录在不同配置下会不一样）</span><br><span class="line">|-- /usr/sbin/nodejs/lib/node_modules/sinopia/</span><br><span class="line"></span><br><span class="line"># 配置和存储目录</span><br><span class="line">|-- /root/.config/sinopia/</span><br><span class="line">    |-- config.yaml  # 配置文件</span><br><span class="line">    |-- htpasswd     # 用户和密码信息</span><br><span class="line">    |-- storage      # 包存储位置（除了 publish 的私包，通过 npm install xx 安装的公共包也会缓存到这个目录，安装过的包再次安装时会直接从这个目录取）</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinopia</span><br></pre></td></tr></table></figure><p>启动成功后，会有下面两行提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warn  --- config file  - /root/.config/sinopia/config.yaml</span><br><span class="line">warn  --- http address - http://0.0.0.0:4873/</span><br></pre></td></tr></table></figure><p>上面一行是 Sinopia 的配置文件所在路径，下面一行是 Sinopia 服务的域名和端口号。然后打开 <code>http://localhost:4873</code>（可通过 curl），如果能正常访问，说明安装成功。</p><ul><li>网络访问</li></ul><p>默认情况下只能本机 <code>localhost:4873</code> 访问，如果想通过 IP 让其他机器也能访问到，需要在 <code>/root/.config/sinopia/config.yaml</code> 最后一行添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure><p>好了，再试一次 <code>192.168.10.14:4873</code>，成功访问。如果还不行，可能是防火墙导致，默认情况下防火墙没有开放 4873 端口，需要开放相应的端口。CentOS 6 和 CentOS 7 不一样，以 CentOS 6 为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进入编辑防火墙配置文件（修改 OUTPUT ACCEPT 下的内容）</span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 然后加上下面这句（作用是防止防火墙占用80端口）</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 再加上下面这一句（开放 4873 端口）</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 4873 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 最后记得重启一下防火墙</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><ul><li>PM2 做守护进程</li></ul><p>Node 服务非常脆弱，一般在实际中使用都会配合守护进程。这里选用 PM2 做守护进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 PM2</span><br><span class="line">npm install -g pm2</span><br><span class="line"></span><br><span class="line"># 通过 PM2 启动 Sinopia</span><br><span class="line">pm2 start `which sinopia`</span><br></pre></td></tr></table></figure><p>注：更多 PM2 操作指南参考相关文档。另外，如果想要结束 PM2 守护的 Sinopia 进程，可使用以下方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop sinopia    # 参数也可以是具体的 PM2 id（不是 pid），比如 pm2 stop 0</span><br></pre></td></tr></table></figure><p>也可以手动结束，操作步骤如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有进程</span><br><span class="line">ps -A</span><br><span class="line"></span><br><span class="line"># 查询结果如下</span><br><span class="line">3239 ?         00:00:31 watch</span><br><span class="line">6035 ?         00:00:11 PM2 v2.10.3: Go</span><br><span class="line">27690 ?        00:00:01 sinopia</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 杀掉 watch 和 sinopia 这两个进程</span><br><span class="line">kill 3239</span><br><span class="line">kill 27690</span><br></pre></td></tr></table></figure><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the default config file. It allows all users to do anything,</span><br><span class="line"># so don&#x27;t use it on production systems.</span><br><span class="line">#</span><br><span class="line"># Look here for more config file examples:</span><br><span class="line"># https://github.com/rlidwka/sinopia/tree/master/conf</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># path to a directory with all packages</span><br><span class="line">storage: ./storage                     # npm 包存放的路径（可以将将此目录指向其他目录）</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd                   # 用于存储 npm 用户的账号和密码信息</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    #max_users: 1000                   # 最大允许的用户数量，默认值为 1000，-1 则为禁止注册</span><br><span class="line"></span><br><span class="line"># a list of other known repositories we can talk to</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/   # 上游源，默认为 npm 的官网，可以使用淘宝的 npm 镜像地址</span><br><span class="line"></span><br><span class="line">packages:                              # 配置权限管理</span><br><span class="line">  &#x27;@*/*&#x27;:</span><br><span class="line">    # scoped packages</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装。$all 所有人，$authenticated 通过验证的人，$anonymous 匿名者</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line">    proxy: npmjs                       # 默认没有这项</span><br><span class="line">    </span><br><span class="line">  &#x27;*&#x27;:</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    #</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish packages</span><br><span class="line">    # (anyone can register by default, remember?)</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span><br><span class="line">    proxy: npmjs                       # 如其名，这里的值是对应于 uplinks</span><br><span class="line"></span><br><span class="line"># log settings</span><br><span class="line">logs:</span><br><span class="line">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class="line">  #- &#123;type: file, path: sinopia.log, level: info&#125;</span><br><span class="line"></span><br><span class="line">listen: 0.0.0.0:4873                   # 默认没有这项，只能在本机访问，添加后可以通过外网访问</span><br></pre></td></tr></table></figure><p>部分配置字段意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">storage    # 仓库保存的路径</span><br><span class="line">auth       # 验证相关</span><br><span class="line">uplinks    # 配置上游的 npm 服务器，主要是用于请求的仓库不存在时去上游服务器拉取</span><br><span class="line">packages   # 配置模块/包的发布(publish)、下载(access)的权限等</span><br><span class="line">listen     # 配置监听端口与主机名</span><br></pre></td></tr></table></figure><ul><li>auth 配置</li></ul><p>max_users: -1 表示我们将最大用户数设置为－1，表示禁用 npm adduser 命令来创建用户，不过我们仍然可以通过当前目录下的 htpasswd 文件来初始化用户。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yorkie:&#123;SHA&#125;?????????????????=:autocreated 2016-02-05T15:33:46.238Z</span><br><span class="line">weflex:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T15:39:19.960Z</span><br><span class="line">james:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T17:59:05.041Z</span><br></pre></td></tr></table></figure><p>上面的加密算法也很简单，就是简单的 SHA1 哈稀之后再转换成 Base64 输出就好，后面跟着的只是表示时间。</p><ul><li>packages 配置</li></ul><p>配置大致分为两个部分，一个是以 <code>@*/*</code> 为开头的，另一个则是通配符 <code>*</code>。</p><p>这个当然就是对 package.json 中的 name 字段进行匹配，比如 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#115;&#116;&#64;&#x31;&#46;&#x33;&#x2e;&#49;">&#x61;&#115;&#116;&#64;&#x31;&#46;&#x33;&#x2e;&#49;</a> 将匹配第一个配置，而 express 则匹配第二个。这里这么配置的意义在于：一般团队或者公司的私有项目，会采用不同的权限控制，于是这里借用了 npm 的 scoped name 即 @company 的形式，例如 @weflex&#x2F;app 即表示 WeFlex 下属的 app 项目了。</p><p>接下来，每一个命名过滤器（filter）下都有三项基本设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access    # 表示哪一类用户可以对匹配的项目进行安装(install)</span><br><span class="line">publish   # 表示哪一类用户可以对匹配的项目进行发布(publish)</span><br><span class="line">proxy     # 如其名，这里的值是对应于 uplinks 的</span><br></pre></td></tr></table></figure><p>对于 1 和 2 的值，我们通常有以下一些可选的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$all            # 表示所有人都可以执行对应的操作</span><br><span class="line">$authenticated  # 表示只有通过验证的人可以执行对应操作</span><br><span class="line">$anonymous      # 表示只有匿名者可以进行对应操作（通常无用）</span><br></pre></td></tr></table></figure><p>或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作。</p><ul><li>为 packages 中 <code>@*/*</code> 字段配置代理源</li></ul><p><code>&#39;@*/*&#39;</code> 下添加 <code>proxy: npmjs</code> 配置，给 scoped packages（<a href="https://docs.npmjs.com/misc/scope">npm 官方的定义</a>） 添加代理源，使得能够安装 scoped packages 类型的包（比如 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#115;&#116;&#64;&#49;&#x2e;&#x33;&#x2e;&#x31;">&#x61;&#115;&#116;&#64;&#49;&#x2e;&#x33;&#x2e;&#x31;</a>）。如果不配置此项，安装基本的包没有问题，但是，安装 scoped packages 包时，比如  webpack，会提示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack</span><br><span class="line"></span><br><span class="line"># 出现以下错误</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found: @webassemblyjs/ast@1.3.1</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2018-05-09T06_26_23_190Z-debug.log</span><br></pre></td></tr></table></figure><p>这是在安装 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#x73;&#116;&#64;&#x31;&#x2e;&#51;&#46;&#x31;">&#x61;&#x73;&#116;&#64;&#x31;&#x2e;&#51;&#46;&#x31;</a> 这个包时出的问题，sinopia 会提示 404。上面安装的包就是这类的包，常见的有 @angular @type 等。修改配置和代码后，重启 sinopia，这时再次安装就会提示成功。</p><p>如果还不成功，可能就是老版本 sinopia 的 bug 导致的（我这版中没出息这个问题），sinopia 每次向 npmjs 请求安装某个包时，请求地址都是转码后再向 npm 请求的，所以会将 @ 转码为 %40，但是 npm 不能识别 %40，所以导致 404 的错误。</p><p>这个时候只需要修改 sinopia 中的转码的地方就可以了。转码的文件是 up-storage.js,，修改 up-storage.js 中的 encode 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var encode = function (url) &#123;</span><br><span class="line">  return encodeURIComponent(url).replace(/^%40/, &#x27;@&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><p>通过服务器来新建用户。服务器上将 registry 改为 <a href="http://localhost:4873：">http://localhost:4873：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure><p>然后添加用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line"># 填写如下信息</span><br><span class="line">user: admin</span><br><span class="line">password: admin</span><br><span class="line">email: admin@admin.com</span><br></pre></td></tr></table></figure><p>这时 htpasswd(config.yaml 同目录) 文件下会生成相应的信息。</p><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://192.168.10.14:4873        # 设置 npm 源</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://192.168.10.14:4873  # 添加用户。如果不发布 npm 包，是不需要注册和登录的，登录 npm 是为了发布包</span><br><span class="line">npm login                                         # 登录 npm。注，npm adduser 成功的后默认就登陆了，所以不需要再 npm login</span><br><span class="line">npm whoami                                        # 检测身份</span><br></pre></td></tr></table></figure><p>注：推荐用 nrm 来管理 npm 源。具体的 nrm 操作查看 node 的 npm 相关章节。</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx              # 选项有 --save (-S)、--save-dev (-D)、-g</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>切换到私有仓库，登录成功之后，就可以执行 npm publish 发布到这个私有 npm 上面啦，发布包的操作跟 npm 官方发布包无差别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login                    # 登录 npm</span><br><span class="line">npm publish                  # 发包</span><br><span class="line">npm unpublish --force test   # 撤销发布。撤销 test 这个包，如果是在当前包的根目录下操作，可以省略包名</span><br></pre></td></tr></table></figure><p>发布包注意事项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 包的名称和版本就是你项目里 package.json 里的 name 和 version，author 字段可以显示包的作者，为空则表示匿名</span><br><span class="line">* 不能和已有的包的名字重名，发布前可通过 npm 的查找是否已存在相同名称的包（npm search xxx）</span><br><span class="line">* npm 对包名的限制：不能有大写字母/空格/下滑线（testPublish、test_publish 都会又报错）</span><br></pre></td></tr></table></figure><h2 id="使用-Docker-安装-Verdaccio"><a href="#使用-Docker-安装-Verdaccio" class="headerlink" title="使用 Docker 安装 Verdaccio"></a>使用 Docker 安装 Verdaccio</h2><p>参考 Docker 安装 Verdaccio <a href="https://verdaccio.org/docs/en/docker.html">文档</a>。</p><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull verdaccio/verdaccio    # 拉取 Verdaccio 的 Docker Image，不指定版本下，拉取的是 latest</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><ul><li>新建宿主机目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上新建需要挂载到的目录（路径可自选）</span><br><span class="line">mkdir /home/kpg/verdaccio</span><br><span class="line">mkdir /home/kpg/verdaccio/conf</span><br><span class="line">mkdir /home/kpg/verdaccio/storage</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取配置文件 config.yaml</span><br><span class="line">cd /home/kpg/verdaccio/conf</span><br><span class="line">git clone https://github.com/verdaccio/docker-examples</span><br><span class="line">mv docker-examples/docker-local-storage-volume/conf/config.yaml config.yaml</span><br><span class="line">rm -rf docker-examples    # config.yaml 复制好后，删除这个目录</span><br></pre></td></tr></table></figure><p>注：如果没有将 config.yaml 配置文件放在 <code>/home/kpg/verdaccio/conf/</code> 目录下，会导致浏览器将访问不了，<code>docker run</code> 看不出错误，只有通过 <code>docker logs</code> 查找日志，才能发现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps                # 找到 verdaccio container id</span><br><span class="line">docker logs containerId  # 查找日志</span><br></pre></td></tr></table></figure><ul><li>设置宿主机目录权限</li></ul><p><code>mkdir verdaccio</code> 创建的目录属主是当前宿主机用户，而每个 docker container 都会运行在自建的用户上。所以要注意挂载目录的权限，要不然 <code>npm adduser</code> 和 <code>npm install</code> 无法写入，提示 500 服务器错误，查看容器日志会有下面这样的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs --tail 20 verdaccio</span><br><span class="line">EACCES: permission denied, open &#x27;/verdaccio/conf/htpasswd&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it verdaccio sh    # 进入容器查找容器的用户 ID（进入后 Shell 前缀变成了 ~）。直接在宿主机里面 cat /etc/passwd 查找不到</span><br><span class="line">whoami                          # 查看当前用户</span><br><span class="line">cat /etc/passwd                 # 找到当前用户的 User ID (10001) 和 Group ID (65533)。docker 容器中的 uid 和 gid 和宿主机是共享的，只是没有具体名称</span><br><span class="line">exit                            # 退出容器</span><br><span class="line">chown -R 10001:65533 verdaccio  # 在宿主机下设置目录权限。-R 表示递归设置</span><br></pre></td></tr></table></figure><ul><li>挂载宿主机目录</li></ul><p>可以在启动时通过 <code>-v</code> 将宿主机目录挂载到容器内目录，也可以通过 docker-compose.yml 来配置 volumes。</p><ul><li>配置 config.yaml</li></ul><p>基本配置参考上面，storage、htpasswd 要指向容器内目录，uplinks 可以使用淘宝 npm 私仓：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">storage: /verdaccio/storage</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: /verdaccio/conf/htpasswd</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>如果将启动参数放在命令中，做成脚本文件来启动会更加方便（如果用 docker-compose 启动，将参数放在 docker-compose.yml 中也很方便）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name verdaccio \</span><br><span class="line">--restart always \</span><br><span class="line">-p 4873:4873 \</span><br><span class="line">-v /home/kpg/verdaccio/conf:/verdaccio/conf \</span><br><span class="line">-v /home/kpg/verdaccio/storage:/verdaccio/storage \</span><br><span class="line">-v /home/kpg/verdaccio/plugins:/verdaccio/plugins \</span><br><span class="line">verdaccio/verdaccio</span><br></pre></td></tr></table></figure><p><code>-v</code> 用于挂载宿主机的一个目录，<code>:</code> 前面的目录是宿主机目录，后面的目录是容器内目录。</p><ul><li>一个错误</li></ul><p><code>npm publish</code> 时出现了一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">npm ERR! code E503</span><br><span class="line">npm ERR! 503 Service Unavailable - PUT http://npm.kpg123.com/sdf - one of the uplinks is down, refuse to publish</span><br></pre></td></tr></table></figure><p>查看 <a href="https://github.com/verdaccio/verdaccio/issues/78">Issues</a> 和<a href="https://verdaccio.org/docs/en/configuration.html#offline-publish">配置文档</a>发现，By default verdaccio does not allow to publish when the client is offline, that behavior can be overridden by setting this to true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish:</span><br><span class="line">  allow_offline: true</span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>如果 nginx 直接安装在宿主机，直接 <code>/etc/nginx/conf.d</code> 下新建 nginx.conf 文件，填入以下内容即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream npm &#123;</span><br><span class="line">    server 127.0.0.1:4873;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name npm.kpg123.com;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://npm;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端 host，然后就可以通过域名访问了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.101 npm.kpg123.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Pages</title>
      <link href="/2019/06/20/Git-Pages/"/>
      <url>/2019/06/20/Git-Pages/</url>
      
        <content type="html"><![CDATA[<p>GitHub Pages 用于介绍用户个人和托管在 GitHub 中的项目的，免费，虽然<a href="https://help.github.com/en/articles/what-is-github-pages#usage-limits">空间和流量有限制</a>（空间上限 1G、月流量上限 100G、每小时更新不超过 10 次），但绝对够用。</p><span id="more"></span><h2 id="新建-GitHub-Pages"><a href="#新建-GitHub-Pages" class="headerlink" title="新建 GitHub Pages"></a>新建 GitHub Pages</h2><p><a href="https://pages.github.com/">GitHub Pages</a> 分两类：User or Organization site (个人或组织 site) 和 Project site (项目 site)。</p><ul><li>个人或组织 site</li></ul><p>仓库名必须为 <code>username.github.io</code>（username 为用户在 github 上的用户名，比如 <code>tracy-xu.github.io</code>），分支为 master，其分支的内容将会被构建和发布在你的 GitHub Pages site 上，这样的 pages 一般一个账号只能有一个，通过 <code>username.github.io</code> 访问。</p><ul><li>项目 site</li></ul><p>可以在 gh-pages 分支上，也可以在 Settings –&gt; GitHub Pages 下设置，通过 <code>username.github.io/project-name</code> 访问。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>为 GitHub Pages 绑定域名需要两步：第一步生成 CNAME 文件，第二步域名解析。</p><h3 id="生成-CNAME-文件"><a href="#生成-CNAME-文件" class="headerlink" title="生成 CNAME 文件"></a>生成 CNAME 文件</h3><p>GitHub Pages CNAME 文件记录自定义域名，其作用是，当访问自定义域名时，会通过 DNS 解析到 GitHub 的服务器 IP，GitHub 仓库千万个，GitHub 服务器会根据 HTTP Host 匹配对应 CNAME 文件所在的仓库，如果没有这个文件，GitHub 服务器不知道返回哪个仓库，会显示 404。</p><p>在 <code>tracy-xu.github.io</code> 这个 rep 中点击 Settings，然后在 Custom domain 中填入要绑定的域名 <code>yunguxt.cn</code>。这个操作会在项目的根目录生成 CNAME 文件，里面内容就是所要绑定的域名 <code>yunguxt.cn</code>。</p><p>注：为防止在像 Hexo 这样一些博客系统中被打包覆盖，可以在 Hexo 中手动创建 CNAME。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>以阿里云为例，登陆阿里云控制台进行域名解析。记录类型有两种方式可选择：A 记录（A 将域名指向一个 IPV4 地址）、CNAME（CNAME 将域名指向另外一个域名）记录。</p><ul><li>A 记录</li></ul><p>A 记录需要找到 git pages 的 IP（ping tracy-xu.github.io 结果是 185.199.110.153），然后再进行后续设置。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>A</td><td>www</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：主机记录 www 和 @ 都要添加，这是为了 <code>www.yunguxt.cn</code> 和 <code>yunguxt.cn</code> 都能访问到页面。</p><ul><li>CNAME 记录</li></ul><p>CNAME 记录不需要通过 IP 来绑定，记录值直接填写 <code>tracy-xu.github.io</code> 即可。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CMAME</td><td>www</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>CMAME</td><td>@</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：域名解析设置完成后，如果还是不能访问，这是因为在等服务商分配 DNS，等待 10 来分钟就可以了，如果还不能访问，就是因为其他原因了，比如阿里云中域名没进行实名认证不能被解析（不分配 DNS 服务器）。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>GitHub Pages 开放了自定义域名 HTTPS 支持，不用再自己买证书或借用第三方服务，就能开启网址左边的小绿锁了。</p><p>设置步骤根据你的自定义域名解析类型分为两种：A、CNAME。</p><ul><li>A 记录</li></ul><p>A 记录的话只需将解析的 ip 指向如下四个即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>其余的步骤和上面域名解析一样。</p><p>注：也可以通过 CNAME 来混合设置，设置 4 个 @ 主机记录的 A 记录和 1 个 www 主机记录的 CNAME 记录。</p><ul><li>CNAME 记录</li></ul><p>只需要在 Repositorys 设置中勾选 Enforce HTTPS 的选项即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow</title>
      <link href="/2019/04/25/Git-Flow/"/>
      <url>/2019/04/25/Git-Flow/</url>
      
        <content type="html"><![CDATA[<p>Git 工作流（Work Flow）是一种分支管理策略。在开发人员较少，项目不复杂时，可以采用简单的工作流，比如只有一个 Master 分支，但当项目庞大，迭代周期长，多人协作，多需求并行时，就需要更加严格的 Work Flow 来管理开发、测试、发布和热修复了。在 Git 中常见的工作流有 Git Flow、GitHub Flow、GitLab Flow。</p><span id="more"></span><p>2010 年 5 月，Vincent Driessen 在 “<a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” 中介绍了一种构建在 Git 之上的软件开发模型。通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离。这种软件开发的活动模型被 Vincent 称为 “Git Flow”。</p><h2 id="Git-Flow-基本流程"><a href="#Git-Flow-基本流程" class="headerlink" title="Git Flow 基本流程"></a>Git Flow 基本流程</h2><p><img src="/images/engineering/git/git-flow.jpg" alt="Git Flow 流程图"></p><p>从 Git Flow 流程图可以看出，Git Flow 的核心是 Branch，通过在项目的不同阶段对 Branch 的不同操作（create、merge、rebase…）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类，Main Branchs（主分支） 和 Supporting Branches（辅助分支），其中 Main Branchs 包含了 Master 和 Develop，而 Supporting Branches 包含了 Feature、Release、Hotfix 以及其他自定义分支。Main Branchs 是长期分支，存活在项目的整个生命周期中，而 Supporting branches 分支是短期分支，短期分支合并后需要删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master -- 主分支</span><br><span class="line">* develop -- 开发分支</span><br><span class="line">* feature/* -- 功能分支</span><br><span class="line">* release/* -- 预发布分支</span><br><span class="line">* hotfix/* -- 热修复分支</span><br></pre></td></tr></table></figure><p>在实践中，需求的创建、提测、发布应由项目负责人完成，普通的开发人员只需要开发功能和改 Bug。也就是说，对于 Master、Develop 这两个公共分支，只有项目负责人有操作权限，普通开发人员只有 Feature、Release、Hotfix 三个辅助分支的操作权限，这样既保证了 Master 和 Develop 的整洁，而且普通开发人员也不需掌握 Git Flow。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>主分支用于发布，存放的是最稳定的正式版本。禁止在此分支上修改代码，只接受其他分支合并（Release、Hotfix）。另外，不管是用来发布 Release 还是 Hotfix，都需要打 Tag。</p><p>注：初始化时，可使用 <code>--allow-empty</code> 参数来 commit 一个空分支（<code>git flow init</code> 就是如此），<code>git commit --allow-empty -m &quot;initial commit&quot;</code>。</p><h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><p>开发分支用于日常开发，是 Feature 和 Release 分支的基础分支，存放最新的开发版（隔夜版 Nightly，是要发布到下一个 Release 的代码）。这个分支可能包含一定的 Bug（Release 还未合并的情况下），但不影响创建新的 Feature 进行新功能的开发（但是需要注意的是，假如 feature&#x2F;b 基于 feature&#x2F;a 的 Develop 创建，这时候的 feature&#x2F;b 不能比 feature&#x2F;a 早发布，如果想早发布只能将这个 feature&#x2F;b 当作一个 Hotfix 了）。</p><p>跟 Master 一样，Develop 的变动也只能是合并（Feature、Release），不能是直接修改。</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>功能分支用于开发新功能、代码重构、优化…，基于 Develop 创建，一般命名为 feature&#x2F;xxx。新功能开发完成，会合并回 Develop 分支进入下一个 Release。</p><p>Feature 分支命名规则是，分支类型&#x2F;分支发布时间-分支功能。比如：feature&#x2F;20170401-fairy-flower，时间使用年月日命名，不足 2 位补 0。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>预发布分支用于预发布（测试和测试阶段的 Bug 修复）。当需要发布一个新 Release 时，可以基于 Develop 分支创建一个 Release 分支，一般命名为 release&#x2F;v1.0.0（关于版本号的命名规则参考相关章节），完成 Release 后，需要合并到 Master 和 Develop。</p><p>版本就是在这个阶段确定的，所以这个分支的命名会加版本后缀。版本正式发布前可生成 Changelog 文档，然后再发布上线。</p><h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><p>热修复分支，用于修改线上 Bug（比如回归时的 Bug，或者用户反馈的 Bug）。基于 Master 创建，一般命名为 hotfix&#x2F;v1.0.0，测试通过后合并到 Master 分支和 Develop 分支。</p><h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的操作必然是频繁且重复的，这个时候可通过 <a href="https://github.com/nvie/gitflow">Git flow script 工具</a>来简单化复杂的 Git 命令。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">apt-get install git-flow</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br><span class="line"># Windows 上或者</span><br><span class="line">curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh</span><br><span class="line">bash gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow help          # 查看帮助</span><br><span class="line">git flow feature help  # 查看 feature 帮助</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line">git flow init                           # 初始化。会询问分支的命名，初始化完成后自动切换到了 develop 分支。支持 -f -d 参数</span><br><span class="line"></span><br><span class="line"># feature</span><br><span class="line">git flow feature start MYFEATURE        # 开始一个 feature。相当于 git checkout -b feature/MYFEATURE</span><br><span class="line">git flow feature publish MYFEATURE      # publish 一个 feature。相当于 git push</span><br><span class="line">git flow feature pull origin MYFEATURE  # 获取 publish 的 feature</span><br><span class="line">git flow feature finish MYFEATURE       # 完成一个 feature。该命令将 feature 分支合并入 develop 分支，并切换到 develop 删除 feature</span><br><span class="line"></span><br><span class="line"># release</span><br><span class="line">git flow release start MYRELEASE        # 开始一个 release。git flow release start v1.0.0，分支全称是 release/v1.0.0</span><br><span class="line">git flow release publish MYRELEASE      # publish 一个 release</span><br><span class="line">git flow release finish MYRELEASE       # 发布一个 release。该命令将 release 合并入 master 和 develop 并切换到 master，删除该 release，创建 tag</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">git flow hotfix start MYVERSION         # 开始一个 hotfix</span><br><span class="line">git flow hotfix finish MYVERSION        # 发布一个 hotfix</span><br></pre></td></tr></table></figure><p><code>git flow init</code> 会询问分支的命名，发布和预发布这两个分支名称采用默认的 master 和 develop 即可，而其他的分支需要填写前缀，比如 <code>feature/</code>。参数 <code>-f</code> 表示强制初始化（可用于重置 git flow 初始化配置），参数 <code>-d</code> 表示使用默认配置初始化。Git Flow 仓库配置是本地配置，换电脑后需要再次初始化配置，为保证各配置相同，最好是使用 <code>git flow init -d</code> 初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br><span class="line"></span><br><span class="line">Initialized empty Git repository in /Users/tracy-xu/Desktop/test/.git/</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? [] version/</span><br></pre></td></tr></table></figure><p>注：Release 和 Hotfix 命令使用和 Feature 一样，只是有些细微区别，比如 <code>git flow release finish</code> 命令将会将 Release 分支合并入 Master 和 Develop 两个分支，且会打上版本号（tag 需要有 message，要不然会创建失败）。</p><p><img src="/images/engineering/git/git-flow-commands.png" alt="git-flow-commands"></p><p>附：<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">Git-Flow 备忘清单</a></p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit Message Style Guide</title>
      <link href="/2019/04/20/Git-Commit-Message-Style-Guide/"/>
      <url>/2019/04/20/Git-Commit-Message-Style-Guide/</url>
      
        <content type="html"><![CDATA[<p>在 Git 中，我们使用 <code>git commit -m &quot;xxx&quot;</code> 来提交代码，参数 <code>-m</code> 用来指定 Commit Message（提交说明），直接执行 <code>git commit</code> 会进入编辑器模式，可提交多行说明。Commit Message 应规范化，规范化的 Commit Message 能带来很多好处：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 提交说明明确，方便快速浏览和查找，比如 git log --pretty=format:%s, git log HEAD --grep feature</span><br><span class="line">* 可以直接从 Commit Message 生成 Change Log</span><br></pre></td></tr></table></figure><p>目前，社区中有很多 Commit Message 规范，本文介绍 Angular Commit Message 规范，因其合理、系统，且有配套工具，在社区中得到来广泛的应用。</p><h2 id="Angular-Commit-Message-规范"><a href="#Angular-Commit-Message-规范" class="headerlink" title="Angular Commit Message 规范"></a>Angular Commit Message 规范</h2><p><a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines">Angular commit message guidelines</a> 中将 Commit message 分为三个部分：Header，Body 和 Footer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。<code>&lt;BLANK LINE&gt;</code> 指空行，各个部分必须由空行分割。为了避免自动换行影响美观，不管是哪一个部分，任何一行都不得超过 72 个字符（或 100 个字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs(changelog): update changelog to beta.5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fix(ivy): prevent templateOverrides from causing infinite loop (#29402)</span><br><span class="line"></span><br><span class="line">Previously, the transitive scope calculation could lead into re-compiling</span><br><span class="line">the same module multiple times. This fix ensures we cannot get into this loop.</span><br><span class="line">It should be fixed more completely (e.g. more cases) once FW-1178 is resolved.</span><br><span class="line"></span><br><span class="line">PR Close #29402</span><br></pre></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需）。</p><ul><li>type</li></ul><p>type 用于说明 Commit 的类别，只允许使用下面 9 个标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* build      # 构建过程或辅助工具的变动。影响构建系统或外部依赖关系的更改（比如：Gulp、Broccoli、NPM）</span><br><span class="line">* chore      # 其他修改，比如改变构建流程，或增加依赖库、工具等</span><br><span class="line">* ci         # 配置文件（对 CI 配置文件和脚本的更改，比如：Travis、Circle、BrowserStack、SauceLabs）</span><br><span class="line">* docs       # 文档（Documentation，比如 Readme、Changelog、Contribute 等等）</span><br><span class="line">* feat       # 新功能（Feature）</span><br><span class="line">* fix        # 修复 Bug</span><br><span class="line">* prerf      # 性能（提高性能的代码更改，比如，提升性能、体验）</span><br><span class="line">* refactor   # 重构（即不是新增功能，也不是修改 bug 的代码变动）</span><br><span class="line">* style      # 格式（不影响代码运行的变动，比如：空白、换行、分号等）</span><br><span class="line">* test       # 测试（增加测试或更正现有测试）</span><br><span class="line">* revert     # 回滚（回滚到某一个版本，带上版本号）</span><br></pre></td></tr></table></figure><p>如果 type 为 feat 和 fix，则该 Commit 将肯定出现在 Change Log 之中。其他情况（docs、chore、style、refactor、test）建议不要放入 Change Log。</p><ul><li>scope</li></ul><p>scope 用于说明 Commit 影响的范围，比如框架中的数据层、控制层、视图层，或业务中某个业务模块，视具体项目的不同而不同，比如：user 用户、pay 支付、product 产品、article 文章、core 核心、router 路由、api 接口、doc 文档…</p><ul><li>subject</li></ul><p>subject 是 Commit 目的的简短描述，不超过 50 个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</span><br><span class="line">* 第一个字母小写</span><br><span class="line">* 结尾不加句号（.）</span><br></pre></td></tr></table></figure><p>常用表述语有：add、change、update、remove、delete。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 Commit 的详细描述，可以分成多行。有两个注意点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 使用第一人称现在时，比如使用 change 而不是 changed 或 changes</span><br><span class="line">* 应该说明代码变动的动机，以及与以前行为的对比</span><br></pre></td></tr></table></figure><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li>不兼容变动</li></ul><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>关闭 Issue 或 Pull requests</li></ul><p>在开源的项目中，如果当前 commit 针对某个 issue 或 pr，那么可以在 Footer 部分关闭这个 issue 或 pr。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fixes #21388</span><br><span class="line">PR Closes #234</span><br></pre></td></tr></table></figure><p>常用的表述语有 sclose、fix、resolve。</p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 Commit 用于撤销以前的 Commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 This reverts commit <hash>.，其中的 Hash 是被撤销 Commit 的 SHA 标识符。</p><p>如果当前 Commit 与被撤销的 Commit 在同一个发布（Release）里面，那么它们都不会出现在 Change Log 里面。如果两者在不同的发布，那么当前 Commit，会出现在 Change Log 的 Reverts 小标题下面。</p><h2 id="设置-Commit-Message-Template"><a href="#设置-Commit-Message-Template" class="headerlink" title="设置 Commit Message Template"></a>设置 Commit Message Template</h2><p>通过设置全局 .gitconfig 来指定 Commit Message 模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><p>TortoiseGit 中可通过依次点击 <code>settings -&gt; Git -&gt; Edit global .gitconfig</code>，然后编辑这个全局 .gitconfig 文件，在其末尾加入 commit 字段配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = xxxxxx@qq.com</span><br><span class="line">    name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">    recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">    helper = manager</span><br><span class="line">[commit]</span><br><span class="line">  template = d:/commit-template</span><br></pre></td></tr></table></figure><h2 id="生成-Change-Log"><a href="#生成-Change-Log" class="headerlink" title="生成 Change Log"></a>生成 Change Log</h2><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档。如果所有 Commit Message 都符合 Angular Commit Message 规范，那么发布新版本时，可以用 <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a> 这个工具自动生成 <a href="https://github.com/angular/angular/blob/master/CHANGELOG.md">CHANGELOG.md</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change Log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动。如果想要生成所有发布的 Change Log，要运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure><p>生成的文档包括以下三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* New features</span><br><span class="line">* Bug fixes</span><br><span class="line">* Breaking changes.</span><br></pre></td></tr></table></figure><p>每个部分都会罗列相关的 Commit ，并且有指向这些 Commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录 Date 中的两个坑</title>
      <link href="/2019/04/01/Javascript-Date-Something/"/>
      <url>/2019/04/01/Javascript-Date-Something/</url>
      
        <content type="html"><![CDATA[<h2 id="new-Date-参数-dataString-格式问题"><a href="#new-Date-参数-dataString-格式问题" class="headerlink" title="new Date 参数 dataString 格式问题"></a>new Date 参数 dataString 格式问题</h2><p>new Date(dataString) 中，参数 dataString 必须符合 ISO 8601 标准或者 RFC 2822 标准，现代主流浏览器这两个标准都支持（IE8 只支持 RFC 2822，不支持 ISO 8601）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(&#x27;2019-01-25T09:14:10.099+00:00&#x27;).getTime();    // ISO 8601 标准。返回 1548407650099</span><br><span class="line">new Date(&#x27;2019/01/25 09:14:10+0000&#x27;).getTime();         // RFC 2822 标准。返回 1548407650000</span><br></pre></td></tr></table></figure><p>然而，在实际工作中，后台（Java）返回的是格式既不是标准的 ISO 8601 也不是标准的 RFC 2822 格式，而是 ISO 8601 和 RFC 2822 混合格式，时区使用的是 RFC 2822 格式，比如，2019-01-25T09:14:10.099+0000，这个格式只有 Chrome 支持，其他浏览器都不支持（比如 iOS WebView、IE），执行 getTime 操作会返回 NaN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date(&#x27;2019-01-25T09:14:10.099+0000&#x27;).getTime();     // NaN</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于这个问题，要么要求后端返回标准的日期字符串格式，要么前端将数据纠正（moment、data-fns 就做了处理）。</p><h2 id="setDate-的副作用"><a href="#setDate-的副作用" class="headerlink" title="setDate 的副作用"></a>setDate 的副作用</h2><p>setDate 参数如果超出了月份的合理范围，会向上个月或下个月设置，&lt;&#x3D; 0 时，会设置上个月的日期，0 是最后一天，-1 是倒数第二天，以此类推，超出范围的正整数同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                            // 2 月 28</span><br></pre></td></tr></table></figure><p>我们可以利用这个特性来获取月份的天数和判断是否是闰年：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取月份天数</span><br><span class="line">function getMonthDayCount(year, month) &#123;</span><br><span class="line">  return new Date(year, month, 0).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMonthDayCount(2017, 10);   // 31</span><br><span class="line"></span><br><span class="line">// 获取一年中所有月份天数</span><br><span class="line">function getAllMonthDayCount(year) &#123;</span><br><span class="line">  var days = [31, new Date(year, 2, 0).getDate(), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</span><br><span class="line">  return days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAllMonthDayCount(2016);    // [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 是否是闰年</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样是不是更容易理解</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return new Date(year, 2, 0).getDate() === 29;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isLeapYear(2000);             // true</span><br></pre></td></tr></table></figure><ul><li>副作用</li></ul><p>但是，当在同一个 Date 对象上连续执行 setDate 操作时，不单单会偏移日期，还会连续偏移月份，这会影响后面的计算，导致结果出错。在实现 Calender 组件时发现这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                    // 2 月 28</span><br><span class="line"></span><br><span class="line">d.setDate(-1);</span><br><span class="line">d;                    // 理想希望返回 2 月 27，但是返回的是 1 月 30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义字体</title>
      <link href="/2018/07/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/"/>
      <url>/2018/07/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>字体文件其实就是一个以 Unicode 作为索引的字形表。用 FontCreator 打开系统安装中的某个字体文件，双击里面的某个字形，你可以对它进行编辑，也能猜得出来每个字形其实就是一个矢量图，因此 ttf 文件所表示的字库也叫矢量字库，说到这个再稍微提及一下另一种字库——点阵字库，两者最大的区别就是点阵字库可以在 Console Mode（命令行模式）下被渲染出来，而矢量字库必须在 Graphics Mode（图形模式）中被渲染。比如早期没有图形接口的 DOS 系统或者某些 Linux 终端，这些字体的索引需要靠固化到硬件驱动上点阵字库，因为早期的计算机只支持英文，这也是后来“汉卡”的由来。</p><span id="more"></span><h2 id="制作一套自己手写的字体"><a href="#制作一套自己手写的字体" class="headerlink" title="制作一套自己手写的字体"></a>制作一套自己手写的字体</h2><p>知道了字体文件的原理，我们就可以像叶根友字体、徐静蕾字体一样，制作一个属于自己的字体文件。</p><p>将 GB2312 中的 6763 个简体汉字一个个手写出来（可以线下手写，然后扫描，切片，也可以用数位板来写），然后用 FontCreator 制作成字体文件，<a href="https://www.zhihu.com/question/20035184">参考这篇文章</a>。</p><h2 id="IconFont"><a href="#IconFont" class="headerlink" title="IconFont"></a>IconFont</h2><p>Unicode 里面 BMP 中的 <code>U+E000 - U+F8FF</code>，PUP 中的 <code>U+F0000 - U+FFFFD</code> 和 <code>U+100000 - U+10FFFD</code>，都是私有平面，可以使用这些码点来自定义字体图标。</p><p>注：除了使用 IconFont 外，svg symbol 也可用来做字体图标。</p><p>字体图标只能被渲染成单色或者 CSS3 的渐变色，除此缺点外，其优势有以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 轻量：一个图标字体比一系列的图像(特别是在Retina屏中使用双倍图像)要小。一旦图标字体加载了，图标就会马上渲染出来，不需要下载一个图像。可以减少HTTP请求，还可以配合HTML5离线存储做性能优化。</span><br><span class="line">* 灵活：color、font-size、hover 状态、透明度、阴影、翻转，随便设置。</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/iconfont.eot&#x27;</span>);    </span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/iconfont.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),   </span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/iconfont.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>), </span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/iconfont.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),   </span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;fonts/iconfont.svg#iconfont&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* html中使用 */</span></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0ba29a</span>; </span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased; <span class="comment">/* 抗锯齿处理 */</span></span><br><span class="line">  -webkit-text-stroke-<span class="attribute">width</span>: <span class="number">0.2px</span>; <span class="comment">/* 边缘进行模糊，处理锯齿 */</span></span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* css伪元素中使用 */</span></span><br><span class="line"><span class="selector-class">.iconfont-edit</span><span class="selector-pseudo">:after</span> &#123;<span class="attribute">content</span>: <span class="string">&quot;\f0022&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>伪元素中使用 Unicode 码点（一般由工具生成）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont iconfont-edit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签中使用 Unicode 码点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;iconfont&quot;</span>&gt;</span>&amp;#xf0022<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可在 data-icon 属性中使用 Unicode 码点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[data-icon]</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span>; <span class="attribute">content</span>: <span class="built_in">attr</span>(data-icon); <span class="attribute">speak</span>: none;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span> <span class="attr">data-icon</span>=<span class="string">&quot;&amp;#xf0022&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>aria-hidden=&quot;true&quot;</code> 是为了防止被阅读器直接把字符读取出来</p><ul><li>兼容</li></ul><p>对于字体格式标准的支持，IE 从 IE4 开始支持 eot（微软自己开发的字体），IE9 开始支持 woff，现代浏览器对 ttf、otf、woff 三种格式均支持，woff 是专门为了 Web 而设计的字体格式标准，是浏览器中推荐使用的格式。</p><ul><li>跨域问题</li></ul><p>浏览器不支持对 iconfont 字体的跨域访问，对于这个问题的解办法有以下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 放在同域下</span><br><span class="line">* 使用 base64 置入 CSS 中</span><br><span class="line">* CORS</span><br></pre></td></tr></table></figure><h3 id="制作字体图标"><a href="#制作字体图标" class="headerlink" title="制作字体图标"></a>制作字体图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 首先需要有创建矢量图标的软件，并且能够输出 SVG 格式，比如 Illustrator 或者 Inkscape。也可以用 Photoshop 的路径工具画出所需要的图标，然后导出路径到 Illustrator 里去填色</span><br><span class="line">* 图标制作完成后，选择“文件”菜单中“保存”，把文件保存成 SVG 格式。使用默认的 SVG 设置</span><br><span class="line">* 把 SVG 格式的图标导入到 icomoon、fontello、iconfont 等字体生成器中，去生成所要的图标字体</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树形结构的生成</title>
      <link href="/2017/12/24/Tree-Structure/"/>
      <url>/2017/12/24/Tree-Structure/</url>
      
        <content type="html"><![CDATA[<p>后台返回树形数据，前端需将其处理为一个树形结构，这是在前后端交互中是非常常见的场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">56</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">81</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">74</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">76</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">63</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">80</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">87</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">62</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">86</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><span id="more"></span><p>树形结构如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">74</span>,</span><br><span class="line">  <span class="attr">parentId</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">62</span>,</span><br><span class="line">      <span class="attr">parentId</span>: <span class="number">74</span></span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      ]</span><br><span class="line">&#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>穷举法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findParentEl</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i].<span class="property">id</span> === id) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.<span class="property">parentId</span>) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = <span class="title function_">findParentEl</span>(el.<span class="property">parentId</span>);</span><br><span class="line">  parentEl.<span class="property">children</span> = [...(parentEl.<span class="property">children</span> || []), el];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(root);</span><br></pre></td></tr></table></figure><ul><li>map</li></ul><p>以空间换时间，可将上面的算法时间复杂度由 O(n^2) 优化到 O(n)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idMap = data.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, el, i</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[el.<span class="property">id</span>] = i;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.<span class="property">parentId</span>) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = data[idMap[el.<span class="property">parentId</span>]];</span><br><span class="line">  parentEl.<span class="property">children</span> = [...(parentEl.<span class="property">children</span> || []), el]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode JavaScript Solutions</title>
      <link href="/2017/10/01/LeetCode-JavaScript-Solutions/"/>
      <url>/2017/10/01/LeetCode-JavaScript-Solutions/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/rep/leetcode/two-sum.html">两数之和</a></li><li><a href="/rep/leetcode/palindrome-number.html">回文数</a></li><li><a href="/rep/leetcode/valid-parentheses.html">有效的括号</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Base 64 编码</title>
      <link href="/2017/05/10/Base-64/"/>
      <url>/2017/05/10/Base-64/</url>
      
        <content type="html"><![CDATA[<p>Base64 是一种用 64 个可打印字符来表示任意二进制数据的二进制编码方法。可以用来处理和传输任意二进制数据。</p><p>Base64 最初是用在电子邮件中，为了满足电子邮件中不能直接使用非 ASCII 码字符的规定，用来传输二进制文件的。除此之外，它还可将任意不可打印的二进制数据，转化为可打印的文本编码，使用文本软件进行编辑（二进制流中有很多都是无法显示和打印的，比如 ASCII 中的控制字符，二进制文件 jpg、pad、exe 等，如果用记事本打开这些文件，会看到一堆乱码）。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Base64 编码将一个 8 位字节序列拆散为 6 位的片段，并为每个 6 位的片段分配一个字符，这个字符是 Base64 字母表中的 64 个字符之一。这 64 个输出字符都是很常见的 ASCII 字符，包括大小写字母、数字、＋ 和 &#x2F;，还使用了特殊字符 &#x3D;。</p><p>Base64 编码表 (The Base64 Alphabet)：</p><table><thead><tr><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>17</td><td>R</td><td>34</td><td>i</td><td>51</td><td>z</td></tr><tr><td>1</td><td>B</td><td>18</td><td>S</td><td>35</td><td>j</td><td>52</td><td>0</td></tr><tr><td>2</td><td>C</td><td>19</td><td>T</td><td>36</td><td>k</td><td>53</td><td>1</td></tr><tr><td>3</td><td>D</td><td>20</td><td>U</td><td>37</td><td>l</td><td>54</td><td>2</td></tr><tr><td>4</td><td>E</td><td>21</td><td>V</td><td>38</td><td>m</td><td>55</td><td>3</td></tr><tr><td>5</td><td>F</td><td>22</td><td>W</td><td>39</td><td>n</td><td>56</td><td>4</td></tr><tr><td>6</td><td>G</td><td>23</td><td>X</td><td>40</td><td>o</td><td>57</td><td>5</td></tr><tr><td>7</td><td>H</td><td>24</td><td>Y</td><td>41</td><td>p</td><td>58</td><td>6</td></tr><tr><td>8</td><td>I</td><td>25</td><td>Z</td><td>42</td><td>q</td><td>59</td><td>7</td></tr><tr><td>9</td><td>J</td><td>26</td><td>a</td><td>43</td><td>r</td><td>60</td><td>8</td></tr><tr><td>10</td><td>K</td><td>27</td><td>b</td><td>44</td><td>s</td><td>61</td><td>9</td></tr><tr><td>11</td><td>L</td><td>28</td><td>c</td><td>45</td><td>t</td><td>62</td><td>+</td></tr><tr><td>12</td><td>M</td><td>29</td><td>d</td><td>46</td><td>u</td><td>63</td><td>&#x2F;</td></tr><tr><td>13</td><td>N</td><td>30</td><td>e</td><td>47</td><td>v</td><td></td><td></td></tr><tr><td>14</td><td>O</td><td>31</td><td>f</td><td>48</td><td>w</td><td></td><td></td></tr><tr><td>15</td><td>P</td><td>32</td><td>g</td><td>49</td><td>x</td><td></td><td></td></tr><tr><td>16</td><td>Q</td><td>33</td><td>h</td><td>50</td><td>y</td><td></td><td></td></tr></tbody></table><p>还可以自己定义 64 个字符的排列顺序，这样就可以自定义 Base64 编码，不过，通常情况下完全没有必要。Base64 是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p><p>注意：由于 Base64 编码用了 8 位字符来表示信息中的 6 个位，所以 Base64 编码字符串大约比原始值增加了 33%，(8 - 6) &#x2F; 6 &#x3D; 1&#x2F;3，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>下面是一个简单的 Base64 编码实例。在这里，三个字符组成的输入值 “Ow!” 是 Base64 编码的，得到的是 4 个字符的 Base64 编码值 “T3ch”。它是按以下方式工作的。</p><table><thead><tr><th>8 位字符</th><th>O</th><th>w</th><th>!</th></tr></thead><tbody><tr><td>8 位值（十六进制）</td><td>$4F</td><td>$77</td><td>$21</td></tr><tr><td>8 位值（二进制）</td><td>01001111</td><td>01110111</td><td>00100001</td></tr></tbody></table><table><thead><tr><th>对上面 8 位值（二进制）进行拆分</th><th>-</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>6 位值（二进制）</td><td>010011</td><td>110111</td><td>011100</td><td>100001</td></tr><tr><td>6 位值（十进制）</td><td>19</td><td>55</td><td>28</td><td>33</td></tr><tr><td>Base64 字符</td><td>T</td><td>3</td><td>c</td><td>h</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 字符串 &quot;Ow!&quot; 被拆分成 3 个 8 位的字节 (0x4F、0x77、0x21)；</span><br><span class="line">* 这 3 个字节构成了一个 24 位的二进制 01001111 01110111 00100001；</span><br><span class="line">* 这些位被划分为一些 6 位的序列 010011、110111、011100、100001；</span><br><span class="line">* 每个 6 位值都表示了从 0~63 之间的一个数字，对应 Base64 字母表中的 64 个字符之一。得到的 Base64 编码字符串是 4 个字符的字符串 &quot;T3ch&quot;。然后就可以通过线路将这个字符串作为“安全的” 8 位字符传送出去，因为只用了一些移植性最好的字符（字母、数字等）；</span><br></pre></td></tr></table></figure><ul><li>用 JavaScript 描述</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Ow!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> binary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> binStr = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">2</span>); <span class="comment">// charCodeAt 返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数</span></span><br><span class="line">  binary.<span class="title function_">push</span>(binStr); <span class="comment">// [&#x27;1001111&#x27;, &#x27;1110111&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个正常的字节都是由 8bit 组成的，不够 8bit 需要在高位补 0，于是得到 [&#x27;01001111&#x27;, &#x27;01110111&#x27;, &#x27;00100001&#x27;]</span></span><br><span class="line"><span class="comment">// 1 把字符串按照 6 位分开，进行分割，得到 [&#x27;010011&#x27;, &#x27;110111&#x27;, &#x27;011100&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line"><span class="comment">// 2 将每一个转换为十进制分别对于 [19, 55, 28, 33];</span></span><br><span class="line"><span class="comment">// 3 将每一位数字分别对于上面提供的 Base64 对应表,得到对应的编码，分别对于 T3ch</span></span><br><span class="line"><span class="comment">// 4 最后就会得到 Base64 编码 T3ch</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符 &quot;Ow!&quot; 最后得到的 Base64 编码为&quot; T3ch&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>前提 – 确定具体的编码方案</li></ul><p>需要注意的是，ASCII 码 128 位后的字符，各个编码方案不兼容，比如汉字有 gb2312、utf-8、gbk 等，每一种编码的 Base64 对应值都不一样，是用 Base64 进行编码前，需要确定编码方案。下面以’严’的 UTF-8 为例：</p><p>“严”的 UTF-8 编码为 E4B8A5，写成二进制就是三字节的 “11100100 10111000 10100101”。将这个 24 位的二进制字符串，转换成四组一共 32 位的二进制值”111001 001011 100010 100101”，相应的十进制数为 57、11、34、37，它们对应的 Base64 值就为5、L、i、l。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeJS（btoa 不支持中文）</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&#x27;严&#x27;</span>);</span><br><span class="line">b.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 5Lil</span></span><br></pre></td></tr></table></figure><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>Base64 编码收到一个 8 位字节序列，将这个二进制序列流划分成 6 位的块。二进制序列有时不能正好平均地分为 6 位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为 24 的倍数（6 和 8 的最小公倍数）。</p><p>对已填充的二进制进行编码时，任何完全填充（不包括原始数据中的位）的 6 位组都有特殊的第 65 个符号 “&#x3D;” 表示。如果 6 位组是部分填充的，就将填充位设置为 0。</p><p>下面是一个填充实例：</p><table><thead><tr><th>输入数据</th><th>二进制序列（填充位以 x 表示）</th><th>已编码数据</th></tr></thead><tbody><tr><td>a:a</td><td>011000 010011 101001 100001</td><td>YTph</td></tr><tr><td>a:aa</td><td>011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx</td><td>YTphYQ&#x3D;&#x3D;</td></tr><tr><td>a:aaa</td><td>011000 010011 101001 100001 011000 010110 0001xx xxxxxx</td><td>YTphYWE&#x3D;</td></tr><tr><td>a:aaaa</td><td>011000 010011 101001 100001 011000 010110 000101 1000001</td><td>YTphYWFh</td></tr></tbody></table><p>初始输入字符串为 “a:a” 为 3 个字节（24 位）。24 是 6 和 8 的倍数，因此按照上面给出的例子计算。无需填充就会得到 Base64 编码为 “YTph”。</p><p>然而，再增加一个字符，输入字符串变为 “a:aa”，转换为二进制就会有 32 位长。而 6 和 8 的下一个公倍数为 48，因此要添加 16 位的填充码。填充的前 4 位是与数据位混合在一起的。得到的 6 位组 01xxxx，会被当作 010000、十进制中的 16，或者 Base64 编码的 Q 来处理。剩下的两个 6 位组都是填充码，用 &#x3D; 来表示。</p><p>‘O’ 的填充实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x27;O&#x27;.charCodeAt().toString(2);</span><br><span class="line">得到二进制（位数不够 8 位时，需要在高位补码）</span><br><span class="line">1001111 --&gt; 01001111</span><br><span class="line">-----------------------------------------</span><br><span class="line">按 6 位拆分二进制（位数不是 24 的倍数时，需要低位补码）</span><br><span class="line">010011, 11xxxx, xxxxxx, xxxxxx</span><br><span class="line">-----------------------------------------</span><br><span class="line">转为十进制</span><br><span class="line">19, 48</span><br><span class="line">-----------------------------------------</span><br><span class="line">Base64 查表结果</span><br><span class="line">Tw==</span><br></pre></td></tr></table></figure><h2 id="JavaScript-中（前端）Base64-编码实现"><a href="#JavaScript-中（前端）Base64-编码实现" class="headerlink" title="JavaScript 中（前端）Base64 编码实现"></a>JavaScript 中（前端）Base64 编码实现</h2><h3 id="字符的编码"><a href="#字符的编码" class="headerlink" title="字符的编码"></a>字符的编码</h3><p>对于字符串来说，在 Web API 中，有两个函数分别用来 Base64 编码和解码的：atob 和 btoa。btoa 函数能够将二进制的字节数据（binary bytes）编码成 ASCII 字符串；相反地，atob 函数能够解码通过 Base64 编码的字符串数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;a:a&#x27;</span>); <span class="comment">// YTph</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">&#x27;YTph&#x27;</span>); <span class="comment">// a:a</span></span><br></pre></td></tr></table></figure><p>注：btoa 和 atob 分别是 Binary to ASCII 和 ASCII to binary 的缩写。b 不是 Base64 的缩写，计算机中的所有数据的本质都是二进制，我们所看到的文字、符号、图片、语音视频…，都是二进制数据在具体编码（字符编码、图像编码…）下的表现。</p><ul><li>Unicode 字符</li></ul><p>btoa 仅仅支持 <a href="https://baike.baidu.com/item/ISO-8859-1">Latin1</a> 范围的字符（其编码范围是 0x00-0xFF，0x00-0x7F 之间完全和 ASCII 一致，0x80-0x9F 之间是控制字符，0xA0-0xFF 之间是文字符号），不能编码 Unicode 字符，对 Unicode 字符串进行编码都会触发字符越界的异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello, 中国！&#x27;</span>;</span><br><span class="line"><span class="title function_">btoa</span>(str); <span class="comment">// Uncaught DOMException: ...The string to be encoded contains characters outside of the Latin1 range.</span></span><br></pre></td></tr></table></figure><p>原因是，由于这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 0x00 ~ 0xFF 范围，则会引发 InvalidCharacterError 异常。这只是 btoa 这个方法的局限，并不是 Base64 的局限，Base64 可以编码所有的二进制数据。</p><p>解决办法是，先把 Unicode 字符串转换为 UTF-8 编码。这里我们可以先将带有非 的串先用 encodeURIComponent 编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello, 中国！&#x27;</span>)); <span class="comment">// SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(<span class="string">&#x27;SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=&#x27;</span>)); <span class="comment">// Hello, 中国！</span></span><br></pre></td></tr></table></figure><p>注意，编码的过程是先 encodeURI，再编码，那么解码的过程应该是先解码，再 decodeURI。</p><ul><li>兼容</li></ul><p>另外，IE9 不支持 atob 和 btoa，解决方案是手动实现 Base64 编解码函数：<a href="https://github.com/dankogai/js-base64">js-base64</a>、<a href="https://github.com/mathiasbynens/base64">base64</a>。</p><h3 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h3><p>dataURL 是 data 类型的 URL，指的是含有 Base64 数据的 URL，目的是在 URL 中使用二进制数据，是在 <a href="https://tools.ietf.org/html/rfc2397">RFC2397</a> 中提出的，其完整的语法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataurl := &quot;data:&quot; [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data      # data:文件类型;编码方式,编码后的文件内容</span><br><span class="line">mediatype := [ type &quot;/&quot; subtype ] *( &quot;;&quot; parameter )</span><br><span class="line">data := *urlchar</span><br><span class="line">parameter := attribute &quot;=&quot; value</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 文本</span><br><span class="line">data:text/plain;charset=UTF-8;base64,5L2g5aW977yM5Lit5paH77yB</span><br><span class="line"></span><br><span class="line"># 图片</span><br><span class="line">data:image/gif;base64,xxxxxxxxxx</span><br></pre></td></tr></table></figure><p>dataURL 可用在：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img src</span><br><span class="line">background url</span><br><span class="line">link href</span><br><span class="line">script src</span><br></pre></td></tr></table></figure><ul><li>FileReader</li></ul><p>Web API 中的 FileReader.readAsDataURL 可以将一个文件转为 dataURL。</p><ul><li>将一个 dataURL 转为 Blob 或者 File</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dataURLtoBlob</span>(<span class="params">dataURL</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataURL.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].<span class="title function_">match</span>(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="title function_">atob</span>(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = binaryString.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = binaryString.<span class="title function_">charCodeAt</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([u8arr], &#123;<span class="attr">type</span>: mime&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dataURLtoFile</span>(<span class="params">dataURL, fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataURL.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].<span class="title function_">match</span>(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="title function_">atob</span>(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = binaryString.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    u8arr[n] = binaryString.<span class="title function_">charCodeAt</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>([u8arr], fileName, &#123;<span class="attr">type</span>:mime&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是图片的话，其实还可以将图片放在 canvas 中，利用 canvas.toBlob 来转（img.onload 导致速度没有上面的方式快）。</p><h2 id="Base64-的应用"><a href="#Base64-的应用" class="headerlink" title="Base64 的应用"></a>Base64 的应用</h2><h3 id="网络传输协议中"><a href="#网络传输协议中" class="headerlink" title="网络传输协议中"></a>网络传输协议中</h3><p>Base64 的用途之一就是便于用文本或二进制文件数据的传送。 在网络传输中，Base64 一般适合以下场合的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 传输信道只支持 ASCII 字符，不方便传输二进制流的场合；</span><br><span class="line">* 含有非 ASCII 字符（127 位以后字符），容易出现编码问题的场合；</span><br></pre></td></tr></table></figure><ul><li>SMTP</li></ul><p>Base64 最早就是用来邮件传输协议（SMTP）中的，是作为 MIME 多媒体电子邮件标准的一部分开发的，原因是邮件传输协议是一个文本协议，只支持 ASCII 字符（纯文本，可打印）传输，如果要传输二进制文件（比如邮件附件中的图像、声音等）和非 ASCII 字符，就需要用 Base64 将二进制文件内容和非 ASCII 字符编码为只包含 ASCII 字符的内容，并指定 MIME（多用途互联网邮件扩展类型）（详情参考 HTTP 里面相关说明）。</p><p>例如，正文为空，带一个名为 hello.txt 的附件，内容为<code>您好！世界！</code>。导出邮件源码，其关键部分如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIME-Version: 1.0                           # 表示当前使用MIME标准1.0版本</span><br><span class="line">Content-Type: text/plain; name=&quot;hello.txt&quot;  # 表示附件文件名为 hello.txt ，格式为纯文本</span><br><span class="line"></span><br><span class="line">Content-Transfer-Encoding: base64           # 表示附件文件内容使用 base64 编码后传输。可选值 7bit、8bit、binary、quoted-printable、base64、custom</span><br><span class="line">5oKo5aW977yM5LiW55WM77yB                    # 文件内容 您好，世界！ Base64编码后的结果</span><br></pre></td></tr></table></figure><p>不过，MIME 使用的不是标准 Base64 编码。</p><ul><li>HTTP</li></ul><p>HTTP 是超文本传输协议，可以传输纯文本（底层也是二进制流），也可以直接传输二进制数据流。在传输纯文本的时候，由于有些数据格式不符合协议本身的规范，这时候就需要对这些数据进行编码处理成安全格式，从而可以合法地作为首部字段和正文的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：=、空格、:、+、/、换行符...；</span><br><span class="line">非 ASCII 码：比如中文；</span><br></pre></td></tr></table></figure><p>当然，在 HTTP 中，URI 编码一般都会用配套的 URIencode，而不使用 Base64，除非需要编码二进制文件为 DataURL。对于 URL 的编码，请看相关章节。</p><p>注：HTTP 也支持 MIME，请查看相关章节。</p><h3 id="dataURL"><a href="#dataURL" class="headerlink" title="dataURL"></a>dataURL</h3><ul><li>img src、background url、link href、script src、图片预览和上传</li></ul><p>注：图片预览和上传这个需求用 Blob 更合理，Blob 通过 URL.createObjectURL 也能预览。</p><h3 id="X-509-公钥证书、HTTP-基本认证和摘要认证"><a href="#X-509-公钥证书、HTTP-基本认证和摘要认证" class="headerlink" title="X.509 公钥证书、HTTP 基本认证和摘要认证"></a>X.509 公钥证书、HTTP 基本认证和摘要认证</h3><p>在<a href="http://www.cnblogs.com/xiaohuochai/p/6184913.html">基本认证</a>、<a href="http://www.cnblogs.com/xiaohuochai/p/6189065.html">摘要认证</a></p><p>详情参考 HTTP 中认证相关章节。</p><p>数字证书签名</p><p>TODO。。。此节由于知识有限，没有完成，待完成。</p><h3 id="掩人耳目"><a href="#掩人耳目" class="headerlink" title="掩人耳目"></a>掩人耳目</h3><p>简易的掩人耳目，至少非开发人一眼看不出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;xwblearn2008@126.com&#x27;</span>); <span class="comment">// eHdibGVhcm4yMDA4QDEyNi5jb20=</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不能用于数据加密或数据校验"><a href="#不能用于数据加密或数据校验" class="headerlink" title="不能用于数据加密或数据校验"></a>不能用于数据加密或数据校验</h3><p>Base64 是一种数据编码方式，目的是让数据符合传输协议的要求，不能将其误用于数据加密或数据校验。标准 Base64 编码解码无需额外信息即完全可逆，即使自定义字符集设计一种类 Base64 的编码方式用于数据加密，在多数场景下也较容易破解。</p><p>对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法 AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解。也可以使用非对称加密算法，如 RSA，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。</p><p>对于数据校验，也应该使用专门的消息认证码生成算法，如 HMAC 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。</p><ul><li>扩展</li></ul><p>针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？</p><p>答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。</p><p>当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在 HMAC 算法中使用 SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。</p><p>另外，也可以使用加入随机 salt 的哈希算法来存储校验用户密码。这里暂不细述。</p><h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3><p>Base64 编码字符串大约比原始值扩大了33%。所以，选择 Base64 编码时要考虑一下文件的 size。另外有个小技巧，在 Chrom 中，把要转化的图片直接拖入，使用控制台中的 Source 选项，可直接查看图片的 Base64 编码。</p><h3 id="Data-URL-不会被浏览器缓存"><a href="#Data-URL-不会被浏览器缓存" class="headerlink" title="Data URL 不会被浏览器缓存"></a>Data URL 不会被浏览器缓存</h3><p>Data URL 不会被浏览器缓存，每次访问都被下载一次。这是一个使用效率方面的问题——尤其当这个文件被整个网站大量使用的时候。</p><h3 id="编码-URL-参数"><a href="#编码-URL-参数" class="headerlink" title="编码 URL 参数"></a>编码 URL 参数</h3><p>由于标准的 Base64 编码后可能出现字符 + 和 &#x2F;，在 URL 中就不能直接作为参数，所以又有一种 “url safe” 的 Base64 编码，其实就是把字符 + 和 &#x2F; 分别变成 - 和 _：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">base64.b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd++//</span></span><br><span class="line">base64.urlsafe_b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd--__ </span></span><br><span class="line">base64.urlsafe_b64decode(<span class="string">&#x27;abcd--__&#x27;</span>) <span class="comment"># i\xb7\x1d\xfb\xef\xff</span></span><br></pre></td></tr></table></figure><p>由于 &#x3D; 字符也可能出现在 Base64 编码中，但 &#x3D; 用在 URL、Cookie 里面会造成歧义，所以，很多 Base64 编码后会把 &#x3D; 去掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA==&#x27;     # 标准 Base64</span><br><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA&#x27;       # 自动去掉 =</span><br></pre></td></tr></table></figure><p>去掉 &#x3D; 后怎么解码呢？因为 Base64 是把 3 个字节变为 4 个字节，所以，Base64 编码的长度永远是 4 的倍数，因此，需要加上 &#x3D; 把 Base64 字符串的长度变为 4 的倍数，就可以正常解码了。去掉 &#x3D; 的 Base64 解码函数需要手动实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pyhone</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA==&#x27;</span>) <span class="comment"># abcd</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># 出错</span></span><br><span class="line"></span><br><span class="line">safe_b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># abcd</span></span><br></pre></td></tr></table></figure><p>注：NodeJS 中没有原生的支持，<a href="https://github.com/joaquimserafim/base64-url">需要手动处理</a>。</p>]]></content>
      
      
      <categories>
          
          <category> foundations </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Emoji</title>
      <link href="/2017/02/13/Emoji/"/>
      <url>/2017/02/13/Emoji/</url>
      
        <content type="html"><![CDATA[<p>Emoji 它是一个日语词，e 表示”絵”，moji 表示”文字”，连在一起，就是”絵文字”，是由日本人发明的，最早用于在短消息之中插入表情，2007年，iPhone 在 iOS 5 的输入法中加入 Emoji后，导致它在全世界范围的流行。</p><p>早期的 Emoji 是将一些特定的符号组合替换成图片，比如将 :) 替换成具体的表情图片。这种方法很难标准化，能够表达的范围也有限。2010年，Unicode 开始<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html">为 Emoji 分配码点</a>，将其标准化。也就是说，现在的 Emoji 符号就是一个文字，它会被渲染为图形。</p><span id="more"></span><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>移动端软键盘上自带 emoji 输入功能，输入的是标准的 Unicode 字符，能够在 textarea 中正确的插入和删除，输出时浏览器也能正确解析，前端无需实现。不过需要注意的是，标准 emoji 在 Mysql 中存储时需要注意字符编码。</p><ul><li>Mysql 存储</li></ul><p>在 Unicode 中 Emoji 的码点在 SMP 这个平面（具体在 U+1F601-U+1F64F 这个区段），这在 UTF-8 中需要 4 个字节来存储。</p><p>Mysql 的 utf8 不是我们常说的那个变长 UTF-8 编码，它是一个 3 个字节定长的编码（数据库要分配空间，所以必须定长？BMP 中 2 个字节的 UTF-8 高位补 0？），如果遇到 4 字节的宽字符就会插入异常（比如 Emoji），三个字节的 utf8 最大能编码的 Unicode 字符是 0xFFFF（BMP），任何不在 BMP 内的字符，都无法使用 Mysql 的 utf8 存储。</p><p>解决办法有两种：</p><p>方法一：是将 Mysql 的 utf8 改为 utf8mb4（4 个定长的字节），缺点就是空间会增加 1&#x2F;4（那些原本 3 个字节就能存下来的字符，现在要用 4 个字节。其实可以修改某个字段为 mb4，而不是将整个 Mysql 都设为 mb4）。</p><p>方法二：遍历输入的文本，把四字节长度的字符用自定义的字符（比如替换为 Emoji 字符本身的码点，这样复杂度会小点，恢复时可直接恢复）替换掉，渲染时再替换回。</p><h3 id="PC-端"><a href="#PC-端" class="headerlink" title="PC 端"></a>PC 端</h3><p>可以通过图片来实现，插入时是图片，保存时也是图片。不过需要注意的是要想在富文本中实现图片的插入和删除需要使用 contenteditable 的 div。参考百度贴吧的表情插入。</p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>要想在 Markdown 中实现 Emoji，可以自定义语法规则（<a href="https://github.com/muan/emoji">Find the emoji</a>），比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:+1:</span><br><span class="line">:-1:</span><br><span class="line">:rainbow:</span><br></pre></td></tr></table></figure><p>渲染解析时，再将上面语法结构替换为图片即可。参考 GitHub Issues 里面的 Markdown 实现。</p>]]></content>
      
      
      <categories>
          
          <category> foundations </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2017/02/01/Character-Encoding/"/>
      <url>/2017/02/01/Character-Encoding/</url>
      
        <content type="html"><![CDATA[<p>计算机只能处理数字，如果要处理文本，就必须先把文本编码转换为数字才能处理（图片、语音、视频…，这些多媒体文件也一样）。</p><span id="more"></span><h2 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h2><p>古代的长途通讯主要是用信鸽、骑马送报、烽烟等方式进行。直到 1837 年，世界第一条电报诞生 – 当时美国科学家莫尔斯尝试用一些“点”和“划”来表示不同的字母、数字和标点符号，这套表示字符的方式也被称为“摩尔斯电码”。</p><p>摩斯电码中定义了 <code>A-Z、a-z、0-9、?、/</code> 这些字符：</p><table><thead><tr><th>字符</th><th>电码符号</th></tr></thead><tbody><tr><td>A</td><td>· -</td></tr><tr><td>B</td><td>- · · ·</td></tr><tr><td>…</td><td>…</td></tr><tr><td>1</td><td>· - - - -</td></tr><tr><td>2</td><td>· · - - -</td></tr><tr><td>…</td><td>…</td></tr><tr><td>?</td><td>· · - - · ·</td></tr><tr><td>&#x2F;</td><td>- · · - ·</td></tr></tbody></table><ul><li>电报的工作原理</li></ul><p>“点”对应短的电脉冲信号，“划”对应长的电脉冲信号，这些信号传到对方，接收机把短的电脉冲信号翻译成“点”，把长的电脉冲信号转换成“划”，译码员根据这些点划组合就可以译成英文字母，从而完成了通信任务。这里把字符表示为“点”或“划”并对应为电脉冲信号的过程既是 ⌈编码⌋，而译码员把接收机接收到的脉冲信号转化成点划后译成字符的过程即为 ⌈解码⌋。</p><h2 id="字符集和编码方案"><a href="#字符集和编码方案" class="headerlink" title="字符集和编码方案"></a>字符集和编码方案</h2><p>莫尔斯编码中包含了大小写英文字母和数字等符号。这里的每一个符号其实就是“字符”，而这所有的字符的集合就叫做“字符集”，“点”和“划”与字符之间的对应关系即可以称为“字符编码”。计算机诞生之后，将摩斯电码中的“点”和“划”换成了以 8 位字节二进制流的方式表示，如数字 1（字符、字型）的二进制流是 0011 0001，对应的十进制流是 49，十六进制流是 31。</p><p>在讲解字符编码前，需要理解以下一些概念：</p><ul><li>比特、字节</li></ul><p>比特 (bit) 也可称为“位”，是计算机信息中的最小单位，是 binary digit（二进制数位） 的缩写，指二进制中的一位。字节 (Byte) 计算机中信息计量的一种单位，一个位就代表 “0” 或 “1”，每 8 个位（bit）组成一个字节（Byte）。</p><ul><li>字符、字符集</li></ul><p>字符 (Character) 是文字与符号的总称，可以是各个国家的文字、标点符号、图形符号、数字等。字符集 (Character Set) 就是字符的集合。表示涵盖了哪些字符，每个字符都有一个数字序号（ID），叫码点（code point）。字符集往往是一张码表，它规定了文字与数字的一一对应关系。</p><ul><li>编码、解码</li></ul><p>编码 (Encoding) 是信息从一种形式或格式转换为另一种形式的过程。解码 (Decoding) 是编码的逆过程。</p><ul><li>字符编码方案</li></ul><p>字符编码（Character Encoding）方案指的是按照何种规则存储字符。字符要怎样编码成二进制字节序，即一个数字序号（ID），要编码成几个字节，字节顺序如何。</p><p>在 Unicode 之前，一个字符集只使用一种编码方案（直接存储码点），对于 ASCII、GB 2312、Big5、GBK、GB 18030 这些的遗留方案来说，既是字符集又是编码方案。Unicode 中，字符集和编码是明确区分的，Unicode 是统一的字符集标准，它有几种可选的编码方案，包括 UTF-8、UTF-16、UTF-32，为了节省空间，不直接存储码点。</p><ul><li>字形字体</li></ul><p>字符编码只是对字符的抽象，不规定字符具体的字体字形，这个由渲染程序实现。</p><p>根据数字序号（ID），调用字体存储的字形，就可以在页面上显示出来了，这就是字形字体（Font）。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><a href="https://en.wikipedia.org/wiki/ASCII">ASCII (American Standard Code for Information Interchange)</a> 美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的<a href="https://baike.baidu.com/item/%E5%8D%95%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86/22081499?fr=aladdin">单字节编码系统</a>，并等同于国际标准 ISO&#x2F;IEC 646，1967 年被正式公布。</p><p>1946年，世界第一台计算机诞生，发明计算机的人用 8 个晶体管的“通”或“断”组合出一些状态来表示世间万物。</p><p>8 个晶体管的“通”或“断”即可以代表一个字节。刚开始，计算机只在美国使用，所有的信息在计算机最底层都是以二进制（“0”或“1”两种不同的状态）的方式存储，而 8 位的字节序一共可以组合出 2 的 8 次方 共 256 种状态，即 256 个字符（十进制编码为 0 - 255，二进制编码为 0 - 11111111，采用 8 bit 编码，不足的前面补 0，即 00000000 - 11111111），这对于当时的美国已经是足够的了，他们尝试把字母、数字、符号和一些终端的动作用 8 位（bit）来组合。</p><ul><li>控制字符</li></ul><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>Abbreviation(缩写)</th><th>字符解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>0</td><td>0</td><td>00</td><td>NUL</td><td>空字符</td></tr><tr><td>0000 0001</td><td>1</td><td>1</td><td>01</td><td>SOH</td><td>标题开始</td></tr><tr><td>0001 1111</td><td>37</td><td>31</td><td>1F</td><td>US</td><td>单元分隔符</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>01111111</td><td>177</td><td>127</td><td>7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><ul><li>可显示字符</li></ul><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>Glyph(字形、字符)</th><th>字符解释</th></tr></thead><tbody><tr><td>0010 0000</td><td>40</td><td>32</td><td>20</td><td>space</td><td>空格</td></tr><tr><td>0010 0001</td><td>41</td><td>33</td><td>21</td><td>!</td><td>叹号</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>01111110</td><td>176</td><td>126</td><td>7E</td><td>~</td><td>波浪号</td></tr></tbody></table><p>这套标准一共规定了 128 个字符（0x00~0x7f，0 ~127）的编码，被称为 ASCII 编码。共包括 33 个（包括前 32 个 和第 127 个）控制字符（Control Code – 控制字符又被称为 Function Code – 功能字符，它们都是不可见的）和 95 个可显示字符（Printable Code - 可打印字符），只用到了一个字节中的后 7 位，最前面一位统一规定为 0。</p><p>注：<a href="https://www.ascii-code.com/">完整的 ASCII 码表</a></p><h2 id="扩展-ASCII-码"><a href="#扩展-ASCII-码" class="headerlink" title="扩展 ASCII 码"></a>扩展 ASCII 码</h2><p>虽然刚开始计算机只在美国使用，128 个字符的确是足够了，但随着科技惊人的发展，欧洲国家、亚洲国家也开始使用上计算机了，128 个字符明显不够，比如法语中字母上方有注音符号，至于亚洲国家的文字，使用的符号就更多了，汉字就大多 10 万左右。</p><p>将 ASCII 中没有利用的最高位利用起来，把原来的 7 位扩充到 8 位（兼容 ASCII），不够就再加一个字节（比如中文），这套编码范围从 0x80~0xFFFF 的编码叫扩展 ASCII 码（各类扩展 ASCII 码在 Windows 中被统称为 ANSI 编码）。</p><h3 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h3><p>欧洲国家将 ASCII 最前面的一位利用起来，这样就多出了 128 位字符，其中 0 – 127 表示的符号与 ASCII 是一样的，不一样的只是 128~255 (0x80 ~ 0xFF) 的这一段。这套编码标志被称为 EASCII(Extended ASCII，延伸美国标准信息交换码)，共由 256 个字符组成。比较著名的 EASCII 有 <a href="https://baike.baidu.com/item/codepage/416287">CP437</a>（英文版 Windows 系统默认的字符编码）和 <a href="https://baike.baidu.com/item/ISO-8859-1">ISO&#x2F;8859-1(Latin-1)</a>。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>作为一种象形文字，汉字是世界上包含符号最多的文字，这不同于通过字母组合的西文单词。据不完全统计，汉字共包含了古文、现代文字等近 10 万个文字，就是我们现在日常用的汉字也有几千个，那么对于只包含 256 个字符一个字节进行编码的 EASCII 码显然不能满足需求。</p><p>在 Unicode 之前，一共存在过 3 套中文编码标准：大陆的 GB2312-80（后来又被扩展成 GBK、GB18030）、台湾的 Big5、香港的 HKSCS。</p><p><a href="http://www.sac.gov.cn/">国家标准化管理委员会</a>在 1981 年，正式制订了中华人民共和国国家标准简体中文字符集，项目代号为 GB2312 或 GB2312-80。GB2312 是对 ASCII 的简体中文扩展，只收录简化汉字，以及一般常用字母和符号，共收录有 7445 个字符，其中简化汉字 6763 个，字母和符号 682 个（全角），主要通行于中国大陆地区和新加坡等地。</p><ul><li>区位码</li></ul><p>汉字用两个字节表示，理论上，两个字节可以表示 256×256&#x3D;65536 种不同的符号，作为汉字编码表示的基础是可行的。但考虑到汉字编码与其它国际通用编码，如 ASCII 西文字符编码的关系，我国国家标准局采用了加以修正的两字节汉字编码方案，只用了两个字节的低 7 位。这个方案可以容纳 128×128&#x3D;16384 种不同的汉字，但为了与标准 ASCII 码兼容，每个字节中都不能再用 32 个控制功能码和码值为 32 的空格以及 127 的操作码。所以每个字节只能有 94 个编码。这样，双七位实际能够表示的字数是：94×94&#x3D;8836 个。</p><p>GB2312 将所收录的字符分为 94 个区，编号为 01 区至 94 区；每个区收录 94 个字符，编号为 01 位至 94 位。这种表示方式也称为<a href="https://baike.baidu.com/item/%E5%8C%BA%E4%BD%8D%E7%A0%81">区位码</a>。GB2312 的每一个字符都由与其唯一对应的区号和位号所确定。例如：汉字“啊”，编号为 16 区 01 位，它的区位码就是 1601（由 16、01 两部分组成，不能读做一千六百零一）。</p><p>分区：</p><table><thead><tr><th>区号</th><th>字数</th><th>字符类别</th></tr></thead><tbody><tr><td>01</td><td>94</td><td>一般符号</td></tr><tr><td>02</td><td>72</td><td>顺序号码</td></tr><tr><td>03</td><td>94</td><td>拉丁字母</td></tr><tr><td>04</td><td>83</td><td>日文假名</td></tr><tr><td>05</td><td>86</td><td>Katakana</td></tr><tr><td>06</td><td>48</td><td>希腊字母</td></tr><tr><td>07</td><td>66</td><td>俄文字母</td></tr><tr><td>08</td><td>63</td><td>汉语拼音符号</td></tr><tr><td>09</td><td>76</td><td>图形符号</td></tr><tr><td>10-15</td><td>-</td><td>备用区</td></tr><tr><td>16-55</td><td>3755</td><td>一级汉字，以拼音为序</td></tr><tr><td>56-87</td><td>3008</td><td>二级汉字，以笔划为序</td></tr><tr><td>88-94</td><td>-</td><td>备用区</td></tr></tbody></table><p>GB2312 字符集和编码对照表：</p><table><thead><tr><th>第 01 区</th><th>+0</th><th>+1</th><th>+2</th><th>+3</th><th>+4</th><th>+5</th><th>+6</th><th>+7</th><th>+8</th><th>+9</th><th>+A</th><th>+B</th><th>+C</th><th>+D</th><th>+E</th><th>+F</th></tr></thead><tbody><tr><td>A1A0</td><td></td><td></td><td>、</td><td>。</td><td>・</td><td>ˉ</td><td>ˇ</td><td>¨</td><td>〃</td><td>々</td><td>―</td><td>～</td><td>‖</td><td>…</td><td>‘</td><td>’</td></tr><tr><td>A1B0</td><td>“</td><td>”</td><td>〔</td><td>〕</td><td>〈</td><td>〉</td><td>《</td><td>》</td><td>「</td><td>」</td><td>『</td><td>』</td><td>〖</td><td>〗</td><td>【</td><td>】</td></tr><tr><td>A1C0</td><td>±</td><td>×</td><td>÷</td><td>∶</td><td>∧</td><td>∨</td><td>∑</td><td>∏</td><td>∪</td><td>∩</td><td>∈</td><td>∷</td><td>√</td><td>⊥</td><td>∥</td><td>∠</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>第 16 区</td><td>+0</td><td>+1</td><td>+2</td><td>+3</td><td>+4</td><td>+5</td><td>+6</td><td>+7</td><td>+8</td><td>+9</td><td>+A</td><td>+B</td><td>+C</td><td>+D</td><td>+E</td><td>+F</td></tr><tr><td>B0A0</td><td></td><td>啊</td><td>阿</td><td>埃</td><td>挨</td><td>哎</td><td>唉</td><td>哀</td><td>皑</td><td>癌</td><td>蔼</td><td>矮</td><td>艾</td><td>碍</td><td>爱</td><td>隘</td></tr></tbody></table><p>注：GB2312 兼容 ASCII 是通过混用的方式，不像 UTF-8 那种重新收录（虽然 GB2312 有重新收录 ASCII 吗，但都是 2 个字节的，即所谓的全拼）</p><ul><li>国标码</li></ul><p><a href="https://baike.baidu.com/item/%E6%B1%89%E5%AD%97%E5%9B%BD%E6%A0%87%E7%A0%81/4880277?fr=aladdin">国标码</a>是汉字信息交换的标准编码。区位码将 ASCII 码原来所代表的东西都占用了，不兼容 ASCII，不能直接存储。于是将区位码偏移 32 位（32D &#x3D; 20H，将十六进制的区位码，区码和位码分别加上 20H），避开 ASCII 前面的控制字符部分，这样就兼容了 ASCII 前 32 位了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 区码和位码的十进制转十六进制</span><br><span class="line">16..toString(16);               // 0x10</span><br><span class="line">1..toString(16);                // 0x1</span><br><span class="line"></span><br><span class="line"># 分别加 20H </span><br><span class="line">(0x10 + 0x20).toString(16);     // 0x30</span><br><span class="line">(0x1 + 0x20).toString(16);      // 0x21</span><br><span class="line"></span><br><span class="line"># 就得到了国标码</span><br><span class="line">1601D -&gt; 1001H -&gt; +20H -&gt; 3021H</span><br></pre></td></tr></table></figure><p>为什么只偏移 20H，不直接偏移 80H？其实，GB2312 虽说是对中文编码，但是里面有对 ASCII 码中的 26 个英文字母和一些特殊符号的重新编码，这么做的目的就是要覆盖掉 ASCII 码 32 位后的符号和英文字母部分，不对 ASCII 兼容。而对于 ASCII 码中前 32 个控制字符则继续沿用（<a href="https://www.zhihu.com/question/20875128">为什么不全部覆盖</a>），所以保留前 32 字符，就需要将汉字编码向后偏移 32（20H），这也就是区位码要加上 20H 得到国标码，这就是 GB2312 的编码规范。</p><p>而这样产生一个弊端，ASCII 码下的英文在 GB2312 下乱码，微软为了解决这个问题，将字节的最高位设为 1，因为 ASCII 中使用 7 位，最高位为 0，这样就区分开了 ASCII 和 GB2312，这也是为什么要加上 8080H。</p><p>也就是说，国标码才是 GB2312 的编码标准，后来的机内码是微软为了兼容 ASCII 采用的方式，本质上是修改了 GB2312 的编码标准，而这种方法最后产生的编码最后就被一些教科书称为内码。</p><ul><li>机内码</li></ul><p><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%86%85%E7%A0%81">机内码</a>又叫内码，GB2312 的机内码是为了解决国标码与 ASCII 码不兼容问题出现的。</p><p>国标码前后字节的最高位为 0，注定会与 ASCII 码冲突，虽然偏移 32 位，解决了与 ASCII 中控制字符的冲突，但是没解决 ASCII 码 32 位之后的字符兼容，不可能在计算机内部直接采用的。如“啊”字，国标码为 30H 和 21H，而西文字符 “0”和 “!” 的 ASCII 也为 30H 和 21H，现假如内存中有两个字节为 31H 和 23H，这到底是一个汉字，还是两个西文字符，就出现了二义性。</p><p>为了解决上面问题，计算机内部使用机内码来处理 GB2312 字符。机内码采用变形国标码，将国标码的每个字节都加上 128（10000000B &#x3D; 128D &#x3D; 80H），即将两个字节的最高位由 0 改 1，其余 7 位不变，这样，两个大于 127 的二进制序列连在一起时，就表示一个汉字。台湾的 Big5 方法也是类似的，都是用 0x80 到 0xFF（128D-255D、10000000B-11111111B）这个区间。</p><p>机内码的这种编码方式就是所谓的 <a href="https://baike.baidu.com/item/EUC">EUC</a> 编码方法（具体来说是 EUC-CN，即在每个区位加上 0xA0 来表示，区和位分别占用一个字节），以便兼容于 ASCII。对于标准 ASCII 字符（小于 127 的字符，即 0x00 - 0x7F）其意义与原来相同，还是按一个字节进行编码。</p><p>回到上面例子，“啊”字的国标码为 3021H，前字节为 00110000B，后字节为 00100001B，高位改 1 为 10110000B 和 10100001B 即为 B0A1，因此，“啊”字的机内码就是 B0A1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 国标码上加 0x80 (0b100000000)</span><br><span class="line"></span><br><span class="line"># 区字节和位字节的十六进制转为二进制</span><br><span class="line">0x30.toString(2);           // 110000</span><br><span class="line">0x21.toString(2);           // 100001</span><br><span class="line"></span><br><span class="line"># 区字节和位字节二进制的高位补 1（十六进制就是加 80H）就得到机内码</span><br><span class="line">0b10110000.toString(16);    // B0</span><br><span class="line">0b10100001.toString(16);    // A1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 区位码上直接加 0xA0</span><br><span class="line">16 + 0xA0;                  // B0</span><br><span class="line">1 + 0xA0;                   // A1</span><br></pre></td></tr></table></figure><p>机内码中，前面的一个字节称之为“高位字节&#x2F;区字节”，从 0xA1 到 0xF7（把 01-87 区的区号加上 0xA0），后面一个字节称为“低位字节&#x2F;位字节”，从 0xA1 到 0xFE（把 01-94 加上 0xA0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以下字符保存为 GB2312 时，file length (in byte) 为 6 个字节。这说明 GB2312 中，前 127 位还是是 ASCII 的 单字节编码，127 位以后是双字节的 GB2312 编码</span><br><span class="line">2,啊，</span><br></pre></td></tr></table></figure><ul><li>区位码、国标码、机内码的转换</li></ul><p>区位码、国标码、机内码在十六进制下的转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">国标码 = 区位码 + 20H</span><br><span class="line">机内码 = 国标码 + 80H = 区位码 + A0H    # (0x80 + 0x20).toString(16) = A0H</span><br></pre></td></tr></table></figure><p>举例，已知机内码 B0A1，求区位码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 解法 1（注意：计算时，区字节和位字节分开减，(0xB0 - 0xA0).toString(16) = 10H）</span><br><span class="line">B0A1H-A0A0H = 1001H = 1601D</span><br><span class="line"></span><br><span class="line"># 解法 2</span><br><span class="line">B0A1H-8080H = 3021H(国标码),3021H-2020H = 1001H = 1601D</span><br></pre></td></tr></table></figure><ul><li>全角和半角</li></ul><p>ASCII 中 127 号以下的那些字符叫“半角”字符，127 号以后，像 GB2312 中的图形符号、汉字字符、英文字符都是“全角”字符。一般的系统命令是不用全角字符的，只是在作文字处理时才会使用全角字符。</p><ul><li>通过机内码输入 GB2312&#x2F;GBK 字符</li></ul><p>Windows 小键盘上，用 Alt + GBK 字符的十进制机内码，能够输入任何 GBK 字符（含 ASCII 字符，因为 GBK 兼容 ASCII）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># “啊”在 GBK 下的机内码的十进制是 45217。按住 Alt，分别在小键盘上输入 45217，再松开 Alt，即可输入“啊”</span><br><span class="line">b0a1H = 45217D</span><br></pre></td></tr></table></figure><p>附：字符转 GB2312 十六进制编码：<a href="https://github.com/liuxiaodong/encodeToGb2312">encodeToGb2312</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># “我爱你”这三个字的机内码就是 52946 45230 50403</span><br><span class="line">encodeToGb2312(&quot;我&quot;);    // CED2，parseInt(&#x27;CED2&#x27;, 16) 结果为 52946</span><br></pre></td></tr></table></figure><h3 id="GBK、GB18030"><a href="#GBK、GB18030" class="headerlink" title="GBK、GB18030"></a>GBK、GB18030</h3><p>GB2312 字符有限，不够用（对于人名、古汉语等方面出现的罕用字，GB2312 就不能处理），于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。这个编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。 后来 GBK 加了几千个新的少数民族的字，扩成了 GB18030。</p><p>GB18030 是 GBK 的超集，GBK 是 GB2312 的超集。GBK 在 Windows、Linux 等多种操作系统中被实现。</p><p>这一系列汉字编码的标准通称叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在 DBCS 系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于 127 的，那么就认为一个双字节字符集里的字符出现了（一个汉字算两个英文字符，strlen(“2,啊，”) &#x3D; 6）。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>ASCII 码和扩展 ASCII 码（ESCII、GBK、JIS…）的时代是一个混乱的时代，没有统一标准，各国编码标准互不兼容，同一个二进制数字可以被解释成不同的符号（Eg：GB2312 编码下的中文，得到二进制序列到了 Big5 编码下解析时，这些二进制序列全部有了新的意义，导致乱码。编码和解码方案的不统一是乱码的主要原因）。</p><p>制定一个包括了地球上所有文化、所有字母和符号的字符集编码方案势在必行。历史上存在两个独立的字符集组织来做这件事：<a href="https://www.iso.org/home.html">ISO</a>&#x2F;<a href="https://www.iec.ch/">IEC</a>（国际标准化组织，国际电工委员会） 和 <a href="http://www.unicode.org/">Unicode</a> 协会（一个由多个软件制造商组成的协会），前者开发了“<a href="https://baike.baidu.com/item/ISO%2010646/1033849?fr=aladdin">ISO 10646</a> 项目”，后者开发了“<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a> 项目”。</p><p>1991 年前后, 两个项目的参与者都认识到, 世界上不需要两个不同的通用字符集，所以双方合并工作成果，为创立一个单一编码表而协同工作。虽然两个项目都独立地公布各自的标准, 但 Unicode 协会和 ISO&#x2F;IEC JTC1&#x2F;SC2 都同意保持 Unicode 和 ISO 10646 标准的码表兼容，从 Unicode 2.0 开始，Unicode 采用了与 ISO 10646-1 相同的字库和字码，ISO 也承诺，ISO 10646 将不会替超出 U+10FFFF 的 UCS-4 编码赋值，以使得两者保持一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 发展过程</span><br><span class="line"></span><br><span class="line">ASCII</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">ESCII、GB2312、GBK...</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">UCS (UCS-2、UCS-4)</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">Unicode (UTF-8、UTF-16、UTF-32)</span><br></pre></td></tr></table></figure><p>Unicode 是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案，1990 年开始研发，1994 年正式公布。目前的 Unicode 字符分为 17 组编排，每组称为一个平面（Plane），每平面拥有 65536（2^16）个码位，共 1114112 个（65536 * 17）码位。</p><p>每一个码位都可以用 16 进制 xy0000 到 xyFFFF 来表示，这里的 xy 是表示一个 16 进制的值，从 00 到 10。平面 0（xy 为 00 时）被称为 BMP （基本多文种平面, Basic Multilingual Plane），它包含了最常用的字符（兼容 ISO-8859-1 字符集），码点范围从 U+0000 到 U+FFFF。剩下还有 16 个“辅助平面”，码点范围从 U+010000 一直到 U+10FFFF。</p><table><thead><tr><th>平面</th><th>始末字符值</th><th>中文名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td>0号平面</td><td>U+0000 - U+FFFF</td><td>基本多文种平面</td><td>BMP</td><td>绝大部分日常现代文字，比如英文、中文、日语、法语等</td></tr><tr><td>1号平面</td><td>U+10000 - U+1FFFF</td><td>多文种补充平面</td><td>SMP</td><td>古代字体、音符、扑克牌、麻将</td></tr><tr><td>2号平面</td><td>U+20000 - U+2FFFF</td><td>表意文字补充平面</td><td>SIP</td><td>CJKV 的增补文字，比如《康熙字典》中出现的非现代文字</td></tr><tr><td>3号平面</td><td>U+30000 - U+3FFFF</td><td>表意文字第三平面</td><td>TIP</td><td>可能存放甲骨文、金文、小篆</td></tr><tr><td>4～13号平面</td><td>U+40000 - U+DFFFF</td><td>（尚未使用）</td><td></td><td>可能存放甲骨文、金文、小篆</td></tr><tr><td>14号平面</td><td>U+E0000 - U+EFFFF</td><td>特别用途补充平面</td><td>SSP</td><td>特殊的控制字符，比如字形变换选取器</td></tr><tr><td>15号平面</td><td>U+F0000 - U+FFFFF</td><td>保留作为私人使用区（A区）</td><td>PUA-A</td><td>随意使用的私人区域</td></tr><tr><td>16号平面</td><td>U+100000 - U+10FFFF</td><td>保留作为私人使用区（B区）</td><td>PUA-B</td><td>随意使用的私人区域</td></tr></tbody></table><p>在 Unicode 5.0.0 版本中，已定义的码位只有 238605 个，分布在平面 0、平面 1、平面 2、平面 14、平面 15、平面 16。其中平面 15 和平面 16 上只是定义了两个各占 65534 个码位的专用区（Private Use Area），分别是 0xF0000-0xFFFFD 和 0x100000-0x10FFFD。所谓专用区，就是保留给大家放自定义字符的区域，可以简写为 PUA。</p><p>平面 0 也有一个专用区 0xE000-0xF8FF，有 6400 个码位。另外平面 0 的 0xD800-0xDFFF，共 2048 个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的是用两个 UTF-16 字符表示 BMP 以外的字符，具体参考 UTF-16 章节。</p><p>如前所述在 Unicode 5.0.0 版本中，238605-65534*2-6400-2408&#x3D;99089。余下的 99089 个已定义码位分布在平面 0、平面 1、平面 2 和平面 14 上，它们对应着 Unicode 目前定义的 99089 个字符，其中包括 71226 个汉字。平面 0、平面 1、平面 2 和平面 14 上分别定义了 52080、3419、43253 和 337 个字符。平面 2 的 43253 个字符都是汉字。平面 0 上定义了 27973 个汉字。</p><p>这 17 个平面结合起来至少需要占据 21 位的空间（0x10FFFF.toString(2).length），也就是差不多 3 个字节（24位），而辅助平面实际上是用 4 个字节表示，方便以后向后扩展。</p><p>Unicode 字符集，中文范围 4E00-9FA5（BMP 中）：</p><table><thead><tr><th>U+</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>4e00</td><td>一</td><td>丁</td><td>丂</td><td>七</td><td>丄</td><td>丅</td><td>丆</td><td>万</td><td>丈</td><td>三</td><td>上</td><td>下</td><td>丌</td><td>不</td><td>与</td><td>丏</td></tr><tr><td>4e10</td><td>丐</td><td>丑</td><td>丒</td><td>专</td><td>且</td><td>丕</td><td>世</td><td>丗</td><td>丘</td><td>丙</td><td>业</td><td>丛</td><td>东</td><td>丝</td><td>丞</td><td>丟</td></tr><tr><td>4e20</td><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;一&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e00</span></span><br><span class="line"><span class="string">&#x27;丑&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e11</span></span><br><span class="line"><span class="string">&#x27;丟&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e1f</span></span><br></pre></td></tr></table></figure><p>Unicode 包含了世界上所有的语言字符的字符集，Unicode 给每个字符分配一个唯一的 <a href="https://www.unicode.org/charts/PDF/U0000.pdf">ID／码点</a> (<a href="https://unicode-table.com/cn/">中文版</a>) — 用一个十六进制数的前面加上 U+ 的 Unicode 表示，例如 “U+0041” 代表字符 “A” 。</p><p>注：Widows 下可通过 charmap (Win + R，输入 charmap) 来查看一个字符的 Unicode 编码。</p><h3 id="UCS"><a href="#UCS" class="headerlink" title="UCS"></a>UCS</h3><p><a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86">UCS 通用字符集 (Universal Character Set)</a>，是由 ISO 10646 标准所定义的标准字符集，其所对应的编码方式为 UCS-2、UCS-4。</p><p>UCS-2 用 2 个字节为字符编码，可以容纳的字符数为 65536 个（2^16），所以 UCS-2 只能编码 BMP 范围内的字符（在 Unicode 中被 UTF-16 所取代）。UCS-4 用 4 个字节为字符编码，实际上只用了 31 位，最高位必须为 0，它可以容纳的字符数为 2147483648 个（2^31，20 多个亿），但实际使用范围并不超过 0x10FFFF，并且为了兼容 Unicode 标准，ISO也承诺将不会为超出 0x10FFFF 的 UCS-4 编码赋值。UCS-2、UCS-4 都是定长的，无论是半角英文字母，还是全角汉字。</p><p>在实际使用中，UCS 已被 Unicode 所替代，二者的字符集一样，Unicode 的编码方案比 UCS 更灵活（UTF-32 等同于 UCS-4，UTF-16 是 UCS-2 的父集，UTF-8 在 UCS 中没有实现）。</p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>UTF (Unicode 转换格式，Unicode Transformation Format) 是 Unicode 的实现方式，是 Unicode 在计算机中的存储和传输标准。其实就是不改变字符集中各个字符的代码的情况下，建立一套新的编码方式，把字符的代码通过这个编码方式映射成传输时的编码，主要目的就是在使用 Unicode 字符集保持通用性的同时节约流量和硬盘空间。</p><p>在 Unicode 中，字符集和编码方案是分离的，Unicode 只是一个字符集，只规定了字符的码点，没有规定这个码点应该如何存储（8 bit、16 bit、32 bit）。像“Unicode 用两个字节编码”、“Unicode 中一个字符等于两个字节”，这些说法是不成立的。</p><p>之所以不对 Unicode 码点直接编码，是从“分词”和“空间”上考量的。比如，汉字“严”的 Unicode 是十六进制数 4E25，转换成二进制数足足有 15 位（100111000100101），也就是说这个符号的表示至少需要 2 个字节，表示其他更大的符号，可能需要 3 个字节或者 4 个字节。</p><ul><li>分词</li></ul><p>如何才能区别 Unicode 和 ASCII？计算机怎么知道 2 个或 4 个字节表示一个符号，而不是分别表示 2 个或 4 个符号呢？</p><ul><li>空间</li></ul><p>要编码 Unicode 那么多字符，至少要用到 2 个字节，而 UCS-2、UCS-4 这种定长的编码方案都不适合在计算机中存储和传输，原先 ASCII 码中的 0 - 127 位，如果直接使用 UCS 的码点直接存储、传输，对英语国家是种巨大的浪费（UCS-2 下 1 GB 变成 2 GB，UCS-4 下 1 GB 变成 4 GB）。</p><p>为了解决上述问题，对 Unicode 的字符码再做二次编码，这就诞生了 UTF-8、UTF-16、UTF-32 编码标准。</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>Unicode 最直观的编码方式是每个码点使用 4 个字节表示，字节内容与码点一一对应。这种编码方法就叫做 UTF-32。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 4 个字节表示一个字符，比如，字母 a 的 UTF-32 为：</span><br><span class="line">0x00000061</span><br></pre></td></tr></table></figure><p>优点：转换规则简单直观，查找效率高，时间复杂度o(1)。缺点：浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。</p><p>UTF-32 可以看作是 UCS-4，或者它的子集（虽然 UCS-4 本身可以编码到 0x7FFFFFFF，但是 ISO 承诺，ISO 10646 将不会替超出 0x10FFFF）。</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8 是一种变长的编码方法（变长节省空间，一般用于外码，来进行存储和传输，而定长方便实现和处理效率高，一般用于内码，比如 JavaScript 中），字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。</p><p>UTF-8 作为最流行的编码方案，其优点有：良好的多语种支持（相对 GBK 等跟语种绑定的编码方式）；兼容 ASCII；没有字节序的问题；以英文和西文符号比较多的场景下（HTML&#x2F;XML），编码较短。</p><ul><li>UTF-8 转码规则</li></ul><p>1）对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；<br>2）对于 n 个字节的字符（n&gt;1），第一个字节的前 n 位设为 1，第 n+1 位设为 0，后面字节的前两位都设为 10，这 n 个字节的其余空位填充该字符 Unicode 码，高位用 0 补足。</p><p>UTF-8 以字节为单位对 Unicode 进行编码，从 Unicode 到 UTF-8 的编码方式如下（字母 x 表示可用编码的位）：</p><table><thead><tr><th>Unicode 编码(十六进制)</th><th>UTF-8 字节流（二进制）</th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。下面，还是以汉字“严”为例，演示如何实现 UTF-8 编码。</p><p>已知“严”的 Unicode 是 4E25，根据上表，可以发现 4E25 处在 000800-00FFFF 范围内，因此“严”的 UTF-8 编码需要三个字节，即格式是 “1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始（100 1110 0010 0101），依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，“严”的 UTF-8 编码是”11100100 10111000 10100101”，转换成十六进制就是 E4B8A5。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点，大部分常用字符都以固定的 2 个字节长度储存，是一种变长表示。</p><p>在 UTF-16 中，基本平面（BMP，U+0000 到 U+FFFF）的字符使用 2 个字节编码，辅助平面（U+010000 到 U+10FFFF）的字符使用 4 个字节编码。和 UTF-32 一样，UTF-16 也不兼容 ASCII 编码（都 Unicode 时代了，为什么还要兼容 ASCII）。</p><p>UTF-16 的优点：UTF-16 的前身 UCS-2 是定长的，处理起来容易，遍历速度要快，这使得 UTF-16 在编程语言内部被大量应用（Java、JavaScript、Windows 操作系统内部…）。另外空间上，UTF-16 在编码中文时比 UTF-8 要少 50%（BMP 的字符，以 UTF-16 编码时使用 2 字节，以 UTF-8 编码时使用 1 至 3 字节。超出 BMP 的字符，以 UTF-16 或 UTF-8 编码都需要 4 字节）。</p><ul><li>与 UCS-2 的区别</li></ul><p>UTF-16 可看成是 UCS-2 的父集，在 0x0000 到 0xFFFF 码位范围内，UTF-16 与 UCS-2 所指的是同一的意思（严格的说这并不正确，因为在 UTF-16 中从 U+D800 到 U+DFFF 的码位不对应于任何字符，而在使用 UCS-2 的时代，U+D800 到 U+DFFF 内的值被占用），当引入辅助平面字符后，对 0x10000 之外的字符，UCS-2 没有与之对应的编码，UTF-16 实现了编码。</p><ul><li>UTF-16 转码规则</li></ul><p>Unicode 码点转 UTF-16，首先区分这是基本平面字符，还是辅助平面字符。对于基本平面的字符，直接将码点转为对应的十六进制形式，以 2 个字节来编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U+597D = 0x597D</span><br></pre></td></tr></table></figure><p>对于辅助平面的字符，以代理对 (surrogate pair) 的形式用 4 个字节来编码。</p><p>Surrogate pair 是 UTF-16 中用于扩展字符而使用的编码方式，其采用四个字节来表示一个字符。具体的做法是取 BMP 范围里的 0xD800<del>0xDBFF 和 0xDC00</del>0xDFFF 的 code point (总范围为 D800-DFFF，这部分码点在 BMP 内是保留的，不映射到任何字符)，前者称为高位代理 high surrogates，后者称为低位代理 low surrogates，一个 high surrogate 接一个 low surrogate 拼成四个字节表示超出 BMP 的字符。</p><p>两个 surrogate range 都是 1024 个 code point，所以 surrogate pair 可以表达 1024 x 1024 &#x3D; 1048576 &#x3D; 0x100000 个字符，这就是 Unicode 的字符集范围上限是 0x10FFFF 的原因 ((0x100000 + 0xffff).toString(16) &#x3D; 0x10ffff)。为了照顾 UTF-16 以及一大堆采用了 UTF-16 的语言、操作系统（比如 Windows），这个上限不能突破。</p><p>UTF-16 对于辅助平面的编码转换，Unicode 3.0 版给出了转码公式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">H = <span class="title class_">Math</span>.<span class="title function_">floor</span>((c - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xD800</span></span><br><span class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></span><br><span class="line"></span><br><span class="line"># 比如辅助平面上的 💩，码点为 U+1f4a9（<span class="variable constant_">JS</span> 中表示为 <span class="string">&#x27;\u&#123;1f4a9&#125;&#x27;</span> 或 <span class="string">&#x27;\ud83d\udca9&#x27;</span>）</span><br><span class="line">H = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="number">0x1f4a9</span> - <span class="number">0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span>      <span class="comment">// 0xd83d</span></span><br><span class="line">L = (<span class="number">0x1f4a9</span> - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span>                <span class="comment">// 0xdca9</span></span><br></pre></td></tr></table></figure><p>注：辅助平面之所以采用 Surrogate pair 的方式编码，而不直接用 4 个字节编码码点，目的是为了区分 BMP 里面 2 个字节的编码，要不然不知道怎么分词。</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>BOM (Byte Order Mark)  — 字节顺序标记，用在文件的开头，用于标记大小端序的。</p><p>字节序就是数据在内存、磁盘、网络传输中存放的顺序，“多字节为编码单元”的编码方案都会存在大小端问题，比如 UTF-16 字符编码方案就分为 UTF-16BE 和 UTF-16LE，如果 BOM 是 FEFF，则表示大端序，如果 BOM 是 FFFE，则表示小端序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Little-Endian  # 小端。就是高位字节排放在内存的高地址端，低位字节排放在内存的低地址端（符合人类的感官思维）</span><br><span class="line">Big-Endian     # 大端。就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端</span><br></pre></td></tr></table></figure><p>Unicode 规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做“零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大 1。如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式，如果头两个字节是 FF FE，就表示该文件采用小端方式。</p><p>例如，一个“奎”的 Unicode 编码是 594E，“乙”的 Unicode 编码是 4E59。如果我们收到 UTF-16 字节流 “594E”，那么这是“奎”还是“乙”？如果 BOM 是大端序，那么代码点就应该是 594E，那么就是“奎”，如果 BOM 是小端序，那么代码点就应该是 4E59，就是“乙”了。</p><ul><li>UTF-16 和 UTF-32 有字节序问题，UTF-8 和 GBK 没有</li></ul><p>为什么 UTF-16 和 UTF-32 有字节序问题，而 UTF-8 和 GBK 没有？要想搞清楚这个问题，需要先搞清楚什么是 Code Unit。</p><p>Code Unit（编码单元&#x2F;码元）：是编码使用的最短比特组合单元。UTF-8 中一个编码单元是 8 bit 长，UTF-16 中一个编码单元是 16 bit 长，UTF-32 是 32 bit（UTF 后边的数字代表的就是码元的大小）。换一种说法就是 UTF-8 的是以一个字节为最小单位的，UTF-16 是以两个字节为最小单位的。</p><p>单个码元可以表示完整的码点，也可以表示码点的一部分。例如，雪人字形(☃)这个码点，在 UTF-8 中需要 3 个码元，在 UTF-16 中需要 1 个。</p><p>以单字节为编码单元的 UTF-8、GB2312 不存在字节序问题，因为字节顺序已经规定好了，不存在谁在高位、谁在低位的问题。比如 UTF-8 的处理过程是这样的：读入第一个字节，该字节中包含了该 Unicode 字符总共用几个字节编码的信息，然后根据上述信息再读入接下来的字节，由此完成一个字符的解码，以此类推。因此整个 Unicode 文件对解码器来说只是一个字节（8 bit）流，所以不涉及字节序的问题。</p><p>而以多字节为编码单元的 UTF-16、UTF-32 中，就需要考虑字节序的问题了。比如，以 2 个字节为编码单元的 UTF-16，这 2 个字节哪个存高位哪个存低位（使用大端还是小端）。Unicode 规范中没有规定字节序，这导致各个平台和 CPU 的实现不一致，有的使用大端有的使用小端，所以必须使用 BOM 来区分。</p><p>注：JavaScript 中字符串的 length 属性返回的是 UTF-16 下字符串的 Code Unit 个数，而不是 Code Point 个数。</p><ul><li>Windows 平台下特有的 UTF-8 width BOM</li></ul><p>BOM 除了标记大小端序外，还可用在 Windows 系统中（记事本）用来标记编码方案。</p><p>UTF-8 本身不存在字节序问题，Windows 记事本中给 UTF-8 带上 BOM 是为了区分编码方案。在 Windows 记事本中一段二进制编码，如何确定它是 GBK 还是 BIG5 还是 UTF-16 还是 UTF-8呢，记事本的做法是在 TXT 文件的最前面保存一个标签，如果记事本打开一个 TXT，发现这个标签，就说明是 Unicode（其中 0xFF 0xFE 代表 UTF16LE，0xFE 0xFF 代表 UTF16BE，0xEF 0xBB 0xBF 代表 UTF-8），如果没有这个标签，那么就是 ANSI，使用操作系统的默认语言编码来解释。</p><p>Unicode 标准中 BOM 只是用来标记字节序，微软用 BOM 来标记编码方案是不标准的，这是 Windows 记事本特有的，带 BOM 的 UTF-8 不但多出 3 个字节，最关键是，这样的文件在 Windows 之外的操作系统里可能会带来问题，不含 BOM 的 UTF-8 才是标准形式。</p><table><thead><tr><th>UTF 编码</th><th>Byte Order Mark (BOM)</th></tr></thead><tbody><tr><td>UTF-8 without BOM</td><td>无</td></tr><tr><td>UTF-8 with BOM</td><td>EF BB BF</td></tr><tr><td>UTF-16LE</td><td>FF FE</td></tr><tr><td>UTF-16BE</td><td>FE FF</td></tr><tr><td>UTF-32LE</td><td>FF FE 00 00</td></tr><tr><td>UTF-32BE</td><td>00 00 FE FF</td></tr></tbody></table><p>注：可以通过一个 Hex Editor 来查看一个文本文件的 BOM。</p><p>关于 Windows 记事本再多说几句，Windows notepad 另存为时编码可以选择 ANSI、Unicode、Unicode big endian、UTF-8，其含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ANSI                # ANSI 是遗留（legacy）编码</span><br><span class="line">Unicode             # UTF-16 LE</span><br><span class="line">Unicode big endian  # UTF-16 BE </span><br><span class="line">UTF-8               # UTF-8 width BOM </span><br></pre></td></tr></table></figure><p>其中，ANSI 是遗留（legacy）编码，对应当前系统 locale 遗留编码，在不同语言系统中编码不同（简中下是 GBK、繁中是 Big5、日文 Windows 操作系统中代表 Shift_JIS），微软术语叫 code page。另外，关于 UTF-8，当涉及到跨平台兼容性时，请不要用记事本编辑 UTF-8 文件，应用专业的文本编辑器保存为不带 BOM 的 UTF-8。</p><p>注：记事本下，依次采用 ANSI，Unicode，Unicode big endian 和 UTF-8 编码方式保存”啊”，然后查看其文件大小（带 BOM 的 UTF-8 会比不带 BOM 的多出 3 个字节）和观察该文件的内部十六进制编码方式。</p><ul><li>主机字节序和网络字节序</li></ul><p>主机字节序是不确定的，而网络字节序是确定的。</p><p>不同的主机有不同的字节序，如 x86 为小端字节序，Motorola 6800 为大端字节序，ARM 字节序是可配置的。</p><p>TCP&#x2F;IP 在 RFC1700 中规定使用“大端”字节序为网络字节序，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。在不使用大端的计算机中，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。</p><h2 id="字符的编码解码和编码转换"><a href="#字符的编码解码和编码转换" class="headerlink" title="字符的编码解码和编码转换"></a>字符的编码解码和编码转换</h2><h3 id="字符的编码解码"><a href="#字符的编码解码" class="headerlink" title="字符的编码解码"></a>字符的编码解码</h3><ul><li>Unicode</li></ul><p>JavaScript 中可通过 charCodeAt、escape 和 String.fromCharCode、unescape 来编解码 Unicode 字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 编码：字符转 Unicode 的十六进制编码</span><br><span class="line">function encodeUnicode(str) &#123;</span><br><span class="line">  let result = &#x27;&#x27;;</span><br><span class="line">  for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    let point = (&#x27;00&#x27; + str.charCodeAt(0).toString(16)).slice(-4);</span><br><span class="line">    </span><br><span class="line">    result += &#x27;\\u&#x27; + point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encodeUnicode(&#x27;严&#x27;);            // \u4e25</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 解码</span><br><span class="line">function decodeUnicode(str) &#123;  </span><br><span class="line">  str = str.replace(/\\/g, &#x27;%&#x27;);  </span><br><span class="line">  return unescape(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeUnicode(&#x27;\u4e25&#x27;);        // 严</span><br></pre></td></tr></table></figure><p>注：JavaScript 中字符使用 UTF-16 存储，charCodeAt 和 escape 其实返回的其实是 UTF-16 十六进制编码，不过在 BMP 中，UTF-16 十六进制编码和 Unicode 的 Code Point 是一样的。另外，上面的方法不支持辅助平面上的字符。</p><ul><li>UTF-8</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编码：字符转 UTF-8 的十六进制编码</span><br><span class="line">encodeURI(&#x27;严&#x27;);                 // &quot;%E4%B8%A5&quot;</span><br><span class="line"></span><br><span class="line"># 解码：UTF-8 字符的十六进制编码转字符</span><br><span class="line">decodeURI(&#x27;%E4%B8%A5&#x27;);          // 严</span><br></pre></td></tr></table></figure><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><ul><li>Unicode 和 UTF-8 互转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unicodeToUTF8</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000000</span> &amp;&amp; hex &lt;= <span class="number">0x0000007F</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hex;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000080</span> &amp;&amp; hex &lt;= <span class="number">0x000007FF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0x7C0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0xC0</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (hex &amp; <span class="number">0x03F</span>) | <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">return</span> r1 | r2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000800</span> &amp;&amp; hex &lt;= <span class="number">0x0000FFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>) | <span class="number">0xE0</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (((hex &amp; <span class="number">0x0FC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r3 = ((hex &amp; <span class="number">0x003F</span>) | <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> r1 | r2 | r3;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00010000</span> &amp;&amp; hex &lt;= <span class="number">0x0010FFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0x1C0000</span>) &gt;&gt; <span class="number">18</span>) | <span class="number">0xE0</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (((hex &amp; <span class="number">0x03F000</span>) &gt;&gt; <span class="number">12</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> r3 = (((hex &amp; <span class="number">0x000FC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r4 = ((hex &amp; <span class="number">0x00003F</span>) | <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> r1 | r2 | r3 | r4;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">unicodeToUTF8</span>(<span class="number">0x4e25</span>);  <span class="comment">// 14989477，14989477..toString(16); e4b8a5</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">utf8ToUnicode</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> utf8Binary = hex.<span class="title function_">toString</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> arrItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; utf8Binary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        arrItem += utf8Binary[i];</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">8</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            arr.<span class="title function_">push</span>(arrItem);</span><br><span class="line">            arrItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            result += arr[i].<span class="title function_">slice</span>(arr.<span class="property">length</span> + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += arr[i].<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">utf8ToUnicode</span>(<span class="number">0xE4B8A5</span>);  <span class="comment">// 4e25</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">utf8ToUnicode</span>(<span class="params">hex</span>) &#123;    </span><br><span class="line">  <span class="keyword">let</span> utf8Binary = hex.<span class="title function_">toString</span>(<span class="number">2</span>);    </span><br><span class="line">  <span class="keyword">let</span> arr = [];    </span><br><span class="line">  <span class="keyword">let</span> arrItem = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; utf8Binary.<span class="property">length</span>; i++) &#123;       </span><br><span class="line">    arrItem += utf8Binary[i];        </span><br><span class="line">    <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">8</span> === <span class="number">0</span>) &#123;            </span><br><span class="line">      arr.<span class="title function_">push</span>(arrItem);            </span><br><span class="line">      arrItem = <span class="string">&#x27;&#x27;</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;            </span><br><span class="line">      result += arr[i].<span class="title function_">slice</span>(arr.<span class="property">length</span> + <span class="number">1</span>)        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">      result += arr[i].<span class="title function_">slice</span>(<span class="number">2</span>);        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">utf8ToUnicode</span>(<span class="number">0xE4B8A5</span>);  <span class="comment">// 4e25</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> foundations </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 设计模式</title>
      <link href="/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>大型的 CSS 项目中，往往会遇到 CSS 结构混乱、多人协作命名冲突、没有组件化无法复用…等等问题。为了解决这些问题于是引入 CSS 设计模式，用 BEM 来解决命名空间的问题，用 SMACSS 来解决代码分层问题，用 OOCSS 来解决解构复用问题。</p><span id="more"></span><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>对于 CSS 选择器的命名空间，一般的做法是通过选择器嵌套来约束命名空间，但是这种方式带来了很多问题 – 嵌套层次深不但影响了性能也导致了重度的 DOM 依赖，还有最重要的是命名冲突。</p><p>一个优秀的 CSS 命名方案，应该要解决以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 具备 NameSpace；</span><br><span class="line">* 不能与嵌套的业务样式命名冲突；</span><br><span class="line">* 独立、对上层不过度依赖；</span><br></pre></td></tr></table></figure><p>BEM 的出现解决了上述问题。</p><p>BEM 中，B 代表 Block（Component）、E 代表 Element、M 代表 Modify。规定用 <code>__</code> 连接 E，用 <code>--</code>连接 M，用 <code>-</code> 连接单词和命名前缀。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.m-page</span><br><span class="line">.m-page__item</span><br><span class="line">.m-page__item--cur</span><br><span class="line">.m-page--center</span><br></pre></td></tr></table></figure><p>注：BEM 最多只有三层，不可能存在嵌套的 Element，比如 <code>.m-page__item__anchor--cur</code>。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS 是一个比较全面的 CSS 规范，它不但规范了命名空间，还对 CSS 进行了分层。具体到项目中，只参考它的分层。</p><h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>命名前缀用于说明 UI 类型归属，可以结合 BEM 一同使用，用于说明 Block 的类型。</p><ul><li>g-栅格</li></ul><p>简单栅格系统：用户后台 <code>g-hd</code>、<code>g-fd</code>、<code>g-bd</code>、<code>g-sd</code>、<code>g-mn</code>，前台和中间页 <code>g-head</code>、<code>g-body</code>、<code>g-foot</code>。</p><ul><li>f-原子类</li></ul><p>常用原子类：<code>f-bfc</code>、<code>f-clearfix</code>、<code>f-ellipsis</code>、<code>f-show</code>、<code>f-hide</code>、<code>f-cb</code>…。</p><p>定义原子类必须谨慎，功能性的原子类还好（<code>f-clearfix</code>、<code>f-bfc</code>），描述性的原子类必须谨慎（比如 <code>f-w100</code>）。原子类的使用场景是供后端使用的，或者前端 fix issue 时紧急使用。</p><p>原子类的缺陷：与 inline style 无异，没有做到结构与样式的分离；容易导致 class 臃肿。</p><ul><li>u-元件</li></ul><p>常用元件：<code>u-btn</code>、<code>u-ipt</code>、<code>u-select</code>、<code>u-line</code>、<code>u-link</code>…。</p><p>利用 OOCSS 来对页面元素进行抽象，是一种非常好的做法，这样可以通过继承，组合出不同的样式。但是也有导致 class 的臃肿的缺点，不过为了前者的实用性，后者的这点缺点也算不了什么。</p><ul><li>m-组件</li></ul><p>常用的 UI 组件：<code>m-tab</code>、<code>m-table</code>、<code>m-form</code>、<code>m-page</code>、<code>m-dialog</code>、<code>m-btns</code>、<code>m-select</code>、<code>m-search-box...</code>、<code>m-header</code>、<code>m-footer</code>…。</p><p>UI 的组件化也就是 HTML、CSS 的组件化。模块化、组件化的目的是封装（作用域隔离）、复用，这使得代码简洁易读易维护，按照最小组件化原则，非常有利于项目在快速迭代中的发展。</p><p>组件化原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 组件化抽象的第一原则是复用（这也是 m 与 c 最主要的区别）；</span><br><span class="line">* 各个组件独立划分，充分解耦，遵守职责单一原则；</span><br><span class="line">* 业务 m 不能与全局 m 冲突，业务 m 要带上业务前缀（比如，m-header-mall），必要时还要加上模块前缀（比如，m-title-mall-index）；</span><br></pre></td></tr></table></figure><p>自定义组件：</p><p>当组件化不满足场景时，可对 modify 进行自定义（组件不满足场景大部分是 modify 不满足）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m-page--center</span><br><span class="line">c-choiceness-stage__carousel--junior</span><br><span class="line">c-choiceness-stage__carousel--high</span><br><span class="line">c-choiceness-stage__carousel--senior</span><br></pre></td></tr></table></figure><ul><li>c-模块</li></ul><p>整个 UI 都可以被模块化，包括业务，使用 <code>c-xx</code> 来作为命名前缀（c 指代 component，表示模块，而非 custom）。</p><p>component 和 module 的区别：component 包含 module，module 是 component 的组成部分，组件一般是可高度复用，可在整个项目或者跨项目通用的，这里的 c 其实指的是不可复用的业务模块（<code>模块 - 组件 = 不可复用的业务模块</code>），主要目的是封装，不具备 m 一样的复用能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-login      # login 不能被复用，所以这里不能用 m-login</span><br></pre></td></tr></table></figure><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCSS 只是一种思想，并没有具体的规范，用 OO 的方式来对 CSS 进行解构抽象，能够达到很好的作用域封装和复用效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.u-btn .u-btn--normal .u-btn--gray</span><br><span class="line">.m-page .m-page--center</span><br><span class="line">.m-tips .m-tips--success</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科里化函数</title>
      <link href="/2016/12/02/Currying/"/>
      <url>/2016/12/02/Currying/</url>
      
        <content type="html"><![CDATA[<p>科里话的关键是返回函数实现连式调用、参数收集、以及判断收集结束做最终调用。判断收集结束有很多办法：对比实参和形参的长度；判断实参的个数是否为 0（不传）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="comment">// 通过手动调用的方式（即不传参数）来判断收集结束</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">currying</span>(fn.<span class="title function_">bind</span>(<span class="literal">null</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 须手动结束调用</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><span id="more"></span><p>上面版本中，对被科里化的函数没要求，但需要手动结束调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123; <span class="comment">// 这里通过型参长度来判断是否要调用，所以 add 的参数不能使用 spread 运算符 ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...remain</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">_fn</span>(...args, ...remain);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本中，被科里化函数的形参长度必须固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>这个版本中，不需手动结束调用，但被科里化的函数的形参必须要有长度。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外循环，几轮冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 共进行 arr.length 轮冒泡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="comment">// 俩俩对比，最后一个元素后面没有元素了，所以减 1，已冒泡上去的元素无需再参与，所以减 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]; <span class="comment">// distribute 交换数组位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bubbleSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>]));</span><br></pre></td></tr></table></figure><span id="more"></span><p>可在原型链上扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">this</span>.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[j] - <span class="variable language_">this</span>[j + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = <span class="variable language_">this</span>[j];</span><br><span class="line">        <span class="variable language_">this</span>[j] = <span class="variable language_">this</span>[j + <span class="number">1</span>];</span><br><span class="line">        <span class="variable language_">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>].<span class="title function_">bubbleSort</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案</title>
      <link href="/2016/07/02/Adaptation-Rule/"/>
      <url>/2016/07/02/Adaptation-Rule/</url>
      
        <content type="html"><![CDATA[<p>在 PC 端，除了数据可视化和中后台这样一些全屏设计场景需要适配，绝大多数的网页采用的都是固定尺寸设计，由于 1366+ 的屏幕尺寸大于常用的固定设计尺寸，网页按设计尺寸 1:1 还原即可，不需要考虑适配。而在移动端，由于屏幕尺寸大小不一，且采用全屏的设计风格，则需要做适配。</p><p>目前移动端端内主流适配方案有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 流体式/弹性式；</span><br><span class="line">* Layout Viewport Scale；</span><br><span class="line">* VW + Rem；</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：适配方案还有设备独立像素和 Media Query（query 的是逻辑像素）。</p><p>抽象的设备独立像素解决的是端内高密度屏的适配（底层图形系统会根据 DPI 自动换算为物理像素），Media Query 解决的是跨端的设计风格适配，而流体、Rem、Layout Viewport Scale 解决的是端内设计要素（盒模型、字体、图片…）的适配（同一 UI 的整体缩放，没有设计上的差异）。</p><p>在设计要素适配中，“盒模型”和“字体”只需要考虑大小，而“图像”相对复杂一些，需要考虑流量、清晰度等问题，常见的解决方案有：矢量化、字体化、image-set 等。</p><h2 id="流体式"><a href="#流体式" class="headerlink" title="流体式"></a>流体式</h2><p>这是最早使用的适配方案，也是最常用的一种，特别是在响应式 UI 框架中（比如 Bootstrap）。其原理是，完美视口下，选需要兼容设备的最小宽度（一般都是 320px）来布局，垂直方向的高度和间距使用定值，水平方向用百分比、定值、flex…，最终达到“当手机屏幕变化时，横向拉伸或者填充空白的效果”。Eg：<a href="https://m.baidu.com/">百度</a>、<a href="https://www.amazon.cn/">亚马逊</a>。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 为完美视口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>步骤二，切图布局</li></ul><p>小往大适配，选需要兼容设备的最小尺寸还原设计稿（一般都是 iPhone5 的 320px，这是当前主流手机中的最小尺寸），当屏幕变宽时，简单的填充空白即可（如果从大到小，小分辨率设备上，就会出现滚动条）。</p><p>注：选主流中最小分辨率机型来进行设计（640 * 1334），<code>CSS 尺寸 = 视觉稿尺寸/dpr = 640/2 = 320</code>。前端在高清视觉稿下切图，使得图片兼容 Retain，在 CSS 中缩放；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">max-width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon</span> &#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">....</span>) no-repeat <span class="number">0</span> <span class="number">0</span>/cover;&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 简单方便；</span><br><span class="line">* 兼容第三方组件（echarts、mintUI...）；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 还原度不精确（如果以开发规范驱动设计就不会存在这个问题） --- 在分辨率不同的设备上，页面的字体大小，内容尺寸都是一样的，不同的是，大屏的内容间的空隙比小屏的大；</span><br></pre></td></tr></table></figure><h2 id="Layout-Viewport-Scale"><a href="#Layout-Viewport-Scale" class="headerlink" title="Layout Viewport Scale"></a>Layout Viewport Scale</h2><p>设计稿、页面布局、Layout Viewport 使用统一宽度，前端按设计稿的尺寸还原，使用定值单位（px、em…），利用浏览器『自身缩放』完成适配。Eg：<a href="http://c.3g.163.com/CreditMarket/default.html">网易新闻</a>。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 的宽度</li></ul><p>一般会设为 640。与流体式一样，这两种方案的核心都是视口的确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=设计稿的宽度&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该方案使用固定宽度值，需要考虑主流分辨率，确定一个合适的值，既不能选大了，也不能选小了，选大了可能会使得在小分辨率屏幕下像素丢失，选小了又可能会使得在大分辨率屏幕下模糊。</p><ul><li>步骤二，缩放</li></ul><p>正常浏览器都会将 <code>Layout Viewport</code> 自动缩放至屏内（视觉视口），不能自动缩放的浏览器要手动计算 scale 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> metaEle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>),</span><br><span class="line">    metaCon = metaEle ? metaEle.<span class="property">content</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    matchScale = metaCon.<span class="title function_">match</span>(<span class="regexp">/initial\-scale=([\d\.]+)/</span>),</span><br><span class="line">    matchWidth = metaCon.<span class="title function_">match</span>(<span class="regexp">/width=([^,\s]+)/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEle &amp;&amp; !matchScale &amp;&amp; (matchWidth &amp;&amp; matchWidth[<span class="number">1</span>] != <span class="string">&#x27;device-width&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> layoutViewportWidth = <span class="built_in">parseInt</span>(matchWidth[<span class="number">1</span>]),</span><br><span class="line">      screenWidth = screen.<span class="property">width</span>;</span><br><span class="line"></span><br><span class="line">    scale = screenWidth / layoutViewportWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      metaEle.<span class="property">content</span> += <span class="string">&#x27;,initial-scale=&#x27;</span> + scale + <span class="string">&#x27;,maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;, minimum-scale=&#x27;</span> + scale + <span class="string">&#x27;,user-scalable=no&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">viewport</span>();</span><br></pre></td></tr></table></figure><p>以下面动态生成的结果为例，640 是根据设计稿定下的，0.5(1&#x2F;dpr，或者 320&#x2F;640) 是根据屏幕宽度动态生成的。生成的 viewport 告诉浏览器网页的布局视口使用 640px，然后把页面缩放成 50%，图片、文字等等所有元素都被缩放在手机屏幕中，这是绝对的等比例缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 开发简单 --- 缩放交给浏览器，完全按视觉稿切图；</span><br><span class="line">* 还原精准 --- 绝对等比例缩放，可以精准还原视觉稿；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 像素丢失 --- 对于一些分辨率较低的手机，可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少；</span><br><span class="line">* 不兼容第三方组件和富文本数据 --- 这也是最大的问题；</span><br></pre></td></tr></table></figure><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p>“流体式”、“Layout Viewport Scale” 这两种适配方案，都存在缺陷，一个优秀的适配方案应做到以下两点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* UI 的精确还原与适配</span><br><span class="line">* 兼容第三方组件和富文本数据</span><br></pre></td></tr></table></figure><p>VW + Rem 就是这样的一个方案。其原理是，屏幕联动 html font-size vw，html font-size 联动 rem（ html font-size value &#x3D; 1 rem），来做到适配。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>定义规范</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设计规范。规定设计稿分辨率，推荐采用 1X 的设计方案（即手机 375，横屏 Pad 960，而不是 2X 的 750、1920），为了方便 figma 下，导入第三方 UI 组件</span><br><span class="line">* 基准值。规定屏幕分成 10 等分（100vw/10），html font-size 为 10vw，所以 1rem = 10vm</span><br></pre></td></tr></table></figure><p>将基准值的定义为 100vw&#x2F;10 &#x3D; 10vw，而不是 100px（除以 19.2、12.8），这仅仅是规范，10vw 体现适配原则，容易理解，而 100px 在没有转换工具的条件下，方便了计算。</p><p>在没有转换工具的情况下，为了方便计算，我们会将 html faont-size 定义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1920 的设计规范下还原的，base 为 1920px/19.2 = 100px，px 转 rem 除以 100 即可 */</span></span><br><span class="line"><span class="comment">/* calc(100vw/19.2) 不直接写成 10vw，是为了体现 1920 的设计规范 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>/<span class="number">19.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在源码里面进行转换不利于源码的维护，在现代前端开发中推荐使用工程化工具转换。</p><ul><li>使用步骤</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 步骤一：定义 html font-size 基准值（一般会定为 10vw，绝大多数适配场景都是按宽度适配，如果按高度适配也可为 10vh）</span><br><span class="line">* 步骤二：开发页面。页面在设计尺寸下开发（比如，平板 1920、手机 750），开发单位为 px</span><br><span class="line">* 步骤三：px 转 rem。这一步请用工具完成，转换算法为 px/基准值（1920 设计规范下是 192，750 设计稿是 75），一般会忽略 border，因为可能变成 0px</span><br></pre></td></tr></table></figure><ul><li>兼容处理</li></ul><p>vw 不支持 Android 4.4 以下设备，这时候就需要对 vw 做兼容处理了。这里不想通过 JS 来解决此问题，本着逐渐增强，平稳退化的原则，选一个默认分辨率处理，比如手机就选 750 的分辨率：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">37.5px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://github.com/amfe/lib-flexible">flexible</a> 就是手淘团队在 Android 4.4- 设备不支持 vw 时的一个 JS 解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(下) -- 视口</title>
      <link href="/2016/06/15/Pixel-Viewport-2/"/>
      <url>/2016/06/15/Pixel-Viewport-2/</url>
      
        <content type="html"><![CDATA[<p>视口（viewport）代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI（菜单栏等）。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><span id="more"></span><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>桌面浏览器中，视口的宽度与浏览器窗口的宽度一致，浏览器窗口就是约束 CSS 布局的视口，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度（超出部分将出现滚动条）。但是在移动端，情况就很复杂了。</p><p>在移动设备上，视口与屏幕宽度不再相关联，是完全独立的，浏览器厂商为了让传统的 PC 网页能够尽可能在移动设备上更多的展示，会把视口的宽度设置地很大（一般在 768px ~ 1024px 之间，Apple 是 980px），并且将其缩放在了屏幕（视觉视口）内。这个浏览器厂商定义的视口被称为“布局视口（Layout Viewport）”，网页的最大宽度是默认的 Layout Viewport 宽度，超出部分会出现滚动条。</p><p><img src="/images/css/layout-viewport.png" alt="layout viewport"></p><p>可通过 Meta Viewport 来设置布局视口，能设置的属性如下所示。</p><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>width</td><td>正整数或 device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或 device-height</td><td>定义视口的高度，单位为像素</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须小于或等于 maximum-scale 设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须大于或等于 minimum-scale 设置</td></tr><tr><td>user-scalable</td><td>yes&#x2F;no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS 中可通过 <code>document.documentElement.clientWidth / clientHeight</code> 获取布局视口的尺寸，CSS 中可设置 <code>html, body &#123;width: 100%&#125;</code>，通过测量 <code>body</code> 的宽度来验证默认布局视口大小。另外，CSS 中的媒体查询，查询的是布局视口的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 700px) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>用户在屏幕上能看到的网页区域被称为“视觉视口（Visual Viewport）” 。</p><p>视觉视口用于承载布局视口，其大小是视觉视口内 CSS 像素的总量，受浏览器缩放影响。用户可以在视觉视口中拖动或者缩放网页，来获得良好的浏览效果，如果用户缩小网站，视觉视口内 CSS 像素数量增多，视觉视口变大，看到的网站区域将变大，同理用户放大网站，视觉视口内 CSS 像素数量减少，视觉视口也变小，能看到的网站区域将缩小。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p><img src="/images/css/visual-viewport.png" alt="visual viewport"></p><p><code>window.innerWidth/innerHeight</code> 可以获取视觉视口的尺寸，大小是屏幕中 CSS 像素的数量。</p><h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><p>移动设备中默认 768px ~ 1024px 尺寸的布局视口对用户不友好，忽略了手机本身的尺寸，于是引入理想视口的概念。将布局视口的宽度设为屏幕的宽度，这样的布局视口被称为“理想视口（Idea Viewport）”。理想视口是移动设备上最佳的布局视口，理想视口下开发的页面不需要缩放就能够完美显示。</p><p>JS 中可通过 <code>screen.width/height</code> 获取理想视口的尺寸（有兼容性问题，可能返回的是设备像素尺寸）。将 Meta Viewport 设置如下就可以将布局视口设为理想视口了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实践中，还会设置缩放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 推荐的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0,viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>initial-scale</code>有一个隐藏的作用，它同时会将布局视口的尺寸设置为缩放后的尺寸，所以<code>initial-scale=1</code>与<code>width=device-width</code>的效果是一样的（不缩放又要求放进 Visual Layout 里，所以 <code>initial-scale=1</code> 与 <code>width=device-width</code> 等同）。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(上) -- 像素</title>
      <link href="/2016/06/10/Pixel-Viewport-1/"/>
      <url>/2016/06/10/Pixel-Viewport-1/</url>
      
        <content type="html"><![CDATA[<p>像素是影像显示的基本单位，其表现为一个个小方格。在 GUI 客户端软件开发中，像素是布局的基础，对于一个客户端开发者来说理解它很重要。其实存在两种像素，<a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html">此像素非彼像素</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设备像素</span><br><span class="line">* 设备独立像素</span><br></pre></td></tr></table></figure><span id="more"></span><p>设计师眼中的像素是设备像素，因为要考虑设计稿中非矢量元素（图片）在程序适配中的高保真，程序员眼中的像素是设备独立像素（Web 的 px，Android 的 dp，IOS 的 pt），因为要考虑适配。PC 时代的标准屏幕中，这两个像素是相等的，我们意识不到这个问题的存在，但是在高密度屏的移动时代就需要面对它了。</p><h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><p>设备像素（Device Pixels）又叫物理像素（Physical Pixel），一个设备像素是屏幕上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。跟设备像素相关概念有分辨率、屏幕尺寸、像素密度，这些参数在屏幕出厂时就固定下来了。以 iPhone 5 屏幕参数为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 屏幕分辨率 -- 640 x 1136</span><br><span class="line">* 屏幕尺寸 -- 4 英寸</span><br><span class="line">* 屏幕像素密度/解析度 -- 326dpi。</span><br></pre></td></tr></table></figure><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率可以细分为屏幕分辨率（显示分辨率）、图像分辨率、视频分辨率。其中，屏幕分辨率指一个屏幕具体由多少个像素点组成。<code>640 x 1136</code> 的屏幕分辨率指的是屏幕上水平有 640 个物理像素，垂直有 1136 个物理像素。常见分辨率中 4:3 有 <code>1024 x 768</code>、16:9 有 <code>1366 × 768</code>、<code>1920 × 1080</code>、<code>2560 x 1440</code>、<code>3860 × 2160</code>, 16:10 有 <code>1920 x 1200</code>。</p><p>也可以用 K 和 P 来描述分辨率，P 代表纵向的像素个数，K 代表横向有几个 1024 个像素。分辨率为 <code>1920 x 1080</code> 的屏幕就属于 1080P 屏幕（也被称为 FHD 全高清屏幕），横向像素超过 2048 的屏幕就属于 2K 屏，横向像素超过 4096 的屏幕就属于 4K 屏。</p><p>分辨率高不代表就清晰，还与尺寸有关，同一尺寸下分辨率越高就越清晰。</p><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸指的是屏幕对角线的物理长度，单位英寸。比如 iPhone 5 的屏幕尺寸为 4 英寸，MBP 的屏幕尺寸为 13.3 英寸。</p><h3 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h3><p>像素密度 (Pixels Per Inch) 指的是每英寸所拥有的像素数量，可用于描述屏幕的清晰度或图片的质量，单位是 ppi。理论上 PPI 越高，单位面积的像素数量就越多，画面会更细腻丰富清晰。屏幕的 PPI 可以通过屏幕分辨率和尺寸计算得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PPI = Math.sqrt(a ** 2 + b ** 2) / 4</span><br></pre></td></tr></table></figure><p>在桌面屏幕中，大部分的 PC 显示器和笔记本都还是普通密度的屏幕，不过像 Retina MBP（Apple 在 2012 年发布了第一款 Retina MBP）、2k 和 4k 这样一些高密度屏也很常见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 14 英寸笔记本（112ppi）</span><br><span class="line">Math.sqrt(1366 ** 2 + 768 ** 2) / 14;</span><br><span class="line">// 14 英寸笔记本（157ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 14;</span><br><span class="line">// 13.3 英寸 MBA (127ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 900 ** 2) / 13.3;</span><br><span class="line">// 23.8 英寸 PC 显示器（92ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 23.8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 13.3 英寸 MBP/Retina MBA (226ppi)</span><br><span class="line">Math.sqrt(2560 ** 2 + 1600 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K XPS (290ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2400 ** 2) / 15.6;</span><br><span class="line">// 13.5 英寸 Surface Book 3 (267ppi)</span><br><span class="line">Math.sqrt(2256 ** 2 + 1504 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K ThinkPad P1 (282ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2160 ** 2) / 15.6;</span><br></pre></td></tr></table></figure><p>在手机屏幕中，2010 年之前的手机分辨率都普遍低，比如，iPhone 3GS、诺基亚 5230、5800，随着智能手机发展，iPhone 4 使得智能手机进入了高密度屏时代，发布会上首次提出了 Retina Display 的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 3GS (164ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 480 ** 2) / 3.5;</span><br><span class="line">// 诺基亚 5230、5800 (223ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 640 ** 2) / 3.2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 4 (329ppi)</span><br><span class="line">Math.sqrt(640 ** 2 + 960 ** 2) / 3.5;</span><br><span class="line">// iPhone 11 (326ppi)</span><br><span class="line">Math.sqrt(828 ** 2 + 1792 ** 2) / 6.1;</span><br><span class="line">// 小米 10 (386ppi)</span><br><span class="line">Math.sqrt(1080 ** 2 + 2340 ** 2) / 6.67;</span><br><span class="line">// 华为 P40 Pro (440ppi)</span><br><span class="line">Math.sqrt(1200 ** 2 + 2640 ** 2) / 6.58;</span><br><span class="line">// 三星 Galaxy S20 (565ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 3200 ** 2) / 6.2;</span><br></pre></td></tr></table></figure><p><a href="https://support.apple.com/en-us/HT202471">Retina Display</a>（视网膜屏幕，视网膜显示器）指的是在正常视距内（iPhone 10inch，iPad 15inch）人睛不能分辨出单独像素显示效果的屏幕。为了达到这种显示效果，需要将更多的物理像素压缩进屏幕中，使屏幕成为高密度屏。</p><p>iPhone 4 发布会上，乔布斯表示当手持设备距人眼 10－12 英寸时，300ppi 是人类视力的极限，当像素密度超过 300ppi 时，人眼就无法区分出单独的像素，因此像素密度达到 329ppi 的 iPhone 4 具备非常优秀的显示功能，不会再出现颗粒感。在后来发布 The New iPad 时，Apple 更是对 Retina Display 给出了科学意义上的解释。</p><p><img src="/images/css/retina2.jpg" alt="retina display"></p><p>根据<a href="https://www.engadget.com/2012-03-01-retina-display-macs-ipads-and-hidpi-doing-the-math.html">上图</a>中视觉成像原理，能够非常容易得出下面这个三角函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tan(α/2) = h/2d</span><br><span class="line"></span><br><span class="line"># 变形公式</span><br><span class="line">α = 2tan^(-1)(h/2d) = 2arctan(h/2d)</span><br><span class="line">h = tan(α/2)*2d</span><br></pre></td></tr></table></figure><p>其中“α”代表视角，“d”代表视距，“h”代表像素间距（或一个像素的尺寸）。在对人类视力研究中发现（斯内伦测试 Snellen Test），正常人眼能辨识所视物的最小视角（识别极限，视敏度 <a href="https://baike.baidu.com/item/%E8%A7%86%E6%95%8F%E5%BA%A6">visual acuity</a>）是 1&#x2F;60 度（1 弧分度），1 弧分度数据主要基于斯内伦视力表中 20&#x2F;20 标准视力（等效于我国视力表中的 1.0）的统计样本，视力超常的（如 2.0 视力）个体无疑会有着更出色的视觉能力，能辨识所视物的最小视角会更小。</p><p>在正常视距下，当视角小于等于 1&#x2F;60 度时，即可以达到 Retina Display 的显示效果。α 大小取决于 d 和 h，而显示设备的使用视距一般是固定的，所以是否是 Retina Display 取决于 h。比如，在 10inch 的视距下，需要至少 343ppi，才能达到此显示效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">angle2rad</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * (<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="title class_">Math</span>.<span class="title function_">tan</span>(<span class="title function_">angle2rad</span>(<span class="number">1</span> / (<span class="number">2</span> * <span class="number">60</span>))) * <span class="number">2</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ppi = <span class="number">1</span> / h;  <span class="comment">// 343</span></span><br></pre></td></tr></table></figure><p>Retina Display 是 Apple 的商标，在安卓手机中没有此叫法，安卓手机中，屏幕根据 PPI 来划分为不同的等级。PPI 在 120 - 160 之间的手机被归为低密度手机，160 - 240 被归为中密度（Medium），240 - 320 被归为高密度（High），320 - 480 以上被归为超高密度，480 - 640 被归为超超高密度，640 以上被称为超超超高密度。</p><p> | ldpi | mdpi | hdpi | xhdpi | xxhdpi | xxxhdpi<br>—|—|—|—|— | — | —<br>密度分界 | 120 | 160 | 240 | 320 | 480 | 640<br>常见屏幕分辨率 | 240 * 320 | 320 * 480 | 480 * 850 | 640 * 960 | 1080 * 1920 | 1440 * 2560<br>默认缩放比例 | 0.75 | 1.0 | 1.5 | 2.0 | 3 | 4</p><p>附：点密度 DPI (Dots Per Inch) 指的是每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点，图片像素点也可以是打印机的墨点，当 DPI 来描述图片和屏幕时，等价于 PPI，描述打印机时，表示打印机每英寸可以打印的点数，打印机的 DPI 越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。另外，PPI&#x2F;DPI 有时候也被称为分辨率，比如，打印分辨率、扫描分辨率。</p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><p>设备独立像素（Density-Independent Pixel）又叫逻辑像素、密度无关像素，简称为 dips，单位为 dp，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统按设备像素比转换为物理像素在屏幕上显示出来。Web 的 px、Android 的 dp、IOS 的 pt，都是对 dp 的实现，<code>1px = 1dp = 1pt</code>。</p><p>之所以使用抽象的设备独立像素而不直接使用设备像素，目的是为了适配，图形系统会自动将应用程序的抽象像素转换为适合于特定设备的物理像素。</p><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><p>在缩放程度为 100%，某一方向上（x 轴或 y 轴）物理像素和设备独立像素的比例叫做“设备像素比” (device pixel ratio)，单位 dpr。设备像素比定义了设备独立像素和设备像素的转换关系，决定了 GUI 软件的渲染尺寸，当处理标准显示器与 HiDPI 或 Rerina 显示器之间的差异时，这很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备像素比 = 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>在 JS 中 <code>window.devicePixelRatio</code> 得到，在 CSS 中，可以通过 <code>-webkit-device-pixel-ratio</code>，<code>-webkit-min-device-pixel-ratio</code> 和 <code>-webkit-max-device-pixel-ratio</code> 进行媒体查询。</p><p>设备独立像素和设备像素间的转换由两个条件决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 页面是否缩放</span><br><span class="line">* 设备像素比（屏幕是否为高密度或超高密度)</span><br></pre></td></tr></table></figure><p>页面放大，设备独立像素会跨越了更多的设备像素，缩小则相反。在排除页面缩放的情况下，他们的换算关系取决于设备像素比。比如，在 2dpr 的设备上，<code>1 个设备独立像素 = 4 个设备像素</code>，CSS 中的 <code>&#123;width: 200px&#125;</code> 需要由 800 个物理像素来显示（面积）。</p><p>在已知 dpr 和 ppi 的情况下，还可以将 dp 转为现实生活中的物理单位，比如, 在 2dpr、326ppi 下，<code>200dp = 400px = 1.23inch (400 / 326)</code>，于是 <code>1dp = 0.00615inch</code>。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Guide</title>
      <link href="/2015/07/01/Git-Guide/"/>
      <url>/2015/07/01/Git-Guide/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>分布式</li></ul><p>Git 是分布式版本控制系统，这不同于 SVN 这类集中式版本控制系统，可以完全去中心化工作，不用和中央服务器 (remote server) 进行通信，在本地即可进行全部版本控制操作，包括 commit、log、diff…，即便是离线下。</p><ul><li>快照</li></ul><p>分支在SVN中实际上是版本库中的一份copy，而git一个仓库是一个快照，所以git 切换、合并分支等操作更快速。</p><ul><li>指针</li></ul><p>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，且创建成本非常低。</p><span id="more"></span><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><p>Index</p></li><li><p>Object</p></li></ul><p>git三大对象类型: 数据对象(Blob Object) &#x2F; 树对象(Tree Object) &#x2F; 提交对象(Commit Object)</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>三大区域</li></ul><p>在 Git 项目中，存在三大区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Workspace/Working Tree/Working Directory：工作区</span><br><span class="line">Index/Stage：暂存区、索引</span><br><span class="line">Repository/Git Directory：版本库、仓库、资源库、Git 目录</span><br></pre></td></tr></table></figure><p><img src="/images/engineering/git/areas.png" alt="Git Flow 流程图"></p><p>基本的 Git 工作流程：在工作区中修改文件。<code>git add</code> 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。<code>git commit</code> 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</p><p><code>git add</code> 是让文件进入 staged，<code>git commit</code> 是让文件进入 committed。</p><p>暂存区设计目的之一，就是为了实现 add，选择性提交。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Todo……</p><p><a href="https://zhuanlan.zhihu.com/p/53750883">https://zhuanlan.zhihu.com/p/53750883</a></p><p>前三个回答：<a href="https://www.zhihu.com/question/19946553/answer/29033220">https://www.zhihu.com/question/19946553/answer/29033220</a></p><p><a href="https://zhuanlan.zhihu.com/p/96631135">https://zhuanlan.zhihu.com/p/96631135</a></p><p><a href="https://zhuanlan.zhihu.com/p/98679880">https://zhuanlan.zhihu.com/p/98679880</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 上使用 apt（或 yum） 安装 <code>sudo apt install git</code>，Windows 上可以从 Git 官网<a href="https://git-scm.com/downloads">下载安装程序</a>，Mac OS 上，Xcode 默认集成了 Git，如果没有安装 Xcode，可通过 Homebrew 单独安装。</p><p>另外，Windows 中要想在 CMD 中执行 Git，需要将 Git 添加到环境变量 path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\bin</span><br><span class="line">C:\Program Files\Git\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]    # git help help 查看 help 命令如何使用</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 共有三级配置，优先级依次是本地配置 &gt; 全局配置 &gt; 系统配置。系统配置在 <code>/etc/gitconfig</code> 文件中（Windows 在 <code>/mingw64/etc/gitconfig</code>。Windows Git Bash 中的根目录是 Git 的安装目录），全局配置在 <code>~/.gitconfig</code> 文件中，本地配置在本地仓库的 <code>.git/config</code> 文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat ~/.gitconfig 如下所示</span><br><span class="line">[user]</span><br><span class="line">email = 240866271@qq.com</span><br><span class="line">name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">helper = manager</span><br><span class="line">[commit]</span><br><span class="line">template = D:/commit-template</span><br></pre></td></tr></table></figure><p>注：mingw（Minimalist GNU on Windows） 是一款 Windows 上的 GNU 工具集（含 vim、ssh client…），mingw64 是其 64 位版。Windows 版 Git 自带 mingw。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list    # 查看系统配置</span><br><span class="line">git config --global --list    # 查看全局配置</span><br><span class="line">git config --local --list     # 查看 repository 配置</span><br><span class="line">git config --list             # 查看当前配置（配置信息会合并，结果是本地、全局、系统三者的合并）</span><br><span class="line">git config &lt;setting&gt;          # 查看特定配置，比如 git config user.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="设置配置信息"><a href="#设置配置信息" class="headerlink" title="设置配置信息"></a>设置配置信息</h3><p>最常见的自定义配置是用户信息（用户名和邮件地址，commit 时用）、Commit Message Template、Credential Helper。</p><ul><li>用户信息</li></ul><p>用户信息用于 commit 时标示用户身份，git log 的提交日志中可以查看，如果没有配置，在 MacOS 下会使用操作系统用户名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 姓名</span><br><span class="line">git config --global user.name &quot;Tracy&quot;</span><br><span class="line"># 邮箱</span><br><span class="line">git config --global user.email &quot;240866271@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注：–global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p><ul><li>提交模版</li></ul><p>Commit Message Template</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><ul><li>换行</li></ul><p>由于各操作系统文本文件所使用的换行符不一样，UNIX&#x2F;Linux&#x2F;OS X 使用的是 LF，Windows&#x2F;Dos 使用的 CRLF。Git 默认提供了一个“换行符自动转换”功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf xx   # true、input（推荐使用）、false</span><br></pre></td></tr></table></figure><p>true 表示开启自动转换，迁入时将文件换行风格转换成 Unix 风格，迁出时根据本地系统确定是否转换成 CRLF。<br>input 表示迁入的时候将换行风格转换成 Unix 风格，迁出时不做处理。<br>false 表示迁入迁出都不对换行风格进行处理。</p><ul><li>其他</li></ul><p>除了上述常用配置，还有其他的配置，比如颜色、别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 显示颜色，会让命令输出看起来更醒目</span><br><span class="line">git config --global color.ui true</span><br><span class="line"></span><br><span class="line"># status、checkout 别名</span><br><span class="line">git config --global alias.st status            # st 就表示 status。git st 等价于 git status</span><br><span class="line">git config --global alias.co checkout          # co 就表示 checkout</span><br><span class="line"></span><br><span class="line"># unstage 别名</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27; # git unstage test.js 等价于 git reset HEAD test.js，可以把暂存区的修改撤销（unstage），重新放回工作区</span><br><span class="line"></span><br><span class="line"># 显示最后一次提交信息别名</span><br><span class="line">git config --global alias.last &#x27;log -1&#x27;        # git last 就能显示最后一次提交</span><br><span class="line"></span><br><span class="line"># log 别名</span><br><span class="line">git config --global alias.lg </span><br><span class="line">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line"># git init 默认分支名</span><br><span class="line">git config --global init.defaultBranch main    # 从 master 改为 main</span><br></pre></td></tr></table></figure><p>注，可直接编辑配置文件来设置配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --system -e    # 系统配置</span><br><span class="line">git config --global -e    # 全局配置</span><br><span class="line">git config -e             # 本地配置</span><br></pre></td></tr></table></figure><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 初始化仓库</span><br><span class="line">git init &lt;folder&gt;                  # 带 --bare 参数，可创建一个裸库</span><br><span class="line"></span><br><span class="line"># 将文件添加到暂存区</span><br><span class="line">git add -p &lt;file&gt;</span><br><span class="line"></span><br><span class="line"># 将暂存区文件添加到本地仓库中（会生成唯一的 hash 值作为 commit id）</span><br><span class="line">git commit -m &quot;add LICENSE&quot;        # 如果想要记述的更加详细，不加 -m 参数即可</span><br><span class="line"># 修改最后一次 commit message（如果不是最后一次，需要组合使用 rebase 命令，才能完成）</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"># 从版本库中删除文件</span><br><span class="line">git rm &lt;file&gt;                      # 删除工作区文件，并删除暂存区对应文件记录</span><br><span class="line">git rm --cached &lt;file&gt;             # 删除暂存区文件记录</span><br><span class="line"></span><br><span class="line"># 查看仓库状态</span><br><span class="line"># Git 文件的 4 种状态：untracked(未跟踪)、staged(已暂存)、unmodified/committed(已提交)、modified(已修改)，它们之间相互转换流程</span><br><span class="line">git status                         # 查看所有文件状态</span><br><span class="line">git status [filename]              # 查看指定文件状态</span><br><span class="line"></span><br><span class="line"># 比较差异（看懂 git diff）</span><br><span class="line">git diff              # 比较 workspace 与 index 的差异</span><br><span class="line">git diff HEAD         # 比较 workspace 与 local repository 中提交记录的差异，其中 HEAD 表示最新提交，HEAD^ 表示上一个提交，HEAD^^ 表示上上一个提交，依此类推，也可以用 HEAD~X 表示，X 代表 ^ 的个数</span><br><span class="line">git diff --cached/--staged     # 比较 index 与 local repositorty  的差异</span><br><span class="line">git diff hash1 hash2  # 比较两个提交记录的差异</span><br><span class="line"></span><br><span class="line"># 查看提交日志</span><br><span class="line">git log          # 可以加参数，比如 --pretty=oneline</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 版本回退</span><br><span class="line">git reset --hard HEAD^             # 当前版本 HEAD,上一个版本 HEAD^,上上个版本 HEAD^^</span><br><span class="line">git reset --hard 130f10a           # 或 HEAD~100</span><br><span class="line"></span><br><span class="line"># 把暂存区的修改撤销掉（to unstage）</span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line"># 查看命令记录</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 丢弃工作区的修改，回到最近一次 git commit 或 git add 时的状态</span><br><span class="line">git checkout -- README.md</span><br><span class="line"></span><br><span class="line"># 把误删的文件恢复到最新版本，checkout 其实用版本库里的版本替换工作区的版本</span><br><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure><p>廖雪峰时光穿梭机</p><p>这列的版本指的是提交记录。</p><p>这个也是我目前不太熟悉的地方，开发中常常需要将回退项目的操作，会退至某次提交</p><p>todo。。。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是用来进行并行作业的。<code>git init</code> 会默认创建 master 主分支。</p><p>以 dev 和 master 作为实例分支。</p><h3 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 查看分支（当前分支前面标有 × 号）</span><br><span class="line">git branch                                # 不带参数查看本地分支，-a 查看所有分支，-r 列出远程跟踪的分支（不是远程分支）</span><br><span class="line"></span><br><span class="line"># 创建分支（基于当前分支）</span><br><span class="line">git branch &lt;branch-name&gt;                  # 只创建不切换</span><br><span class="line"></span><br><span class="line"># 切换分支</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"># 创建（基于当前分支）和切换分支</span><br><span class="line">git checkout -b dev                       # 相当于 git branch dev、git checkout dev</span><br><span class="line">git checkout --orphan dev                 # 创建一个没有任何的提交记录的空分支，但是当前分支的内容都有，可用 git rm -rf . 删除原来代码树下的所有文件</span><br><span class="line"></span><br><span class="line"># 重新命名分支</span><br><span class="line">git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 合并分支（合并指定分支到当前分支，比如当前分支是 master）</span><br><span class="line">git merge dev</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev   # --no-ff 参数，表示禁用 Fast forward</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d dev                         # 删除已合并的本地分支（但不能删除当前分支，需要切换，才能删除）。-d -r 参数删除远程追踪分支（只是删除 git branch -r 列表中的追踪分支，并不会删除远程分支）</span><br><span class="line">git branch -D dev                         # 强行删除一个没有合并过的本地分支</span><br><span class="line"></span><br><span class="line"># 看看分支的历史提交记录</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 拉取远程仓库更新，但不合并</span><br><span class="line">git fetch                     # 默认下，git fetch 取回所有分支的更新，如果只想取回特定分支的更新，可以指定分支名，比如：git fetch origin master</span><br><span class="line"></span><br><span class="line"># 拉取远程仓库更新，且合并（git pull [远程主机名] [远程分支名]:[本地分支名]）（实质上，这等同于先做git fetch，再做git merge）</span><br><span class="line">git pull</span><br><span class="line">git pull origin dev           # 如果省略本地分支名，则表示远程分支与当前分支合并</span><br><span class="line"></span><br><span class="line"># 向远程仓库库推送更新（git push [远程主机名] [本地分支名]:[远程分支名]）（为防止冲突，push 前要先 pull）</span><br><span class="line">git push -u origin master     # 当前分支可能与多个主机存在追踪关系（tracking），所以首次要用 -u（--set-upstream）指定一个默认主机（upstream），以后可直接 git push</span><br><span class="line">git push origin master        # 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支，如果该远程分支不存在，则会被新建</span><br><span class="line">git push origin :dev          # 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支</span><br><span class="line">git push origin               # 将当前分支推送到 origin 主机的对应分支</span><br><span class="line">git push                      # 如果当前分支只有一个追踪分支，那么连主机名都可以省略</span><br><span class="line">git push --force              # --force/-f 强制推送</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete dev  # 删除 origin 主机的 dev 分支。注：远程的默认分支，不能为当前将要删的目标分支，如果是，需要将默认分支切换到其他分支上，再删</span><br><span class="line"></span><br><span class="line"># 从远程库 clone，默认情况只能看到 master 分支，需要在 dev 分支，必须创建远程 origin 的 dev 分支到本地</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name # 关联</span><br></pre></td></tr></table></figure><p>注：不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式。如果要修改这个设置，可以采用 git config 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># matching</span><br><span class="line">git config --global push.default matching</span><br><span class="line"></span><br><span class="line"># simple</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>Git 中的标签和分支有点类似，都是引用或者说指针，不过标签的位置是固定的，在给指定提交打好标签以后，它就固定于此位置，而分支的位置是会不断变动的，随着分支的向前推移或者向后回滚，都在不断变化。分支和标签的用处也不一样，分支用于并行作业，而标签用于处理发布。</p><p>Git 标签分为两种类型：轻量型（lightweight）和附注型（annotated）。轻量标签是指向特定提交对象的引用，而附注标签则是仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。建议使用附注标签，以便保留相关信息。标签名应采用统一的格式，<code>v$&#123;MajorVersion&#125;.$&#123;MinorVersion&#125;.$&#123;FixVersion&#125;-$&#123;TypeLabel&#125;</code>，其中 TypeLabel (alpha、 beta…) 可选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看标签</span><br><span class="line">git tag                                 # 查看所有 tag</span><br><span class="line">git tag -l v1.0.*                       # 查看符合模式的 tag</span><br><span class="line">git show v1.0.0                         # 查看 tag 信息</span><br><span class="line"></span><br><span class="line"># 新建标签</span><br><span class="line">git tag v1.0.0                          # 新建轻量 tag</span><br><span class="line">git tag v1.0.0 9fceb02                  # 为某个 commit 新建 tag（一般用于后期加注标签）。用 git log --pretty=oneline --abbrev-commit 查看 commit id</span><br><span class="line">git tag -a v1.0.0 -m &quot;message&quot;          # 新建带注释的 tag（用 -a 来创建一个带备注的 tag，-m 指定说明文字）</span><br><span class="line"></span><br><span class="line"># 推送标签</span><br><span class="line">git push origin v1.0.0                  # 推送某个具体 tag</span><br><span class="line">git push origin --tags                  # 推送所有 tag</span><br><span class="line"></span><br><span class="line"># 切换标签</span><br><span class="line">git checkout v1.0.0                     # 切换方法跟分支一样</span><br><span class="line"></span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d v1.0.0                       # 删除本地某个 tag</span><br><span class="line">git push origin :refs/tags/v1.0.0   # 删除远端某个 tag</span><br></pre></td></tr></table></figure><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Stash 可用在一些特殊的工作场景中，比如，需要临时修复 Bug，可以把当前工作现场储藏起来，等 Bug 修复后恢复现场后继续工作。在 Git Flow 下，Stash 基本用不到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 保存存储</span><br><span class="line">git stash</span><br><span class="line">git stash save &quot;save message&quot; # 带注释的存储</span><br><span class="line"></span><br><span class="line"># 查看存储列表</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 查看存储详情</span><br><span class="line">git stash show                          # 默认查看第一个 stash，即 stash@&#123;0&#125;，可以以指定。另外，-p 参数，可以查看到具体的详情</span><br><span class="line"></span><br><span class="line"># 恢复存储</span><br><span class="line">git stash pop                           # 恢复的同时把存储也删了，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定 git stash pop stash@&#123;$num&#125;</span><br><span class="line">git stash apply                         # 恢复某个存储，但不会把存储从存储列表中删除，默认使用第一个存储，也可以指定</span><br><span class="line"></span><br><span class="line"># 删除存储</span><br><span class="line">git stash drop                          # 删除某个存储，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定</span><br><span class="line">git stash clear                         # 删除所有存储</span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>.gitignore 配置文件用于忽略文件，不被添加到版本库中，其配置语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以斜杠 / 开头表示目录</span><br><span class="line">以星号 * 通配多个字符</span><br><span class="line">以问号 ? 通配单个字符</span><br><span class="line">以方括号 [] 包含单个字符的匹配列表</span><br><span class="line">以叹号 ! 表示不忽略匹配到的文件或目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 txt 结尾的文件</span><br><span class="line">*.txt</span><br><span class="line"># 忽略 doc 目录下 所有 txt 文件，不包括子目录（doc/subdir/a.txt）</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc 目录下所有 txt 的文件，包括子目录</span><br><span class="line">doc/**/*.txt</span><br><span class="line"></span><br><span class="line"># README.txt 除外</span><br><span class="line">!README.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件（不管 build 是根目录还是子目录，都会被忽略）</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略根目录下的 TODOLIST 文件（不包括 subdir/TODOLIST）</span><br><span class="line">/TODOLIST</span><br></pre></td></tr></table></figure><p>注：Git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程中心化仓库可用来备份存储和共享协作（clone、push、pull…）。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 生成私钥和公钥证书</span><br><span class="line">ssh-keygen -t rsa -C &quot;any comment can be here&quot;</span><br><span class="line"></span><br><span class="line"># 测试证书登录是否设置成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"># 克隆远程仓库</span><br><span class="line">git clone [remote url] [local url]                    # git clone git@github.com:michaelliao/gitskills.git （GitHub 可以使用 HTTPS 和 SSH 协议）</span><br><span class="line"></span><br><span class="line"># 添加远程仓库</span><br><span class="line">git remote add [shortname] [url]                      # git remote add origin git@github.com:Windrivder/Windrivder.git</span><br><span class="line"></span><br><span class="line"># 删除远程仓库</span><br><span class="line">git remote rm [remote name]</span><br><span class="line"></span><br><span class="line"># 修改远程仓库名</span><br><span class="line">git remote rename [old remote name] [new remote name]</span><br><span class="line"></span><br><span class="line"># 要查看远程库的信息</span><br><span class="line">git remote                                            # 查看已经存在的远程仓库</span><br><span class="line">git remote -v                                         # 查看已经存在的远程仓库的详细信息</span><br></pre></td></tr></table></figure><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>SSH 可通过证书来实现免密登录，然而，这对 HTTP 协议来说是不可能的，每一个连接都是需要用户名和密码的（<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">官网文档</a>）。为了不用每次都输入用户名和密码，Git 使用 credential.help 来存储本地凭证（默认所有都不缓存，每一次连接都会询问你的用户名和密码），其所支持的选项如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache        # cache 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在 15 分钟后从内存中清除</span><br><span class="line">store        # store 模式会将凭证用明文的形式存放在磁盘中（默认在 home 目录），永不过期</span><br><span class="line">osxkeychain  # Mac 下 store 的加密版，凭证保存在用户的钥匙串中</span><br><span class="line">manager      # Windows 下 store 的加密版，凭证保存在 Windows 的凭据管理器中。在 system 级别被设置（credential.helper=manager），优先于 global 和 local</span><br></pre></td></tr></table></figure><p>可通过 Git 的帮助文档来查看我们系统支持哪种 helper。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Linux 下</span><br><span class="line">git help -a | grep credential</span><br><span class="line"># 输出结果</span><br><span class="line">credential                 remote-ftps</span><br><span class="line">credential-cache           remote-ftps</span><br><span class="line">credential-cache--daemo    remote-ftps</span><br><span class="line">credential-store           remote-ftps</span><br><span class="line"></span><br><span class="line"># Window 下（CMD 使用 findstr，PowerShell 使用 sls。或者在 C:\Program Files\Git\mingw64\libexec\git-core 目录下执行 (ls).Name | sls credential）</span><br><span class="line">git help -a | sls credential</span><br><span class="line"># 输出结果</span><br><span class="line">git-credential-manager.exe</span><br><span class="line">git-credential-store.exe</span><br><span class="line">git-credential-wincred.exe</span><br><span class="line">git-credential.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看默认配置</span><br><span class="line">git config --list | grep credential</span><br></pre></td></tr></table></figure><p>Mac 默认 credential helper 是 osxkeychain，Windows 默认是 manager，而 Linux 默认不存储，需手动设置，以 store 模式为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这样，会生成 <code>~/.git-credentials</code> 文件，用户信息会以明文保存在里面，<code>https://&#123;userName&#125;:&#123;password&#125;@github.com</code>，比如 <code>https://Tracy-xu:395083226%40gh@github.com</code>。</p><p>注：要操作一个远程仓库，首先要有 Git 服务器登录权限，然后要有项目权限（项目的所有者，或者 Collaborators – 协作者）。</p><h2 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h2><p>SSH 作为 Git 所支持通信协议其中之一，如果想通过 SSH 来使用 Git，则需要安装 SSH Server。Linux 一般都自带 SSH，而 Windows 配置起来麻烦，所以这里以 Linux 为例。 </p><p>当然，在实际使用中不单单只会用到一个简单的非常底层的 Git 服务器，还有其他很多功能会使用到（比如，提供图形化界面的用户管理、SSH 管理、Log、Issue、Pull Request，甚至 Wiki 和持续集成），所以一般会使用 GitHub、GitLab、GitBucket 基于 Git 实现的 Git 仓库托管系统。</p><ol><li>安装 Git</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git                # CentOS 用 yum 带 -y 参数安装（-y 参数不用一步步询问）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个 Git 用户，用来运行 Git 服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br><span class="line"></span><br><span class="line"># 默认情况下 SSH 不允许空密码用户登录（可在 sshd_config 中设置，参考相关章节），所以还需给 git 这个用户设置一个密码。</span><br><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><ol start="3"><li>设置证书登录</li></ol><p>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个（参考 Linux 相关章节。在没有像 GitHub、GitLab 这样的平台来管理 authorized_keys，管理员手动管理 authorized_keys 很麻烦）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 验证证书登录是否设置成功（如果让输入密码则没有成功，如果不让输入则设置成功）</span><br><span class="line">ssh -T git@192.168.10.140</span><br><span class="line"></span><br><span class="line"># 不让输入密码，回车后，原生的 Git Service 没有任何返回，GitHub 会有返回</span><br><span class="line">ssh -T git@github.com    </span><br><span class="line">Hi Tracy-xu! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>注：<code>~/.ssh</code> 目录在用户目录下（不同用户 <code>~</code> 下输入 <code>pwd</code>，结果会是 <code>/root</code> 或者 <code>/home/xxx</code>），修改 <code>~/.ssh/authorized_keys</code> 只对当前用户生效。另外，如果不设置证书登录，默认会使用密码登录。</p><ol start="4"><li>初始化 Git 仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选定一个目录作为 Git 仓库，假定是 /srv/sample.git，在 /srv 目录下输入命令</span><br><span class="line">sudo git init --bare sample.git</span><br><span class="line"></span><br><span class="line"># 把 owner 改为 git（如果这一步不设置，push 时会报权限不足：insufficient permission for adding an object to repository databa）</span><br><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>与 <code>git init</code> 不同的是，<code>git init --bare</code> 被用来创建“裸库”，裸库没有 work tree（工作区），只有 .git 目录，记录着版本历史，一般用于公共的远程中央仓库，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区。另外，服务器上的 Git 仓库通常都以 .git 结尾。</p><ol start="5"><li>禁用 Shell 登录</li></ol><p>出于安全考虑，第二步创建的 git 账户不允许登录 Shell（GitHub 就是如此，<code>ssh git@github.com </code>），只允许 Git 相关操作，所以要把 Shell 登录改为 git-shell 登录。编辑 <code>/etc/passwd</code> 文件，为 git 用户指定的 git-shell 即可（参考 Linux passwd 相关章节）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为</span><br><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>还要复制一个名为 git-shell-commands 的目录，要不然 <code>ssh git@192.168.10.140</code> 时会报 fatal:Interactive git shell is not enabled 错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/git-1.8.3.1/contrib/git-shell-commands /home/git -R</span><br><span class="line">chown git /home/git/git-shell-commands/ -R</span><br><span class="line">chmod +x /home/git/git-shell-commands/help</span><br><span class="line">chmod +x /home/git/git-shell-commands/list</span><br></pre></td></tr></table></figure><p>现在，不管是开机登录，还是 su 切换用户登录，还是 SSH 远程登录，git 用户登录的都将是 git-shell，进来看到的是 <code>git&gt;</code> 而不是 <code>[root@localhost ~]#</code>。另外，不能将 git 账户登录权限改为 <code>/sbin/nologin</code>，禁用登录，要不然客户端在 clone 时会报 <code>fatal: protocol error: bad line length character: This</code> 错误。</p><ol start="6"><li>克隆远程仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@192.168.10.140:/srv/sample.git</span><br></pre></td></tr></table></figure><p>直接 clone 会提示这是一个空仓库。也可以在本地创建一个仓库，然后添加 remote 地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">...</span><br><span class="line">git remote add origin ssh://git@192.168.10.140:/srv/sample.git      # clone 时可以省略 ssh:// 协议，设置地址时不可省略</span><br><span class="line">git push --set-upstream origin master                               # 可以缩写为 git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Media Query</title>
      <link href="/2015/06/02/Media%20Query/"/>
      <url>/2015/06/02/Media%20Query/</url>
      
        <content type="html"><![CDATA[<p>媒体查询在 CSS2 中就已经存在了，但是只能查询 meida type，CSS3 中除了能查询 media type 外，还加入了 media feature 的查询。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询包含一个“媒体类型（media type）”以及至少一个测试“媒体特性（media feature）”的表达式，表达式和媒体类型将根据实际情况计算的到 true 或者 false。如果指定的媒体类型符合当前设备并且媒体特性表达式都为真，那当前媒体查询为真，media query 为 true，对应的样式规则生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [媒体类型] 媒体特性 &#123;&#125;    # 除非使用了 not 或者 only 操作符，否则 media type 是可选的，默认值为 <span class="attribute">all</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>and</td><td>逻辑与，用于连接 media type、meidia feature 用于结合多个媒体特性或媒体类型</td></tr><tr><td>,</td><td>设备列表</td></tr><tr><td>not</td><td>排除某种设备</td></tr><tr><td>only</td><td>限定某种设备类型</td></tr></tbody></table><p><code>and</code> 用于结合多个媒体特性或媒体类型到一个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* media type 为 all 时 media feature 为 min-width 700 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用 and 添加限制条件 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 and 添加 media type，限制媒体类型为显示器 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 用于结合多个 media query ，任 一media query 为 true 时应用样式，相当于逻辑运算符中的 or。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 宽度大于 700px，或者宽度大于高度的显示器上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>not</code> 用于对整个 media query 结果取反，必须位于一个 media query 的开头。另外，在逗号分隔的多个 media query 中，not 只对它作用的 media query 生效。not 不能对单个 media feature 取反，只能作用于整个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* not 将在最后求值 */</span></span><br><span class="line"><span class="comment">/* 等价于 @media not (print and (max-width:1024px))&#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> print <span class="keyword">and</span>(<span class="attribute">max-width</span>:<span class="number">1024px</span>)&#123;...&#125;  # </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多个 media query 求值 */</span></span><br><span class="line"><span class="comment">/* 求值顺序如下 @media (not (screen and (color))), print and (color) &#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">color</span>), print <span class="keyword">and</span> (<span class="attribute">color</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>only</code> 用于向早期浏览器隐藏媒体查询，only 必须位于 media query 的开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>无法识别媒体查询的浏览器要求获得逗号分割的媒体类型列表，规范要求：它们应该在第一个不是连字符的非数字、字母之前截断每个值。所以上面的示例解释为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为没有 <code>only</code> 这样的媒体类型，所以样式表被忽略。如果不加 only，下面的示例会被解析为 <code>@media screen &#123;&#125;</code> 这样一来即使浏览器不知道 media query 的真正含义，样式也会应用于所有屏幕设备。</p><p>尽管存在此行为，如果希望向其他不太常用的浏览器隐藏样式，任然建议在媒体查询前面添加 only。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体类型（media-type）"><a href="#媒体类型（media-type）" class="headerlink" title="媒体类型（media type）"></a>媒体类型（media type）</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>print</td><td>文档打印或打印预览模式</td></tr><tr><td>screen</td><td>彩色电脑屏幕</td></tr><tr><td>speech</td><td>阅读器</td></tr></tbody></table><p>注意：在 CSS2.1 和 CSS3 media query 中定义的 media type：tty、tv、projection、handheld、braille、embossed、aural，在<a href="https://www.w3.org/TR/mediaqueries-4/">media queries level 4</a> 中都废弃了，不推荐使用。</p><h3 id="媒体特性（media-feature）"><a href="#媒体特性（media-feature）" class="headerlink" title="媒体特性（media feature）"></a>媒体特性（media feature）</h3><table><thead><tr><th>媒体特性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>viewport width</td></tr><tr><td>height</td><td>viewport height</td></tr><tr><td>device-width 、 device-height</td><td>设备的宽度、高度</td></tr><tr><td>aspect-ratio</td><td>viewport 的宽高比如：16&#x2F;9</td></tr><tr><td>device-aspect-ratio</td><td>设备宽高比</td></tr><tr><td>orientation</td><td>宽度和高度的大小关系。landscape（横屏）、portrait（竖屏）</td></tr><tr><td>resolution</td><td>设备的分辨率</td></tr></tbody></table><p>上面是一些常见的 media feature，不是全部，media feature 的维度很多，但是最常用的是 viewport 的 width 和 height。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在 CSS2 中，媒体查询只使用于 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签中，以 media 属性来查询，CSS3 中可以用 @media 来查询。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/reset.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/print.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:600px) and (max-width:900px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="keyword">@import</span> url(<span class="string">&quot;css/style.css&quot;</span>);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;css/reset.css&quot;</span>) screen;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  选择器 &#123;</span><br><span class="line">    属性: 属性值;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Media-Query-常用方法"><a href="#Media-Query-常用方法" class="headerlink" title="Media Query 常用方法"></a>Media Query 常用方法</h2><ul><li>排他（exclusive）</li></ul><p>为确保在某一个条件下只有一个样式表生效，将查询条件严格划分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">401px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>覆盖（overriding）</li></ul><p>可以对元素设置相同优先级，使用样式顺序，通过覆盖，避免排他。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动优先（Mobile first）</li></ul><p>默认样式假设为移动设备宽度，然后通过 min-width 控制扩展样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootStrap 移动优先，断点分别为 768、992、1200，这三个断点的区间对应手机、平板、桌面、大桌面。</p><ul><li>PC 优先（desktop first）</li></ul><p>默认以宽屏进行样式设置，通过 max-width 控制样式覆盖。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 标签嵌套规则</title>
      <link href="/2014/06/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/"/>
      <url>/2014/06/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML4-x2F-XHTML-嵌套规则"><a href="#HTML4-x2F-XHTML-嵌套规则" class="headerlink" title="HTML4&#x2F;XHTML 嵌套规则"></a>HTML4&#x2F;XHTML 嵌套规则</h2><p>在 HTML4&#x2F;XHTML DTD 中，将元素的分为 inline level (行内级) 和 block level (块级) 两类。</p><ul><li>inline level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span、a、dfn、abbr、cite、img、label、q、u、em、i、strong、b、big、small、sub、sup、表单类；计算机输出类(tt、kbd、code、var、samp)</span><br></pre></td></tr></table></figure><ul><li>block level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div、h1-h6、hr、ul、ol、dl、li、fieldset、address、from、table、html5 中新增的结构化语义标签、pre、blockquote、dir、menu</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：HTML 中的 inline level、block level 与 CSS 中的 inline、block 意义不一样，HTML 强调的是语义和结构，而 CSS 强调的是样式。要不然无法解释：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><ul><li>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素(另，a 不能在嵌套 a)：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”#”</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<code>h1、h2、h3、h4、h5、h6、p、dt</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML5-嵌套规则"><a href="#HTML5-嵌套规则" class="headerlink" title="HTML5 嵌套规则"></a>HTML5 嵌套规则</h2><p>在 <a href="https://html.spec.whatwg.org/multipage/dom.html#element-definitions">HTML5 规范</a>中，已经不按 inline level 和 block level 来区分元素类型了，元素按 <a href="https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content">Categories</a> 分类，元素的 <a href="https://html.spec.whatwg.org/multipage/dom.html#content-models">Content Model</a> 规定了合法的元素内容类型。</p><ul><li>Categories</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Metadata 元数据信息元素 base, link, meta, noscript, script, style, template, title</span><br><span class="line">* Flow 流式元素，所有可以放在 body 标签内，构成文档内容的元素均属于 Flow 元素。除 base, link, meta, style, title 等只能放在head 标签内的元素外，剩下的均属 Flow 元素</span><br><span class="line">* Sectioning 结构元素 article, aside, nav, section</span><br><span class="line">* Heading 标题元素 h1, h2, h3, h4, h5, h6</span><br><span class="line">* Phrasing 短语元素，所有可以放在 p 标签内，构成段落内容的元素均属于 Phrasing 元素。HTML5 中的 Phrasing 元素大致就是 HTML4 中所定义的 inline level 元素。另外，所有 Phrasing 元素均属于 Flow 元素</span><br><span class="line">* Embedded 嵌入资源元素 audio, video, img, canvas, svg, iframe, embed, object, math</span><br><span class="line">* Interactive 交互元素 a, audio, video, button, details, embed, iframe, img, input, label, object, select, textarea</span><br></pre></td></tr></table></figure><ul><li>Content Model</li></ul><p>各元素都有自己的 Content Model，比如 <a href="https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-a-element">a 元素</a>的 Content Model 为 <a href="https://html.spec.whatwg.org/multipage/dom.html#transparent-content-models">transparent</a>，这类元素本身内部可以有任何类型的内容，是否合法要看其父元素的 Content Model 和其内容的 Categories，还有 p 元素，其内容模型为 Phrasing, 这意味着 p 元素只接受 Phrasing 元素为子元素（p 自身 Categories 类型为 Flow content，因而 p 不能嵌套 p）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p&gt;ins&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ul&gt;li&gt;h4&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个例子都是不合法的。</p><p><a href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element">p 元素</a>的 content model 是 phrasing content，<a href="https://html.spec.whatwg.org/multipage/edits.html#the-ins-element">ins</a> 本身属于 phrasing content 故可以嵌套；ins 元素的 content model 是 transparent，故在此时里面是否能有 a 需检查 p&gt;a 的合法性；a 元素也属于 phrasing content，故 p&gt;ins&gt;a 合法；a 元素的 content model 也是 transparent，故此时里面包含 div 的合法性向上传递，检查 ins&gt;div 又向上传递，变成检查 p&gt;div。所以，div 不属于 phrasing content，这个嵌套是不合法。</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 过渡与动画</title>
      <link href="/2014/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <url>/2014/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: [property duration timing-function delay]</span><br></pre></td></tr></table></figure><p>property 默认值 all，duration 和 delay 默认值 0，timing-function 默认值 ease。可使用 <code>,</code> 分割，实现多个动画，配合 duration，还可实现队列动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">display</span>: flex; <span class="attribute">width</span>: <span class="number">65px</span>; <span class="attribute">height</span>: <span class="number">40px</span>; <span class="attribute">align-items</span>: center; <span class="attribute">justify-content</span>: center; <span class="attribute">background</span>: <span class="number">#92B901</span>; <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="attribute">opacity</span>: <span class="number">0.4</span>; <span class="attribute">transition</span>: transform <span class="number">1s</span>, opacity <span class="number">1s</span>, background <span class="number">1s</span>, width <span class="number">1s</span>, height <span class="number">1s</span>, font-size <span class="number">1s</span>;&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">width</span>: <span class="number">90px</span>; <span class="attribute">height</span>: <span class="number">60px</span>; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>); <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">opacity</span>: <span class="number">1</span>; <span class="attribute">background</span>: <span class="number">#1ec7e6</span>;&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>transition 不会在页面加载时自动执行动画，它需要交互或异步去触发，比如 CSS 的伪类 <code>:hover</code>，JS 事件或 <code>setTimeout</code> 去执行动画。</p><p>开启硬件加速，可以使 transition 运行更加流畅：<code>body&#123;transform: translate3d(0, 0, 0);&#125;</code>；</p><h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>不是所有的 CSS 属性都支持 transition，<strong>属性存在中间状态，且能计算出中间状态（开始状态和结束状态是具体数值），才支持 transition</strong>。像 <code>visibility</code>、<code>display</code> 就不存在中间状态，<code>height: auto</code> 不能计算出中间状态，支持的属性常见有以下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* length/percentage: 真实的数字 如：`word-spacing`, `width`, `vertical-align`, `top`, `right`, `bottom`, `left`, `padding`, `outline-width`, `margin`, `min-width`, `min-height`, `max-width`, `max-height`, `line-height`, `height`, `border-width`, `border-spacing`, `background-position` 等；</span><br><span class="line">* number 真实的（浮点型）数值，如：`zoom`, `opacity`, `font-weight` 等；</span><br><span class="line">* color: RGB 和 Alpha 值，如：`background-color`, `border-color`, `color`, `outline-color` 等 CSS 属性；</span><br><span class="line">* shadow: x, y, blur 和 color，如：text-shadow</span><br><span class="line">* transform list</span><br></pre></td></tr></table></figure><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* ease：逐渐变慢（默认值），等同于贝塞尔曲线 (0.25, 0.1, 0.25, 1.0)；</span><br><span class="line">* linear：匀速，等同于贝塞尔曲线 (0.0, 0.0, 1.0, 1.0)；</span><br><span class="line">* ease-in：加速，等同于贝塞尔曲线 (0.42, 0, 1.0, 1.0)；</span><br><span class="line">* ease-out：减速，等同于贝塞尔曲线 (0, 0, 0.58, 1.0)；</span><br><span class="line">* ease-in-out：加速然后减速，等同于贝塞尔曲线 (0.42, 0, 0.58, 1.0)；</span><br><span class="line">* cubic-bezier (n,n,n,n)：在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。实际用到的很少，可以到工具网站中设置值 http://cubic-bezier.com；</span><br></pre></td></tr></table></figure><p>这几个贝塞尔值的区别：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease&quot;</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in&quot;</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-out&quot;</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in-out&quot;</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;linear&quot;</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> red solid; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;<span class="attribute">width</span>: <span class="number">50px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">background-color</span>: red; <span class="attribute">color</span>: <span class="number">#fff</span>;&#125;</span><br><span class="line"><span class="selector-class">.ease</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease;&#125;</span><br><span class="line"><span class="selector-class">.ease-in</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in;&#125;</span><br><span class="line"><span class="selector-class">.ease-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-out;&#125;</span><br><span class="line"><span class="selector-class">.ease-in-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in-out;&#125;</span><br><span class="line"><span class="selector-class">.linear</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> linear;&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span> &#123;<span class="attribute">margin-left</span>: <span class="number">500px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="transition-与-animation-区别"><a href="#transition-与-animation-区别" class="headerlink" title="transition 与 animation 区别"></a>transition 与 animation 区别</h3><p>transition 是属性过渡动画，animation 是关键帧过渡动画，两种动画触发方式不一样，属性过渡必须通过交互或者异步修改属性值，而关键帧只需要应用即可，可以在交互时，也可以不在交互时。</p><p>另外，在 CSS <code>:hover</code> 中，当鼠标移出时，属性值会恢复，发生过渡，transition 的逆向动画被触发，而 animation 关键帧动画不会 reverse，需另声明 reverse 的关键帧来实现，而且需通过事件来应用，要不然进入时会发生 reverse 动画。</p><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: [name duration timing-function delay iteration-count direction fill-mode play-state]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* animation-name 关键帧名，默认值 none</span><br><span class="line">* animation-duration 动画时长，默认值 0</span><br><span class="line">* animation-timing-function 动画速度，默认值 ease</span><br><span class="line">* animation-delay 延迟，默认值 0</span><br><span class="line">* animation-iteration-count 播放次数，默认值 1</span><br><span class="line">* animation-direction 轮流反向播放，默认值 normal</span><br><span class="line">* animation-play-state 默认值 running（播放）、paused（暂停）</span><br><span class="line">* animation-fill-mode 默认值 none（不改变默认行为）、forwards（保持在最后一个关键帧中定义的状态）、backwards（保持在第一个关键帧中定义的状态）、both</span><br></pre></td></tr></table></figure><p>animation 属性简写至少要有名称和时长。</p><p>animation 使用时需先定义关键帧（@keyframes），在使用关键帧（animation）。关键帧中，用百分比来规定变化发生的时间，或用关键词 from 和 to，等同于 0%（动画开始） 和 100%（动画完成）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> fade &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">background</span>: <span class="number">#f00</span>; <span class="attribute">animation</span>: fade <span class="number">1s</span>;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 单位</title>
      <link href="/2013/06/22/CSS%20%E5%8D%95%E4%BD%8D/"/>
      <url>/2013/06/22/CSS%20%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px 是一个<a href="https://www.w3.org/TR/css3-values/#lengths">绝对单位</a>，不相对于谁，只受平台 dpi 影响。cm、pt 之类的也都是绝对长度，但与 px 这个抽象单位不同的是它们都是物理单位，1pt 则是 1&#x2F;72 英寸，而 1 英寸换算到公制是 2.54cm，在 CSS 中所有的物理单位会直接映射到像素，在 96dpi 下 <code>1in = 2.54cm = 96px</code> <code>1cm = 37.8px</code>。</p><span id="more"></span><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em 是一个相对单位，相对于当前元素的 font-size（如果当前元素没有 font-size 或者 font-size 是相对单位，则先继承父辈的字号，再计算 em）。也可以说，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小。不管怎么样，要想计算 em 的大小，要先确定当前元素<strong>具体</strong>的 font-size。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 12px; line-height: 1.5em&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block; width: 4em; font-size: 3em;&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子中，span 先继承父元素 font-size，再计算自身 font-size，即 <code>3em * 12px = 36px</code>，width 为 <code>4 * 36px = 144px</code>。另外，对于相对单位属性的继承，要在父辈元素先计算为具体值，再继承，div 的 line-height 为 <code>1.5em * 12px = 18px</code>，所以 span 的 line-height 为 18px，而不是直接继承 1.5em。</p><p>由于 em 相对于当前元素的字号大小，而且字号会继承，这导致不能统一管理基础变量，且依赖追溯复杂，不适合在整个页面中使用，只适用于做局部缩放的场景。</p><p>历史上，因为 IE 不支持 px 为单位的缩放，故使用 em 来做缩放。<a href="http://clagnut.com/about">Richard Rutter</a> 在 <a href="http://clagnut.com/blog/348/">How to size text using ems</a> 和 <a href="http://alistapart.com/article/howtosizetextincss">How to Size Text in CSS</a> 中做过详细的介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;:root&#x27;</span>), <span class="literal">null</span>).<span class="property">fontSize</span>; <span class="comment">// 16px，Chrome 上最小支持的字号为 12px</span></span><br></pre></td></tr></table></figure><p>以 <code>&lt;html&gt;</code> 的 <code>font-size</code> 为基准，浏览器默认的字号为 16px，换算为 em 即 <code>1em = 16px</code>、<code>12px = 0.75em</code>、<code>10px = 0.625em</code>，为了方便 <code>font-size</code> 的换算，可将 html 字号设为 <code>font-size: 62.5%</code>（即 <code>16px * 62.5% = 10px</code>），或者直接 <code>font-size: 10px</code>，这样 <code>1em = 10px</code>、<code>1.2em = 12px</code>、<code>1.4em = 14px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">h1</span>, <span class="number">2.4em</span> × <span class="number">10</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4em</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>, <span class="number">1.4em</span> × <span class="number">10</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4em</span>;&#125;</span><br></pre></td></tr></table></figure><p>随着浏览器的更新换代，这种做法早已被淹没在历史尘埃中。</p><h2 id="percent"><a href="#percent" class="headerlink" title="percent"></a>percent</h2><p>一般情况下 % 相对于包含块（containing block），在应用于字体大小时，相对于父字体大小。</p><p>包含块的确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 对于普通定位元素就是父元素</span><br><span class="line">* 对于 position: absolute 的元素是相对于已定位的父元素（offset parent）</span><br><span class="line">* 对于 position: fixed 的元素是相对于 ViewPort（可视窗口）</span><br></pre></td></tr></table></figure><p>需要注意的是，padding、margin 如果设置了百分比，会发现左右和预期一样，用的父元素宽度的百分比，但是上下用的也是宽度百分比，而不是想象中的高度的百分比。另外，percent 在被后代元素继承时继承的是百分比计算后的值，而不是原百分比，比如 line-height 120% 和 1.2 在被继承时。</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem 相对于根元素 font-size 的单位。引入它是为了解决 em 依赖追溯困难，计算复杂的问题。而 rem 是相对于根元素 <code>&lt;html&gt;</code>，依赖简单，只需要在根元素确定一个参考值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">1.4</span> × <span class="number">10px</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4rem</span>;&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.4</span> × <span class="number">10px</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4rem</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然 em、rem 相对于 font-size，但是并不单单只能应用于 font-size。另外，所有的 em、rem、percent 渲染的时候，都会被转为 px，因为<strong>px是计算机矢量图渲染成像的原理</strong>。</p><p>rem 一般用来做移动端适配。</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw 是 CSS3 引入的单位，相对于视口的宽度，视口被均分为 100 单位的 vw，1vw &#x3D; 1% 窗口宽度。vh同理。常用来配合 rem 做移动端适配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个单位都有各自的优缺点，取决于场景，不能脱离场景谈应用。例如，em、rem、vh、vw、 Percent 这些相对单位，比较适合做尺寸联动适配。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2013/05/07/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2013/05/07/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>简单选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 通配符选择器</span><br><span class="line">E 标签选择器</span><br><span class="line">类选择器</span><br><span class="line">ID 选择器</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>关系选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E F 后代选择器</span><br><span class="line">E&gt;F 子选择器</span><br><span class="line">E~F 相邻选择器</span><br><span class="line">E+F 相邻兄弟选择器</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[attr]</span><br><span class="line">[attr=val]</span><br><span class="line">[attr|=val] 开头匹配（分词）</span><br><span class="line">[attr~=val] 包含匹配（分词）</span><br><span class="line">[attr^=val] 开头匹配</span><br><span class="line">[attr$=val] 结尾匹配</span><br><span class="line">[attr*=val] 包含匹配</span><br></pre></td></tr></table></figure><ul><li>伪类选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 结构性伪类选择器</span><br><span class="line">:root</span><br><span class="line">:not</span><br><span class="line">:empty                  # E 元素中没有子节点（包含文本节点）</span><br><span class="line">:target</span><br><span class="line"></span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br><span class="line">:first-of-type</span><br><span class="line">:last-of-type</span><br><span class="line">:nth-child(n)           # 父元素中的第 n 个 E 元素</span><br><span class="line">:nth-last-child(n)      # 父元素中的第 n 个 E 元素，从后向前计算</span><br><span class="line">:nth-of-type(n)</span><br><span class="line">:nth-last-of-type(n)</span><br><span class="line"></span><br><span class="line"># UI 元素状态伪类选择器</span><br><span class="line">:link</span><br><span class="line">:visited</span><br><span class="line">:hover</span><br><span class="line">:active</span><br><span class="line">:focus</span><br><span class="line"></span><br><span class="line">:enabled</span><br><span class="line">:disabled</span><br><span class="line">:checked</span><br><span class="line">:read-only</span><br><span class="line">:read-write</span><br><span class="line"></span><br><span class="line">:required</span><br><span class="line">:optional</span><br><span class="line">:valid</span><br><span class="line">:inlvalid</span><br><span class="line">:in-range</span><br><span class="line">:out-of-range</span><br><span class="line"></span><br><span class="line">:only-of-type</span><br><span class="line">:only-child</span><br><span class="line"></span><br><span class="line">:lang</span><br></pre></td></tr></table></figure><p>注2：带 <code>type</code> 的选择器，是 type（类型）里面进行筛选的，<code>first-of-type</code>（type里面的第一个）、<code>only-of-type</code>（type里面唯一）。</p><ul><li>伪元素选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::before 原始的开始</span><br><span class="line">::after 元素的结尾</span><br><span class="line">::first-letter 第一个字母</span><br><span class="line">::first-line 第一行</span><br><span class="line">::selecton 选中的内容</span><br></pre></td></tr></table></figure><p>伪元素表示的是并不真实存在的元素（特殊的位置），与伪类的主要区别是，伪类选择的是元素，而伪元素选择器选择的是伪元素。</p><h2 id="选择器的应用"><a href="#选择器的应用" class="headerlink" title="选择器的应用"></a>选择器的应用</h2><p>选择器可组合，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E.class &#123;&#125;</span><br><span class="line">:hover &#123;&#125;</span><br><span class="line">E:hover &#123;&#125;</span><br><span class="line">[attr] &#123;&#125;</span><br><span class="line">E[attr] &#123;&#125;</span><br><span class="line">:first-child &#123;&#125;</span><br><span class="line">E:first-child &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>,</code> 分割</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E,F &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>nth-child 和 not 选择器的妙用</li></ul><p>注1：n 从 1 开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:nth-child(odd)</span><br><span class="line">E:nth-child(even)</span><br><span class="line">E:nth-child(2n)</span><br></pre></td></tr></table></figure><p>选择 1 到 3 的元素并显示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 not 反选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>)) &#123;&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>逗号分隔列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>)<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 a 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;http&quot;</span>]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:has() 选择器是一个关系型伪类选择器，也被称为函数型伪类选择器，它和 :is()、:not() 以及 :where()函数型选择器被称为 CSS的逻辑组合选择器 ！</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 精粹</title>
      <link href="/2013/03/15/HTML%20%E7%B2%BE%E7%B2%B9/"/>
      <url>/2013/03/15/HTML%20%E7%B2%BE%E7%B2%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p><code>&lt;!DOCTYPE&gt;</code> 标签位于文档中的最前面的位置，作用相当于一个标识符，此标签可告知 Parser（排版引擎）使用哪种 <code>HTML</code> 或 <code>XHTML</code> 解析规则，和使用哪种渲染模式。</p><p>DOCTYPE 的基本结构：<code>&lt;!DOCTYPE Element-name DTD-type DTD-name DTD-url&gt;</code>，HTML5 <code>&lt;!DOCTYPE Element-name&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &lt;!DOCTYPE&gt; 是关键字，表示声明 DTD</span><br><span class="line">* Element-name 指定该 DTD 的根元素名称</span><br><span class="line">* DTD-type 指定该 DTD 是属于标准公用的还是私人定制的。若是 PUBLIC 则表示该 DTD 是标准公用的，如果设为 SYSTEM 则表示是私人定制的</span><br><span class="line">* DTD-name 指定该 DTD 的文件名称</span><br><span class="line">* DTD-url 指定该 DTD 文件所在的 URL 网址</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD 是一份规则，会被 DOCTYPE 标签所声明引用，老版本的 Parser 会根据 DTD-name 来选择对应的解析规则（到底是 4s、4t…）。现代浏览器 HTML5 规则下的 Parser，无需指定 DTD，且向下兼容。</p><p>DTD 的种类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!!xt/!!!4t XHTML1.0/HTML4.01 transitional</span><br><span class="line">!!!xs/!!!4s XHTML1.0/HTML4.01 strict</span><br><span class="line">!!!xf/!!!4f XHTML1.0/HTML4.01 frameset</span><br><span class="line">!!!xxs XHTML 1.1</span><br><span class="line">!!! HTML5</span><br></pre></td></tr></table></figure><p>例如，XHTML1.0 strict：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/XHTML1/DTD/XHTML1-strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的声明中，声明了文档的根元素是 <code>HTML</code>，它在公共标识符被定义为 <code>&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</code>，浏览器将明白如何寻找匹配此公共标识符的 <code>DTD</code>。</p><p>HTML5 的 Doctype 没有对 DTD 进行引用。原因：HTML5 不是基于 SGML 的，DTD 是 SGML 里概念，所以 HTML5 没有 DTD，现代浏览器的 Parser 都按照 HTML5 规范编写，HTML5 兼容所有的老版本 HTML，语法非常包容。主张开发规范由开发者自定义，而不是由 Parser 强制校验。</p><p>附：<a href="http://www.w3.org/TR/XHTML1/DTD/XHTML1-strict.dtd">xhtml1-strict</a></p><h3 id="Quirks-model、Standard-model"><a href="#Quirks-model、Standard-model" class="headerlink" title="Quirks model、Standard model"></a>Quirks model、Standard model</h3><p>Quirks model 和 Standard model 用于区分 W3C 标准网页和非 W3C 标准网页，浏览器 Parser 会根据 DOCTYPE 选择不同的渲染模式，W3C 标准网页采用 Standard model，非标准网页 Quirks model，以此来保证网页的正确显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略 DTD-name 和 DTD-url --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 省略 DTD-url --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">compatMode</span>; <span class="comment">// CSS1Compat（标准模式）、BackCompat（怪异模式）</span></span><br></pre></td></tr></table></figure><p>省略了 DTD-name 的 DOCTYPE 声明是无效的，因为它包含公共标识符关键字 PUBLIC，却没有公共标识符（指示所用 HTML 版本的名称），这将会触发怪异模式，而省略了 DTD-url 的 DOCTYPE 照常进入 Standards Model。</p><p>没有 <code>&lt;DOCTYPE&gt;</code>，<code>&lt;DOCTYPE&gt;</code> 前有其他内容或者省略 DTD-name，这都会触发 Quirks model。</p><p>注：Chrome 下测试发现，虽然 <code>document.compatMode</code> 还能返回 BackCompat，但 Parser 已经去掉了对 Quirks model 的处理，将 Quirks model 下的网页按 Standards model 处理了。</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>文档结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html HTML 文档</span><br><span class="line">head 文档信息</span><br><span class="line">body 文档主体</span><br></pre></td></tr></table></figure><!--more--><ul><li>文档元信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base 页面中所有链接的默认地址或默认目标</span><br><span class="line">title 文档的标题</span><br><span class="line">meta 文档的元信息</span><br><span class="line">link 文档与外部资源的关系</span><br><span class="line">style 文档的样式信息</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置网页关键词 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;JavaScript,CSS,HTML&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置网页简介说明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;JavaScript: The World&#x27;s Best Programming language&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页作者信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;auther&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Insonia&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置网页编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动跳转(重定向)和刷新页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;url=http://www.baidu.com&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告诉搜索引擎robots，对此网操作意图(如果不加此标签，默认的是all) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;roots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：元信息标签–可选属性有 http-equiv, name, scheme。必需的属性 content</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://static.leke.cn/images/common/header/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.leke.cn&quot;</span>&gt;</span>Leke<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div 无语义的 section</span><br><span class="line">span 无语义 inline 结构标签</span><br><span class="line">section 区块，带语义的 div</span><br><span class="line">article 独立区块 </span><br><span class="line">aside article 的辅助信息</span><br><span class="line">nav 导航</span><br><span class="line">footer 页脚</span><br><span class="line">header 页眉</span><br><span class="line">figure 媒介内容的分组</span><br><span class="line">figcaption figure 元素的标题</span><br><span class="line">address 文档作者或拥有者的联系信息</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>content<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://static.leke.cn/images/index/tiyan.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>互联网教育<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:service@strong.cn&quot;</span>&gt;</span>用户服务信箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>施强教育科技有限公司<span class="tag">&lt;<span class="name">br</span>&gt;</span>杭州市滨江区滨安路1168号<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a 锚连接</span><br><span class="line">h1 - h6 标题</span><br><span class="line">p 段落</span><br><span class="line">i 斜体字(无语义)</span><br><span class="line">b 粗体字(无语义)</span><br><span class="line">small 小号字体</span><br><span class="line">em 强调文本(带语义，且语义比strong更重)</span><br><span class="line">strong 强调文本(带语义，语义比em弱)</span><br><span class="line">del 被删除文本</span><br><span class="line">ins 被插入文本</span><br><span class="line">u 下划线</span><br><span class="line">s 删除线</span><br><span class="line">q 短的引用</span><br><span class="line">blockquote 长的引用</span><br><span class="line">cite 引用（citation）</span><br><span class="line">br 折行</span><br><span class="line">mark 标记</span><br><span class="line">wbr 软换行</span><br><span class="line">hr 水平线</span><br><span class="line">pre 预格式文本</span><br><span class="line">abbr 缩写</span><br><span class="line">dfn 定义项目</span><br><span class="line">time 日期/时间</span><br><span class="line">ruby ruby 注释（可以用来进行音注）</span><br><span class="line">rt ruby注释的解释</span><br><span class="line">rb </span><br><span class="line">rtc </span><br><span class="line">rp 若浏览器不支持 ruby 元素显示的内容</span><br><span class="line">code 计算机代码文本</span><br><span class="line">samp 计算机代码样本文本</span><br><span class="line">kbd 键盘文本</span><br><span class="line">var 文本的变量部分</span><br></pre></td></tr></table></figure><p>注：<code>i</code>、<code>b</code>、<code>u</code>、<code>small</code>，在 HTML5 中被重新定义了意义（<a href="https://www.w3.org/TR/html5-diff/">HTML5 Differences from HTML4</a>）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rb</span>&gt;</span>施强教育<span class="tag">&lt;/<span class="name">rb</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rt</span>&gt;</span>Strong Jao Yu<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  漢 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>Kan<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  字 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>ji<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    最是那一低头的温柔，</span><br><span class="line">    象一朵水莲花不胜凉风的娇羞，</span><br><span class="line">    道一声珍重，道一声珍重，</span><br><span class="line">    那一声珍重里有甜蜜的忧愁</span><br><span class="line">  <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>---摘自<span class="tag">&lt;<span class="name">cite</span>&gt;</span>《徐志摩诗集》<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">孔子说：<span class="tag">&lt;<span class="name">q</span> <span class="attr">cite</span>=<span class="string">&quot;http://www.lunyu.com&quot;</span>&gt;</span>学而时习之，不亦说乎<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"></span><br><span class="line">More information can be found in <span class="tag">&lt;<span class="name">cite</span>&gt;</span>[ISO-0000]<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>.</span><br></pre></td></tr></table></figure><p>注：<code>blockquote</code> 和 <code>q</code> 都可以引用，比如引用一句话，一段文档摘录，很明显 <code>q</code> 表示一句话（短），<code>blockquote</code> 引用文档摘录（长），它们两个都有 cite 属性，表示引用的出处。而 <code>cite</code> 表引用时，用于引用文献。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Hypertext Markup Language&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被废弃 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">&quot;World Wide Web&quot;</span>&gt;</span>WWW<span class="tag">&lt;/<span class="name">acronym</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一盒有 <span class="tag">&lt;<span class="name">del</span>&gt;</span>20<span class="tag">&lt;/<span class="name">del</span>&gt;</span> <span class="tag">&lt;<span class="name">ins</span>&gt;</span>30<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>个。</span><br><span class="line">原价：<span class="tag">&lt;<span class="name">del</span>&gt;</span>120元<span class="tag">&lt;/<span class="name">del</span>&gt;</span>，折后：<span class="tag">&lt;<span class="name">ins</span>&gt;</span>60元<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dfn</span> <span class="attr">id</span>=<span class="string">&quot;def-internet&quot;</span>&gt;</span>The Internet<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span> is a global system of interconnected networks.</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">    (function foo(i)&#123;</span><br><span class="line">      if (i &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return i + foo(i - 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(10000);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">A simple equation: <span class="tag">&lt;<span class="name">var</span>&gt;</span>x<span class="tag">&lt;/<span class="name">var</span>&gt;</span> = <span class="tag">&lt;<span class="name">var</span>&gt;</span>y<span class="tag">&lt;/<span class="name">var</span>&gt;</span> + 2</span><br><span class="line">Save the document by pressing <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>S<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>http://this<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.is<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.a<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.really<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.long<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.example<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.com/With<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The <span class="symbol">&amp;lt;</span>mark<span class="symbol">&amp;gt;</span> element is used to <span class="tag">&lt;<span class="name">mark</span>&gt;</span>highlight<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> text</span><br></pre></td></tr></table></figure><ul><li>嵌入内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img 图片</span><br><span class="line">iframe 内联框架</span><br><span class="line">embed 外部交互内容或插件</span><br><span class="line">object 内嵌对象</span><br><span class="line">param 对象的参数</span><br><span class="line">video 视频</span><br><span class="line">audio 音频</span><br><span class="line">source 媒介源</span><br><span class="line">track 媒体播放器中的文本轨道</span><br><span class="line">canvas 图形</span><br><span class="line">svg 矢量图</span><br><span class="line">map 图像映射</span><br><span class="line">area 图像映射内部的区域</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;planets.jpg&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#planetmap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;planetmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;planetmap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;180,139,14&quot;</span> <span class="attr">href</span> =<span class="string">&quot;venus.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Venus&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;129,161,10&quot;</span> <span class="attr">href</span> =<span class="string">&quot;mercur.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Mercury&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;0,0,110,260&quot;</span> <span class="attr">href</span> =<span class="string">&quot;sun.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Sun&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>img</code> 元素中的 “usemap” 属性引用 <code>map</code> 元素中的 “id” 或 “name” 属性（根据浏览器），所以同时向 <code>map</code> 元素添加了 “id” 和 “name” 属性。</p><ul><li>表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table 表格</span><br><span class="line">caption 表格标题</span><br><span class="line">thread 表头</span><br><span class="line">tbody 表体</span><br><span class="line">tfoot 表尾</span><br><span class="line">tr 行</span><br><span class="line">th 单元格</span><br><span class="line">td 单元格</span><br></pre></td></tr></table></figure><ul><li>表单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">form 表单</span><br><span class="line">fieldset fieldset 元素可将表单内的相关元素分组</span><br><span class="line">legend fieldset 标题</span><br><span class="line">label 标注</span><br><span class="line">input 文本框</span><br><span class="line">button 按钮</span><br><span class="line">textarea 文本框</span><br><span class="line">select 下拉列表</span><br><span class="line">option 选项</span><br><span class="line">optgroup 选项组合</span><br><span class="line">datalist 定义下拉列表</span><br><span class="line">progress 任务进度</span><br><span class="line">meter 度量</span><br><span class="line">output</span><br></pre></td></tr></table></figure><p>注：<code>progress</code>、<code>meter</code>、<code>details</code>、<code>summary</code>、<code>dialog</code>… 这些 UI 组件元素在各浏览器上 UI 不统一，且 UI 并不一定满足所有人的审美，一般都会自己做这些组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>健康信息<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    身高：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    体重：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span>&gt;</span>3/10<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">&quot;0.6&quot;</span>&gt;</span>60%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;myCar&quot;</span> <span class="attr">list</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;BMW&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Ford&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Volvo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;Swedish Cars&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;German Cars&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;mercedes&quot;</span>&gt;</span>Mercedes<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ol 有序列表</span><br><span class="line">ul 无须列表</span><br><span class="line">dl 定义列表</span><br><span class="line">li 列表项</span><br><span class="line">dt 定义列表中的项目</span><br><span class="line">dd 定义列表中项目的描述</span><br></pre></td></tr></table></figure><ul><li>脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script 客户端脚本</span><br><span class="line">noscript 针对不支持客户端脚本的用户的替代内容</span><br></pre></td></tr></table></figure><ul><li>交互</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">details 定义元素的细节</span><br><span class="line">summary 为 details 元素定义可见的标题</span><br><span class="line">dialog 对话框</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>All pages and graphics on this web site are the property of W3School.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Web Components</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">element</span><br><span class="line">shadow</span><br><span class="line">template</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://www.w3.org/TR/html5/">官方文档</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element">MDN</a>、<a href="https://www.w3.org/TR/html5-diff/">HTML5 Differences from HTML4</a></p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>HTML5 将 HTML 从简单文档标记语言，发展到一个完整的应用程序开发平台。除最基础的标签外，HTML5 还包括用于增强存储、多媒体和硬件访问的 JavaScript APIs。HTML5 之前 HTML 规范由 <a href="https://www.w3.org/wiki/HTML/Specifications">W3C</a> 制定，HTML5 由 <a href="https://html.spec.whatwg.org/">whatwg</a> 制定。</p><p>HTML5 包括的内容有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 语义化结构标签</span><br><span class="line">* 新表单类型</span><br><span class="line">* 新属性：自定义属性 data-xxx，全局属性 placeholder...</span><br><span class="line">* 多媒体</span><br><span class="line">* Canvas</span><br><span class="line">* Web Storage</span><br><span class="line">* Application Cache</span><br><span class="line">* Web Workers</span><br><span class="line">* History API</span><br><span class="line">* User interaction（Drag and drop、document.designMode、contenteditable...）</span><br></pre></td></tr></table></figure><p>注：<a href="https://dom.spec.whatwg.org/">DOM 规范</a>、<a href="https://websockets.spec.whatwg.org/">WebSocket 规范</a>、<a href="https://w3c.github.io/IndexedDB/">IndexedDB 规范</a>、Web SQL 规范（被废弃）、<a href="https://xhr.spec.whatwg.org/">XHR 规范</a>（含 FormData）、<a href="https://www.w3.org/TR/geolocation/">Geolocation 规范</a>、<a href="https://www.w3.org/TR/FileAPI/">FileAPI 规范</a>（Blob&#x2F;File、FileReader）、<a href="https://www.w3.org/TR/MathML3/">MathML 规范</a>、<a href="https://www.w3.org/TR/SVG2">SVG 规范</a>…都是单独制定的，不属于 HTML5 规范，Web API 没有统一的规范。另外，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN Web API</a> 文档中有说明具体 API 来源于哪个规范。</p><h3 id="标签和属性"><a href="#标签和属性" class="headerlink" title="标签和属性"></a>标签和属性</h3><ul><li>新增的标签、属性和表单类型</li></ul><p>结构化语义标签：<code>header</code>、<code>footer</code>、<code>nav</code>、<code>section</code>、<code>article</code>、<code>aside</code>、<code>figure</code>、<code>figcaption</code>。多媒体标签：<code>video</code>、<code>audio</code>、<code>embed</code>。表单类型：<code>email</code>、<code>url</code>、<code>number</code>、<code>range</code>、<code>Date Pickers(date、month、week、time、datetime、datetime-local)</code>、<code>search</code>、<code>color</code>。其他功能标签：<code>command</code>、<code>progress</code>、<code>time</code>、<code>canvas</code>、<code>details</code>、<code>datalist</code>、<code>dialog</code>、<code>ruby</code>、<code>rt</code>、<code>rp</code>、<code>wbr</code>、<code>keygen</code>、<code>output</code>、<code>mark</code>、<code>meter</code>。全局属性：<code>contenteditable</code>、<code>contextmenu</code>、<code>draggable</code>、<code>dropzone</code>、<code>spellcheck</code>、<code>hidden</code>、<code>data-*</code></p><ul><li>废除的标签和属性</li></ul><p>废除的标签：可用 CSS 代替纯表现的标签 <code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、<code>strike</code>、<code>tt</code>，不再使用 frame（包括 <code>frame</code>、<code>noframes</code>、<code>frameset</code>，但 <code>iframe</code> 还可继续使用），<code>acronym</code>（用 <code>abbr</code> 代替）、<code>applet</code>（用 <code>object</code> 代替）、<code>dir</code>（用 <code>ul</code> 代替）。废除的属性：<code>align</code>、<code>bgcolor</code>、<code>height</code>、<code>width</code>、<code>valign</code>、<code>hspace</code>、<code>vspace</code>、body 标签上的 <code>link</code>、<code>vlink</code>、<code>align</code>、<code>text</code>、iframe 元素上的 <code>scrolling</code>、table 上的 <code>cellpadding</code>、<code>cellspacing</code>、<code>border</code>。</p><p>注意：上述标签和属性由于语义或者性能上原因被废除，这只是在规范上被废除（不建议使用），但不代表 parser 不能正确解析，现代浏览器 HTML5 规范下的 Parser 非常包容（兼容所有的 HTML4 和 XHTML），要不然含有这些标签的 XHTML&#x2F;HTML4 代码，无法在 HTML5 Parser 下运行。</p><h3 id="结构化语义标签兼容处理"><a href="#结构化语义标签兼容处理" class="headerlink" title="结构化语义标签兼容处理"></a>结构化语义标签兼容处理</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">details</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">figure</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">section</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br><span class="line"><span class="selector-tag">mark</span> &#123;<span class="attribute">background</span>: <span class="number">#ff0</span>; <span class="attribute">color</span>: <span class="number">#000</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> elements = <span class="string">&#x27;article,aside,details,figcaption,figure,footer,header,hgroup,nav,section,mark&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">while</span>(i &lt; elements.<span class="property">length</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(elements[i]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  i ++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span>(!<span class="comment">/*@cc_on!@*/</span><span class="number">0</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> e = <span class="string">&quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;</span>.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> i= e.<span class="property">length</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">while</span> (i--) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">createElement</span>(e[i]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)() </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&#x27;section header nav aside article footer figure figcaption&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\w+/g</span>, <span class="keyword">function</span>(<span class="params">n</span>) &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(n);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">![endif]--&gt;</span><br></pre></td></tr></table></figure><p>注：上面 JS 代码必须添加在页面的 head 标签内，因为 IE 浏览器必须在元素解析前知道这个元素。</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
