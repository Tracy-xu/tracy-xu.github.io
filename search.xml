<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>弹框的函数调用</title>
      <link href="/2024/09/28/javascript/%E5%BC%B9%E6%A1%86%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2024/09/28/javascript/%E5%BC%B9%E6%A1%86%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;van-popup v-<span class="attr">model</span>:show=<span class="string">&quot;visiblePopup&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">v-if</span>=<span class="string">&quot;visiblePopup&quot;</span> <span class="attr">:some-props</span>=<span class="string">&quot;someProps&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/van-popup&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123;ref, reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> visiblePopup = <span class="title function_">ref</span>(<span class="literal">false</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> someProps = <span class="title function_">reactive</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>像上面这样的模板式弹框代码，在项目中是最常见不过的，以 <code>Component</code> 方式调用弹框，如果代码组织不好，会使得 <code>template</code> 变得异常凌乱，更重要的是其中充斥着诸如 <code>visiblePopup</code>、<code>someProps</code> 等这样的中间变量，显得尤为不优雅。而像下面这样以函数方式调用则简洁得多。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleOpenComp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">showPopup</span>(comp, someProps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>很多 UI 库均提供了弹框的函数调用，比如 Vant UI 的 <code>Dialog</code>，Arco Design 的 <code>Modal</code>，如果没有提供，则需手动改造。以 Vant UI 的 <code>Popup</code> 为例，将其由 <code>Component</code> 组件转换为函数组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createVNode, render, h, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Component</span>, <span class="title class_">VNode</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">PopupProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Popup</span> <span class="keyword">from</span> <span class="string">&#x27;./popup.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> <span class="keyword">extends</span> <span class="title class_">PopupProps</span> &#123;</span><br><span class="line">  title?: <span class="built_in">string</span></span><br><span class="line">  showConfirmButton?: <span class="built_in">boolean</span></span><br><span class="line">  showCancelButton?: <span class="built_in">boolean</span></span><br><span class="line">  onBeforeConfirm?: <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CloseType</span> = <span class="string">&#x27;close&#x27;</span> | <span class="string">&#x27;cancel&#x27;</span> | <span class="string">&#x27;confirm&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ShowPopup</span> &#123;</span><br><span class="line">  (<span class="attr">comp</span>: <span class="title class_">Component</span>, <span class="attr">props</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; | <span class="literal">null</span>, <span class="attr">options</span>: <span class="title class_">Partial</span>&lt;<span class="title class_">Options</span>&gt;): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">showPopup</span>: <span class="title class_">ShowPopup</span> = <span class="function">(<span class="params">comp, props = &#123;&#125;, options = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(container)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">closePopup</span> = (<span class="params"><span class="keyword">type</span>: CloseType</span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">render</span>(<span class="literal">null</span>, container)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(container)</span><br><span class="line">      <span class="keyword">type</span> === <span class="string">&#x27;confirm&#x27;</span> ? <span class="title function_">resolve</span>() : <span class="title function_">reject</span>(<span class="keyword">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onUpdateShow</span> = <span class="keyword">async</span> (<span class="params">value: <span class="built_in">boolean</span>, <span class="keyword">type</span>: CloseType</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="title function_">closePopup</span>(<span class="keyword">type</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> vnode = <span class="title function_">createVNode</span>(</span><br><span class="line">      <span class="title class_">Popup</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        ...options,</span><br><span class="line">        <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;onUpdate:show&#x27;</span>: onUpdateShow</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">default</span>: (): <span class="function"><span class="params">VNode</span> =&gt;</span> <span class="title function_">h</span>(comp, &#123; ...props, closePopup &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(vnode, container)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 接口和类型生成</title>
      <link href="/2024/08/13/engineering/TypeScript%20%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%94%9F%E6%88%90/"/>
      <url>/2024/08/13/engineering/TypeScript%20%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>接口和类型的定义是一件耗时费力的工作，通过解析 OpenAPI&#x2F;Swagger 文档，自动化生成接口是一种很好的解决方案，这也便于接口更新时做 <code>git diff</code>，清晰的显示接口更新的内容。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">AppResetPasswordReq</span> &#123;</span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetPassword</span>(<span class="params">params: AppResetPasswordReq</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Result</span>&lt;<span class="built_in">boolean</span>&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/app/reset/password&#x27;</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// more...</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>在 OpenAPI 中，<code>paths</code> 定义了请求路径、请求方法、注释、函数名、实体模型引用等信息， <code>components.schemas</code> 则定义了实体模型，包括请求字段是否必填，以及实体间的嵌套关系：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;/app/reset/password&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;post&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;summary&quot;</span><span class="punctuation">:</span> <span class="string">&quot;修改密码验证码&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;operationId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resetPassword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;requestBody&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;application/json&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;$ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#/components/schemas/AppResetPasswordReq&quot;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;responses&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;200&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;*/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;$ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#/components/schemas/ResultBoolean&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;schemas&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;AppResetPasswordReq&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;code&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;email&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;password&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;邮箱&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;密码&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;邮箱验证码&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;忘记密码请求对象&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ResultBoolean&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;requestId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求ID&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求结果&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;example&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求编码&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;int32&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;example&quot;</span><span class="punctuation">:</span> <span class="number">200</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求消息&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求返回体&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>解析时，需要注意以下几点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Java 中的一些基础类型，需要转为 JS 的基础类型，比如 integer 转为 number</span><br><span class="line">* 嵌套的实体模型中，最外层为最基础实体模型 Result&lt;T&gt;、ListResult&lt;T&gt;、PageResult&lt;T&gt;、TreeNodeResult&lt;T&gt;，应提取公用生成泛型，按泛型注解</span><br><span class="line">* object 类型需递归子属性类型</span><br></pre></td></tr></table></figure><p>最终的生成程序以下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">OpenApi</span>, <span class="title class_">OpenApiReference</span>, <span class="title class_">OpenApiSchema</span>, <span class="title class_">OpenApiOperation</span>, <span class="title class_">OpenApiResponse</span>, <span class="title class_">OpenApiMediaType</span>, <span class="title class_">OpenApiRequestBody</span>, <span class="title class_">OpenApiResponses</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;openapi-v3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">genericityList</span>: <span class="built_in">string</span>[] = [<span class="string">&#x27;ListResult&#x27;</span>, <span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;PageResult&#x27;</span>, <span class="string">&#x27;PageData&#x27;</span>, <span class="string">&#x27;TreeNodeResult&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">typeMapping</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="string">&#x27;integer&#x27;</span>: <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Integer&#x27;</span>: <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tsContent = <span class="string">`import axios from &#x27;axios&#x27;;</span></span><br><span class="line"><span class="string">import type &#123; Result, ListResult, PageResult, TreeNodeResult &#125; from &#x27;@/core/types/global&#x27;;\n\n`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateType</span>(<span class="params">openapi: OpenApi</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> typeContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!openapi.<span class="property">components</span>?.<span class="property">schemas</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> typeContent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">entries</span>(openapi.<span class="property">components</span>.<span class="property">schemas</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[typeName, schema]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">shouldSkipType</span>(typeName)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    schema = schema <span class="keyword">as</span> <span class="title class_">OpenApiSchema</span>;</span><br><span class="line">    <span class="keyword">const</span> properties = schema.<span class="property">properties</span> || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> requiredFields = schema.<span class="property">required</span> || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> paramsTypeDefinition = <span class="title class_">Object</span>.<span class="title function_">entries</span>(properties)</span><br><span class="line">      .<span class="title function_">map</span>(<span class="function">(<span class="params">[name, prop]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> required = requiredFields.<span class="title function_">includes</span>(name) ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span><span class="subst">$&#123;required&#125;</span>: <span class="subst">$&#123;getPropertyType(prop)&#125;</span>;`</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">join</span>(<span class="string">&#x27;\n  &#x27;</span>);</span><br><span class="line"></span><br><span class="line">    typeContent += <span class="string">`export interface <span class="subst">$&#123;typeName&#125;</span> &#123;\n  <span class="subst">$&#123;paramsTypeDefinition&#125;</span>\n&#125;\n\n`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> typeContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateApi</span>(<span class="params">openapi: OpenApi</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> apiContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">entries</span>(openapi.<span class="property">paths</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[path, methods]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">entries</span>(methods <span class="keyword">as</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">OpenApiOperation</span>&gt;).<span class="title function_">forEach</span>(<span class="function">(<span class="params">[method, operation]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> operationId = operation.<span class="property">operationId</span>;</span><br><span class="line">      <span class="keyword">const</span> summary = operation.<span class="property">summary</span> || operation.<span class="property">description</span>;</span><br><span class="line">      <span class="keyword">const</span> requestBody = operation.<span class="property">requestBody</span> <span class="keyword">as</span> <span class="title class_">OpenApiRequestBody</span>;</span><br><span class="line">      <span class="keyword">const</span> responses = operation.<span class="property">responses</span> <span class="keyword">as</span> <span class="title class_">OpenApiResponses</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取请求体的类型</span></span><br><span class="line">      <span class="keyword">let</span> requestType = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (requestBody?.<span class="property">content</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> contentType <span class="keyword">in</span> requestBody.<span class="property">content</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (requestBody.<span class="property">content</span>[contentType].<span class="property">schema</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> requestBodySchema = requestBody.<span class="property">content</span>[contentType].<span class="property">schema</span> <span class="keyword">as</span> <span class="title class_">OpenApiReference</span>;</span><br><span class="line">            <span class="keyword">const</span> ref = requestBodySchema.<span class="property">$ref</span>;</span><br><span class="line">            <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">              <span class="keyword">const</span> parts = ref.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              requestType = parts[parts.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">              requestType = <span class="title function_">handleSpecialTypes</span>(openapi, requestType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取响应体的类型</span></span><br><span class="line">      <span class="keyword">let</span> responseType = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> response200 = responses[<span class="string">&#x27;200&#x27;</span>] <span class="keyword">as</span> <span class="title class_">OpenApiResponse</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> contentType <span class="keyword">in</span> response200.<span class="property">content</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> mediaType = response200.<span class="property">content</span>[contentType] <span class="keyword">as</span> <span class="title class_">OpenApiMediaType</span>;</span><br><span class="line">        <span class="keyword">if</span> (mediaType.<span class="property">schema</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> responseSchema = mediaType.<span class="property">schema</span> <span class="keyword">as</span> <span class="title class_">OpenApiReference</span>;</span><br><span class="line">          <span class="keyword">const</span> ref = responseSchema.<span class="property">$ref</span>;</span><br><span class="line">          <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">            <span class="keyword">const</span> parts = ref.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            responseType = parts[parts.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">            responseType = <span class="title function_">handleSpecialTypes</span>(openapi, responseType);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建函数名称</span></span><br><span class="line">      <span class="keyword">const</span> functionName = operationId &amp;&amp; operationId.<span class="title function_">replace</span>(<span class="regexp">/[^\w]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建函数注释</span></span><br><span class="line">      <span class="keyword">const</span> functionComment = <span class="string">`/**\n * <span class="subst">$&#123;summary&#125;</span>\n */`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建请求函数</span></span><br><span class="line">      <span class="keyword">const</span> paramsType = requestType ? <span class="string">`params: <span class="subst">$&#123;requestType&#125;</span>`</span> : <span class="string">&#x27;params?: any&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> responseTypeDefinition = responseType ? <span class="string">`Promise&lt;<span class="subst">$&#123;responseType&#125;</span>&gt;`</span> : <span class="string">&#x27;Promise&lt;any&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> axiosConfig = method.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;get&#x27;</span> ? <span class="string">&#x27;&#123; params &#125;&#x27;</span> : <span class="string">&#x27;params&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> functionDefinition = <span class="string">`<span class="subst">$&#123;functionComment&#125;</span>\nexport function <span class="subst">$&#123;functionName&#125;</span>(\n  <span class="subst">$&#123;paramsType&#125;</span>\n): <span class="subst">$&#123;responseTypeDefinition&#125;</span> &#123;\n  return axios.<span class="subst">$&#123;method.toLowerCase()&#125;</span>(&#x27;<span class="subst">$&#123;path&#125;</span>&#x27;, <span class="subst">$&#123;axiosConfig&#125;</span>);\n&#125;\n\n`</span>;</span><br><span class="line"></span><br><span class="line">      apiContent += functionDefinition;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> apiContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取属性类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPropertyType</span>(<span class="params">property: OpenApiSchema | OpenApiReference</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 类型为数组，则递归生成数组项类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> property &amp;&amp; property.<span class="property">type</span> === <span class="string">&#x27;array&#x27;</span> &amp;&amp; property.<span class="property">items</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;getPropertyType(property.items)&#125;</span>[]`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类型为对象，则递归生成各子属性类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> property &amp;&amp; property.<span class="property">type</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; property.<span class="property">properties</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123; <span class="subst">$&#123;<span class="built_in">Object</span>.entries(property.properties).map(([name, prop]) =&gt; <span class="string">`<span class="subst">$&#123;name&#125;</span>: <span class="subst">$&#123;getPropertyType(prop)&#125;</span>`</span>).join(<span class="string">&#x27;, &#x27;</span>)&#125;</span> &#125;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Java 基础类型则转为 JS 基础类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> property &amp;&amp; property.<span class="property">type</span> &amp;&amp; typeMapping[property.<span class="property">type</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> typeMapping[property.<span class="property">type</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 属性指向其他 schema，则取所指向的类型</span></span><br><span class="line">  <span class="keyword">if</span> ((property <span class="keyword">as</span> <span class="title class_">OpenApiReference</span>).<span class="property">$ref</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = (property <span class="keyword">as</span> <span class="title class_">OpenApiReference</span>).<span class="property">$ref</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> parts = ref.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> refType = parts[parts.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> refType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> property &amp;&amp; property.<span class="property">type</span> || <span class="string">&#x27;any&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否跳过公共类型</span></span><br><span class="line"><span class="comment"> * 公共类型被提取为泛型，无需生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shouldSkipType</span>(<span class="params">typeName: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> genericityList.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> typeName.<span class="title function_">startsWith</span>(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理特殊类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleSpecialTypes</span>(<span class="params">openapi: OpenApi, typeName: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="comment">// 如果以泛型做前缀，则解析为泛型</span></span><br><span class="line">  genericityList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeName.<span class="title function_">startsWith</span>(item)) &#123;</span><br><span class="line">      typeName = <span class="string">`<span class="subst">$&#123;item&#125;</span>&lt;<span class="subst">$&#123;getInnerType(openapi, typeName, item)&#125;</span>&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> typeName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取泛型参数类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInnerType</span>(<span class="params">openapi: OpenApi, typeName: <span class="built_in">string</span>, prefix: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> innerType = typeName.<span class="title function_">substring</span>(prefix.<span class="property">length</span>);</span><br><span class="line">  <span class="comment">// Java 基础类型则转为 JS 基础类型</span></span><br><span class="line">  <span class="keyword">if</span> (typeMapping[innerType]) &#123;</span><br><span class="line">    <span class="keyword">return</span> typeMapping[innerType];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (openapi.<span class="property">components</span>?.<span class="property">schemas</span>) &#123;</span><br><span class="line">    <span class="comment">// schemas 中已存在的自定义类型，使用原类型名称</span></span><br><span class="line">    <span class="keyword">const</span> ref = openapi.<span class="property">components</span>.<span class="property">schemas</span>[innerType <span class="keyword">as</span> a];</span><br><span class="line">    <span class="keyword">type</span> a = keyof <span class="keyword">typeof</span> openapi.<span class="property">components</span>.<span class="property">schemas</span></span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      <span class="keyword">return</span> innerType;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基础类型转换为小写开头</span></span><br><span class="line">  <span class="keyword">return</span> innerType.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toLowerCase</span>() + innerType.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">username</span>: <span class="built_in">string</span> = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">password</span>: <span class="built_in">string</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getOpenApiDoc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="property">get</span>&lt;<span class="title class_">OpenApi</span>&gt;(<span class="string">&#x27;https://aaa.com/v3/api-docs/app&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Basic <span class="subst">$&#123;btoa(<span class="string">`<span class="subst">$&#123;username&#125;</span>:<span class="subst">$&#123;password&#125;</span>`</span>)&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> openapi = res.<span class="property">data</span></span><br><span class="line">  tsContent += <span class="title function_">generateType</span>(openapi);</span><br><span class="line">  tsContent += <span class="title function_">generateApi</span>(openapi);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> outputFile = <span class="string">&#x27;generated-api.ts&#x27;</span>;</span><br><span class="line">  fs.<span class="title function_">writeFile</span>(outputFile, tsContent, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`写入文件时出错: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`TypeScript Axios 接口已生成到 <span class="subst">$&#123;outputFile&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getOpenApiDoc</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket 连接共享</title>
      <link href="/2024/03/26/javascript/WebSocket%20%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB/"/>
      <url>/2024/03/26/javascript/WebSocket%20%E8%BF%9E%E6%8E%A5%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>1000 多个用户同时在线，用户打开多个 Tab 页，每个 Tab 页都会创建一个 WS 连接，最终创建了 140000 多个 WS 连接，导致服务端奔溃。通过使用 <code>SharedWorker</code> 转发 WS 消息，让所有页面共用一个 WS 连接来解决问题。</p><span id="more"></span><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; v4 <span class="keyword">as</span> uuidv4 &#125; <span class="keyword">from</span> <span class="string">&#x27;uuid&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  messageId?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">path</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">data</span>: <span class="built_in">any</span>;</span><br><span class="line">  code?: <span class="built_in">number</span>;</span><br><span class="line">  message?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Handler</span> = <span class="function">(<span class="params">message: Message</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedWebSocket</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> worker!: <span class="title class_">SharedWorker</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">connected</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">handlers</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Handler</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">listeners</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Handler</span>[]&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">private</span> token!: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">private</span> <span class="attr">timeout</span>: <span class="built_in">number</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">readonly</span> url: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">url</span> = url</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initSharedWorker</span>()</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;message&#x27;</span>, <span class="attr">data</span>: <span class="string">&#x27;ping&#x27;</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">30000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">initSharedWorker</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">worker</span> = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>.<span class="title function_">start</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="keyword">type</span> &#125; = event.<span class="property">data</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;message&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onMessage</span>(event)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;open&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onOpen</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;close&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onClose</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">connect</span>(<span class="attr">token</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">token</span> = token</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">connected</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;connect&#x27;</span>, <span class="attr">data</span>: &#123; token, <span class="attr">url</span>: <span class="variable language_">this</span>.<span class="property">url</span> &#125; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">onMessage</span>(<span class="attr">event</span>: <span class="title class_">MessageEvent</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = event.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (data !== <span class="string">&#x27;pong&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">message</span>: <span class="title class_">Message</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)</span><br><span class="line">      <span class="keyword">const</span> handler = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(message.<span class="property">messageId</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> listeners = <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(message.<span class="property">path</span>)</span><br><span class="line">      <span class="comment">// request-response</span></span><br><span class="line">      <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">        <span class="title function_">handler</span>(message)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pub-sub</span></span><br><span class="line">      <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">        listeners.<span class="title function_">forEach</span>(<span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">listener</span>(message)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">debug</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">delete</span>(message.<span class="property">messageId</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">onOpen</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">connected</span> = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">onClose</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">connected</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reconnect</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">reconnect</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">connect</span>(<span class="variable language_">this</span>.<span class="property">token</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sendMessage</span>(<span class="attr">message</span>: <span class="title class_">Message</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Message</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> messageId = <span class="title function_">uuidv4</span>()</span><br><span class="line">    message.<span class="property">messageId</span> = messageId</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">worker</span>.<span class="property">port</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;message&#x27;</span>, <span class="attr">data</span>: message &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="title class_">Message</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">error</span>: <span class="title class_">Message</span> = &#123;</span><br><span class="line">          messageId,</span><br><span class="line">          <span class="attr">path</span>: message.<span class="property">path</span>,</span><br><span class="line">          <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">          <span class="attr">code</span>: <span class="number">409</span>,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&#x27;timeout&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">delete</span>(message.<span class="property">messageId</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;, <span class="variable language_">this</span>.<span class="property">timeout</span>)</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">value: Message</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value.<span class="property">path</span> === <span class="string">&#x27;/touch&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(messageId, handler)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">on</span>(<span class="attr">event</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="title class_">Handler</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handlers = <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">get</span>(event)</span><br><span class="line">    <span class="keyword">if</span> (!handlers) &#123;</span><br><span class="line">      handlers = []</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">set</span>(event, handlers)</span><br><span class="line">    &#125;</span><br><span class="line">    handlers.<span class="title function_">push</span>(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">off</span>(<span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listeners</span>.<span class="title function_">delete</span>(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useWsClient = <span class="keyword">new</span> <span class="title class_">SharedWebSocket</span>(<span class="string">&#x27;wss://xxx&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sharedWorker.ts</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">socket</span>: <span class="title class_">WebSocket</span> | <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ports</span>: <span class="title class_">MessagePort</span>[] = []</span><br><span class="line"></span><br><span class="line">globalThis.<span class="title function_">addEventListener</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span> (<span class="params">event: MessageEvent</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">port</span>: <span class="title class_">MessagePort</span> = event.<span class="property">ports</span>[<span class="number">0</span>]</span><br><span class="line">  ports.<span class="title function_">push</span>(port)</span><br><span class="line"></span><br><span class="line">  port.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event: MessageEvent</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = event.<span class="property">data</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;connect&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">connect</span>(data.<span class="property">data</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;close&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">close</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (socket?.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">        socket.<span class="title function_">send</span>(<span class="keyword">typeof</span> data.<span class="property">data</span> !== <span class="string">&#x27;string&#x27;</span> ? <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data.<span class="property">data</span>) : data.<span class="property">data</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">data: &#123; url: <span class="built_in">string</span>; token: <span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!socket || socket.<span class="property">readyState</span> !== <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; url, token &#125; = data</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url, [token])</span><br><span class="line">    socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      ports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">        port.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;open&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">event: CloseEvent</span>) &#123;</span><br><span class="line">      ports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">        port.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event: MessageEvent</span>) &#123;</span><br><span class="line">      ports.<span class="title function_">forEach</span>(<span class="function">(<span class="params">port</span>) =&gt;</span> &#123;</span><br><span class="line">        port.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: event.<span class="property">data</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (socket?.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">    socket.<span class="title function_">close</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 类型编程</title>
      <link href="/2022/06/01/javascript/Typescript%20%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/06/01/javascript/Typescript%20%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性，主要作用是对不特定数据类型的支持，以实现函数、接口（Interface）、类的复用。</p><span id="more"></span><p>泛型类似于函数，函数的本质是推后执行（调用），部分待定（函数参数）的代码，泛型的本质是推后执行（调用），部分待定（泛型参数）的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F&lt;A, B&gt; = A | B</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = F&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;A&gt; &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> X = <span class="title class_">List</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代入法查看泛型调用后的具体类型</span></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hash</span>&lt;V = <span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型中使用 <code>extends</code> 和三元运算符</li></ul><p>泛型中使用 <code>extends</code>，判断是否为子类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LikeString</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// 如果 T 继承/包含于 string（T 是 string 的子类型），那就返回 true </span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LikeNumber</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="number">1</span> : <span class="number">2</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LikePerson</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Person</span> ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">LikeString</span>&lt;<span class="string">&#x27;a&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>若 <code>T</code> 为联合类型，则会使用泛型分配律，分开计算。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">unknown</span> ? T[] : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt; <span class="comment">// 结果是 string[] | number[]，而不是 (string | number)[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代入法计算过程</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = (<span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="built_in">string</span>[] : <span class="built_in">never</span>) | (<span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="built_in">number</span>[] : <span class="built_in">never</span>)</span><br></pre></td></tr></table></figure><p>若 <code>T</code> 为 <code>never</code>，则直接返回 <code>never</code>，不会进入条件运算。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">LikeString</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure><p>上述规则只对泛型有效，不在泛型中的联合类型和 <code>never</code>，按正常规则计算。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="built_in">unknown</span> ? <span class="number">1</span> : <span class="number">2</span> <span class="comment">// never 空集属于 unknown 的子集，所以返回 1，不是 never</span></span><br></pre></td></tr></table></figure><ul><li>泛型中使用 <code>keyof</code></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetKeys</span>&lt;T&gt; = keyof T <span class="comment">// keyof 返回的是联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">GetKeys</span>&lt;<span class="title class_">Person</span>&gt; <span class="comment">// id | age | name，注，无法直接调试 Result 结果，只能通过声明变量观察结果 const r: Result = &#x27;id&#x27; </span></span><br></pre></td></tr></table></figure><p>在泛型中使用泛型约束 <code>extends keyof</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 key 的类型</span></span><br><span class="line"><span class="comment">// 约束 K 的类型，只能从 keyof T 中取，不可以随意传</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetKeyType</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T[K] <span class="comment">// type X = Person[&#x27;age&#x27;]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">GetKeyType</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span>&gt; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><ul><li>映射类型</li></ul><p>映射类型（Mapped Types）将现有类型根据某种映射规则转换为一种新的类型。映射类型常通过 <code>keyof</code>、<code>in</code>、修饰符（<code>?</code>、<code>readonly</code>、<code>-readonly</code>、<code>-?</code>）和条件类型（Conditional Types）实现。以几种内置的工具类型 <code>Partial</code>、<code>Required</code>、<code>Record</code>、<code>Exclude</code>、<code>Extract</code>、<code>Pick</code>、<code>Omit</code> 为例，看其如何使用映射类型的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Readonly 只读属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">X1</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// Readonly 实现如下</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="comment">// [K in keyof T] 表示对类型 T 的每个属性进行映射，并使用 readonly 关键字将其设为只读</span></span><br><span class="line">  <span class="comment">// 不能写成索引签名 [K: keyof T]: T[K]</span></span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 readonly，可写属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Partial 给所有属性加上可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// Partial 实现如下</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Required 必选属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Required</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"><span class="comment">// Required 实现如下</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Required</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]-?: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Record 用于定义对象类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// Record 实现如下</span></span><br><span class="line"><span class="comment">// 对象的 Key，只能有 3 种类型，需要约束</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Record</span>&lt;<span class="title class_">Key</span> <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>, <span class="title class_">Val</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">Key</span>]: <span class="title class_">Val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exclude 从联合类型中排除指定类型（求差集）</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Exclude</span>&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">1</span> | <span class="number">2</span>&gt; <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Exclude 实现如下</span></span><br><span class="line"><span class="comment">// 联合类型会分开计算 </span></span><br><span class="line"><span class="comment">// 1 | 2 | 3 extends 1 | 2 会分开为 type Result = (1 extends 1 | 2 ? never : 1) | (2 extends 1 | 2 ? never : 2) | (3 extends 1 | 2 ? never : 3)</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Exclude</span>&lt;A, B&gt; = A <span class="keyword">extends</span> B ? <span class="built_in">never</span> : A</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extract 求交集</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Extract</span>&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">2</span> | <span class="number">4</span>&gt; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Extract 实现如下，为 Exclude 的反向操作</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Extract</span>&lt;A, B&gt; = A <span class="keyword">extends</span> B ? A : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick 选择指定属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Pick</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// Pick 实现如下</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">Key</span>]: T[K]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Omit 忽略指定属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Omit</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// Omit 实现如下</span></span><br><span class="line"><span class="comment">// 核心是 as 后的 (K extends Key ? never : K)，当前 K 在 Key 中，则删除，否则保留</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, <span class="title class_">Key</span>&gt; = &#123;</span><br><span class="line">  <span class="comment">// [K in keyof T as never]: T // 断言为 never，会删除所有</span></span><br><span class="line">  <span class="comment">// [K in keyof T as &#x27;id&#x27;]: T // 断言为 id，只会保留 id</span></span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> (K <span class="keyword">extends</span> <span class="title class_">Key</span> ? <span class="built_in">never</span> : K)]: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TS 原码中通过 Pick 来实现 Omit（反向思路）</span></span><br><span class="line"><span class="comment">// Pick&lt;T, 不要的 Key&gt;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Omit</span>&lt;T, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof T&gt; = <span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, <span class="title class_">Key</span>&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="类型体操"><a href="#类型体操" class="headerlink" title="类型体操"></a>类型体操</h2><p>JavaScript 中可以对<strong>值</strong>进行各种运算（算术运算、逻辑运算、比较运算…）以及循环、判断流的程控制和函数、面向对象等高级特性，如果把 TypeScript 的类型系统当作一门语言，TypeScript 可以对<strong>类型</strong>进行各种运算以及循环、判断流程控制和泛型等高级特性。</p><p>以计算斐波那契数列第 n 项值为例，使用 TypeScript 类型实现和 JavaScript 解释为以下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fibonacci</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span>,</span><br><span class="line">  <span class="comment">// 循环下标（数组 length 表示）</span></span><br><span class="line">  <span class="title class_">TArray</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">unknown</span>&gt; = [<span class="built_in">unknown</span>, <span class="built_in">unknown</span>, <span class="built_in">unknown</span>],</span><br><span class="line">  <span class="comment">// 前前一项值（数组 length 表示）</span></span><br><span class="line">  <span class="title class_">PrePre</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">unknown</span>&gt; = [<span class="built_in">unknown</span>],</span><br><span class="line">  <span class="comment">// 前一项值（数组 length 表示）</span></span><br><span class="line">  <span class="title class_">Pre</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">unknown</span>&gt; = [<span class="built_in">unknown</span>],</span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="number">1</span></span><br><span class="line">  ? <span class="number">1</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="number">2</span></span><br><span class="line">    ? <span class="number">1</span></span><br><span class="line">    : <span class="title class_">TArray</span>[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> T <span class="comment">// 如果已经循环了 T 次</span></span><br><span class="line">      ? [...<span class="title class_">Pre</span>, ...<span class="title class_">PrePre</span>][<span class="string">&#x27;length&#x27;</span>] <span class="comment">// 前两项相加</span></span><br><span class="line">      : <span class="title class_">Fibonacci</span>&lt;T, [...<span class="title class_">TArray</span>, <span class="built_in">unknown</span>], <span class="title class_">Pre</span>, [...<span class="title class_">Pre</span>, ...<span class="title class_">PrePre</span>]&gt;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Fibonacci</span>&lt;<span class="number">6</span>&gt; <span class="comment">// 8，(1 + 1 + 2 + 3 + 5 + 8)</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> prePre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      result = pre + prePre</span><br><span class="line">      prePre = pre</span><br><span class="line">      pre = result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fibonacci</span>(<span class="number">6</span>) <span class="comment">// 结果是 8 (1 + 1 + 2 + 3 + 5 + 8)</span></span><br></pre></td></tr></table></figure><p>注：TypeScript 类型体操是纯粹的函数式编程，函数式编程最基本原则是数据不可变，TypeScript 中类型一但声明就不能改变。</p><h3 id="体操的基本原理"><a href="#体操的基本原理" class="headerlink" title="体操的基本原理"></a>体操的基本原理</h3><p>TypeScript 类型体操的本质是可以对类型进行循环、判断、交叉、联合、泛型等运算和操作。</p><ul><li>循环</li></ul><p>TypeScript 中除了可以通过递归实现循环外，还可以通过分布式条件类型或映射类型实现，但它们都不能传递类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分布式条件类型</span></span><br><span class="line"><span class="comment">// 当泛型参数 T 为联合类型时，条件类型即为分布式条件类型，会将 T 中的每一项分别分发给 extends 进行比对</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? T : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Example</span>&lt;<span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="number">3</span> | <span class="number">4</span>&gt; <span class="comment">// 3 | 4</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  [<span class="title class_">Key</span> <span class="keyword">in</span> T]: <span class="title class_">Key</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Example</span>&lt;<span class="string">&#x27;1&#x27;</span> | <span class="string">&#x27;2&#x27;</span> | <span class="number">3</span> | <span class="number">4</span>&gt; <span class="comment">// &#123; 1: &#x27;1&#x27;; 2: &#x27;2&#x27;; 3: 3; 4: 4; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>判断</li></ul><p>使用三名运算实现条件判断。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (A &lt;= B) true else false</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="number">1</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="number">1</span> | <span class="number">2</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = A <span class="keyword">extends</span> B ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// A 包含于 B，返回 true 否则 false</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (A &lt;= B) and (C &lt;= D) ...</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="number">1</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="number">1</span> | <span class="number">2</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="number">3</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="number">3</span> | <span class="number">4</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = A <span class="keyword">extends</span> B </span><br><span class="line">  ? C <span class="keyword">extends</span> D </span><br><span class="line">    ? <span class="string">&#x27;true, true&#x27;</span></span><br><span class="line">    : <span class="string">&#x27;true, false&#x27;</span></span><br><span class="line">  : C <span class="keyword">extends</span> D</span><br><span class="line">    ? <span class="string">&#x27;false, true&#x27;</span></span><br><span class="line">    : <span class="string">&#x27;false, false&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断空元组</span></span><br><span class="line"><span class="keyword">type</span> A = []</span><br><span class="line"><span class="comment">// 约束 Arr 必须是一个数组</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsEmptyArray</span>&lt;<span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = <span class="title class_">Arr</span>[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">IsEmptyArray</span>&lt;A&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断非空元组</span></span><br><span class="line"><span class="keyword">type</span> A = []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsNotEmptyArray</span>&lt;<span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = <span class="title class_">Arr</span>[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">IsNotEmptyArray</span>&lt;A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样写</span></span><br><span class="line"><span class="comment">// [...infer X, infer Y] 表示至少有一个，也可写为 [...unknown[], unknown]，X、Y 相当于类型变量，加 infer 表示引用类型变量，这样就可不用写实际类型</span></span><br><span class="line"><span class="comment">// ...相当于 JS 中的 rest 运算符，...unknown[] 表示 0 个或无数个</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsNotEmptyArray</span>&lt;<span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = <span class="title class_">Arr</span> <span class="keyword">extends</span> [...infer X, infer Y] ? <span class="literal">true</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>递归</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转元组</span></span><br><span class="line"><span class="keyword">type</span> A = [<span class="string">&#x27;ji&#x27;</span>, <span class="string">&#x27;ni&#x27;</span>, <span class="string">&#x27;tai&#x27;</span>, <span class="string">&#x27;mei&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Reverse</span>&lt;<span class="title class_">Arr</span> <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = <span class="title class_">Arr</span> <span class="keyword">extends</span> [...infer <span class="title class_">Rest</span>, infer <span class="title class_">Last</span>]</span><br><span class="line">  ? [<span class="title class_">Last</span>, ...<span class="title class_">Reverse</span>&lt;<span class="title class_">Rest</span>&gt;]</span><br><span class="line">  : <span class="title class_">Arr</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Reverse</span>&lt;A&gt; <span class="comment">// [&#x27;mei&#x27;, &#x27;tai&#x27;, &#x27;ni&#x27;, &#x27;ji&#x27;]</span></span><br></pre></td></tr></table></figure><p>注：经测试，元组递归的层数最多 <code>48</code> 层，普通对象的层数限制未测出。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未知层数的对象类型属性添加 readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: <span class="title class_">DeepReadonly</span>&lt;T[P]&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SomeObject</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      <span class="attr">c</span>: <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">DeepReadonly</span>&lt;<span class="title class_">SomeObject</span>&gt; = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: &#123;<span class="attr">c</span>: <span class="number">2</span>&#125;&#125;&#125;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span> = <span class="number">23</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><ul><li>比较运算</li></ul><p>TypeScript 中没有 <code>==</code>，但是通过 <code>extends</code> 可以实现类似的效果。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EqEq</span>&lt;<span class="variable constant_">T1</span>, <span class="variable constant_">T2</span>&gt; = [<span class="variable constant_">T1</span>] <span class="keyword">extends</span> [<span class="variable constant_">T2</span>] </span><br><span class="line">  ? ([<span class="variable constant_">T2</span>] <span class="keyword">extends</span> [<span class="variable constant_">T1</span>] ? <span class="literal">true</span> : <span class="literal">false</span>) </span><br><span class="line">  : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">EqEq</span>&lt;<span class="number">5</span>, <span class="number">10</span>&gt;;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">EqEq</span>&lt;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>&gt;;  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result3</span> = <span class="title class_">EqEq</span>&lt;<span class="literal">true</span>, <span class="literal">false</span>&gt;;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result4</span> = <span class="title class_">EqEq</span>&lt;<span class="built_in">never</span>, <span class="built_in">never</span>&gt;;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>模式匹配和 infer 引用</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Tuple</span> = [<span class="string">&#x27;ji&#x27;</span>, <span class="string">&#x27;ni&#x27;</span>, <span class="string">&#x27;tai&#x27;</span>, <span class="string">&#x27;mei&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">Tuple</span> <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>] ? <span class="title class_">First</span> : <span class="built_in">never</span> <span class="comment">// &#x27;ji&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">Tuple</span> <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>] ? <span class="title class_">Rest</span> : <span class="built_in">never</span> <span class="comment">// [&#x27;ni&#x27;, &#x27;tai&#x27;, &#x27;mei&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="元组的基本体操"><a href="#元组的基本体操" class="headerlink" title="元组的基本体操"></a>元组的基本体操</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展元组</span></span><br><span class="line"><span class="keyword">type</span> A = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">type</span> B = [...A, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元组最后一项</span></span><br><span class="line"><span class="keyword">type</span> A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Last</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = T <span class="keyword">extends</span> [...<span class="built_in">unknown</span>[], infer <span class="title class_">Last</span>] ? <span class="title class_">Last</span> : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Last</span>&lt;A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用 JS 的思维实现，下面这样是错的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Last</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = T[T[<span class="string">&#x27;length&#x27;</span>] - <span class="number">1</span>] <span class="comment">// TS 中没有提供减法操作，4 - 1 在 TS 中无法计算</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元组除了最后一项的其他项</span></span><br><span class="line"><span class="keyword">type</span> A = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NotLast</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = T <span class="keyword">extends</span> [...infer X, <span class="built_in">unknown</span>] ? X : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">NotLast</span>&lt;A&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用 JS 的思维实现，下面这样是错的</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Last</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = T[T[<span class="string">&#x27;length&#x27;</span>] - <span class="number">1</span>] <span class="comment">// TS 中没有提供减法操作，4 - 1 在 TS 中无法计算</span></span><br></pre></td></tr></table></figure><h3 id="字符串的基本体操"><a href="#字符串的基本体操" class="headerlink" title="字符串的基本体操"></a>字符串的基本体操</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小写切换</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;tracy&#x27;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Capitalize</span>&lt;A&gt; <span class="comment">// &#x27;Tracy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = <span class="string">&#x27;ji&#x27;</span> | <span class="string">&#x27;ni&#x27;</span> | <span class="string">&#x27;tai&#x27;</span> | <span class="string">&#x27;mei&#x27;</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="title class_">Capitalize</span>&lt;C&gt; <span class="comment">// 联合类型在泛型中会按分配律计算，结果为 &#x27;Ji&#x27; | &#x27;Ni&#x27; | &#x27;Tai&#x27; | &#x27;Mei&#x27;</span></span><br></pre></td></tr></table></figure><p>除了 <code>Capitalize</code> 首字母大写外，TypeScript 还内置了 <code>Uppercase</code> 全变成大写，<code>Uncapitalize</code> 首字母小写，<code>Lowercase</code> 全变成小写。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;ji&#x27;</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="string">&#x27;ni&#x27;</span></span><br><span class="line"><span class="keyword">type</span> C = <span class="string">&#x27;tai&#x27;</span></span><br><span class="line"><span class="keyword">type</span> D = <span class="string">&#x27;mei&#x27;</span></span><br><span class="line"><span class="keyword">type</span> X = <span class="string">`<span class="subst">$&#123;A&#125;</span> <span class="subst">$&#123;B&#125;</span> <span class="subst">$&#123;C&#125;</span> <span class="subst">$&#123;D&#125;</span>`</span> <span class="comment">// &#x27;ji ni tai mei&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转字符串</span></span><br><span class="line"><span class="comment">// 将类型转为字符串有一定的限制，仅支持下面的类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CanStringified</span> = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">bigint</span> | <span class="built_in">boolean</span> | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 将支持的类型转化为字符串</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Stringify</span>&lt;T <span class="keyword">extends</span> <span class="title class_">CanStringified</span>&gt; = <span class="string">`<span class="subst">$&#123;T&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="title class_">Stringify</span>&lt;<span class="number">0</span>&gt; <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="title class_">Stringify</span>&lt;-<span class="number">1</span>&gt; <span class="comment">// &#x27;-1&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result3</span> = <span class="title class_">Stringify</span>&lt;<span class="number">0.1</span>&gt; <span class="comment">// &#x27;0.1&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result4</span> = <span class="title class_">Stringify</span>&lt;<span class="string">&#x27;0.2&#x27;</span>&gt; <span class="comment">// &#x27;0.2&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一个字符</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;ji ni tai mei&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;<span class="built_in">string</span>&#125;</span>`</span> ? F : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">First</span>&lt;A&gt; <span class="comment">// &#x27;j&#x27;</span></span><br></pre></td></tr></table></figure><p>注：使用模式匹配只能获取第一个字符和其它剩下字符，不能获取最后一个字符，如果想要获取最后一个字符，可转为元组操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最后一个字符</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="string">&#x27;ji ni tai mei&#x27;</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LastOfTuple</span>&lt;T <span class="keyword">extends</span> <span class="built_in">unknown</span>[]&gt; = T <span class="keyword">extends</span> [...infer _, infer L] ? L : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringToTuple</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? [F, ...<span class="title class_">StringToTuple</span>&lt;R&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LastOfString</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = <span class="title class_">LastOfTuple</span>&lt;<span class="title class_">StringToTuple</span>&lt;S&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">LastOfString</span>&lt;A&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转联合类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringToUnion</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? <span class="title class_">First</span> | <span class="title class_">StringToUnion</span>&lt;<span class="title class_">Rest</span>&gt;</span><br><span class="line">  : <span class="built_in">never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">StringToUnion</span>&lt;<span class="string">&#x27;jinitaimei&#x27;</span>&gt; <span class="comment">// &quot;j&quot; | &quot;i&quot; | &quot;n&quot; | &quot;t&quot; | &quot;a&quot; | &quot;m&quot; | &quot;e&quot;，联合类型会自动去重</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转元组</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringToTuple</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer First&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? [<span class="title class_">First</span>, ...<span class="title class_">StringToTuple</span>&lt;<span class="title class_">Rest</span>&gt;]</span><br><span class="line">  : []</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">StringToTuple</span>&lt;<span class="string">&#x27;jinitaimei&#x27;</span>&gt; <span class="comment">// [&quot;j&quot;, &quot;i&quot;, &quot;n&quot;, &quot;i&quot;, &quot;t&quot;, &quot;a&quot;, &quot;i&quot;, &quot;m&quot;, &quot;e&quot;, &quot;i&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type-Challenges"></a>Type-Challenges</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md#%E4%BB%8B%E7%BB%8D">Type-Challenges</a> 中常见问题解法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0004 Pick</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">Key</span>]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Pick</span>&lt;&#123;<span class="attr">a</span>: <span class="number">1</span>; <span class="attr">b</span>: <span class="number">2</span>; <span class="attr">c</span>: <span class="number">3</span>&#125;, <span class="string">&#x27;a&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可使用代入法来思考泛型</span></span><br><span class="line">&#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>]: &#123;<span class="attr">a</span>: <span class="number">1</span>; <span class="attr">b</span>: <span class="number">2</span>; <span class="attr">c</span>: <span class="number">3</span>&#125;[<span class="string">&#x27;a&#x27;</span>] <span class="comment">// 即 &#x27;a&#x27;: 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3321 Parameters</span></span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Parameters</span>&lt;F <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = F <span class="keyword">extends</span> (...<span class="attr">args</span>: infer X) =&gt; <span class="built_in">any</span> ? X : <span class="built_in">never</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = (<span class="attr">arg1</span>: <span class="built_in">string</span>, <span class="attr">arg2</span>: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Parameters</span>&lt;<span class="keyword">typeof</span> foo&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0189 Awaited</span></span><br><span class="line"><span class="comment">// 获取 Promise resove 的数据类型</span></span><br><span class="line"><span class="comment">// 注意，不能直接使用 Promise 类型，否则 Thenable 用例不能通过</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Awaited</span>&lt;P <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt;&gt; = P <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;infer X&gt;</span><br><span class="line">  ? X <span class="keyword">extends</span> <span class="title class_">PromiseLike</span>&lt;<span class="built_in">any</span>&gt; </span><br><span class="line">    ? <span class="title class_">Awaited</span>&lt;X&gt; </span><br><span class="line">    : X</span><br><span class="line">  : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4471 Zip</span></span><br><span class="line"><span class="comment">// 像拉拉链一样将元组交叉组合</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Zip</span>&lt;A <span class="keyword">extends</span> <span class="built_in">any</span>[], B <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = A <span class="keyword">extends</span> [infer <span class="title class_">AFirst</span>, ...infer <span class="title class_">ARest</span>]</span><br><span class="line">  ? B <span class="keyword">extends</span> [infer <span class="title class_">BFirst</span>, ...infer <span class="title class_">BRest</span>]</span><br><span class="line">    ? [[<span class="title class_">AFirst</span>, <span class="title class_">BFirst</span>], ...<span class="title class_">Zip</span>&lt;<span class="title class_">ARest</span>, <span class="title class_">BRest</span>&gt;]</span><br><span class="line">      : []</span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4484 IsTuple</span></span><br><span class="line"><span class="comment">// 判断是否为元组</span></span><br><span class="line"><span class="comment">// 元组的长度是固定的，length 返回固定值，而数组长度是不固定的，length 返回 number</span></span><br><span class="line"><span class="comment">// 泛型中的 never 会直接返回 never，为了使其返回 true false，这里使用 [] 包裹，当然使用 &#123;&#125; 或函数类型包裹效果也一样</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">IsTuple</span>&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="built_in">never</span>] </span><br><span class="line">  ? <span class="literal">false</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]</span><br><span class="line">    ? <span class="built_in">number</span> <span class="keyword">extends</span> T[<span class="string">&#x27;length&#x27;</span>] <span class="comment">// 如果是数组则返回 false</span></span><br><span class="line">      ? <span class="literal">false</span></span><br><span class="line">      : <span class="literal">true</span></span><br><span class="line">    :<span class="literal">false</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5310 Join</span></span><br><span class="line"><span class="comment">// 将元组使用分隔符连接成字符串</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Join</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>[], U <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span>&gt; = T <span class="keyword">extends</span> [infer <span class="title class_">First</span> <span class="keyword">extends</span> <span class="built_in">string</span>, ...infer <span class="title class_">Rest</span> <span class="keyword">extends</span> <span class="built_in">string</span>[]]</span><br><span class="line">  ? <span class="title class_">Rest</span>[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span></span><br><span class="line">    ? <span class="title class_">First</span></span><br><span class="line">    : <span class="string">`<span class="subst">$&#123;First&#125;</span><span class="subst">$&#123;U&#125;</span><span class="subst">$&#123;Join&lt;Rest, U&gt;&#125;</span>`</span></span><br><span class="line">  : <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Scratch 编程</title>
      <link href="/2022/03/02/scratch/Scratch/"/>
      <url>/2022/03/02/scratch/Scratch/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/scratch/scratch.jpg" alt="Scratch"></p><span id="more"></span><p>计算机是一种输入&#x2F;采集、存储、处理和输出数据的机器。数据通过键盘、鼠标、摄像头、传感器输入&#x2F;采集，被存储于硬盘和内存中，通过 CPU 进行运算处理，最后通过屏幕、打印机、扬声器、机器臂等设备输出。这些数据可以是数字、文本、图像、声音等各种形式。无论是科学计算、媒体处理、数据分析、通信还是娱乐，计算机都扮演着关键的角色，它们能够以极快的速度和准确性处理数据。</p><p>仅从“输入-存储-计算-输出”模型上看，人类与计算机是一样的，人类通过眼睛、鼻子、皮肤和舌头等各种器官采集数据，通过大脑存储和计算数据，然后通过嘴巴、四肢及其他身体部位响应大脑计算好的数据。人类与机器的最大区别在于人类拥有自主、感知、智能、情感、创造力和伦理判断等高度复杂的特征，而机器只是工具，受限于编程和数据，缺乏这些特征。</p><p>机器能学习，独立思考问题和解决问题，拥有自我意识，有自己的价值观和世界观体系，有和生物一样的各种本能（比如生存和安全需求）等待一系列，这被称为人工智能 AI (Artificial Intelligence)。人工智能普遍用于自动驾驶、人脸识别、语音识别、聊天机器人等场景，现阶段人类还未到达强人工智能（Strong AI）时代。</p><p>语言是用来交流表达的，不管是自然语言还是计算机语言。人类之间通过自然语言进行交流，人类与计算机通过计算机语言交流，为计算机编写程序（编程），程序是一系列指令的集合，它告诉计算机要做什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">Fibonacci</span>&lt;</span><br><span class="line">  T <span class="keyword">extends</span> number,</span><br><span class="line">  <span class="title class_">TArray</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;unknown&gt; = [unknown, unknown, unknown],</span><br><span class="line">  <span class="title class_">PrePre</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;unknown&gt; = [unknown],</span><br><span class="line">  <span class="title class_">Pre</span> <span class="keyword">extends</span> <span class="title class_">ReadonlyArray</span>&lt;unknown&gt; = [unknown],</span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="number">1</span></span><br><span class="line">  ? <span class="number">1</span></span><br><span class="line">  : T <span class="keyword">extends</span> <span class="number">2</span></span><br><span class="line">    ? <span class="number">1</span></span><br><span class="line">    : <span class="title class_">TArray</span>[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> T</span><br><span class="line">      ? [...<span class="title class_">Pre</span>, ...<span class="title class_">PrePre</span>][<span class="string">&#x27;length&#x27;</span>]</span><br><span class="line">      : <span class="title class_">Fibonacci</span>&lt;T, [...<span class="title class_">TArray</span>, unknown], <span class="title class_">Pre</span>, [...<span class="title class_">Pre</span>, ...<span class="title class_">PrePre</span>]&gt;</span><br><span class="line">  </span><br><span class="line">type <span class="title class_">Result</span> = <span class="title class_">Fibonacci</span>&lt;<span class="number">6</span>&gt; <span class="comment">// 8，(1 + 1 + 2 + 3 + 5 + 8)</span></span><br></pre></td></tr></table></figure><p>计算机语言有很多，大部分程序都是基于文本的，比如 C、Python…，Scratch 是 MIT 开发的一款可视化图形编程语言，以搭积木的形式编写程序，这让学习编程更加容易和有趣。</p><h2 id="Scratch-语法"><a href="#Scratch-语法" class="headerlink" title="Scratch 语法"></a>Scratch 语法</h2><p>积木是 Scratch 语法的最基本要素，不同的积木代表着不同的编程命令、操作和功能，类似于文本语言中的语句或表达式。积木分为十大模块，运动、外观、声音、事件、控制、侦测、运算、变量、自制积木、扩展积木，按功能又分为命令积木（语句）和功能积木（表达式）。积木可以传参，凹槽的形状决定了参数的数据类型。</p><p>命令积木用于控制程序的流程和执行命令。包括流程控制、事件触发、改变程序状态（如移动到某个位置）等积木。功能积木用于执行计算或操作。包括数学运算、逻辑运算、变量操作。功能积木有返回值，可作为参数传递给功能积木或命令积木。功能积木有两种形状，六边形和圆角，前者返回布尔类型值，后者返回数字或字符串类型值。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>流程控制是编程的最基础要素，循序指重复做一件事情。日常生活等红绿灯、跳绳、购物、穿着选择都是最常见的例子。</p><ul><li><a href="/rep/scratch/1%E5%8A%A0%E5%88%B0100.sb3">循环</a></li><li><a href="/rep/scratch/%E8%B4%AD%E7%89%A9.sb3">判断</a></li><li><a href="/rep/scratch/%E5%BB%B6%E8%BF%9F.sb3">延迟</a></li><li><a href="/rep/scratch/%E5%A4%9A%E9%87%8D%E5%BD%B1%E5%88%86%E8%BA%AB%E6%9C%AF.sb3">克隆</a></li></ul><p>注：Scratch 中的循环即支持 <code>for</code> 也支持 <code>while</code>，<code>while</code> 循环更加灵活，适用于循环次数不确定的情况，而 <code>for</code> 循环更适用于已知循环次数的情况。</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Scratch 支持的运算包括，算术运算、比较运算、逻辑运算、字符运算（连接、charAt、length、includes）、Math 运算（取余、四舍五入、绝对值等）。运算符（operators）和操作数（operands）组成的一组代码被称为表达式（Expression）。</p><ul><li><a href="/rep/scratch/%E8%BF%90%E7%AE%971.sb3">算术运算、数学函数</a></li><li><a href="/rep/scratch/%E8%BF%90%E7%AE%972.sb3">随机数、字符串、取余、四舍五入</a></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量用于存储和表示数据或值。可以理解为一个盒子，其中可以存放不同类型的物品，每个盒子有一个名称，可以通过名称来查找或更改盒子里的内容。变量有两种作用域，私有变量和全角变量，私有变量适用于当前角色，全角变量使用于所有角色。</p><ul><li><a href="/rep/scratch/%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC.sb3">变量的赋值</a></li><li><a href="/rep/scratch/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.sb3">变量的作用域</a></li><li><a href="/rep/scratch/%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F.sb3">布尔类型变量</a></li><li><a href="/rep/scratch/%E5%8F%98%E9%87%8F%E5%80%BC%E6%98%BE%E7%A4%BA%E5%99%A8.sb3">变量值显示器</a></li></ul><p>注意：变量不支持布尔类型的赋值，可通过 <code>0</code>、<code>1</code> 代替。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 Scratch 中支持的数据类型包括：数字、字符串、布尔、列表。</p><ul><li><a href="/rep/scratch/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.sb3">数据类型</a></li><li><a href="/rep/scratch/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.sb3">自动类型转换</a></li><li><a href="/rep/scratch/%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86.sb3">列表遍历</a></li><li><a href="/rep/scratch/%E9%9A%8F%E6%9C%BA%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90.sb3">随机列表生成</a></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在 Scratch 中，函数通过自定义积木实现，用于封装一段脚本。自定义积木不能跨角色共用，且只支持参数不支持返回值，返回只能通过变量解决。</p><ul><li><a href="/rep/scratch/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A7%AF%E6%9C%A8.sb3">自定义积木</a></li><li><a href="/rep/scratch/%E9%80%92%E5%BD%92.sb3">递归</a></li></ul><p>注意：形参可通过拖拉的方式应用到对应的地方使用。</p><h2 id="GUI-编程"><a href="#GUI-编程" class="headerlink" title="GUI 编程"></a>GUI 编程</h2><p>在 Scratch 中，对角色或舞台进行编程，脚本必须在角色或舞台下，脚本可不可以应用到多个角色。</p><h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>角色的中心点（中心点是针对角色的，每个角色都有中心点，跟位置不同，中心点一般用来描述运动的基点）和角色的位置。</p><h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>外观不但可用来打印输出结果，也可以控制背景、角色、角色造型的显示。</p><ul><li><a href="/rep/scratch/%E4%B8%B2%E8%81%94%E7%94%B5%E8%B7%AF%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%AA%8C.sb3">造型切换</a></li><li><a href="/rep/scratch/%E6%AC%A7%E5%A7%86%E5%AE%9A%E5%BE%8B%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%AA%8C.sb3">虚像特效</a></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>GUI 编程的核心是事件。Scratch 除了支持常见的鼠标事件外，还支持发布与订阅式的自定义广播事件，这在角色间通信非常方便。</p><ul><li><a href="/rep/scratch/%E8%AE%A1%E7%AE%97%E7%90%83%E4%BD%93%E4%BD%93%E7%A7%AF%E5%92%8C%E8%A1%A8%E9%9D%A2%E7%A7%AF.sb3">广播</a></li></ul><h3 id="侦测"><a href="#侦测" class="headerlink" title="侦测"></a>侦测</h3><p>侦测积木实际上是一种事件监听的机制。这些积木用于检测特定的事件或条件，然后触发相应的操作或行为。类似于文本语言中的事件监听器。</p><ul><li><a href="/rep/scratch/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5.sb3">获取用户输入</a></li></ul><h3 id="扩展积木"><a href="#扩展积木" class="headerlink" title="扩展积木"></a>扩展积木</h3><p>扩展积木是 Scratch 内置的，包括画笔、音乐、翻译等。</p><ul><li><a href="/rep/scratch/%E8%9C%98%E8%9B%9B%E7%BD%91.sb3">蜘蛛网</a></li><li><a href="/rep/scratch/%E9%A3%8E%E8%BD%A6.sb3">风车</a></li></ul><h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><ul><li><a href="/rep/scratch/%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC.sb3">鸡兔同笼</a></li><li><a href="/rep/scratch/%E8%A7%81%E7%BC%9D%E6%8F%92%E9%92%88.sb3">见缝插针</a></li><li><a href="/rep/scratch/%E6%A6%82%E7%8E%87.sb3">概率</a></li><li><a href="/rep/scratch/%E6%8E%B7%E8%89%B2%E5%AD%90.sb3">掷色子</a></li><li><a href="/rep/scratch/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.sb3">冒泡排序</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 少儿编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用户角色权限设计</title>
      <link href="/2022/01/06/project/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/01/06/project/%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>在多角色的系统中（比如管理端）一般会给不同角色的用户分配不同的权限。权限一般有以下分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 页面权限</span><br><span class="line">* 操作权限</span><br><span class="line">* 数据权限</span><br><span class="line">* API 权限</span><br></pre></td></tr></table></figure><p>页面一般通过路由分发，所以页面权限也叫做路由权限。在这些权限中，API 权限是后端权限，其他都是前端权限，下面从前端角度介绍用户角色权限的设计。</p><span id="more"></span><h2 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h2><p>页面权限包含了所有权限类型，操作和数据都在页面内，操作权限和数据权限可作为页面权限的子权限。页面绝大多数由菜单触发（少数由按钮或地址栏输入触发），以菜单为载体不但能配置菜单本身，还能配置权限。</p><p>权限既可以在服务端配置，也可以在客户端配置，在服务端配置更容易维护。</p><ul><li>服务端配置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// ID</span></span><br><span class="line">  <span class="attr">parentId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 父级菜单 ID</span></span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 菜单名称（菜单管理列表的显示名称）</span></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 路由或 URL</span></span><br><span class="line">  <span class="attr">sort</span>: <span class="number">0</span>, <span class="comment">// 排序</span></span><br><span class="line">  <span class="attr">icon</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 图标</span></span><br><span class="line">  <span class="attr">hidden</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 是否隐藏，不生成菜单</span></span><br><span class="line">  <span class="attr">functions</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">// 操作权限（增、删、改、查...）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菜单权限列表是一个树形结构，描述了菜单的从属关系，决定了菜单的生成层级。对于那些不需要生成菜单的页面（由按钮触发或地址直接打开的页面），可通过 <code>hidden</code> 字段描述菜单项是否显示。</p><p>实际操作中，一般由菜单管理生成总的菜单权限列表，角色管理时为角色勾选权限，然后在用户管理中为用户赋予角色。</p><ul><li>客户端配置</li></ul><p>以在前端路由表中配置为例（当然不一定写在路由表中，独立一个菜单权限文件也可以）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  meta : &#123;</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">false</span> <span class="comment">// 是否生成菜单</span></span><br><span class="line">    <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;teacher&#x27;</span>], <span class="comment">// 空表示不需要权限，任何角色都可访问，即为开放菜单</span></span><br><span class="line">    <span class="attr">functions</span>: &#123;</span><br><span class="line">      <span class="attr">admin</span>: [<span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;edit&#x27;</span>, <span class="string">&#x27;export&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><ul><li>路由鉴权</li></ul><p>页面权限采用白名单制，不在此名单内的访问和操作都是非法的，实际需求中并不是所有的页面都需要权限，比如 404，登录页，活动页等，这些页面都不需要权限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鉴权列表外的，直接放行</span></span><br><span class="line"><span class="keyword">if</span> (!totalRoutePermitList.<span class="title function_">includes</span>(curRouteName)) &#123;</span><br><span class="line">  <span class="comment">// 有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (myRoutePermitList.<span class="title function_">includes</span>(curRouteName)) &#123;</span><br><span class="line">    <span class="comment">// 有权限</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无权限</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者将这些不需鉴权页面作为访问白名单加入到我的权限列表进行鉴权，但这需要维护白名单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将白名单列表合并到我的权限列表</span></span><br><span class="line">myRoutePermitList = [...routePermitWhiteList, ...myRoutePermitList]</span><br><span class="line"><span class="keyword">if</span> (myRoutePermitList.<span class="title function_">includes</span>(curRouteName)) &#123;</span><br><span class="line">  <span class="comment">// 有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 无权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作鉴权</li></ul><p>不是所有的操作都需要参与鉴权，根据需求选择性鉴权即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!myFunPermitList.<span class="title function_">includes</span>(curFunName)) &#123;</span><br><span class="line">  <span class="comment">// 无权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 中通常配合 <code>v-if</code> 或自定义指令实现操作按钮的隐藏显示。</p>]]></content>
      
      
      <categories>
          
          <category> 项目设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用二进制设计课堂权限</title>
      <link href="/2021/10/06/project/%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E6%9D%83%E9%99%90/"/>
      <url>/2021/10/06/project/%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%AE%BE%E8%AE%A1%E8%AF%BE%E5%A0%82%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>使用二进制能很方便的表达和计算（组合、切换和校验）权限，以 Linux 文件权限为例。</p><table><thead><tr><th>权限</th><th>字母表示</th><th>数字表示</th><th>二进制</th></tr></thead><tbody><tr><td>读</td><td>r</td><td>4</td><td>0b100</td></tr><tr><td>写</td><td>w</td><td>2</td><td>0b010</td></tr><tr><td>执行</td><td>x</td><td>1</td><td>0b001</td></tr></tbody></table><span id="more"></span><p>权限之间可组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 读写 = <span class="number">0b100</span> | <span class="number">0b010</span> <span class="comment">// 6 即 0b110</span></span><br><span class="line"><span class="keyword">const</span> 读写执行 = <span class="number">0b100</span> | <span class="number">0b010</span> | <span class="number">0b001</span> <span class="comment">// 7 即 0b111</span></span><br></pre></td></tr></table></figure><p>总的组合结果共 <code>C(2,1) * C(2,1) * C(2,1)</code>，8 种，无权限 <code>0</code> (<code>---</code>)，读权限 <code>4</code> (<code>r--</code>)，写权限 <code>2</code> (<code>-w-</code>)，执行权限 <code>1</code> (<code>--x</code>)，读和写权限 <code>6</code> (<code>rw-</code>)，读和执行权限 <code>5</code> (<code>r-x</code>)，写和执行权限 <code>3</code> (<code>-wx</code>)，读、写和执行权限 <code>7</code> (<code>rwx</code>)。</p><h2 id="二进制运算符"><a href="#二进制运算符" class="headerlink" title="二进制运算符"></a>二进制运算符</h2><p>二进制位运算符包括 <code>|</code>（按位或 OR）、<code>&amp;</code>（按位与 AND）、<code>^</code>（按位异或 XOR）、<code>~</code>（按位非，取反 NOT）、<code>&lt;&lt;</code>（左移 Left shift）、<code>&gt;&gt;</code>（有符号右移）、<code>&gt;&gt;&gt;</code>（无符号右移）。</p><p>JavaScript 位运算是基于 32 位整数的，会先把 64 位浮点数转换为 32 位整数计算，计算完成后再将 32 位转为 64 位。</p><ul><li><code>|</code> 运算符</li></ul><p><code>|</code> 运算将两个操作数的每个对应位进行或运算，结果中，两个操作数对应位上至少有一个为 <code>1</code> 时才为 <code>1</code>，否则为 <code>0</code>（相当于求并），即 <code>1 | 1 = 1</code>、<code>0 | 0 = 0</code>、<code>0 | 1 = 1</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  1100</span><br><span class="line">| 0010</span><br><span class="line">-------</span><br><span class="line">  1110</span><br></pre></td></tr></table></figure><ul><li><code>&amp;</code> 运算符</li></ul><p><code>&amp;</code> 运算将两个操作数的每个对应位进行与运算，结果中，两个操作数对应位上都为 <code>1</code> 时才为 <code>1</code>，否则为 <code>0</code>，即 <code>1 &amp; 1 = 1</code>、<code>0 &amp; 0 = 0</code>、<code>0 &amp; 1 = 0</code>。以操作数 <code>0010</code> 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  xxyx</span><br><span class="line">&amp; 0010</span><br><span class="line">-------</span><br><span class="line">  00a0</span><br></pre></td></tr></table></figure><p>上述例子中 <code>x</code> 位为任何数，<code>&amp;</code> 运算的结果都是 <code>0</code>，最终结果只受 <code>y</code> 位影响，当 <code>y = 0</code> 时，结果为 <code>0000</code>，<code>y = 1</code> 时，结果为 <code>0010</code>。即如果 <code>a &amp; b === b</code> 为 <code>true</code>，则说明 <code>a</code> 包含 <code>b</code>。</p><ul><li><code>^</code> 运算符</li></ul><p><code>^</code> 运算将两个操作数的每个对应位进行异或运算，结果中，两个操作数对应位上不相同时才为 <code>1</code>，相同时为 <code>0</code>。利用这个特点，可实现 Toggle 计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0001</span><br><span class="line">^ 0010</span><br><span class="line">-------</span><br><span class="line">  0011</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0011</span><br><span class="line">^ 0010</span><br><span class="line">-------</span><br><span class="line">  0001</span><br></pre></td></tr></table></figure><ul><li><code>~</code> 运算符</li></ul><p><code>~</code> 将操作数的每一位取反。有点类似于反码，但不同的是，<code>~</code> 会将符号位也取反，而取反码，符号位不变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1010</span><br><span class="line">-------</span><br><span class="line">0101</span><br></pre></td></tr></table></figure><p>以 <code>~10</code> (<code>~0b1010</code>) 为例，其 32 位二进制为 <code>00000000000000000000000000001010</code> (正数的补码就是原码)，<code>~</code> 取反得到 <code>11111111111111111111111111110101</code>，由于符号位是 <code>1</code>，所以这是一个负数，而计算机中存储负数是以补码的方式来存储的，所以对补码求原码再转成十进制即可，对补码求原码就是使用此补码再求一遍补码，也就是先取反码再补 <code>1</code>，即 <code>10000000000000000000000000001010</code> 加 <code>1</code>，结果为 <code>10000000000000000000000000001011</code>，即 <code>-11</code>。</p><p><code>~-2</code> 的 32 位二进制为 <code>11111111111111111111111111111110</code>（负数的补码需要反码再加 1），<code>~</code> 取反得到 <code>00000000000000000000000000000001</code>，再将结果转为十进制，即 <code>1</code>。</p><p>任何数字 <code>x</code> 的按位非运算结果都是 <code>-(x + 1)</code>。例如，<code>~-5</code> 运算结果为 <code>4</code>。</p><ul><li><code>&lt;&lt;</code> 左移运算符</li></ul><p>将数值的二进制码向左移动一定的位（&lt; 32），右边用 <code>0</code> 填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1010 &gt;&gt; 1</span><br><span class="line">10100</span><br></pre></td></tr></table></figure><p>使用左移还可用来取整。位运算操作的是整数，忽略小数部分，等同于数值的整数部分，左移 0 位，结果还是整数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.111</span> &lt;&lt; <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">2.344</span> &lt;&lt; <span class="number">0</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li><code>&gt;&gt;</code> 右移运算符</li></ul><p>将数值的二进制码向右移动一定的位（&lt;32），遗弃被丢出的位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1010 &gt;&gt; 1</span><br><span class="line"> 101</span><br></pre></td></tr></table></figure><h2 id="课堂权限设计"><a href="#课堂权限设计" class="headerlink" title="课堂权限设计"></a>课堂权限设计</h2><p>定义课堂黑板权限为 <code>1</code>、语音权限为 <code>2</code>、视频权限为 <code>4</code>。权限间可组合，同时拥有黑板、语音和视频权限 <code>Board | Audio | Video</code>，即 <code>0111</code>。使用左移 <code>&lt;&lt;</code> 定义权限、使用按位或 <code>|</code> 组合权限、使用按位异或 <code>^</code> 切换权限（添加或删除权限）、使用按位与 <code>&amp;</code> 校验权限。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;&lt; 定义权限</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">  <span class="title class_">None</span> = <span class="number">0</span>, <span class="comment">// 0000</span></span><br><span class="line">  <span class="title class_">Board</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 0001，左移 0 位</span></span><br><span class="line">  <span class="title class_">Audio</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 0010，左移 1 位</span></span><br><span class="line">  <span class="title class_">Video</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 0100，左移 2 位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Student</span> = &#123;</span><br><span class="line">  <span class="attr">permission</span>: <span class="title class_">Permission</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">student</span>: <span class="title class_">Student</span> = &#123;</span><br><span class="line">  <span class="attr">permission</span>: <span class="title class_">Permission</span>.<span class="property">Board</span> | <span class="title class_">Permission</span>.<span class="property">Audio</span> <span class="comment">// 0011</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp; 校验权限</span></span><br><span class="line"><span class="comment">// 用户的权限和黑板权限做与运算，结果依然等于黑板权限，则说明用户拥有黑板权限</span></span><br><span class="line"><span class="keyword">if</span> ((student.<span class="property">permission</span> &amp; <span class="title class_">Permission</span>.<span class="property">Board</span>) === <span class="title class_">Permission</span>.<span class="property">Board</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拥有黑板权限&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((student.<span class="property">permission</span> &amp; <span class="title class_">Permission</span>.<span class="property">Audio</span>) === <span class="title class_">Permission</span>.<span class="property">Audio</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拥有语音权限&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((student.<span class="property">permission</span> &amp; <span class="title class_">Permission</span>.<span class="property">Video</span>) === <span class="title class_">Permission</span>.<span class="property">Video</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拥有视频权限&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ^ 切换权限</span></span><br><span class="line">student.<span class="property">permission</span> = student.<span class="property">permission</span> ^ <span class="title class_">Permission</span>.<span class="property">Audio</span> <span class="comment">// 如果没有语音权限授予语音权限，如果有则删除</span></span><br></pre></td></tr></table></figure><p>注：如果只是单纯的添加权限，可以使用按位或 <code>|</code>，单纯的删除权限，则可以先取反，再执行与操作 <code>&amp;(~feature)</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.<span class="property">permission</span> = student.<span class="property">permission</span> &amp;(~<span class="title class_">Permission</span>.<span class="property">Audio</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>画板的抗锯齿</title>
      <link href="/2021/10/01/canvas/%E7%94%BB%E6%9D%BF%E7%9A%84%E7%88%86%E7%82%B9%E5%92%8C%E6%8A%97%E9%94%AF%E9%BD%BF/"/>
      <url>/2021/10/01/canvas/%E7%94%BB%E6%9D%BF%E7%9A%84%E7%88%86%E7%82%B9%E5%92%8C%E6%8A%97%E9%94%AF%E9%BD%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h2><h3 id="折线问题"><a href="#折线问题" class="headerlink" title="折线问题"></a>折线问题</h3><p>通过 <code>lineTo</code> 实现自由画笔，本质是点与点连接的线段，无论点如何密集，都无法避免线段间的折线，快速移动下爆点率更低，线段更长，折线还会更明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">moveTo</span>(beginPoint.<span class="property">x</span>, beginPoint.<span class="property">y</span>)</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(endPoint.<span class="property">x</span>, endPoint.<span class="property">y</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><p><a href="/rep/javascript/sketchpad-lineTo.html">Demo</a></p><ul><li>使用二次贝塞尔曲线处理折线</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">moveTo</span>(beginPoint.<span class="property">x</span>, beginPoint.<span class="property">y</span>)</span><br><span class="line">ctx.<span class="title function_">quadraticCurveTo</span>(ctrlPoint.<span class="property">x</span>, ctrlPoint.<span class="property">y</span>, endPoint.<span class="property">x</span>, endPoint.<span class="property">y</span>)</span><br></pre></td></tr></table></figure><p>二次贝塞尔曲线需要三个点，起点、终点和控制点，控制点确定了曲线的方向和形状。以 <code>[A, B, C, D, E, F]</code> 六点为例，其关键点算法为，以 <code>A</code> 为起点，<code>B</code> 为控制点，<code>B</code>, <code>C</code> 的中间点 <code>B1</code> 为终点，绘制二次贝塞尔曲线线段，接下来以 <code>B1</code> 为起点，<code>C</code> 为控制点，<code>C</code>, <code>D</code> 的中间点 <code>C1</code> 为终点，依此类推，直到最后。</p><p>注：使用最后两个点的中间点作为终点，而不是最后一个点作为终点，可以使得曲线的转折更加平滑，更自然地过渡，而不会出现突然的转折。除了首尾点外，整个线条串过的均为中间点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> points = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleDrawing</span>(<span class="params">ev</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> curPoint = <span class="title function_">getPosition</span>(ev)</span><br><span class="line">  points.<span class="title function_">push</span>(curPoint)</span><br><span class="line">  <span class="keyword">if</span> (points.<span class="property">length</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lastTwoPoints = points.<span class="title function_">slice</span>(-<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 控制点</span></span><br><span class="line">    <span class="keyword">const</span> ctrlPoint = lastTwoPoints[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 终点</span></span><br><span class="line">    <span class="keyword">const</span> endPoint = &#123;</span><br><span class="line">      <span class="attr">x</span>: (lastTwoPoints[<span class="number">0</span>].<span class="property">x</span> + lastTwoPoints[<span class="number">1</span>].<span class="property">x</span>) / <span class="number">2</span>,</span><br><span class="line">      <span class="attr">y</span>: (lastTwoPoints[<span class="number">0</span>].<span class="property">y</span> + lastTwoPoints[<span class="number">1</span>].<span class="property">y</span>) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">drawLine</span>(ctrlPoint, beginPoint, endPoint)</span><br><span class="line">    <span class="comment">// 重置起点</span></span><br><span class="line">    beginPoint = endPoint</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="/rep/javascript/sketchpad-quadraticCurveTo.html">Demo</a></p><h3 id="高分屏显示虚化"><a href="#高分屏显示虚化" class="headerlink" title="高分屏显示虚化"></a>高分屏显示虚化</h3><p>在 Retina 屏中，一个逻辑像素对应多个物理像素，如果逻辑像素不足，必然会导致显示虚化。在 Canvas 中，可以先按物理像素放大，再按逻辑像素缩小解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span></span><br><span class="line"><span class="keyword">const</span> retinaWidth = canvas.<span class="property">width</span> * dpr</span><br><span class="line"><span class="keyword">const</span> retinaHeight = canvas.<span class="property">height</span> * dpr</span><br><span class="line">canvas.<span class="property">width</span> = retinaWidth</span><br><span class="line">canvas.<span class="property">height</span> = retinaHeight</span><br><span class="line">canvas.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;retinaWidth / dpr&#125;</span>px`</span></span><br><span class="line">canvas.<span class="property">style</span>.<span class="property">height</span> = <span class="string">`<span class="subst">$&#123;retinaHeight / dpr&#125;</span>px`</span></span><br><span class="line">ctx.<span class="title function_">scale</span>(dpr, dpr)</span><br></pre></td></tr></table></figure><p><a href="/rep/javascript/sketchpad-retina.html">Demo</a></p>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数参数的求值策略</title>
      <link href="/2020/08/01/pl/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
      <url>/2020/08/01/pl/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>函数参数的<a href="https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085">求值策略 Evaluation Strategy</a> 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。</p><span id="more"></span><p>按值传递（pass by value）是指在调用函数时将实参复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实参。</p><p>引用传递（pass by reference）是指在调用函数时将实参的地址直接传递到函数中，在函数中对参数所进行的修改，将影响到实参。</p><p>按值传递传递的是原始值的复制，或内存地址值的复制（比如 JS 中的共享传递，C&#x2F;C++ 中的指针传递）。按引用传递传递的是内存地址（不是内存地址值）。</p><h2 id="JavaScript-中参数的求值策略"><a href="#JavaScript-中参数的求值策略" class="headerlink" title="JavaScript 中参数的求值策略"></a>JavaScript 中参数的求值策略</h2><p>Javascript 中函数参数求值策略是按值传递。无论是值类型还是引用类型，都会在栈上创建副本（拷贝、复制），不同是，对于值类型而言，这个副本就是整个原始值的复制，对于引用类型，由于引用类型的实例在堆中，在栈上只有它的一个地址引用值，其副本也只是这个引用值的复制，而不是整个原始对象的复制，这种策略也被称为按共享传递（传递的是地址值，可通过引用来修改原始对象的属性，重新赋值则会断开对原始对象的引用，不影响原始对象），类似于 C 中的指针传递。按共享传递是按值传递的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params">num, obj</span>) &#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  obj.<span class="property">value</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 只是引用类型的副作用，不能证明是引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = new Object(); // 断开了对 greeting 的引用</span></span><br><span class="line">  <span class="comment">// obj.value = &#x27;world&#x27;; // 如果是引用传递，改变形参 obj 的属性 value，也会反映在 greeting 变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">change</span>(a, greeting);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面例子的内存模型图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">a 10               |</span><br><span class="line">greeting 0x01 ---&gt; |  0x01 hello world</span><br><span class="line">num 10             |  </span><br><span class="line">obj 0x01      ---&gt; |</span><br></pre></td></tr></table></figure><p>如果是按引用传递，直接传递第二格的内容即可，不需要有第四格。</p><h2 id="其他语言中参数的求值策略"><a href="#其他语言中参数的求值策略" class="headerlink" title="其他语言中参数的求值策略"></a>其他语言中参数的求值策略</h2><p>Java 中参数求值策略与 JavaScript 一样，都是按值传递（含共享传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByValue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">    <span class="type">TestByValue</span> <span class="variable">testByValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestByValue</span>();</span><br><span class="line">    testByValue.change(a, greeting);</span><br><span class="line">    System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(greeting.value); <span class="comment">// hello</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> num, Greeting greeting)</span> &#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    greeting.value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// greeting = new Greeting(); // 断开了对 greeting 的引用</span></span><br><span class="line">    <span class="comment">// greeting.value = &quot;world&quot;;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">javac TestByValue.java </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">java TestByValue     </span><br></pre></td></tr></table></figure><p>PHP 既支持值传递又支持引用传递，通过 &amp; 运算符（取址运算符）实现引用传递。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">&amp;<span class="variable">$num</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$num</span> = <span class="variable">$num</span> + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出１</span></span><br><span class="line"><span class="title function_ invoke__">change</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure><p>C&#x2F;C++ 支持值传递（含指针传递）， 另外 C++ 还支持引用传递，通过 &amp; 取址运算符实现引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> &amp;num2, <span class="type">int</span> *num3)</span> </span>&#123;</span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  num2 = <span class="number">22</span>;</span><br><span class="line">  *num3 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num4 = 2;</span></span><br><span class="line">  <span class="comment">// num3 = &amp;num4; // 对指针变量赋值，会断开原先的引用，不会影响外面</span></span><br><span class="line">  <span class="comment">// printf(&quot;%p\n&quot;, num3); // 外面的 c 还是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">change</span>(a, b, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1，值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22，引用传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33 或 3，指针传递</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码需使用 <code>gcc test.cpp -lstdc++ -o test</code> 作为 C++ 编译，不能使用 <code>gcc -o test test.c</code> 作为 C 编译，C 没有按引用传递，都是按值传递，通过指针传递也可实现引用传递的效果，要想通过 C 编译，需删除引用传递。</p><p>其内存图如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 1</span><br><span class="line">b/num2 2 </span><br><span class="line">c [0x7ff7b2c49920] 3</span><br><span class="line">num1 1</span><br><span class="line">num3 [0x7ff7b2c498f8] 0x7ff7b2c49920</span><br></pre></td></tr></table></figure><p>num1 的内容是复制于 a 的原值，num2 是 b 的别名，num3 的内容是 c 的地址值，*num3 指向 c 的内容。</p><p>指针传递本质上也是值传递的方式，它所传递的是一个地址值，与 JavaScript 中的共享传递一样。C&#x2F;C++ 中通过 * 指针运算符实现指针传递。</p><p>作为指针类型数据本身，其既可使用指针传递又可使用引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *&amp;p)</span> </span>&#123; <span class="comment">// int *&amp;p 表示 p 是一个整型指针的别名，int *p 则会重新分配内存，创建新指针</span></span><br><span class="line">std::cout&lt;&lt;&amp;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line">  std::cout&lt;&lt;&amp;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">change</span>(b);</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算子的求值策略"><a href="#算子的求值策略" class="headerlink" title="算子的求值策略"></a>算子的求值策略</h3><p>求值策略不但规定了函数参数的求值规则，也规定了算子的求值规则，比如赋值表达式中的 <code>=</code> 运算符。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = a; <span class="comment">// 值传递</span></span><br><span class="line">  <span class="type">int</span> *num2; <span class="comment">// 值传递中的指针传递</span></span><br><span class="line">  num2 = &amp;b;</span><br><span class="line">  <span class="type">int</span> &amp;num3 = c; <span class="comment">// 引用传递</span></span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  *num2 = <span class="number">22</span>;</span><br><span class="line">  num3 = <span class="number">33</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> num = a;</span><br><span class="line"><span class="keyword">const</span> obj = b; <span class="comment">// 值传递中的共享传递</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS 和 CSRF</title>
      <link href="/2020/04/25/network/XSS-CSRF/"/>
      <url>/2020/04/25/network/XSS-CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS (Cross-site scripting) 跨站脚本攻击，首字母缩写本应为 CSS，但因为 CSS 在网页设计领域已经被广泛指层叠样式表（Cascading Style Sheets），所以将意为“交叉”的 Cross 改以交叉形的 X 做为缩写。</p><span id="more"></span><p>XSS 是指攻击者利用网站没有对用户提交数据进行转义或过滤的缺点，在网站上注入恶意脚本，受害者在使用网站时恶意脚本被执行的攻击。注入脚本有 JavaScript、CSS、HTML，注入方法有很多，比如：表单提交、URL 参数、图片上传、外链等。XSS 的危害有盗取帐号、转账…。可搭建 <a href="https://github.com/zhuifengshaonianhanlu/pikachu">pikachu 靶场</a>实验。</p><p>从利用的角度上，XSS 可以分为 3 类：存储型、反射型、DOM 型，另外，如果自己注入的 XSS 脚本，仅能 XSS 到自己，则称为 Self XSS。不管哪种类型的 XSS，XSS 的本质就是让受害者浏览器执行攻击者插入的脚本，本质没有区别。</p><ul><li>存储型</li></ul><p>存储型 XSS 是指注入的脚本被存储在服务器中持久化的 XSS。在 IM、留言、文章、个人信息…这些场景中最常出现，是危害最大的 XSS。</p><p>以 IM 为例，如果服务端在往数据库存入用户聊天数据时没做 XSS 处理，而正好 CSR 或者 SSR 渲染时又直接输出，这时则会出现漏洞。攻击者在聊天框中输入以下 Payload，所有在聊天室的人都将被攻击。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=# onerror=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>反射型</li></ul><p>反射型 XSS 是指将用户的输入反射给浏览器的一种 XSS。非持久化，与 DOM 型不同的是用户的输入在服务端渲染（字符串），常出现在搜索栏中，攻击者构造好含恶意代码参数的 URL后，欺骗受害者去访问。</p><p>以如下<a href="http://b-ref-xss-1s.lab.aqlab.cn/">搜索栏</a> SSR 代码为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span> <span class="attr">value</span>=<span class="string">&#x27;&lt;%- $keyword %&gt;&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&lt;%- $keyword %&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>攻击者构造 Payload 为 <code>&#39; oninput=alert(&#39;xss&#39;)//</code> 的 URL <code>meiyike.cn?keyword=%27%20oninput=alert(%27xss%27)//</code>，在浏览器上反射为以下形式，然后诱导受害者点击触发。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span> <span class="attr">value</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">oninput</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)//&#x27;&gt;</span></span><br></pre></td></tr></table></figure><ul><li>DOM 型</li></ul><p>DOM 型是通过对 DOM 树的修改而实现的 XSS，其本质上也属于反射型，只不过用户的输入在前端渲染（<code>innerHTML</code>、<code>appendChild</code>、<code>document.write</code>…），属于前端自身浏览器解析机制的漏洞，没有服务端的参与（存储型与反射型都需要服务器响应参与）。</p><p>注：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">HTML5 规范中</a>指定不执行由 <code>innerHTML</code> 插入的 <code>&lt;script&gt;</code>。</p><h3 id="Payload-和绕过方式"><a href="#Payload-和绕过方式" class="headerlink" title="Payload 和绕过方式"></a>Payload 和绕过方式</h3><ul><li>Payload</li></ul><p>用以完成各种具体功能的 XSS 脚本，被称为 XSSPayload，常用 XSSPayload 有以下类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// img</span><br><span class="line">&lt;img src=# onerror=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><br><span class="line"></span><br><span class="line">// details</span><br><span class="line">&lt;details open ontoggle=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// 表单</span><br><span class="line">&lt;select autofocus onfocus=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line">&lt;textarea autofocus onfocus=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line">&lt;input autofocus onfocus=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// iframe</span><br><span class="line">&lt;iframe onload=alert(&#x27;xss&#x27;);&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">// 音视频</span><br><span class="line">&lt;video&gt;&lt;source onerror=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line">&lt;audio src=#  onerror=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// svg</span><br><span class="line">&lt;svg onload=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">// script</span><br><span class="line">&lt;script&gt;alert(&#x27;xss&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可根据具体的输出点（value 属性中、html 标签中、script 标签中）来构造 Payload，比如在 value 属性中，可提前闭合属性和标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;[输出]&quot; type=text&gt;</span><br><span class="line">&quot;&gt;&lt;img src=x onerror=alert(1)&gt;</span><br><span class="line">&#x27; oninput=alert(&#x27;xss&#x27;)//</span><br></pre></td></tr></table></figure><ul><li>绕过方式</li></ul><p>大多数 XSS 检查器或 WAF 都是利用黑名单或者白名单的形式对 XSS 攻击进行拦截，常见的绕过方式有以下几种。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">编码绕过</span><br><span class="line">Unicode 编码绕过</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&amp;#59;&quot;&gt;</span><br><span class="line">URL 编码绕过</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(unescape(&#x27;%61%6c%65%72%74%28%22%78%73%73%22%29%3b&#x27;))&quot;&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">Ascii 编码绕过</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(String.fromCharCode(97,108,101,114,116,40,34,120,115,115,34,41,59))&quot;&gt;</span><br><span class="line">Hex 绕过</span><br><span class="line">&lt;img src=x onerror=eval(&#x27;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&#x27;)&gt;</span><br><span class="line">Base64 绕过</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot;&gt;</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;eval(atob(&#x27;ZG9jdW1lbnQubG9jYXRpb249J2h0dHA6Ly93d3cuYmFpZHUuY29tJw==&#x27;))&quot;&gt;</span><br><span class="line"></span><br><span class="line">绕过空格过滤</span><br><span class="line">&lt;img/src=&quot;&quot;/onerror=alert(&#x27;xss&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">绕过引号过滤</span><br><span class="line">&lt;img src=&quot;&quot; onerror=alert(`xss`)&gt;</span><br><span class="line"></span><br><span class="line">绕过括号过滤</span><br><span class="line">&lt;img src=x onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;</span><br><span class="line"></span><br><span class="line">绕过关键字过滤</span><br><span class="line">&lt;ImG sRc=x onerRor=alert(&#x27;xss&#x27;)&gt;</span><br></pre></td></tr></table></figure><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><p>XSS 需要客户端和服务端来共同防范（DOM 型完全由客户端防范），常用的手段有，转义和过滤、CSP、HttpOnly。</p><ul><li>转义和过滤</li></ul><p>不要信任用户提交的数据，对用户的输入进行转义（escape）和过滤。各种类型的输出点转义和过滤规则不一样，输出在 HTML 标签之间和属性中（比如 value）时，要考虑 HTML 构造中的尖括号、双引号、”&amp;” 等关键字符，对输出进行 HTML Entity 编码转义，过滤移除用户输入中的 <code>style</code>、<code>script</code>、<code>iframe</code> 节点等，移除 <code>onerror</code> 等 DOM 属性，输出在 script 标签之间，则要考虑分号、注释、引号等关键字符。</p><p>现在前端框架（React、Vue）都具有内置的 XSS 预防功能，标签会被转义输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="string">&#x27;&lt;img src=# onerror=&quot;alert(\&#x27;xss\&#x27;)&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;xss&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;img src=# onerror=&quot;alert(&#x27;xss&#x27;)&quot;&amp;gt;</span><br></pre></td></tr></table></figure><p>对一定会渲染 HTML 的位置（富文本）需要使用 XSS 检查器过滤，比如 <a href="https://github.com/apostrophecms/sanitize-html">sanitize-html</a>、<a href="https://github.com/leizongmin/js-xss">js-xss</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sanitize <span class="keyword">from</span> <span class="string">&#x27;sanitize-html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xss = <span class="string">&#x27;&lt;img src=# onerror=&quot;alert(\&#x27;xss\&#x27;)&quot;&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">__html:</span> <span class="attr">sanitize</span>(<span class="attr">xss</span>)</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在传统的服务端 SSR 中，原理一样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- EJS 中使用 &lt;%= 代替 &lt;%- 实现 HTML 的转义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&lt;%= $keyword %&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CSP</li></ul><p>内容安全策略 CSP (Content Security Policy) 可在服务端使用 HTTP 的 Content-Security-Policy 头部来指定策略，也可在前端通过 <code>meta</code> 标签设置。前端和服务端设置 CSP 的效果相同，但是 <code>meta</code> 无法使用 report。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;form-action &#x27;self&#x27;;&quot;&gt;</span><br></pre></td></tr></table></figure><p>上面的配置只允许加载同域下的资源。</p><ul><li>HttpOnly</li></ul><p>对于以盗取 Cookie 为目的的 XSS，设置 Cookie 的 HttpOnly 属性是一种有效的防范手段。浏览器会禁止页面中的 JavaScript 访问带有 HttpOnly 属性的 Cookie。在 Express 下设置 httpOnly：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">cookie</span>(<span class="string">&#x27;sessionId&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span>, <span class="attr">httpOnly</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>对于存储型 XSS，服务端和客户端都需要正确进行过滤输出。</p><p>防御的方法，一般认为是正确escape(转义)，就是替换尖括号、引号等特殊符号。但是这是不够的，因为这只解决了html的问题。考虑如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var name = &#x27;&lt;?= $name ?&gt;&#x27;;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF (XSRF) 跨站请求伪造， 是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。例如，用户登录网站 A，保留了会话 Cookie，然后用户被某些信息诱导访问危险网站 B，B 上提前构造好参数的 <code>img</code> 标签对 A 的服务端发起跨域 GET 请求，并且携带了 A 的 Cookie ，身份被冒用，请求被执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/index.php?action=delete&amp;id=123&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>造成 CSFR 的根本原因是跨域访问时的第三方 Cookie 携带。</p><p>XHR、font… 这些 HTTP 请求默认都是同源策略的，但是 <code>img</code>、<code>link</code>、<code>script</code>、<code>iframe</code> 的 GET 请求允许 cross-origin，另外，CORS 也可用来打破同源策略，一旦设置不当，范围过宽，都会造成 CSRF 漏洞。</p><h3 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h3><ul><li>验证码</li></ul><p>添加验证码来识别是不是用户主动去发起请求，简单可靠，低成本，但对用户交互不友好。</p><ul><li>HTTP Referer</li></ul><p>HTTP 请求头 Referer 字段，记录了请求的来源地址，服务器验证这个来源地址是否合法即可。</p><ul><li>Samesite Cookie</li></ul><p>Cookie 的 Samesite 属性，用来声明 Cookie 是否仅限于第一方或者同一站点上下文。可用来防止 CSRF 攻击和用户追踪。Samesite 有三个属性值，分别是 <code>strict</code>、<code>lax</code> 和 <code>none</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">cookie</span>(<span class="string">&#x27;sessionId&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">samesite</span>: <span class="string">&#x27;lax&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p><code>strict</code> 严格模式，表明 Cookie 在任何情况都不可能作为第三方的 Cookie。此时，在 B 站点下发起对 A 站点的任何请求，A 站点的 Cookie 都不会包含在 Cookie 请求头中。</p><p><code>lax</code> 宽松模式，允许安全 HTTP 方法（<code>Get</code>、<code>OPTIONS</code> 、<code>HEAD</code>）携带 Cookie，但是不安全 HTTP 方法（<code>POST</code>、<code>PUT</code>、<code>DELETE</code>）不能携带。<code>Lax</code> 是 Chrome 80 起的默认设置。</p><p><code>none</code> 没有限制，必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送）。</p><ul><li>Tooken + 自定义 Header</li></ul><p>CSRF 依赖于 Cookie，如果不通过 Cookie 保持会话，则无法利用 CSRF 相关的攻击向量。可将会话保留在浏览器本地存储中，然后通过自定义 HTTP Header（比如 authorization）携带。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH</title>
      <link href="/2020/04/22/linux/SSH/"/>
      <url>/2020/04/22/linux/SSH/</url>
      
        <content type="html"><![CDATA[<p>SSH 是一种网络协议，用于计算机之间的加密登录。传统的网络服务程序，如：FTP、PoP 和 Telnet 在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，非常容易就可以截获这些口令和数据。</p><p>除了可以代替 Telnet 做远程登录外（Telnet 因为采用明文传送报文，安全性不好，很多 Linux 服务器都不开放 Telnet 服务，要想使用 Telnet 需要安装），SSH 还可以为 FTP、PoP、甚至为 PPP 提供一个安全的”通道”（比如 SFTP）。</p><span id="more"></span><p>SSH 存在多种实现，既有商业实现，也有开源实现，其中 OpenSSH 是 Linux 下的开源实现，应用非常广泛。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>SSH 已经成为 Linux 系统的标准配置，一般 Linux 系统都会自带 SSH（含 SSH Client 和 SSH Server）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证 SSH Client</span></span><br><span class="line">ssh -V <span class="comment"># OpenSSH_8.2p1 Ubuntu-4ubuntu0.5, OpenSSL 1.1.1f  31 Mar 2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 SSH Server</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 SSH（如果返回结果有 sshd，则说明已经安装好 SSH，否则可以使用下面命令在线安装）</span></span><br><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure><p>注：Windows Git 自带 mingw，mingw 里面有 SSH Client 但是没有 Server，另外，Windows 10 中已默认安装 OpenSSH Client，通过<code>设置 --&gt; 应用 --&gt; 管理可选应用 --&gt; 添加功能</code>，还可以安装 OpenSSH Server。安装目录在 <code>C:\Windows\System32\OpenSSH</code>，里面的程序有有：scp.exe、sftp.exe、ssh.exe…。</p><p>另外，Windows 下是通过 net start 和 net stop 来开启和停止某个服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启和停止 SSH Server</span></span><br><span class="line">net start sshd</span><br><span class="line">net stop sshd</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对于普通用户，默认配置即可，一般都无需再配置。如果需要配置，<code>/etc/ssh</code> 目录下，ssh_config 是客户端配置文件，sshd_config 是服务端配置文件。修改 sshd_config 文件，这个文件下可以改 SSH 登录端口和禁止 root 登录。改端口可以防止被端口扫描。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment">#Port 22                                      # SSH 默认端口</span></span><br><span class="line"><span class="comment">#PermitRootLogin yes                          # 是否允许 root 认证登录</span></span><br><span class="line">PermitEmptyPasswords no                       <span class="comment"># 是否允许空密码登录</span></span><br><span class="line"><span class="comment">#PasswordAuthentication yes                   # 是允许密码认证</span></span><br><span class="line"><span class="comment">#AuthorizedKeysFile     .ssh/authorized_keys  # 默认公钥存放的位置</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>修改完成后，重启 sshd 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录 SSH Server（更详细的可以用 ssh -h 查看）</span></span><br><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不指定用户（默认使用 root 账户登录）</span></span><br><span class="line">ssh 192.168.0.11 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定用户</span></span><br><span class="line">ssh -l root 192.168.0.11</span><br><span class="line">ssh root@192.168.0.11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 SSH 端口（SSH 默认端口是 22）</span></span><br><span class="line">ssh -p 12333 192.168.0.11</span><br><span class="line">ssh -l root -p 12333 192.168.0.11</span><br><span class="line">ssh -p 12333 root@192.168.0.11</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成密钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;any comment can be here&quot;</span>    <span class="comment"># -t 指定密钥的类型（rsa、dsa...），-C 指定识别这个密钥的注释（可选）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地的公钥追加至远程主机的 authorized_keys 文件内</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.10.141</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证公钥登录是否设置成功</span></span><br><span class="line">ssh -T root@192.168.10.141</span><br></pre></td></tr></table></figure><p>生成密钥时，会提示设置私钥的密码 Enter passphrase (empty for no passphrase)，直接回车则为不设密码，如果设置了私钥密码，每次使用 SSH 进行操作都需要输入私钥密码。虽然这样增加了安全性，但是使用 SSH 的目的很多时候就是想更加方便，跳过输入账号密码这一步。只要保存好自己的私钥不泄露，一般不设私钥密码是没有太大的风险的。如果已经生成带密码的私钥，又想取消密码可执行以下操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改私钥密码</span></span><br><span class="line">ssh-keygen -f id_rsa -p  <span class="comment"># 要在 ~/.ssh 目录下执行</span></span><br></pre></td></tr></table></figure><p>注：作为 SSH 客户端，<code>~/.ssh</code> 目录下，会有 3 个文件 id_rsa、id_rsa.pub、known_hosts，作为 SSH 服务端，也会有三个文件 id_rsa、id_rsa.pub、authorized_keys。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id_rsa              # 保存的是私钥</span><br><span class="line">id_rsa.pub          # 保存的是公钥</span><br><span class="line">known_hosts         # 保存的是 SSH 服务端公钥指纹</span><br><span class="line">authorized_keys     # 保存的是 SSH 客户端公钥</span><br></pre></td></tr></table></figure><h2 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本格式</span></span><br><span class="line">ssh username@host</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以远程 192.168.10.141 这台机器为例</span></span><br><span class="line">ssh root@192.168.10.141</span><br></pre></td></tr></table></figure><p>输入密码后回车，登录成功。在使用完毕后，通过 exit 命令退出 ssh 登录</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>SSH 之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）远程主机收到用户的登录请求，把自己的公钥发给用户；</span><br><span class="line">2）用户使用这个公钥，将登录密码加密后，发送回来；</span><br><span class="line">3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录；</span><br></pre></td></tr></table></figure><p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 Wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><p>为了解决这个问题，SSH 在首次登录时会让用户确认是否相信远程主机的，确信过的远程主机会被保存在 known_hosts 这个文件中。</p><ul><li>known_hosts</li></ul><p>第一次登录远程主机时，会出现下面这样的提示（意思是，无法确认 192.168.10.14 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;192.168.10.14 (192.168.10.14)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:4SsJ0OdMFdSGTaCJDYph5J3LtQF2fFC3MTZ1bwr8G7g.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? </span><br></pre></td></tr></table></figure><p>注：所谓”公钥指纹”，是指公钥的 SHA256 或 MD5 计算结果。因为公钥长度较长（这里采用 RSA 算法，长达 1024 位），很难比对，所以对其进行 SHA256 或 MD5 计算，将它变成一个 128 位的指纹，再进行比较，就容易多了。</p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。经过风险衡量以后，用户决定接受这个远程主机的公钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)? </span><br></pre></td></tr></table></figure><p>系统会出现一句提示，表示 host 主机已经得到认可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;192.168.10.141&#x27; (ECDSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>当远程主机的公钥被接受以后，它就会被保存在文件 <code>$HOME/.ssh/known_hosts</code> 之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个 SSH 用户都有自己的 known_hosts 文件，此外系统也有一个这样的文件，通常是 <code>/etc/ssh/ssh_known_hosts</code>，保存一些对所有用户都可信赖的远程主机的公钥。</p><h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><p>使用密码登录，每次都必须输入密码，非常麻烦。好在 SSH 还提供了公钥登录，可以省去输入密码的步骤。</p><p>所谓”公钥登录”，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。</p><p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 ssh-keygen 生成一个。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul><li>本机生成密钥文件</li></ul><p>本地系统执行以下命令，一路回车，生成密钥文件（以 DSA 算法生成公钥和私钥），其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>注：完成后，控制台里面有密钥生成的位置信息，生成密钥文件里面，$HOME&#x2F;.ssh&#x2F; 目录下，会生成两个文件，id_rsa 为私钥文件，id_rsa.pub 为公钥文件。</p><ul><li>将公钥文件传输到远程机器</li></ul><p>本地机器执行以下命令，将公钥文件传输的远程机器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：在本机上执行 ssh-copy-id 命令，ssh-copy-id 是一个快捷命令，用于将本地的公钥追加至远程主机的 ~/.ssh/authorized_keys 文件内</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.10.141</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：也可以通过其他手段来完成，比如 cat、scp、touch 组合命令，比如：</span></span><br><span class="line"><span class="comment"># 步骤 1. 在本机上执行</span></span><br><span class="line">ssh root@192.168.10.141 <span class="string">&quot;mkdir .ssh&quot;</span>                       <span class="comment"># 需要输入密码</span></span><br><span class="line">scp ~/.ssh/id_rsa.pub root@192.168.60.141:.ssh/id_rsa.pub  <span class="comment"># 需要输入密码</span></span><br><span class="line"><span class="comment"># 步骤 2. 在远程主机上执行</span></span><br><span class="line"><span class="built_in">touch</span> ~/.ssh/authorized_keys                               <span class="comment"># 如果已经存在这个文件, 跳过这条</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys            <span class="comment"># 将 id_rsa.pub 的内容追加到 authorized_keys 中</span></span><br></pre></td></tr></table></figure><ul><li>登录</li></ul><p>再次使用已经做免密处理的用户登录远程机器，已经不需要密码了，免密登录处理完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.10.141</span><br></pre></td></tr></table></figure><h3 id="authorized-keys"><a href="#authorized-keys" class="headerlink" title="authorized_keys"></a>authorized_keys</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的 $HOME&#x2F;.ssh&#x2F;authorized_keys 文件中。公钥就是一段字符串，只要把它追加在 authorized_keys 文件的末尾就行了。</p><p>这里不使用上面的 ssh-copy-id 命令，改用下面的命令，解释公钥的保存过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host <span class="string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh user@host                                      <span class="comment"># 表示登录远程主机</span></span><br><span class="line"><span class="string">&#x27;mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span>        <span class="comment"># 表示登录后在远程 shell 上执行的命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -p .ssh                                      <span class="comment"># 这个命令的作用是，如果用户主目录中的 .ssh 目录不存在，就创建一个</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; .ssh/authorized_keys<span class="string">&#x27; &lt; ~/.ssh/id_rsa.pub   # 这个命令的作用是，将本地的公钥文件 ~/.ssh/id_rsa.pub，重定向追加到远程文件 authorized_keys 的末尾</span></span><br></pre></td></tr></table></figure><p>写入 authorized_keys 文件后，公钥登录的设置就完成了。</p><h3 id="文件和目录权限"><a href="#文件和目录权限" class="headerlink" title="文件和目录权限"></a>文件和目录权限</h3><p>配置完成后，如果发现还是不能免密登录，查看日志发现，这是权限问题引起的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> /var/log/secure -n 20</span><br></pre></td></tr></table></figure><p>Authentication refused: bad ownership or modes for directory &#x2F;root，从字面上可以看出是目录的属主和权限配置不当，查找资料得知：SSH 不希望 home 目录和 ~&#x2F;.ssh 目录对组有写权限。</p><p>修改远程机器的 .ssh 目录需要 700 权限，authorized_keys 文件需要 600 权限即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 ~</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys </span><br></pre></td></tr></table></figure><p>注：关于 Linux 权限，请查看 Linux 相关章节。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针和引用</title>
      <link href="/2020/01/15/pl/Pointer-Reference/"/>
      <url>/2020/01/15/pl/Pointer-Reference/</url>
      
        <content type="html"><![CDATA[<p>指针是内存地址，指针变量是用来存放内存地址的变量，指向内存的一个存储单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> *p1;</span><br><span class="line">  <span class="type">int</span> **p2;</span><br><span class="line"></span><br><span class="line">  p1 = &amp;a; <span class="comment">// 指针 p1 指向 a</span></span><br><span class="line">  p2 = &amp;p1; <span class="comment">// 指针 p2 指向指针 p1，即 p2 的内容为 p1 的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p1); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **p2); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：定义指针时，<code>*</code> 两边的空格可以选择，<code>int* ptr</code> 与 <code>int *ptr</code> <code>int*ptr</code> 意义一样，另外，<code>int</code> 整型，<code>int*</code> 表示指向「整型」的指针，<code>int**</code> 表示指向「指向整型的指针」的指针。</p><p>指针与引用的区别：指针指向一块内存，它的内容是所指内存的地址，而引用是某块内存的别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="type">int</span> *p = &amp;a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p); <span class="comment">// 0x7ff7b2a82920</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, p, &amp;a); <span class="comment">// 0x7ff7b2a82928 0x7ff7b2a82928</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">  <span class="type">int</span> &amp;b = a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p %p\n&quot;</span>, &amp;a, &amp;b); <span class="comment">// 0x7ff7b2e77928 0x7ff7b2e77928</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于 C 不支持引用传递，上述代码需以 C++ 编译运行。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM 私仓</title>
      <link href="/2019/07/01/engineering/Sinopia/"/>
      <url>/2019/07/01/engineering/Sinopia/</url>
      
        <content type="html"><![CDATA[<p>npm 私仓可用于提高包的下载速度和保护内部代码，常见的 npm 私仓技术方案有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* npm on-site  # 缺点是收费，而且 npm 在国内访问慢</span><br><span class="line">* Git + SSH 直接引用到 GitHub 项目地址 # 缺点是不能更新（npm update），不能使用 Semver（语义化版本规范），而且 URL 不美观</span><br><span class="line">* cnpm</span><br><span class="line">* Sinopia/Verdaccio</span><br><span class="line">* Nexus</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Sinopia-x2F-Verdaccio"><a href="#Sinopia-x2F-Verdaccio" class="headerlink" title="Sinopia&#x2F;Verdaccio"></a>Sinopia&#x2F;Verdaccio</h2><p>Sinopia 是一个零配置的私有的带缓存功能的 npm 包管理工具。使用 Sinopia，不用安装 CouchDB 或 MYSQL 之类的数据库，Sinopia 有自己的迷你数据库，如果要下载的包不存在，它将自动去你配置的 npm 地址上去下载，而且硬盘中只缓存你现在过的包，以节省空间。</p><p>Sinopia 特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 不同步拉取 npm 库，占据大量硬盘，没有硬盘被撑爆的问题</span><br><span class="line">* 安装配置极其简单，不需要数据库</span><br><span class="line">* 支持配置上游 Registry 配置，一次拉取即缓存</span><br><span class="line">* 支持 Forever 及 Pm2 守护进程管理</span><br></pre></td></tr></table></figure><p>注意：由于 Sinopia 已经没人维护了，推荐使用 <a href="https://github.com/verdaccio/verdaccio">Verdaccio</a>，Verdaccio 是 Sinopia 的 Fork，安装配置基本和 Sinopia 一致。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Sinopia 前，首先要确保已经安装 Node，Linux 下安装 Node 参考具体章节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sinopia -g</span><br></pre></td></tr></table></figure><p>Sinopia 目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 程序安装目录（全局安装目录在不同配置下会不一样）</span><br><span class="line">|-- /usr/sbin/nodejs/lib/node_modules/sinopia/</span><br><span class="line"></span><br><span class="line"># 配置和存储目录</span><br><span class="line">|-- /root/.config/sinopia/</span><br><span class="line">    |-- config.yaml  # 配置文件</span><br><span class="line">    |-- htpasswd     # 用户和密码信息</span><br><span class="line">    |-- storage      # 包存储位置（除了 publish 的私包，通过 npm install xx 安装的公共包也会缓存到这个目录，安装过的包再次安装时会直接从这个目录取）</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinopia</span><br></pre></td></tr></table></figure><p>启动成功后，会有下面两行提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warn  --- config file  - /root/.config/sinopia/config.yaml</span><br><span class="line">warn  --- http address - http://0.0.0.0:4873/</span><br></pre></td></tr></table></figure><p>上面一行是 Sinopia 的配置文件所在路径，下面一行是 Sinopia 服务的域名和端口号。然后打开 <code>http://localhost:4873</code>（可通过 curl），如果能正常访问，说明安装成功。</p><ul><li>网络访问</li></ul><p>默认情况下只能本机 <code>localhost:4873</code> 访问，如果想通过 IP 让其他机器也能访问到，需要在 <code>/root/.config/sinopia/config.yaml</code> 最后一行添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure><p>好了，再试一次 <code>192.168.10.14:4873</code>，成功访问。如果还不行，可能是防火墙导致，默认情况下防火墙没有开放 4873 端口，需要开放相应的端口。CentOS 6 和 CentOS 7 不一样，以 CentOS 6 为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进入编辑防火墙配置文件（修改 OUTPUT ACCEPT 下的内容）</span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 然后加上下面这句（作用是防止防火墙占用80端口）</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 再加上下面这一句（开放 4873 端口）</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 4873 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 最后记得重启一下防火墙</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><ul><li>PM2 做守护进程</li></ul><p>Node 服务非常脆弱，一般在实际中使用都会配合守护进程。这里选用 PM2 做守护进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 PM2</span><br><span class="line">npm install -g pm2</span><br><span class="line"></span><br><span class="line"># 通过 PM2 启动 Sinopia</span><br><span class="line">pm2 start `which sinopia`</span><br></pre></td></tr></table></figure><p>注：更多 PM2 操作指南参考相关文档。另外，如果想要结束 PM2 守护的 Sinopia 进程，可使用以下方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop sinopia    # 参数也可以是具体的 PM2 id（不是 pid），比如 pm2 stop 0</span><br></pre></td></tr></table></figure><p>也可以手动结束，操作步骤如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有进程</span><br><span class="line">ps -A</span><br><span class="line"></span><br><span class="line"># 查询结果如下</span><br><span class="line">3239 ?         00:00:31 watch</span><br><span class="line">6035 ?         00:00:11 PM2 v2.10.3: Go</span><br><span class="line">27690 ?        00:00:01 sinopia</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 杀掉 watch 和 sinopia 这两个进程</span><br><span class="line">kill 3239</span><br><span class="line">kill 27690</span><br></pre></td></tr></table></figure><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the default config file. It allows all users to do anything,</span><br><span class="line"># so don&#x27;t use it on production systems.</span><br><span class="line">#</span><br><span class="line"># Look here for more config file examples:</span><br><span class="line"># https://github.com/rlidwka/sinopia/tree/master/conf</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># path to a directory with all packages</span><br><span class="line">storage: ./storage                     # npm 包存放的路径（可以将将此目录指向其他目录）</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd                   # 用于存储 npm 用户的账号和密码信息</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    #max_users: 1000                   # 最大允许的用户数量，默认值为 1000，-1 则为禁止注册</span><br><span class="line"></span><br><span class="line"># a list of other known repositories we can talk to</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/   # 上游源，默认为 npm 的官网，可以使用淘宝的 npm 镜像地址</span><br><span class="line"></span><br><span class="line">packages:                              # 配置权限管理</span><br><span class="line">  &#x27;@*/*&#x27;:</span><br><span class="line">    # scoped packages</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装。$all 所有人，$authenticated 通过验证的人，$anonymous 匿名者</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line">    proxy: npmjs                       # 默认没有这项</span><br><span class="line">    </span><br><span class="line">  &#x27;*&#x27;:</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    #</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish packages</span><br><span class="line">    # (anyone can register by default, remember?)</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span><br><span class="line">    proxy: npmjs                       # 如其名，这里的值是对应于 uplinks</span><br><span class="line"></span><br><span class="line"># log settings</span><br><span class="line">logs:</span><br><span class="line">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class="line">  #- &#123;type: file, path: sinopia.log, level: info&#125;</span><br><span class="line"></span><br><span class="line">listen: 0.0.0.0:4873                   # 默认没有这项，只能在本机访问，添加后可以通过外网访问</span><br></pre></td></tr></table></figure><p>部分配置字段意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">storage    # 仓库保存的路径</span><br><span class="line">auth       # 验证相关</span><br><span class="line">uplinks    # 配置上游的 npm 服务器，主要是用于请求的仓库不存在时去上游服务器拉取</span><br><span class="line">packages   # 配置模块/包的发布(publish)、下载(access)的权限等</span><br><span class="line">listen     # 配置监听端口与主机名</span><br></pre></td></tr></table></figure><ul><li>auth 配置</li></ul><p>max_users: -1 表示我们将最大用户数设置为－1，表示禁用 npm adduser 命令来创建用户，不过我们仍然可以通过当前目录下的 htpasswd 文件来初始化用户。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yorkie:&#123;SHA&#125;?????????????????=:autocreated 2016-02-05T15:33:46.238Z</span><br><span class="line">weflex:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T15:39:19.960Z</span><br><span class="line">james:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T17:59:05.041Z</span><br></pre></td></tr></table></figure><p>上面的加密算法也很简单，就是简单的 SHA1 哈稀之后再转换成 Base64 输出就好，后面跟着的只是表示时间。</p><ul><li>packages 配置</li></ul><p>配置大致分为两个部分，一个是以 <code>@*/*</code> 为开头的，另一个则是通配符 <code>*</code>。</p><p>这个当然就是对 package.json 中的 name 字段进行匹配，比如 @webassemblyjs&#x2F;<a href="mailto:&#97;&#115;&#x74;&#x40;&#x31;&#x2e;&#x33;&#x2e;&#49;">&#97;&#115;&#x74;&#x40;&#x31;&#x2e;&#x33;&#x2e;&#49;</a> 将匹配第一个配置，而 express 则匹配第二个。这里这么配置的意义在于：一般团队或者公司的私有项目，会采用不同的权限控制，于是这里借用了 npm 的 scoped name 即 @company 的形式，例如 @weflex&#x2F;app 即表示 WeFlex 下属的 app 项目了。</p><p>接下来，每一个命名过滤器（filter）下都有三项基本设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access    # 表示哪一类用户可以对匹配的项目进行安装(install)</span><br><span class="line">publish   # 表示哪一类用户可以对匹配的项目进行发布(publish)</span><br><span class="line">proxy     # 如其名，这里的值是对应于 uplinks 的</span><br></pre></td></tr></table></figure><p>对于 1 和 2 的值，我们通常有以下一些可选的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$all            # 表示所有人都可以执行对应的操作</span><br><span class="line">$authenticated  # 表示只有通过验证的人可以执行对应操作</span><br><span class="line">$anonymous      # 表示只有匿名者可以进行对应操作（通常无用）</span><br></pre></td></tr></table></figure><p>或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作。</p><ul><li>为 packages 中 <code>@*/*</code> 字段配置代理源</li></ul><p><code>&#39;@*/*&#39;</code> 下添加 <code>proxy: npmjs</code> 配置，给 scoped packages（<a href="https://docs.npmjs.com/misc/scope">npm 官方的定义</a>） 添加代理源，使得能够安装 scoped packages 类型的包（比如 @webassemblyjs&#x2F;<a href="mailto:&#97;&#115;&#116;&#x40;&#49;&#46;&#x33;&#x2e;&#x31;">&#97;&#115;&#116;&#x40;&#49;&#46;&#x33;&#x2e;&#x31;</a>）。如果不配置此项，安装基本的包没有问题，但是，安装 scoped packages 包时，比如  webpack，会提示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack</span><br><span class="line"></span><br><span class="line"># 出现以下错误</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found: @webassemblyjs/ast@1.3.1</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2018-05-09T06_26_23_190Z-debug.log</span><br></pre></td></tr></table></figure><p>这是在安装 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#115;&#116;&#x40;&#49;&#46;&#x33;&#46;&#x31;">&#x61;&#115;&#116;&#x40;&#49;&#46;&#x33;&#46;&#x31;</a> 这个包时出的问题，sinopia 会提示 404。上面安装的包就是这类的包，常见的有 @angular @type 等。修改配置和代码后，重启 sinopia，这时再次安装就会提示成功。</p><p>如果还不成功，可能就是老版本 sinopia 的 bug 导致的（我这版中没出息这个问题），sinopia 每次向 npmjs 请求安装某个包时，请求地址都是转码后再向 npm 请求的，所以会将 @ 转码为 %40，但是 npm 不能识别 %40，所以导致 404 的错误。</p><p>这个时候只需要修改 sinopia 中的转码的地方就可以了。转码的文件是 up-storage.js,，修改 up-storage.js 中的 encode 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var encode = function (url) &#123;</span><br><span class="line">  return encodeURIComponent(url).replace(/^%40/, &#x27;@&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><p>通过服务器来新建用户。服务器上将 registry 改为 <a href="http://localhost:4873：">http://localhost:4873：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure><p>然后添加用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line"># 填写如下信息</span><br><span class="line">user: admin</span><br><span class="line">password: admin</span><br><span class="line">email: admin@admin.com</span><br></pre></td></tr></table></figure><p>这时 htpasswd(config.yaml 同目录) 文件下会生成相应的信息。</p><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://192.168.10.14:4873        # 设置 npm 源</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://192.168.10.14:4873  # 添加用户。如果不发布 npm 包，是不需要注册和登录的，登录 npm 是为了发布包</span><br><span class="line">npm login                                         # 登录 npm。注，npm adduser 成功的后默认就登陆了，所以不需要再 npm login</span><br><span class="line">npm whoami                                        # 检测身份</span><br></pre></td></tr></table></figure><p>注：推荐用 nrm 来管理 npm 源。具体的 nrm 操作查看 node 的 npm 相关章节。</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx              # 选项有 --save (-S)、--save-dev (-D)、-g</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>切换到私有仓库，登录成功之后，就可以执行 npm publish 发布到这个私有 npm 上面啦，发布包的操作跟 npm 官方发布包无差别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login                    # 登录 npm</span><br><span class="line">npm publish                  # 发包</span><br><span class="line">npm unpublish --force test   # 撤销发布。撤销 test 这个包，如果是在当前包的根目录下操作，可以省略包名</span><br></pre></td></tr></table></figure><p>发布包注意事项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 包的名称和版本就是你项目里 package.json 里的 name 和 version，author 字段可以显示包的作者，为空则表示匿名</span><br><span class="line">* 不能和已有的包的名字重名，发布前可通过 npm 的查找是否已存在相同名称的包（npm search xxx）</span><br><span class="line">* npm 对包名的限制：不能有大写字母/空格/下滑线（testPublish、test_publish 都会又报错）</span><br></pre></td></tr></table></figure><h2 id="使用-Docker-安装-Verdaccio"><a href="#使用-Docker-安装-Verdaccio" class="headerlink" title="使用 Docker 安装 Verdaccio"></a>使用 Docker 安装 Verdaccio</h2><p>参考 Docker 安装 Verdaccio <a href="https://verdaccio.org/docs/en/docker.html">文档</a>。</p><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull verdaccio/verdaccio    # 拉取 Verdaccio 的 Docker Image，不指定版本下，拉取的是 latest</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><ul><li>新建宿主机目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上新建需要挂载到的目录（路径可自选）</span><br><span class="line">mkdir /home/kpg/verdaccio</span><br><span class="line">mkdir /home/kpg/verdaccio/conf</span><br><span class="line">mkdir /home/kpg/verdaccio/storage</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取配置文件 config.yaml</span><br><span class="line">cd /home/kpg/verdaccio/conf</span><br><span class="line">git clone https://github.com/verdaccio/docker-examples</span><br><span class="line">mv docker-examples/docker-local-storage-volume/conf/config.yaml config.yaml</span><br><span class="line">rm -rf docker-examples    # config.yaml 复制好后，删除这个目录</span><br></pre></td></tr></table></figure><p>注：如果没有将 config.yaml 配置文件放在 <code>/home/kpg/verdaccio/conf/</code> 目录下，会导致浏览器将访问不了，<code>docker run</code> 看不出错误，只有通过 <code>docker logs</code> 查找日志，才能发现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps                # 找到 verdaccio container id</span><br><span class="line">docker logs containerId  # 查找日志</span><br></pre></td></tr></table></figure><ul><li>设置宿主机目录权限</li></ul><p><code>mkdir verdaccio</code> 创建的目录属主是当前宿主机用户，而每个 docker container 都会运行在自建的用户上。所以要注意挂载目录的权限，要不然 <code>npm adduser</code> 和 <code>npm install</code> 无法写入，提示 500 服务器错误，查看容器日志会有下面这样的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs --tail 20 verdaccio</span><br><span class="line">EACCES: permission denied, open &#x27;/verdaccio/conf/htpasswd&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it verdaccio sh    # 进入容器查找容器的用户 ID（进入后 Shell 前缀变成了 ~）。直接在宿主机里面 cat /etc/passwd 查找不到</span><br><span class="line">whoami                          # 查看当前用户</span><br><span class="line">cat /etc/passwd                 # 找到当前用户的 User ID (10001) 和 Group ID (65533)。docker 容器中的 uid 和 gid 和宿主机是共享的，只是没有具体名称</span><br><span class="line">exit                            # 退出容器</span><br><span class="line">chown -R 10001:65533 verdaccio  # 在宿主机下设置目录权限。-R 表示递归设置</span><br></pre></td></tr></table></figure><ul><li>挂载宿主机目录</li></ul><p>可以在启动时通过 <code>-v</code> 将宿主机目录挂载到容器内目录，也可以通过 docker-compose.yml 来配置 volumes。</p><ul><li>配置 config.yaml</li></ul><p>基本配置参考上面，storage、htpasswd 要指向容器内目录，uplinks 可以使用淘宝 npm 私仓：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">storage: /verdaccio/storage</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: /verdaccio/conf/htpasswd</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>如果将启动参数放在命令中，做成脚本文件来启动会更加方便（如果用 docker-compose 启动，将参数放在 docker-compose.yml 中也很方便）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name verdaccio \</span><br><span class="line">--restart always \</span><br><span class="line">-p 4873:4873 \</span><br><span class="line">-v /home/kpg/verdaccio/conf:/verdaccio/conf \</span><br><span class="line">-v /home/kpg/verdaccio/storage:/verdaccio/storage \</span><br><span class="line">-v /home/kpg/verdaccio/plugins:/verdaccio/plugins \</span><br><span class="line">verdaccio/verdaccio</span><br></pre></td></tr></table></figure><p><code>-v</code> 用于挂载宿主机的一个目录，<code>:</code> 前面的目录是宿主机目录，后面的目录是容器内目录。</p><ul><li>一个错误</li></ul><p><code>npm publish</code> 时出现了一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">npm ERR! code E503</span><br><span class="line">npm ERR! 503 Service Unavailable - PUT http://npm.kpg123.com/sdf - one of the uplinks is down, refuse to publish</span><br></pre></td></tr></table></figure><p>查看 <a href="https://github.com/verdaccio/verdaccio/issues/78">Issues</a> 和<a href="https://verdaccio.org/docs/en/configuration.html#offline-publish">配置文档</a>发现，By default verdaccio does not allow to publish when the client is offline, that behavior can be overridden by setting this to true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish:</span><br><span class="line">  allow_offline: true</span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>如果 nginx 直接安装在宿主机，直接 <code>/etc/nginx/conf.d</code> 下新建 nginx.conf 文件，填入以下内容即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream npm &#123;</span><br><span class="line">    server 127.0.0.1:4873;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name npm.kpg123.com;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://npm;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端 host，然后就可以通过域名访问了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.101 npm.kpg123.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Pages</title>
      <link href="/2019/06/20/engineering/Git-Pages/"/>
      <url>/2019/06/20/engineering/Git-Pages/</url>
      
        <content type="html"><![CDATA[<p>GitHub Pages 用于介绍用户个人和托管在 GitHub 中的项目的，免费，虽然<a href="https://help.github.com/en/articles/what-is-github-pages#usage-limits">空间和流量有限制</a>（空间上限 1G、月流量上限 100G、每小时更新不超过 10 次），但绝对够用。</p><span id="more"></span><h2 id="新建-GitHub-Pages"><a href="#新建-GitHub-Pages" class="headerlink" title="新建 GitHub Pages"></a>新建 GitHub Pages</h2><p><a href="https://pages.github.com/">GitHub Pages</a> 分两类：User or Organization site (个人或组织 site) 和 Project site (项目 site)。</p><ul><li>个人或组织 site</li></ul><p>仓库名必须为 <code>username.github.io</code>（username 为用户在 github 上的用户名，比如 <code>tracy-xu.github.io</code>），分支为 master，其分支的内容将会被构建和发布在你的 GitHub Pages site 上，这样的 pages 一般一个账号只能有一个，通过 <code>username.github.io</code> 访问。</p><ul><li>项目 site</li></ul><p>一个项目可拥有一个 site，使用 gh-pages 分支，也可以在 Settings –&gt; GitHub Pages 下设置，通过 <code>username.github.io/project-name</code> 访问。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>为 GitHub Pages 绑定域名需要两步：第一步生成 CNAME 文件，第二步域名解析。</p><h3 id="生成-CNAME-文件"><a href="#生成-CNAME-文件" class="headerlink" title="生成 CNAME 文件"></a>生成 CNAME 文件</h3><p>GitHub Pages CNAME 文件记录自定义域名，其作用是，当访问自定义域名时，会通过 DNS 解析到 GitHub 的服务器 IP，GitHub 仓库千万个，GitHub 服务器会根据 HTTP Host 匹配对应 CNAME 文件所在的仓库，如果没有这个文件，GitHub 服务器不知道返回哪个仓库，会显示 404。</p><p>在 <code>tracy-xu.github.io</code> 这个 rep 中点击 Settings，然后在 Custom domain 中填入要绑定的域名 <code>tracyxu.cn</code>。这个操作会在项目的根目录生成 CNAME 文件，里面内容就是所要绑定的域名 <code>tracyxu.cn</code>。</p><p>注：为防止在像 Hexo 这样一些博客系统中被打包覆盖，可以在 Hexo 中手动创建 CNAME。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>以阿里云为例，登陆阿里云控制台进行域名解析。记录类型有两种方式可选择：A 记录（A 将域名指向一个 IPV4 地址）、CNAME（CNAME 将域名指向另外一个域名）记录。</p><ul><li>A 记录</li></ul><p>A 记录需要找到 git pages 的 IP（ping tracy-xu.github.io 结果是 185.199.110.153），然后再进行后续设置。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>A</td><td>www</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：主机记录 www 和 @ 都要添加，这是为了 <code>www.tracyxu.cn</code> 和 <code>tracyxu.cn</code> 都能访问到页面。</p><ul><li>CNAME 记录</li></ul><p>CNAME 记录不需要通过 IP 来绑定，记录值直接填写 <code>tracy-xu.github.io</code> 即可。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CMAME</td><td>www</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>CMAME</td><td>@</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：域名解析设置完成后，如果还是不能访问，这是因为在等服务商分配 DNS，等待 10 来分钟就可以了，如果还不能访问，就是因为其他原因了，比如阿里云中域名没进行实名认证不能被解析（不分配 DNS 服务器）。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>GitHub Pages 开放了自定义域名 HTTPS 支持，不用再自己买证书或借用第三方服务，就能开启网址左边的小绿锁了。</p><p>设置步骤根据你的自定义域名解析类型分为两种：A、CNAME。</p><ul><li>A 记录</li></ul><p>A 记录的话只需将解析的 ip 指向如下四个即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>其余的步骤和上面域名解析一样。</p><p>注：也可以通过 CNAME 来混合设置，设置 4 个 @ 主机记录的 A 记录和 1 个 www 主机记录的 CNAME 记录。</p><ul><li>CNAME 记录</li></ul><p>只需要在 Repositorys 设置中勾选 Enforce HTTPS 的选项即可。</p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow</title>
      <link href="/2019/04/25/engineering/Git-Flow/"/>
      <url>/2019/04/25/engineering/Git-Flow/</url>
      
        <content type="html"><![CDATA[<p>Git 工作流（Work Flow）是一种分支管理策略。在开发人员较少，项目不复杂时，可以采用简单的工作流，比如只有一个 Master 分支，但当项目庞大，迭代周期长，多人协作，多需求并行时，就需要更加严格的 Work Flow 来管理开发、测试、发布和热修复了。在 Git 中常见的工作流有 Git Flow、GitHub Flow、GitLab Flow。</p><span id="more"></span><p>2010 年 5 月，Vincent Driessen 在 “<a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” 中介绍了一种构建在 Git 之上的软件开发模型。通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离。这种软件开发的活动模型被 Vincent 称为 “Git Flow”。</p><h2 id="Git-Flow-基本流程"><a href="#Git-Flow-基本流程" class="headerlink" title="Git Flow 基本流程"></a>Git Flow 基本流程</h2><p><img src="/images/engineering/git/git-flow.jpg" alt="Git Flow 流程图"></p><p>从 Git Flow 流程图可以看出，Git Flow 的核心是 Branch，通过在项目的不同阶段对 Branch 的不同操作（create、merge、rebase…）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类，Main Branchs（主分支） 和 Supporting Branches（辅助分支），其中 Main Branchs 包含了 Master 和 Develop，而 Supporting Branches 包含了 Feature、Release、Hotfix 以及其他自定义分支。Main Branchs 是长期分支，存活在项目的整个生命周期中，而 Supporting branches 分支是短期分支，短期分支合并后需要删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master -- 主分支</span><br><span class="line">* develop -- 开发分支</span><br><span class="line">* feature/* -- 功能分支</span><br><span class="line">* release/* -- 预发布分支</span><br><span class="line">* hotfix/* -- 热修复分支</span><br></pre></td></tr></table></figure><p>在实践中，需求的创建、提测、发布应由项目负责人完成，普通的开发人员只需要开发功能和改 Bug。也就是说，对于 Master、Develop 这两个公共分支，只有项目负责人有操作权限，普通开发人员只有 Feature、Release、Hotfix 三个辅助分支的操作权限，这样既保证了 Master 和 Develop 的整洁，而且普通开发人员也不需掌握 Git Flow。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>主分支用于发布，存放的是最稳定的正式版本。禁止在此分支上修改代码，只接受其他分支合并（Release、Hotfix）。另外，不管是用来发布 Release 还是 Hotfix，都需要打 Tag。</p><p>注：初始化时，可使用 <code>--allow-empty</code> 参数来 commit 一个空分支（<code>git flow init</code> 就是如此），<code>git commit --allow-empty -m &quot;initial commit&quot;</code>。</p><h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><p>开发分支用于日常开发，是 Feature 和 Release 分支的基础分支，存放最新的开发版（隔夜版 Nightly，是要发布到下一个 Release 的代码）。这个分支可能包含一定的 Bug（Release 还未合并的情况下），但不影响创建新的 Feature 进行新功能的开发（但是需要注意的是，假如 feature&#x2F;b 基于 feature&#x2F;a 的 Develop 创建，这时候的 feature&#x2F;b 不能比 feature&#x2F;a 早发布，如果想早发布只能将这个 feature&#x2F;b 当作一个 Hotfix 了）。</p><p>跟 Master 一样，Develop 的变动也只能是合并（Feature、Release），不能是直接修改。</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>功能分支用于开发新功能、代码重构、优化…，基于 Develop 创建，一般命名为 feature&#x2F;xxx。新功能开发完成，会合并回 Develop 分支进入下一个 Release。</p><p>Feature 分支命名规则是，分支类型&#x2F;分支发布时间-分支功能。比如：feature&#x2F;20170401-fairy-flower，时间使用年月日命名，不足 2 位补 0。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>预发布分支用于预发布（测试和测试阶段的 Bug 修复）。当需要发布一个新 Release 时，可以基于 Develop 分支创建一个 Release 分支，一般命名为 release&#x2F;v1.0.0（关于版本号的命名规则参考相关章节），完成 Release 后，需要合并到 Master 和 Develop。</p><p>版本就是在这个阶段确定的，所以这个分支的命名会加版本后缀。版本正式发布前可生成 Changelog 文档，然后再发布上线。</p><h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><p>热修复分支，用于修改线上 Bug（比如回归时的 Bug，或者用户反馈的 Bug）。基于 Master 创建，一般命名为 hotfix&#x2F;v1.0.0，测试通过后合并到 Master 分支和 Develop 分支。</p><h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的操作必然是频繁且重复的，这个时候可通过 <a href="https://github.com/nvie/gitflow">Git flow script 工具</a>来简单化复杂的 Git 命令。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">apt-get install git-flow</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br><span class="line"># Windows 上或者</span><br><span class="line">curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh</span><br><span class="line">bash gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow help          # 查看帮助</span><br><span class="line">git flow feature help  # 查看 feature 帮助</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line">git flow init                           # 初始化。会询问分支的命名，初始化完成后自动切换到了 develop 分支。支持 -f -d 参数</span><br><span class="line"></span><br><span class="line"># feature</span><br><span class="line">git flow feature start MYFEATURE        # 开始一个 feature。相当于 git checkout -b feature/MYFEATURE</span><br><span class="line">git flow feature publish MYFEATURE      # publish 一个 feature。相当于 git push</span><br><span class="line">git flow feature pull origin MYFEATURE  # 获取 publish 的 feature</span><br><span class="line">git flow feature finish MYFEATURE       # 完成一个 feature。该命令将 feature 分支合并入 develop 分支，并切换到 develop 删除 feature</span><br><span class="line"></span><br><span class="line"># release</span><br><span class="line">git flow release start MYRELEASE        # 开始一个 release。git flow release start v1.0.0，分支全称是 release/v1.0.0</span><br><span class="line">git flow release publish MYRELEASE      # publish 一个 release</span><br><span class="line">git flow release finish MYRELEASE       # 发布一个 release。该命令将 release 合并入 master 和 develop 并切换到 master，删除该 release，创建 tag</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">git flow hotfix start MYVERSION         # 开始一个 hotfix</span><br><span class="line">git flow hotfix finish MYVERSION        # 发布一个 hotfix</span><br></pre></td></tr></table></figure><p><code>git flow init</code> 会询问分支的命名，发布和预发布这两个分支名称采用默认的 master 和 develop 即可，而其他的分支需要填写前缀，比如 <code>feature/</code>。参数 <code>-f</code> 表示强制初始化（可用于重置 git flow 初始化配置），参数 <code>-d</code> 表示使用默认配置初始化。Git Flow 仓库配置是本地配置，换电脑后需要再次初始化配置，为保证各配置相同，最好是使用 <code>git flow init -d</code> 初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br><span class="line"></span><br><span class="line">Initialized empty Git repository in /Users/tracy-xu/Desktop/test/.git/</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? [] version/</span><br></pre></td></tr></table></figure><p>注：Release 和 Hotfix 命令使用和 Feature 一样，只是有些细微区别，比如 <code>git flow release finish</code> 命令将会将 Release 分支合并入 Master 和 Develop 两个分支，且会打上版本号（tag 需要有 message，要不然会创建失败）。</p><p><img src="/images/engineering/git/git-flow-commands.png" alt="git-flow-commands"></p><p>附：<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">Git-Flow 备忘清单</a></p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit Message Style Guide</title>
      <link href="/2019/04/20/engineering/Git-Commit-Message-Style-Guide/"/>
      <url>/2019/04/20/engineering/Git-Commit-Message-Style-Guide/</url>
      
        <content type="html"><![CDATA[<p>在 Git 中，我们使用 <code>git commit -m &quot;xxx&quot;</code> 来提交代码，参数 <code>-m</code> 用来指定 Commit Message（提交说明），直接执行 <code>git commit</code> 会进入编辑器模式，可提交多行说明。Commit Message 应规范化，规范化的 Commit Message 能带来很多好处：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 提交说明明确，方便快速浏览和查找，比如 git log --pretty=format:%s, git log HEAD --grep feature</span><br><span class="line">* 可以直接从 Commit Message 生成 Change Log</span><br></pre></td></tr></table></figure><p>目前，社区中有很多 Commit Message 规范，本文介绍 Conventional Commits 规范，因其合理、系统，且有配套工具，在社区中得到来广泛的应用。</p><h2 id="Conventional-Commits-提交规范"><a href="#Conventional-Commits-提交规范" class="headerlink" title="Conventional Commits 提交规范"></a>Conventional Commits 提交规范</h2><p><a href="https://www.conventionalcommits.org/">Conventional Commits</a> 中将 Commit message 分为三个部分：Header，Body 和 Footer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可选。<code>&lt;BLANK LINE&gt;</code> 指空行，各个部分必须由空行分割。为了避免自动换行影响美观，不管是哪一个部分，任何一行都不得超过 72 个字符（或 100 个字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs(changelog): update changelog to beta.5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fix(ivy): prevent templateOverrides from causing infinite loop (#29402)</span><br><span class="line"></span><br><span class="line">Previously, the transitive scope calculation could lead into re-compiling</span><br><span class="line">the same module multiple times. This fix ensures we cannot get into this loop.</span><br><span class="line">It should be fixed more completely (e.g. more cases) once FW-1178 is resolved.</span><br><span class="line"></span><br><span class="line">PR Close #29402</span><br></pre></td></tr></table></figure><p>注：<a href="https://github.com/angular/angular/blob/main/CONTRIBUTING.md#commit">Angular commit message guidelines</a> 采用同样的提交规范。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需）。</p><ul><li>type</li></ul><p>type 用于说明 Commit 的类别，只允许使用下面 9 个标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* feat       # 新功能（Feature）</span><br><span class="line">* fix        # 修复 Bug</span><br><span class="line">* perf      # 性能（提高性能的代码更改，比如，提升性能、体验）</span><br><span class="line">* refactor   # 重构（即不是新增功能，也不是修改 bug 的代码变动）</span><br><span class="line">* style      # 格式（不影响代码运行的变动，比如：空白、换行、分号等）</span><br><span class="line">* build      # 构建过程或辅助工具的变动。影响构建系统或外部依赖关系的更改（比如：Gulp、Broccoli、NPM）</span><br><span class="line">* chore      # 其他修改，比如改变构建流程，或增加依赖库、工具等</span><br><span class="line">* ci         # 持续集成相关修改（对 CI 配置文件和脚本的更改，比如：k8s、docker）</span><br><span class="line">* docs       # 文档（Documentation，比如 Readme、Changelog、Contribute 等等）</span><br><span class="line">* test       # 测试（增加测试或更正现有测试）</span><br><span class="line">* revert     # 回滚（回滚到某一个版本，带上版本号）</span><br></pre></td></tr></table></figure><p>如果 type 为 feat 和 fix，则该 Commit 将肯定出现在 Change Log 之中。其他情况（docs、chore、style、refactor、test）建议不要放入 Change Log。</p><ul><li>scope</li></ul><p>scope 用于说明 Commit 影响的范围，比如框架中的数据层、控制层、视图层，或业务中某个业务模块，视具体项目的不同而不同，比如：user 用户、pay 支付、product 产品、article 文章、core 核心、router 路由、api 接口、doc 文档…</p><ul><li>subject</li></ul><p>subject 是 Commit 目的的简短描述，不超过 50 个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</span><br><span class="line">* 第一个字母小写</span><br><span class="line">* 结尾不加句号（.）</span><br></pre></td></tr></table></figure><p>常用表述语有：add、change、update、remove、delete。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 Commit 的详细描述，可以分成多行。有两个注意点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 使用第一人称现在时，比如使用 change 而不是 changed 或 changes</span><br><span class="line">* 应该说明代码变动的动机，以及与以前行为的对比</span><br></pre></td></tr></table></figure><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li>不兼容变动</li></ul><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>关闭 Issue 或 Pull requests</li></ul><p>在开源的项目中，如果当前 commit 针对某个 issue 或 pr，那么可以在 Footer 部分关闭这个 issue 或 pr。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fixes #21388</span><br><span class="line">PR Closes #234</span><br></pre></td></tr></table></figure><p>常用的表述语有 sclose、fix、resolve。</p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 Commit 用于撤销以前的 Commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 This reverts commit <hash>.，其中的 Hash 是被撤销 Commit 的 SHA 标识符。</p><p>如果当前 Commit 与被撤销的 Commit 在同一个发布（Release）里面，那么它们都不会出现在 Change Log 里面。如果两者在不同的发布，那么当前 Commit，会出现在 Change Log 的 Reverts 小标题下面。</p><h2 id="为-git-commit-添加表情"><a href="#为-git-commit-添加表情" class="headerlink" title="为 git commit 添加表情"></a>为 git commit 添加表情</h2><p>为 commit message 添加 Emoji 不仅有趣，也可表达当前提交的类型。Emoji <a href="https://unicode.org/emoji/charts/full-emoji-list.html">CLDR Short Name</a> 被 GitHub (<a href="https://github.com/ikatyang/emoji-cheat-sheet">emoji-cheat-sheet</a> <a href="https://api.github.com/emojis">github-emoji-api</a>)、Gitlab、GitBucket 所支持，提交信息中可通过短名的方式使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;:apple: i have a apple&#x27;</span><br></pre></td></tr></table></figure><p>Git 中常用的 Emoji CLDR Short Name 列表如下：</p><table><thead><tr><th>Emoji</th><th>Emoji 代码</th><th>Commit 说明</th></tr></thead><tbody><tr><td>:tada: (庆祝)</td><td>:tada:</td><td>初次提交</td></tr><tr><td>:sparkles: (火花)</td><td>:sparkles:</td><td>引入新功能</td></tr><tr><td>:bug: (虫子)</td><td>:bug:</td><td>修复 bug</td></tr><tr><td>:lipstick: (口红)</td><td>:lipstick:</td><td>更新 UI 和样式文件</td></tr><tr><td>:art: (调色板)</td><td>:art:</td><td>改进代码结构&#x2F;代码格式</td></tr><tr><td>:hammer: (锤子)</td><td>:hammer:</td><td>重大重构</td></tr><tr><td>:zap: (闪电) <br> :racehorse: (赛马)</td><td>:zap: <br> :racehorse:</td><td>提升性能</td></tr><tr><td>:fire: (火焰)</td><td>:fire:</td><td>移除代码或文件</td></tr><tr><td>:wrench: (扳手)</td><td>:wrench:</td><td>修改配置文件</td></tr><tr><td>:construction_worker: (工人)</td><td>:construction_worker:</td><td>添加 CI 构建系统</td></tr><tr><td>:green_heart: (绿心)</td><td>:green_heart:</td><td>修复 CI 构建问题</td></tr><tr><td>:heavy_minus_sign: (减号)</td><td>:heavy_minus_sign:</td><td>减少一个依赖</td></tr><tr><td>:heavy_plus_sign: (加号)</td><td>:heavy_plus_sign:</td><td>增加一个依赖</td></tr><tr><td>:ambulance: (急救车)</td><td>:ambulance:</td><td>重要补丁</td></tr><tr><td>:rotating_light: (警车灯)</td><td>:rotating_light:</td><td>移除 linter 警告</td></tr><tr><td>:memo: (备忘录)</td><td>:memo:</td><td>撰写文档</td></tr><tr><td>:rocket: (火箭)</td><td>:rocket:</td><td>部署功能</td></tr><tr><td>:white_check_mark: (白色复选框)</td><td>:white_check_mark:</td><td>增加测试</td></tr><tr><td>:lock: (锁)</td><td>:lock:</td><td>修复安全问题</td></tr><tr><td>:globe_with_meridians: (地球)</td><td>:globe_with_meridians:</td><td>国际化与本地化</td></tr><tr><td>:apple: (苹果)</td><td>:apple:</td><td>修复 macOS 下的问题</td></tr><tr><td>:penguin: (企鹅)</td><td>:penguin:</td><td>修复 Linux 下的问题</td></tr><tr><td>:checkered_flag: (旗帜)</td><td>:checked_flag:</td><td>修复 Windows 下的问题</td></tr><tr><td>:bookmark: (书签)</td><td>:bookmark:</td><td>发行&#x2F;版本标签</td></tr><tr><td>:construction: (施工)</td><td>:construction:</td><td>工作进行中</td></tr><tr><td>:arrow_down: (下降箭头)</td><td>:arrow_down:</td><td>降级依赖</td></tr><tr><td>:arrow_up: (上升箭头)</td><td>:arrow_up:</td><td>升级依赖</td></tr><tr><td>:chart_with_upwards_trend: (上升趋势图)</td><td>:chart_with_upwards_trend:</td><td>添加分析或跟踪代码</td></tr><tr><td>:whale: (鲸鱼)</td><td>:whale:</td><td>Docker 相关工作</td></tr><tr><td>:pencil2: (铅笔)</td><td>:pencil2:</td><td>修复 typo</td></tr></tbody></table><p>Emoji 还可对单个 commit type 再次进行细分，比如 <code>feat</code> 下 <code>:tada: feat</code> 表示初始化项目，<code>:sparkles: feat</code> 引入新功能（默认），<code>:lipstick: feat</code> 修改样式。</p><p>这套 Emoji 规范的使用，需要配合编辑器插件、Git Commit 交互式工具（比如 gitmoji）或着 Git Commit Template，否则一个个查找难以使用。</p><p>注：除了使用 Emoji 短名，也可以直接在 commit message 中使用 Emoji code，VSCode 中可通过 git-commit-plugin 插件（但是这个插件所使用的 Emoji 语义与上面通用的不一致）。</p><h2 id="设置-Commit-Message-Template"><a href="#设置-Commit-Message-Template" class="headerlink" title="设置 Commit Message Template"></a>设置 Commit Message Template</h2><p>通过设置全局 .gitconfig 来指定 Commit Message 模板。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template C:/Users/CCH/commit-template</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;:tada: :sparkles: :lipstick: feat | :bug: :ambulance: fix | :hammer: refactor | :zap: :racehorse: perf | :art: style | :memo: docs | :wrench: ci | :wrench: :heavy_plus_sign: :heavy_minus_sign: chore&gt;: &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>TortoiseGit 中可通过依次点击 <code>settings -&gt; Git -&gt; Edit global .gitconfig</code>，然后编辑这个全局 .gitconfig 文件，在其末尾加入 commit 字段配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = xxxxxx@qq.com</span><br><span class="line">    name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">    recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">    helper = manager</span><br><span class="line">[commit]</span><br><span class="line">  template = d:/commit-template</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SFTP</title>
      <link href="/2019/01/08/linux/SFTP/"/>
      <url>/2019/01/08/linux/SFTP/</url>
      
        <content type="html"><![CDATA[<p>SFTP 是 Secure File Transfer Protocol 的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。SFTP 与 FTP 有着几乎一样的语法和功能。</p><span id="more"></span><p>SFTP 为 SSH 的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在 SSH 软件包中，已经包含了一个叫作 SFTP(Secure File Transfer Protocol) 的安全文件信息传输子系统，SFTP 本身没有单独的守护进程，它必须使用 sshd 守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP 并不像一个服务器程序，而更像是一个客户端程序。</p><p>SFTP 同样是使用加密传输认证信息和传输的数据，所以，使用 SFTP 是非常安全的。但是，由于这种传输方式使用了加密&#x2F;解密技术，所以传输效率比普通的 FTP 要低得多，如果您对网络安全性要求更高时，可以使用 SFTP 代替 FTP。</p><p>Windows 中可以使用 Core FTP、FileZilla、 WinSCP、Xftp 这样一些图形客户端来连接 SFTP 进行文件或目录的上传、下载，建立、删除等操作。而 Linux 下可使用命令行来操作 SFTP，参考下面常用命令。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>在 SFTP 的环境下的操作就和一般 FTP 的操作类似，ls、rm、mkdir、dir、pwd… 等指令都是对远端进行操作，如果要对本地操作，只需在上述的指令上加 ‘l’ 变为：lls、lcd、lpwd…。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">sftp xxx.xxx.xxx.xxx       <span class="comment"># 登录 root 用户</span></span><br><span class="line">sftp zygf@xxx.xxx.xxx.xxx  <span class="comment"># 登录 zygf 用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看sftp支持哪些命令</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定目录</span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传</span></span><br><span class="line">put /path/filename(本地主机) /path/filename(远端主机)；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">get /path/filename(远端主机) /path/filename(本地主机)。</span><br><span class="line"></span><br><span class="line">另外提一下sftp在非正规端口（正规的是22号端口）登录：sftp -o port=1000 username@remote ip.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">quit / <span class="built_in">bye</span> / <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>注：WinSCP 上通过 sftp 可以连接远程 Linux 主机，但是 ftp 不可以。这是因为，在 Linux 上，SFTP 和 FTP 是两个不同的服务，SFTP 为 SSH 的一部分，开通了 SSH 意味着 SFTP 开通了，但不意味着 FTP 也开通了，FTP 也需要手动开启，Linux 下开源的 FTP 实现是 Vsftp。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>造轮子</title>
      <link href="/2018/03/15/javascript/%E9%80%A0%E8%BD%AE%E5%AD%90/"/>
      <url>/2018/03/15/javascript/%E9%80%A0%E8%BD%AE%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>不依赖任何框架、库，无需编译，用最原生的 JavaScript 造轮子。</p><span id="more"></span><ul><li><a href="/rep/javascript/JSONP.html">JSONP</a> </li><li>模板引擎</li><li>富文本编辑器</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树形结构</title>
      <link href="/2017/12/24/algorithm/Tree-Structure/"/>
      <url>/2017/12/24/algorithm/Tree-Structure/</url>
      
        <content type="html"><![CDATA[<p>树形结构是一种层次嵌套的结构。它提供了一种有序的组织方式，能够方便地表示层次关系和结构化数据，在文件系统、数据库索引、DOM 等场景中被广泛应用。树形结构的遍历、搜索和操作等算法也是计算机中常见的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">74</span>,</span><br><span class="line">    <span class="string">&quot;parentId&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;children&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">62</span>,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">74</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">86</span>,</span><br><span class="line">        <span class="string">&quot;parentId&quot;</span>: <span class="number">74</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历是树数据结构的最基础操作，是树的转换、查找、筛选等一系列操作的基础。</p><p>树的遍历遍历分为广度优先遍历（BFS）和深度优先遍历（DFS）。深度优先遍历按节点的访问顺序又分为先序遍历、后序遍历，二叉树还有中序遍历，实现方法可以是递归，也可以是循环，而广度优先遍历是非递归的，使用循环来实现。</p><p>深度优先是按路径遍历，访问一条路径（一颗子树），直到末端节点，不能再深入为止，然后回溯并访问其他分支。而访问子树的时候，先访问根再访问根的子树，称为先序遍历，先访问子树再访问根，称为后序遍历。广度优先是按层序遍历，按顺序逐层遍历，遍历完第 <code>n</code> 层再遍历 <code>n+1</code> 层。</p><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">forEachTree</span>(<span class="params">tree, callback, childrenName = <span class="string">&#x27;subList&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node</span><br><span class="line">  <span class="keyword">const</span> list = [...tree]</span><br><span class="line">  <span class="keyword">while</span> ((node = list.<span class="title function_">shift</span>())) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(node)</span><br><span class="line">    node[childrenName] &amp;&amp; list.<span class="title function_">push</span>(...node[childrenName])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点 <code>push</code> 到队列后面，遍历时从队列前面 <code>shift</code> 节点，即一层层遍历（队列先进先出）。</p><h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><ul><li>递归</li></ul><p>递归的深度优先搜索也被称为回溯。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachTree</span>(<span class="params">tree, callback</span>) &#123;</span><br><span class="line">  tree.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(item)</span><br><span class="line">    item.<span class="property">children</span> &amp;&amp; <span class="title function_">forEachTree</span>(item.<span class="property">children</span>, callback)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历与先序遍历思想一致，只不过调换一下节点访问和子树遍历的顺序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachTree</span> (tree, callback) &#123;</span><br><span class="line">  tree.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">children</span> &amp;&amp; <span class="title function_">forEachTree</span>(item.<span class="property">children</span>, callback)</span><br><span class="line">    <span class="title function_">callback</span>(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历与广度优先实现类似，要维护一个队列，不同的是子节点不追加到队列最后，而是加到队列最前面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachTree</span> (tree, callback) &#123;</span><br><span class="line">  <span class="keyword">let</span> node, list = [...tree]</span><br><span class="line">  <span class="keyword">while</span> (node = list.<span class="title function_">shift</span>()) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(node)</span><br><span class="line">    node.<span class="property">children</span> &amp;&amp; list.<span class="title function_">unshift</span>(...node.<span class="property">children</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点 <code>unshift</code> 到队列前面，遍历时从队列前面 <code>shift</code> 节点，即一颗颗子树遍历（栈先进后出）。</p><p>JavaScript 中可用 Array 实现 List 和 Stock。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历略微复杂一点，需要不断将子树扩展到根节点前面去，执行列表遍历，遍历到某个节点如果它没有子节点或者它的子节点已经扩展到它前面了，则执行访问操作，否则扩展子节点到当前节点前面</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEachTree</span> (tree, callback) &#123;</span><br><span class="line">  <span class="keyword">let</span> node, list = [...tree], i =  <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (node = list[i]) &#123;</span><br><span class="line">    <span class="keyword">let</span> childCount = node.<span class="property">children</span> ? node.<span class="property">children</span>.<span class="property">length</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (!childCount || node.<span class="property">children</span>[childCount - <span class="number">1</span>] === list[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(node)</span><br><span class="line">      i++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list.<span class="title function_">splice</span>(i, <span class="number">0</span>, ...node.<span class="property">children</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表和树的相互转换"><a href="#列表和树的相互转换" class="headerlink" title="列表和树的相互转换"></a>列表和树的相互转换</h2><h3 id="列表转树"><a href="#列表转树" class="headerlink" title="列表转树"></a>列表转树</h3><ul><li>递归</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">56</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">81</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">74</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">76</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">63</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">80</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">87</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">62</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">86</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父元素 id 默认为 null，从根节点开始构建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span>(<span class="params">list, parentId = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tree = []</span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为子元素</span></span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">parentId</span> === parentId) &#123;    </span><br><span class="line">      <span class="comment">// 将当前元素作为父元素，获取当前元素的子元素                   </span></span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">listToTree</span>(list, item.<span class="property">id</span>)  </span><br><span class="line">      <span class="keyword">if</span> (children.<span class="property">length</span>) &#123;</span><br><span class="line">        item.<span class="property">children</span> = children</span><br><span class="line">      &#125;</span><br><span class="line">      tree.<span class="title function_">push</span>(item)                             </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> tree                                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">listToTree</span>(data)</span><br></pre></td></tr></table></figure><p>使用 <code>filter</code> 和 <code>map</code> 简化上述代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span>(<span class="params">list, parentId = <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">parentId</span> === parentId)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> children = <span class="title function_">listToTree</span>(list, item.<span class="property">id</span>)</span><br><span class="line">      <span class="keyword">if</span> (children.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;...item, children&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;...item&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>引用</li></ul><p>利用 JavaScript 引用类型特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 最好是深拷贝一下，否则引用类型特性，会导致原始数据改变</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">findParentEl</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i].<span class="property">id</span> === id) &#123;</span><br><span class="line">        <span class="keyword">return</span> list[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span></span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!el.<span class="property">parentId</span>) &#123;</span><br><span class="line">      root = el</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> parentEl = <span class="title function_">findParentEl</span>(el.<span class="property">parentId</span>)</span><br><span class="line">    parentEl.<span class="property">children</span> = [...(parentEl.<span class="property">children</span> || []), el]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 map 结构，以空间换时间，可将上面的算法时间复杂度由 <code>O(n^2)</code> 优化到 <code>O(n)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> idMap = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, el, i</span>) =&gt;</span> &#123;</span><br><span class="line">    acc[el.<span class="property">id</span>] = i</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = <span class="literal">null</span></span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!el.<span class="property">parentId</span>) &#123;</span><br><span class="line">      root = el</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> parentEl = list[idMap[el.<span class="property">parentId</span>]]</span><br><span class="line">    parentEl.<span class="property">children</span> = [...(parentEl.<span class="property">children</span> || []), el]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>filter</code> 找根节点，简化上述代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listToTree</span> (list) &#123;</span><br><span class="line">  <span class="keyword">let</span> info = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">map, node</span>) =&gt;</span> (map[node.<span class="property">id</span>] = node, node.<span class="property">children</span> = [], map), &#123;&#125;)</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">filter</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    info[node.<span class="property">parentId</span>] &amp;&amp; info[node.<span class="property">parentId</span>].<span class="property">children</span>.<span class="title function_">push</span>(node)</span><br><span class="line">    <span class="keyword">return</span> !node.<span class="property">parentId</span> <span class="comment">// 没有父节点的节点，即根节点</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树转列表"><a href="#树转列表" class="headerlink" title="树转列表"></a>树转列表</h3><p>以采用深度优先中的递归和循环解法为例。</p><ul><li>递归</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenTree</span>(<span class="params">tree, childrenName = <span class="string">&#x27;children&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; [childrenName]: children, ...rest &#125; = item</span><br><span class="line">    <span class="keyword">const</span> hasChildren = children &amp;&amp; children.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> acc.<span class="title function_">concat</span>(</span><br><span class="line">      rest,</span><br><span class="line">      hasChildren ? <span class="title function_">flattenTree</span>(children, childrenName) : []</span><br><span class="line">    )</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果除了使用 <code>reduce</code> 累计外，还可作为参数传递累计，原理一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenTree</span>(<span class="params">tree, result = [], level = <span class="number">0</span></span>) &#123;</span><br><span class="line">  tree.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(node)</span><br><span class="line">    <span class="comment">// 节点深度</span></span><br><span class="line">    node.<span class="property">level</span> = level + <span class="number">1</span></span><br><span class="line">    node.<span class="property">children</span> &amp;&amp; <span class="title function_">flattenTree</span>(node.<span class="property">children</span>, result, level + <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换时添加额外信息，比如 <code>hasChildren</code>、<code>chain</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenTree</span>(<span class="params">tree, childrenName = <span class="string">&#x27;children&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; [childrenName]: children, chain = [], ...rest &#125; = item</span><br><span class="line">    <span class="keyword">const</span> hasChildren = children &amp;&amp; children.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> node = &#123;</span><br><span class="line">      ...rest,</span><br><span class="line">      hasChildren,</span><br><span class="line">      <span class="attr">chain</span>: [...chain, &#123; ...rest &#125;],</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasChildren) &#123;</span><br><span class="line">      children = children?.<span class="title function_">map</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        child.<span class="property">chain</span> = node.<span class="property">chain</span></span><br><span class="line">        <span class="keyword">return</span> child</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> acc.<span class="title function_">concat</span>(</span><br><span class="line">      node,</span><br><span class="line">      hasChildren ? <span class="title function_">flattenTree</span>(children, childrenName) : []</span><br><span class="line">    )</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenTree</span> (tree) &#123;</span><br><span class="line">  <span class="keyword">let</span> node, result = tree.<span class="title function_">map</span>(<span class="function"><span class="params">node</span> =&gt;</span> (node.<span class="property">level</span> = <span class="number">1</span>, node))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; result.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!result[i].<span class="property">children</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">let</span> list = result[i].<span class="property">children</span>.<span class="title function_">map</span>(<span class="function"><span class="params">node</span> =&gt;</span> (node.<span class="property">level</span> = result[i].<span class="property">level</span> + <span class="number">1</span>, node))</span><br><span class="line">    result.<span class="title function_">splice</span>(i+<span class="number">1</span>, <span class="number">0</span>, ...list)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的其他操作"><a href="#树的其他操作" class="headerlink" title="树的其他操作"></a>树的其他操作</h2><ul><li>查找</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTree</span>(<span class="params">tree = [], callback, childrenName = <span class="string">&#x27;subList&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> tree) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; [childrenName]: children &#125; = item</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">callback</span>(item)) &#123;</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasChildren = !!children?.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasChildren) &#123;</span><br><span class="line">      <span class="keyword">const</span> foundInChild = <span class="title function_">findTree</span>(children, callback, childrenName)</span><br><span class="line">      <span class="keyword">if</span> (foundInChild) &#123;</span><br><span class="line">        <span class="keyword">return</span> foundInChild</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找节点路径</span></span><br><span class="line"><span class="comment">// 使用先序遍历查找路径，维护一个队列存储路径上每个节点 id，假设节点就在当前分支，如果当前分支查不到，则回溯</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTreePath</span> (tree, callback, path = []) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> tree) &#123;</span><br><span class="line">    path.<span class="title function_">push</span>(data.<span class="property">id</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">callback</span>(data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">children</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> foundInChild = <span class="title function_">findTreePath</span>(data.<span class="property">children</span>, callback, path)</span><br><span class="line">      <span class="keyword">if</span> (foundInChild.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> foundInChild</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findTreePath</span>(tree, <span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">id</span> === <span class="number">86</span>) <span class="comment">// [74, 86]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找多个节点路径</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findTreePathList</span> (tree, callback, path = [], result = []) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> tree) &#123;</span><br><span class="line">    path.<span class="title function_">push</span>(data.<span class="property">id</span>)</span><br><span class="line">    <span class="title function_">callback</span>(data) &amp;&amp; result.<span class="title function_">push</span>([...path])</span><br><span class="line">    data.<span class="property">children</span> &amp;&amp; <span class="title function_">findTreePathList</span>(data.<span class="property">children</span>, callback, path, result)</span><br><span class="line">    path.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findTreePathList</span>(tree, <span class="function">(<span class="params">item</span>) =&gt;</span> [<span class="number">62</span>, <span class="number">86</span>].<span class="title function_">includes</span>(item.<span class="property">id</span>)) <span class="comment">// [[74, 62], [74, 86]]</span></span><br></pre></td></tr></table></figure><ul><li>筛选</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">filterTree</span> (tree, callback) &#123;</span><br><span class="line">  <span class="comment">// 使用 map 复制节点，防止修改原树</span></span><br><span class="line">  <span class="keyword">return</span> tree.<span class="title function_">map</span>(<span class="function"><span class="params">node</span> =&gt;</span> (&#123; ...node &#125;)).<span class="title function_">filter</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">    node.<span class="property">children</span> = node.<span class="property">children</span> &amp;&amp; <span class="title function_">filterTree</span>(node.<span class="property">children</span>, callback)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(node) || (node.<span class="property">children</span> &amp;&amp; node.<span class="property">children</span>.<span class="property">length</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>映射</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapTree</span>(<span class="params">tree, callback, childrenName = <span class="string">&#x27;subList&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(tree)).<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item = <span class="title function_">callback</span>(item)</span><br><span class="line">    <span class="keyword">const</span> hasChildren = !!item[childrenName]?.<span class="property">length</span></span><br><span class="line">    item[childrenName] = hasChildren &amp;&amp; <span class="title function_">mapTree</span>(item[childrenName], callback, childrenName)</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>mapTree</code> 计算节点的深度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mapTree</span>(</span><br><span class="line">  res.<span class="property">data</span>,</span><br><span class="line">  <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 计算节点深度</span></span><br><span class="line">    item.<span class="property">level</span> = (item.<span class="property">parentLevel</span> || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 告诉子节点父节点的深度</span></span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">children</span>) &#123;</span><br><span class="line">      item.<span class="property">children</span>.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        child.<span class="property">parentLevel</span> = item.<span class="property">level</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;children&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sortTree</span> = (<span class="params">tree, callback, childrenName = <span class="string">&#x27;subList&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> tree</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item[childrenName] ? &#123; ...item, [childrenName]: <span class="title function_">sortTree</span>(item[childrenName], callback, childrenName) &#125; : item</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">sort</span>(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检测</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">someTree</span>(<span class="params">tree, callback, childrenName = <span class="string">&#x27;subList&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> tree || []) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback &amp;&amp; <span class="title function_">callback</span>(item)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> hasChildren = !!item[childrenName]?.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (hasChildren &amp;&amp; <span class="title function_">someTree</span>(item[childrenName], callback, childrenName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode JavaScript Solutions</title>
      <link href="/2017/10/01/algorithm/LeetCode-JavaScript-Solutions/"/>
      <url>/2017/10/01/algorithm/LeetCode-JavaScript-Solutions/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/rep/leetcode/two-sum.html">两数之和</a></li><li><a href="/rep/leetcode/palindrome-number.html">回文数</a></li><li><a href="/rep/leetcode/valid-parentheses.html">有效的括号</a></li><li><a href="/rep/leetcode/binary-tree-preorder-traversal.html">二叉树的前序遍历</a></li><li><a href="/rep/leetcode/invert-binary-tree.html">翻转二叉树</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Base 64 编码</title>
      <link href="/2017/05/10/foundation/Base-64/"/>
      <url>/2017/05/10/foundation/Base-64/</url>
      
        <content type="html"><![CDATA[<p>Base64 是一种用 64 个可打印字符来表示任意二进制数据的二进制编码方法。可以用来处理和传输任意二进制数据。</p><p>Base64 最初是用在电子邮件中，为了满足电子邮件中不能直接使用非 ASCII 码字符的规定，用来传输二进制文件的。除此之外，它还可将任意不可打印的二进制数据，转化为可打印的文本编码，使用文本软件进行编辑（二进制流中有很多都是无法显示和打印的，比如 ASCII 中的控制字符，二进制文件 jpg、pad、exe 等，如果用记事本打开这些文件，会看到一堆乱码）。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Base64 编码将一个 8 位字节序列拆散为 6 位的片段，并为每个 6 位的片段分配一个字符，这个字符是 Base64 字母表中的 64 个字符之一。这 64 个输出字符都是很常见的 ASCII 字符，包括大小写字母、数字、＋ 和 &#x2F;，还使用了特殊字符 &#x3D;。</p><p>Base64 编码表 (The Base64 Alphabet)：</p><table><thead><tr><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th><th>索引</th><th>对应字符</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>17</td><td>R</td><td>34</td><td>i</td><td>51</td><td>z</td></tr><tr><td>1</td><td>B</td><td>18</td><td>S</td><td>35</td><td>j</td><td>52</td><td>0</td></tr><tr><td>2</td><td>C</td><td>19</td><td>T</td><td>36</td><td>k</td><td>53</td><td>1</td></tr><tr><td>3</td><td>D</td><td>20</td><td>U</td><td>37</td><td>l</td><td>54</td><td>2</td></tr><tr><td>4</td><td>E</td><td>21</td><td>V</td><td>38</td><td>m</td><td>55</td><td>3</td></tr><tr><td>5</td><td>F</td><td>22</td><td>W</td><td>39</td><td>n</td><td>56</td><td>4</td></tr><tr><td>6</td><td>G</td><td>23</td><td>X</td><td>40</td><td>o</td><td>57</td><td>5</td></tr><tr><td>7</td><td>H</td><td>24</td><td>Y</td><td>41</td><td>p</td><td>58</td><td>6</td></tr><tr><td>8</td><td>I</td><td>25</td><td>Z</td><td>42</td><td>q</td><td>59</td><td>7</td></tr><tr><td>9</td><td>J</td><td>26</td><td>a</td><td>43</td><td>r</td><td>60</td><td>8</td></tr><tr><td>10</td><td>K</td><td>27</td><td>b</td><td>44</td><td>s</td><td>61</td><td>9</td></tr><tr><td>11</td><td>L</td><td>28</td><td>c</td><td>45</td><td>t</td><td>62</td><td>+</td></tr><tr><td>12</td><td>M</td><td>29</td><td>d</td><td>46</td><td>u</td><td>63</td><td>&#x2F;</td></tr><tr><td>13</td><td>N</td><td>30</td><td>e</td><td>47</td><td>v</td><td></td><td></td></tr><tr><td>14</td><td>O</td><td>31</td><td>f</td><td>48</td><td>w</td><td></td><td></td></tr><tr><td>15</td><td>P</td><td>32</td><td>g</td><td>49</td><td>x</td><td></td><td></td></tr><tr><td>16</td><td>Q</td><td>33</td><td>h</td><td>50</td><td>y</td><td></td><td></td></tr></tbody></table><p>还可以自己定义 64 个字符的排列顺序，这样就可以自定义 Base64 编码，不过，通常情况下没有必要。</p><p>注意：由于 Base64 编码用了 8 位字符来表示信息中的 6 个位，所以 Base64 编码字符串大约比原始值增加了 33%，(8 - 6) &#x2F; 6 &#x3D; 1&#x2F;3，选择 Base64 编码时要考虑一下文件的 size。另外，Base64 是一种通过查表的数据编码方法，目的是让数据符合传输协议的要求，不能将其误用于数据加密或数据校验，即使使用自定义的编码表也不行。</p><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>下面是一个简单的 Base64 编码实例。在这里，三个字符组成的输入值 “Ow!” 是 Base64 编码的，得到的是 4 个字符的 Base64 编码值 “T3ch”。它是按以下方式工作的。</p><table><thead><tr><th>8 位字符</th><th>O</th><th>w</th><th>!</th></tr></thead><tbody><tr><td>8 位值（十六进制）</td><td>$4F</td><td>$77</td><td>$21</td></tr><tr><td>8 位值（二进制）</td><td>01001111</td><td>01110111</td><td>00100001</td></tr></tbody></table><table><thead><tr><th>对上面 8 位值（二进制）进行拆分</th><th>-</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>6 位值（二进制）</td><td>010011</td><td>110111</td><td>011100</td><td>100001</td></tr><tr><td>6 位值（十进制）</td><td>19</td><td>55</td><td>28</td><td>33</td></tr><tr><td>Base64 字符</td><td>T</td><td>3</td><td>c</td><td>h</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 字符串 &quot;Ow!&quot; 被拆分成 3 个 8 位的字节 (0x4F、0x77、0x21)；</span><br><span class="line">* 这 3 个字节构成了一个 24 位的二进制 01001111 01110111 00100001；</span><br><span class="line">* 这些位被划分为一些 6 位的序列 010011、110111、011100、100001；</span><br><span class="line">* 每个 6 位值都表示了从 0~63 之间的一个数字，对应 Base64 字母表中的 64 个字符之一。得到的 Base64 编码字符串是 4 个字符的字符串 &quot;T3ch&quot;。然后就可以通过线路将这个字符串作为“安全的” 8 位字符传送出去，因为只用了一些移植性最好的字符（字母、数字等）；</span><br></pre></td></tr></table></figure><ul><li>用 JavaScript 描述</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Ow!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> binary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> binStr = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">2</span>); <span class="comment">// charCodeAt 返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数</span></span><br><span class="line">  binary.<span class="title function_">push</span>(binStr); <span class="comment">// [&#x27;1001111&#x27;, &#x27;1110111&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个正常的字节都是由 8bit 组成的，不够 8bit 需要在高位补 0，于是得到 [&#x27;01001111&#x27;, &#x27;01110111&#x27;, &#x27;00100001&#x27;]</span></span><br><span class="line"><span class="comment">// 1 把字符串按照 6 位分开，进行分割，得到 [&#x27;010011&#x27;, &#x27;110111&#x27;, &#x27;011100&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line"><span class="comment">// 2 将每一个转换为十进制分别对于 [19, 55, 28, 33];</span></span><br><span class="line"><span class="comment">// 3 将每一位数字分别对于上面提供的 Base64 对应表,得到对应的编码，分别对于 T3ch</span></span><br><span class="line"><span class="comment">// 4 最后就会得到 Base64 编码 T3ch</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符 &quot;Ow!&quot; 最后得到的 Base64 编码为&quot; T3ch&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>前提 – 确定具体的编码方案</li></ul><p>需要注意的是，ASCII 码 128 位后的字符，各个编码方案不兼容，比如汉字有 gb2312、utf-8、gbk 等，每一种编码的 Base64 对应值都不一样，是用 Base64 进行编码前，需要确定编码方案。下面以’严’的 UTF-8 为例：</p><p>“严”的 UTF-8 编码为 E4B8A5，写成二进制就是三字节的 “11100100 10111000 10100101”。将这个 24 位的二进制字符串，转换成四组一共 32 位的二进制值”111001 001011 100010 100101”，相应的十进制数为 57、11、34、37，它们对应的 Base64 值就为5、L、i、l。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeJS（btoa 不支持中文）</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&#x27;严&#x27;</span>);</span><br><span class="line">b.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 5Lil</span></span><br></pre></td></tr></table></figure><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>Base64 编码收到一个 8 位字节序列，将这个二进制序列流划分成 6 位的块。二进制序列有时不能正好平均地分为 6 位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为 24 的倍数（6 和 8 的最小公倍数）。</p><p>对已填充的二进制进行编码时，任何完全填充（不包括原始数据中的位）的 6 位组都有特殊的第 65 个符号 “&#x3D;” 表示。如果 6 位组是部分填充的，就将填充位设置为 0。</p><p>下面是一个填充实例：</p><table><thead><tr><th>输入数据</th><th>二进制序列（填充位以 x 表示）</th><th>已编码数据</th></tr></thead><tbody><tr><td>a:a</td><td>011000 010011 101001 100001</td><td>YTph</td></tr><tr><td>a:aa</td><td>011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx</td><td>YTphYQ&#x3D;&#x3D;</td></tr><tr><td>a:aaa</td><td>011000 010011 101001 100001 011000 010110 0001xx xxxxxx</td><td>YTphYWE&#x3D;</td></tr><tr><td>a:aaaa</td><td>011000 010011 101001 100001 011000 010110 000101 1000001</td><td>YTphYWFh</td></tr></tbody></table><p>初始输入字符串为 “a:a” 为 3 个字节（24 位）。24 是 6 和 8 的倍数，因此按照上面给出的例子计算。无需填充就会得到 Base64 编码为 “YTph”。</p><p>然而，再增加一个字符，输入字符串变为 “a:aa”，转换为二进制就会有 32 位长。而 6 和 8 的下一个公倍数为 48，因此要添加 16 位的填充码。填充的前 4 位是与数据位混合在一起的。得到的 6 位组 01xxxx，会被当作 010000、十进制中的 16，或者 Base64 编码的 Q 来处理。剩下的两个 6 位组都是填充码，用 &#x3D; 来表示。</p><p>‘O’ 的填充实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x27;O&#x27;.charCodeAt().toString(2);</span><br><span class="line">得到二进制（位数不够 8 位时，需要在高位补码）</span><br><span class="line">1001111 --&gt; 01001111</span><br><span class="line">-----------------------------------------</span><br><span class="line">按 6 位拆分二进制（位数不是 24 的倍数时，需要低位补码）</span><br><span class="line">010011, 11xxxx, xxxxxx, xxxxxx</span><br><span class="line">-----------------------------------------</span><br><span class="line">转为十进制</span><br><span class="line">19, 48</span><br><span class="line">-----------------------------------------</span><br><span class="line">Base64 查表结果</span><br><span class="line">Tw==</span><br></pre></td></tr></table></figure><h2 id="浏览器中-Base64-编码生成"><a href="#浏览器中-Base64-编码生成" class="headerlink" title="浏览器中 Base64 编码生成"></a>浏览器中 Base64 编码生成</h2><h3 id="字符的编码"><a href="#字符的编码" class="headerlink" title="字符的编码"></a>字符的编码</h3><p>Web API 中 <code>atob</code> 和 <code>btoa</code> 用来对字符进行 Base64 编码和解码。<code>btoa</code> 将二进制的字节数据（binary bytes）编码成 ASCII 字符串，<code>atob</code> 解码通过 Base64 编码的字符串数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;a:a&#x27;</span>); <span class="comment">// YTph</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">&#x27;YTph&#x27;</span>); <span class="comment">// a:a</span></span><br></pre></td></tr></table></figure><p>注：<code>btoa</code> 和 <code>atob</code> 分别是 Binary to ASCII 和 ASCII to binary 的缩写。b 不是 Base64 的缩写，计算机中的所有数据的本质都是二进制，我们所看到的文字、符号、图片、语音视频…，都是二进制数据在具体编码（字符编码、图像编码…）下的表现。</p><p>IE9 不支持 <code>atob</code> 和 <code>btoa</code>，可手动实现 Base64 编解码函数：<a href="https://github.com/dankogai/js-base64">js-base64</a>、<a href="https://github.com/mathiasbynens/base64">base64</a>。</p><ul><li>编码 Unicode 字符</li></ul><p><code>btoa</code> 仅仅支持 <a href="https://baike.baidu.com/item/ISO-8859-1">Latin1</a> 范围的字符（其编码范围是 <code>0x00-0xFF</code>，<code>0x00-0x7F</code> 之间完全和 ASCII 一致，<code>0x80-0x9F</code> 之间是控制字符，<code>0xA0-0xFF</code> 之间是文字符号），不能编码 Unicode 字符，对 Unicode 字符串进行编码都会触发字符越界的异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello, 中国！&#x27;</span>;</span><br><span class="line"><span class="title function_">btoa</span>(str); <span class="comment">// Uncaught DOMException: ...The string to be encoded contains characters outside of the Latin1 range.</span></span><br></pre></td></tr></table></figure><p>原因是这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 <code>0x00 ~ 0xFF</code> 范围，则会引发 InvalidCharacterError 异常。这只是 <code>btoa</code> 这个方法的局限，并不是 Base64 的局限，Base64 可以编码所有的二进制数据。</p><p>解决办法是先把 Unicode 字符串转换为 UTF-8 编码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello, 中国！&#x27;</span>)); <span class="comment">// SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(<span class="string">&#x27;SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=&#x27;</span>)); <span class="comment">// Hello, 中国！</span></span><br></pre></td></tr></table></figure><h3 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h3><p>dataURL 是 data 类型的 URL，指含有 Base64 数据的 URL，用于在 URL 中使用二进制数据，在 <a href="https://tools.ietf.org/html/rfc2397">RFC2397</a> 中提出，完整的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:文件类型;编码方式,编码后的文件内容</span><br><span class="line">data: [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data</span><br></pre></td></tr></table></figure><p>比如，文本和图片的 dataURL 表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain;charset=UTF-8;base64,5L2g5aW977yM5Lit5paH77yB</span><br><span class="line">data:image/gif;base64,xxxxxxxxxx</span><br></pre></td></tr></table></figure><p>dataURL 在 <code>img src</code>、<code>background url</code>、<code>link href</code>、<code>script src</code>… 中使用。</p><ul><li>dataURL 生成</li></ul><p>Web API 中的 <code>FileReader.readAsDataURL</code> 可以将一个文件转为 dataURL，图片还可以使用 canvas 的 <code>canvas.toDataURL</code> 生成。将一个 dataURL 转为 <code>Blob</code> 或者 <code>File</code>，<a href="/rep/foundation/base64.js">dataURLtoBlob</a>、<a href="/rep/foundation/base64.js">dataURLtoFile</a>。</p><h2 id="URL-Safe"><a href="#URL-Safe" class="headerlink" title="URL Safe"></a>URL Safe</h2><p>由于标准的 Base64 编码可能会出现 <code>+</code>、<code>/</code>、<code>=</code> 字符，这在 URL、Cookie 中不能直接作为参数，会造成歧义，所以又有一种 “URL Safe” 的 Base64 编码，其实就是把字符 <code>+</code> 和 <code>/</code> 分别变成 <code>-</code> 和 <code>_</code>，把 <code>=</code> 去掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base64.b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd++//</span></span><br><span class="line">base64.urlsafe_b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd--__ </span></span><br><span class="line">base64.urlsafe_b64decode(<span class="string">&#x27;abcd--__&#x27;</span>) <span class="comment"># i\xb7\x1d\xfb\xef\xff</span></span><br><span class="line"></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA==&#x27;</span>) <span class="comment"># abcd</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># 出错</span></span><br><span class="line"></span><br><span class="line">safe_b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># abcd</span></span><br></pre></td></tr></table></figure><h2 id="Base64-的应用"><a href="#Base64-的应用" class="headerlink" title="Base64 的应用"></a>Base64 的应用</h2><h3 id="网络传输协议中"><a href="#网络传输协议中" class="headerlink" title="网络传输协议中"></a>网络传输协议中</h3><p>Base64 的用途之一就是便于用文本或二进制文件数据的传送。 在网络传输中，Base64 一般适合以下场合的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 传输信道只支持 ASCII 字符，不方便传输二进制流的场合；</span><br><span class="line">* 含有非 ASCII 字符（127 位以后字符），容易出现编码问题的场合；</span><br></pre></td></tr></table></figure><ul><li>SMTP</li></ul><p>Base64 最早就是用来邮件传输协议（SMTP）中的，是作为 MIME 多媒体电子邮件标准的一部分开发的，原因是邮件传输协议是一个文本协议，只支持 ASCII 字符（纯文本，可打印）传输，如果要传输二进制文件（比如邮件附件中的图像、声音等）和非 ASCII 字符，就需要用 Base64 将二进制文件内容和非 ASCII 字符编码为只包含 ASCII 字符的内容，并指定 MIME（多用途互联网邮件扩展类型）（详情参考 HTTP 里面相关说明）。</p><p>例如，正文为空，带一个名为 hello.txt 的附件，内容为<code>您好！世界！</code>。导出邮件源码，其关键部分如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIME-Version: 1.0                           # 表示当前使用MIME标准1.0版本</span><br><span class="line">Content-Type: text/plain; name=&quot;hello.txt&quot;  # 表示附件文件名为 hello.txt ，格式为纯文本</span><br><span class="line"></span><br><span class="line">Content-Transfer-Encoding: base64           # 表示附件文件内容使用 base64 编码后传输。可选值 7bit、8bit、binary、quoted-printable、base64、custom</span><br><span class="line">5oKo5aW977yM5LiW55WM77yB                    # 文件内容 您好，世界！ Base64编码后的结果</span><br></pre></td></tr></table></figure><p>不过，MIME 使用的不是标准 Base64 编码。</p><ul><li>HTTP</li></ul><p>HTTP 是超文本传输协议，可以传输纯文本（底层也是二进制流），也可以直接传输二进制数据流。在传输纯文本的时候，由于有些数据格式不符合协议本身的规范，这时候就需要对这些数据进行编码处理成安全格式，从而可以合法地作为首部字段和正文的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：=、空格、:、+、/、换行符...；</span><br><span class="line">非 ASCII 码：比如中文；</span><br></pre></td></tr></table></figure><p>当然，在 HTTP 中，URI 编码一般都会用配套的 URIencode，而不使用 Base64，除非需要编码二进制文件为 DataURL。对于 URL 的编码，请看相关章节。</p><p>注：HTTP 也支持 MIME，请查看相关章节。</p><h3 id="dataURL"><a href="#dataURL" class="headerlink" title="dataURL"></a>dataURL</h3><ul><li>img src、background url、link href、script src、图片预览和上传</li></ul><p>注：图片预览和上传这个需求用 Blob 更合理，Blob 通过 URL.createObjectURL 也能预览。</p><h3 id="X-509-公钥证书、HTTP-基本认证和摘要认证"><a href="#X-509-公钥证书、HTTP-基本认证和摘要认证" class="headerlink" title="X.509 公钥证书、HTTP 基本认证和摘要认证"></a>X.509 公钥证书、HTTP 基本认证和摘要认证</h3><p>在<a href="http://www.cnblogs.com/xiaohuochai/p/6184913.html">基本认证</a>、<a href="http://www.cnblogs.com/xiaohuochai/p/6189065.html">摘要认证</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符编码</title>
      <link href="/2017/02/01/foundation/Character-Encoding/"/>
      <url>/2017/02/01/foundation/Character-Encoding/</url>
      
        <content type="html"><![CDATA[<p>计算机只能处理数字，如果要处理文本，就必须先把文本编码转换为数字才能处理（图片、语音、视频…，这些多媒体文件也一样）。</p><span id="more"></span><h2 id="摩尔斯电码"><a href="#摩尔斯电码" class="headerlink" title="摩尔斯电码"></a>摩尔斯电码</h2><p>古代的长途通讯主要是用信鸽、骑马送报、烽烟等方式进行。直到 1837 年，世界第一条电报诞生 – 当时美国科学家莫尔斯尝试用一些“点”和“划”来表示不同的字母、数字和标点符号，这套表示字符的方式也被称为“摩尔斯电码”。</p><p>摩斯电码中定义了 <code>A-Z、a-z、0-9、?、/</code> 这些字符：</p><table><thead><tr><th>字符</th><th>电码符号</th></tr></thead><tbody><tr><td>A</td><td>· -</td></tr><tr><td>B</td><td>- · · ·</td></tr><tr><td>…</td><td>…</td></tr><tr><td>1</td><td>· - - - -</td></tr><tr><td>2</td><td>· · - - -</td></tr><tr><td>…</td><td>…</td></tr><tr><td>?</td><td>· · - - · ·</td></tr><tr><td>&#x2F;</td><td>- · · - ·</td></tr></tbody></table><ul><li>电报的工作原理</li></ul><p>“点”对应短的电脉冲信号，“划”对应长的电脉冲信号，这些信号传到对方，接收机把短的电脉冲信号翻译成“点”，把长的电脉冲信号转换成“划”，译码员根据这些点划组合就可以译成英文字母，从而完成了通信任务。这里把字符表示为“点”或“划”并对应为电脉冲信号的过程既是 ⌈编码⌋，而译码员把接收机接收到的脉冲信号转化成点划后译成字符的过程即为 ⌈解码⌋。</p><h2 id="字符集和编码方案"><a href="#字符集和编码方案" class="headerlink" title="字符集和编码方案"></a>字符集和编码方案</h2><p>莫尔斯编码中包含了大小写英文字母和数字等符号。这里的每一个符号其实就是“字符”，而这所有的字符的集合就叫做“字符集”，“点”和“划”与字符之间的对应关系即可以称为“字符编码”。计算机诞生之后，将摩斯电码中的“点”和“划”换成了以 8 位字节二进制流的方式表示，如数字 1（字符、字型）的二进制流是 0011 0001，对应的十进制流是 49，十六进制流是 31。</p><p>在讲解字符编码前，需要理解以下一些概念：</p><ul><li>比特、字节</li></ul><p>比特 (bit) 也可称为“位”，是计算机信息中的最小单位，是 binary digit（二进制数位） 的缩写，指二进制中的一位。字节 (Byte) 计算机中信息计量的一种单位，一个位就代表 “0” 或 “1”，每 8 个位（bit）组成一个字节（Byte）。</p><ul><li>字符、字符集</li></ul><p>字符 (Character) 是文字与符号的总称，可以是各个国家的文字、标点符号、图形符号、数字等。字符集 (Character Set) 就是字符的集合。表示涵盖了哪些字符，每个字符都有一个数字序号（ID），叫码点（code point）。字符集往往是一张码表，它规定了文字与数字的一一对应关系。</p><ul><li>编码、解码</li></ul><p>编码 (Encoding) 是信息从一种形式或格式转换为另一种形式的过程。解码 (Decoding) 是编码的逆过程。</p><ul><li>字符编码方案</li></ul><p>字符编码（Character Encoding）方案指的是按照何种规则存储字符。字符要怎样编码成二进制字节序，即一个数字序号（ID），要编码成几个字节，字节顺序如何。</p><p>在 Unicode 之前，一个字符集只使用一种编码方案（直接存储码点），对于 ASCII、GB 2312、Big5、GBK、GB 18030 这些的遗留方案来说，既是字符集又是编码方案。Unicode 中，字符集和编码是明确区分的，Unicode 是统一的字符集标准，它有几种可选的编码方案，包括 UTF-8、UTF-16、UTF-32，为了节省空间，不直接存储码点。</p><ul><li>字形字体</li></ul><p>字符编码只是对字符的抽象，不规定字符具体的字体字形，这个由渲染程序实现。</p><p>根据数字序号（ID），调用字体存储的字形，就可以在页面上显示出来了，这就是字形字体（Font）。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><a href="https://en.wikipedia.org/wiki/ASCII">ASCII (American Standard Code for Information Interchange)</a> 美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的<a href="https://baike.baidu.com/item/%E5%8D%95%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86/22081499?fr=aladdin">单字节编码系统</a>，并等同于国际标准 ISO&#x2F;IEC 646，1967 年被正式公布。</p><p>1946年，世界第一台计算机诞生，发明计算机的人用 8 个晶体管的“通”或“断”组合出一些状态来表示世间万物。</p><p>8 个晶体管的“通”或“断”即可以代表一个字节。刚开始，计算机只在美国使用，所有的信息在计算机最底层都是以二进制（“0”或“1”两种不同的状态）的方式存储，而 8 位的字节序一共可以组合出 2 的 8 次方 共 256 种状态，即 256 个字符（十进制编码为 0 - 255，二进制编码为 0 - 11111111，采用 8 bit 编码，不足的前面补 0，即 00000000 - 11111111），这对于当时的美国已经是足够的了，他们尝试把字母、数字、符号和一些终端的动作用 8 位（bit）来组合。</p><ul><li>控制字符</li></ul><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>Abbreviation(缩写)</th><th>字符解释</th></tr></thead><tbody><tr><td>0000 0000</td><td>0</td><td>0</td><td>00</td><td>NUL</td><td>空字符</td></tr><tr><td>0000 0001</td><td>1</td><td>1</td><td>01</td><td>SOH</td><td>标题开始</td></tr><tr><td>0001 1111</td><td>37</td><td>31</td><td>1F</td><td>US</td><td>单元分隔符</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>01111111</td><td>177</td><td>127</td><td>7F</td><td>DEL (delete)</td><td>删除</td></tr></tbody></table><ul><li>可显示字符</li></ul><table><thead><tr><th>Bin(二进制)</th><th>Oct(八进制)</th><th>Dec(十进制)</th><th>Hex(十六进制)</th><th>Glyph(字形、字符)</th><th>字符解释</th></tr></thead><tbody><tr><td>0010 0000</td><td>40</td><td>32</td><td>20</td><td>space</td><td>空格</td></tr><tr><td>0010 0001</td><td>41</td><td>33</td><td>21</td><td>!</td><td>叹号</td></tr><tr><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td>01111110</td><td>176</td><td>126</td><td>7E</td><td>~</td><td>波浪号</td></tr></tbody></table><p>这套标准一共规定了 128 个字符（0x00~0x7f，0 ~127）的编码，被称为 ASCII 编码。共包括 33 个（包括前 32 个 和第 127 个）控制字符（Control Code – 控制字符又被称为 Function Code – 功能字符，它们都是不可见的）和 95 个可显示字符（Printable Code - 可打印字符），只用到了一个字节中的后 7 位，最前面一位统一规定为 0。</p><p>注：<a href="https://www.ascii-code.com/">完整的 ASCII 码表</a></p><h2 id="扩展-ASCII-码"><a href="#扩展-ASCII-码" class="headerlink" title="扩展 ASCII 码"></a>扩展 ASCII 码</h2><p>虽然刚开始计算机只在美国使用，128 个字符的确是足够了，但随着科技惊人的发展，欧洲国家、亚洲国家也开始使用上计算机了，128 个字符明显不够，比如法语中字母上方有注音符号，至于亚洲国家的文字，使用的符号就更多了，汉字就大多 10 万左右。</p><p>将 ASCII 中没有利用的最高位利用起来，把原来的 7 位扩充到 8 位（兼容 ASCII），不够就再加一个字节（比如中文），这套编码范围从 0x80~0xFFFF 的编码叫扩展 ASCII 码（各类扩展 ASCII 码在 Windows 中被统称为 ANSI 编码）。</p><h3 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h3><p>欧洲国家将 ASCII 最前面的一位利用起来，这样就多出了 128 位字符，其中 0 – 127 表示的符号与 ASCII 是一样的，不一样的只是 128~255 (0x80 ~ 0xFF) 的这一段。这套编码标志被称为 EASCII(Extended ASCII，延伸美国标准信息交换码)，共由 256 个字符组成。比较著名的 EASCII 有 <a href="https://baike.baidu.com/item/codepage/416287">CP437</a>（英文版 Windows 系统默认的字符编码）和 <a href="https://baike.baidu.com/item/ISO-8859-1">ISO&#x2F;8859-1(Latin-1)</a>。</p><h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>作为一种象形文字，汉字是世界上包含符号最多的文字，这不同于通过字母组合的西文单词。据不完全统计，汉字共包含了古文、现代文字等近 10 万个文字，就是我们现在日常用的汉字也有几千个，那么对于只包含 256 个字符一个字节进行编码的 EASCII 码显然不能满足需求。</p><p>在 Unicode 之前，一共存在过 3 套中文编码标准：大陆的 GB2312-80（后来又被扩展成 GBK、GB18030）、台湾的 Big5、香港的 HKSCS。</p><p><a href="http://www.sac.gov.cn/">国家标准化管理委员会</a>在 1981 年，正式制订了中华人民共和国国家标准简体中文字符集，项目代号为 GB2312 或 GB2312-80。GB2312 是对 ASCII 的简体中文扩展，只收录简化汉字，以及一般常用字母和符号，共收录有 7445 个字符，其中简化汉字 6763 个，字母和符号 682 个（全角），主要通行于中国大陆地区和新加坡等地。</p><ul><li>区位码</li></ul><p>汉字用两个字节表示，理论上，两个字节可以表示 256×256&#x3D;65536 种不同的符号，作为汉字编码表示的基础是可行的。但考虑到汉字编码与其它国际通用编码，如 ASCII 西文字符编码的关系，我国国家标准局采用了加以修正的两字节汉字编码方案，只用了两个字节的低 7 位。这个方案可以容纳 128×128&#x3D;16384 种不同的汉字，但为了与标准 ASCII 码兼容，每个字节中都不能再用 32 个控制功能码和码值为 32 的空格以及 127 的操作码。所以每个字节只能有 94 个编码。这样，双七位实际能够表示的字数是：94×94&#x3D;8836 个。</p><p>GB2312 将所收录的字符分为 94 个区，编号为 01 区至 94 区；每个区收录 94 个字符，编号为 01 位至 94 位。这种表示方式也称为<a href="https://baike.baidu.com/item/%E5%8C%BA%E4%BD%8D%E7%A0%81">区位码</a>。GB2312 的每一个字符都由与其唯一对应的区号和位号所确定。例如：汉字“啊”，编号为 16 区 01 位，它的区位码就是 1601（由 16、01 两部分组成，不能读做一千六百零一）。</p><p>分区：</p><table><thead><tr><th>区号</th><th>字数</th><th>字符类别</th></tr></thead><tbody><tr><td>01</td><td>94</td><td>一般符号</td></tr><tr><td>02</td><td>72</td><td>顺序号码</td></tr><tr><td>03</td><td>94</td><td>拉丁字母</td></tr><tr><td>04</td><td>83</td><td>日文假名</td></tr><tr><td>05</td><td>86</td><td>Katakana</td></tr><tr><td>06</td><td>48</td><td>希腊字母</td></tr><tr><td>07</td><td>66</td><td>俄文字母</td></tr><tr><td>08</td><td>63</td><td>汉语拼音符号</td></tr><tr><td>09</td><td>76</td><td>图形符号</td></tr><tr><td>10-15</td><td>-</td><td>备用区</td></tr><tr><td>16-55</td><td>3755</td><td>一级汉字，以拼音为序</td></tr><tr><td>56-87</td><td>3008</td><td>二级汉字，以笔划为序</td></tr><tr><td>88-94</td><td>-</td><td>备用区</td></tr></tbody></table><p>GB2312 字符集和编码对照表：</p><table><thead><tr><th>第 01 区</th><th>+0</th><th>+1</th><th>+2</th><th>+3</th><th>+4</th><th>+5</th><th>+6</th><th>+7</th><th>+8</th><th>+9</th><th>+A</th><th>+B</th><th>+C</th><th>+D</th><th>+E</th><th>+F</th></tr></thead><tbody><tr><td>A1A0</td><td></td><td></td><td>、</td><td>。</td><td>・</td><td>ˉ</td><td>ˇ</td><td>¨</td><td>〃</td><td>々</td><td>―</td><td>～</td><td>‖</td><td>…</td><td>‘</td><td>’</td></tr><tr><td>A1B0</td><td>“</td><td>”</td><td>〔</td><td>〕</td><td>〈</td><td>〉</td><td>《</td><td>》</td><td>「</td><td>」</td><td>『</td><td>』</td><td>〖</td><td>〗</td><td>【</td><td>】</td></tr><tr><td>A1C0</td><td>±</td><td>×</td><td>÷</td><td>∶</td><td>∧</td><td>∨</td><td>∑</td><td>∏</td><td>∪</td><td>∩</td><td>∈</td><td>∷</td><td>√</td><td>⊥</td><td>∥</td><td>∠</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>第 16 区</td><td>+0</td><td>+1</td><td>+2</td><td>+3</td><td>+4</td><td>+5</td><td>+6</td><td>+7</td><td>+8</td><td>+9</td><td>+A</td><td>+B</td><td>+C</td><td>+D</td><td>+E</td><td>+F</td></tr><tr><td>B0A0</td><td></td><td>啊</td><td>阿</td><td>埃</td><td>挨</td><td>哎</td><td>唉</td><td>哀</td><td>皑</td><td>癌</td><td>蔼</td><td>矮</td><td>艾</td><td>碍</td><td>爱</td><td>隘</td></tr></tbody></table><p>注：GB2312 兼容 ASCII 是通过混用的方式，不像 UTF-8 那种重新收录（虽然 GB2312 有重新收录 ASCII 吗，但都是 2 个字节的，即所谓的全拼）</p><ul><li>国标码</li></ul><p><a href="https://baike.baidu.com/item/%E6%B1%89%E5%AD%97%E5%9B%BD%E6%A0%87%E7%A0%81/4880277?fr=aladdin">国标码</a>是汉字信息交换的标准编码。区位码将 ASCII 码原来所代表的东西都占用了，不兼容 ASCII，不能直接存储。于是将区位码偏移 32 位（32D &#x3D; 20H，将十六进制的区位码，区码和位码分别加上 20H），避开 ASCII 前面的控制字符部分，这样就兼容了 ASCII 前 32 位了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 区码和位码的十进制转十六进制</span><br><span class="line">16..toString(16);               // 0x10</span><br><span class="line">1..toString(16);                // 0x1</span><br><span class="line"></span><br><span class="line"># 分别加 20H </span><br><span class="line">(0x10 + 0x20).toString(16);     // 0x30</span><br><span class="line">(0x1 + 0x20).toString(16);      // 0x21</span><br><span class="line"></span><br><span class="line"># 就得到了国标码</span><br><span class="line">1601D -&gt; 1001H -&gt; +20H -&gt; 3021H</span><br></pre></td></tr></table></figure><p>为什么只偏移 20H，不直接偏移 80H？其实，GB2312 虽说是对中文编码，但是里面有对 ASCII 码中的 26 个英文字母和一些特殊符号的重新编码，这么做的目的就是要覆盖掉 ASCII 码 32 位后的符号和英文字母部分，不对 ASCII 兼容。而对于 ASCII 码中前 32 个控制字符则继续沿用（<a href="https://www.zhihu.com/question/20875128">为什么不全部覆盖</a>），所以保留前 32 字符，就需要将汉字编码向后偏移 32（20H），这也就是区位码要加上 20H 得到国标码，这就是 GB2312 的编码规范。</p><p>而这样产生一个弊端，ASCII 码下的英文在 GB2312 下乱码，微软为了解决这个问题，将字节的最高位设为 1，因为 ASCII 中使用 7 位，最高位为 0，这样就区分开了 ASCII 和 GB2312，这也是为什么要加上 8080H。</p><p>也就是说，国标码才是 GB2312 的编码标准，后来的机内码是微软为了兼容 ASCII 采用的方式，本质上是修改了 GB2312 的编码标准，而这种方法最后产生的编码最后就被一些教科书称为内码。</p><ul><li>机内码</li></ul><p><a href="https://baike.baidu.com/item/%E6%9C%BA%E5%86%85%E7%A0%81">机内码</a>又叫内码，GB2312 的机内码是为了解决国标码与 ASCII 码不兼容问题出现的。</p><p>国标码前后字节的最高位为 0，注定会与 ASCII 码冲突，虽然偏移 32 位，解决了与 ASCII 中控制字符的冲突，但是没解决 ASCII 码 32 位之后的字符兼容，不可能在计算机内部直接采用的。如“啊”字，国标码为 30H 和 21H，而西文字符 “0”和 “!” 的 ASCII 也为 30H 和 21H，现假如内存中有两个字节为 31H 和 23H，这到底是一个汉字，还是两个西文字符，就出现了二义性。</p><p>为了解决上面问题，计算机内部使用机内码来处理 GB2312 字符。机内码采用变形国标码，将国标码的每个字节都加上 128（10000000B &#x3D; 128D &#x3D; 80H），即将两个字节的最高位由 0 改 1，其余 7 位不变，这样，两个大于 127 的二进制序列连在一起时，就表示一个汉字。台湾的 Big5 方法也是类似的，都是用 0x80 到 0xFF（128D-255D、10000000B-11111111B）这个区间。</p><p>机内码的这种编码方式就是所谓的 <a href="https://baike.baidu.com/item/EUC">EUC</a> 编码方法（具体来说是 EUC-CN，即在每个区位加上 0xA0 来表示，区和位分别占用一个字节），以便兼容于 ASCII。对于标准 ASCII 字符（小于 127 的字符，即 0x00 - 0x7F）其意义与原来相同，还是按一个字节进行编码。</p><p>回到上面例子，“啊”字的国标码为 3021H，前字节为 00110000B，后字节为 00100001B，高位改 1 为 10110000B 和 10100001B 即为 B0A1，因此，“啊”字的机内码就是 B0A1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 国标码上加 0x80 (0b100000000)</span><br><span class="line"></span><br><span class="line"># 区字节和位字节的十六进制转为二进制</span><br><span class="line">0x30.toString(2);           // 110000</span><br><span class="line">0x21.toString(2);           // 100001</span><br><span class="line"></span><br><span class="line"># 区字节和位字节二进制的高位补 1（十六进制就是加 80H）就得到机内码</span><br><span class="line">0b10110000.toString(16);    // B0</span><br><span class="line">0b10100001.toString(16);    // A1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 区位码上直接加 0xA0</span><br><span class="line">16 + 0xA0;                  // B0</span><br><span class="line">1 + 0xA0;                   // A1</span><br></pre></td></tr></table></figure><p>机内码中，前面的一个字节称之为“高位字节&#x2F;区字节”，从 0xA1 到 0xF7（把 01-87 区的区号加上 0xA0），后面一个字节称为“低位字节&#x2F;位字节”，从 0xA1 到 0xFE（把 01-94 加上 0xA0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以下字符保存为 GB2312 时，file length (in byte) 为 6 个字节。这说明 GB2312 中，前 127 位还是是 ASCII 的 单字节编码，127 位以后是双字节的 GB2312 编码</span><br><span class="line">2,啊，</span><br></pre></td></tr></table></figure><ul><li>区位码、国标码、机内码的转换</li></ul><p>区位码、国标码、机内码在十六进制下的转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">国标码 = 区位码 + 20H</span><br><span class="line">机内码 = 国标码 + 80H = 区位码 + A0H    # (0x80 + 0x20).toString(16) = A0H</span><br></pre></td></tr></table></figure><p>举例，已知机内码 B0A1，求区位码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 解法 1（注意：计算时，区字节和位字节分开减，(0xB0 - 0xA0).toString(16) = 10H）</span><br><span class="line">B0A1H-A0A0H = 1001H = 1601D</span><br><span class="line"></span><br><span class="line"># 解法 2</span><br><span class="line">B0A1H-8080H = 3021H(国标码),3021H-2020H = 1001H = 1601D</span><br></pre></td></tr></table></figure><ul><li>全角和半角</li></ul><p>ASCII 中 127 号以下的那些字符叫“半角”字符，127 号以后，像 GB2312 中的图形符号、汉字字符、英文字符都是“全角”字符。一般的系统命令是不用全角字符的，只是在作文字处理时才会使用全角字符。</p><ul><li>通过机内码输入 GB2312&#x2F;GBK 字符</li></ul><p>Windows 小键盘上，用 Alt + GBK 字符的十进制机内码，能够输入任何 GBK 字符（含 ASCII 字符，因为 GBK 兼容 ASCII）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># “啊”在 GBK 下的机内码的十进制是 45217。按住 Alt，分别在小键盘上输入 45217，再松开 Alt，即可输入“啊”</span><br><span class="line">b0a1H = 45217D</span><br></pre></td></tr></table></figure><p>附：字符转 GB2312 十六进制编码：<a href="https://github.com/liuxiaodong/encodeToGb2312">encodeToGb2312</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># “我爱你”这三个字的机内码就是 52946 45230 50403</span><br><span class="line">encodeToGb2312(&quot;我&quot;);    // CED2，parseInt(&#x27;CED2&#x27;, 16) 结果为 52946</span><br></pre></td></tr></table></figure><h3 id="GBK、GB18030"><a href="#GBK、GB18030" class="headerlink" title="GBK、GB18030"></a>GBK、GB18030</h3><p>GB2312 字符有限，不够用（对于人名、古汉语等方面出现的罕用字，GB2312 就不能处理），于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。这个编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。 后来 GBK 加了几千个新的少数民族的字，扩成了 GB18030。</p><p>GB18030 是 GBK 的超集，GBK 是 GB2312 的超集。GBK 在 Windows、Linux 等多种操作系统中被实现。</p><p>这一系列汉字编码的标准通称叫做 “DBCS”（Double Byte Charecter Set 双字节字符集）。在 DBCS 系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于 127 的，那么就认为一个双字节字符集里的字符出现了（一个汉字算两个英文字符，strlen(“2,啊，”) &#x3D; 6）。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>ASCII 码和扩展 ASCII 码（ESCII、GBK、JIS…）的时代是一个混乱的时代，没有统一标准，各国编码标准互不兼容，同一个二进制数字可以被解释成不同的符号（Eg：GB2312 编码下的中文，得到二进制序列到了 Big5 编码下解析时，这些二进制序列全部有了新的意义，导致乱码。编码和解码方案的不统一是乱码的主要原因）。</p><p>制定一个包括了地球上所有文化、所有字母和符号的字符集编码方案势在必行。历史上存在两个独立的字符集组织来做这件事：<a href="https://www.iso.org/home.html">ISO</a>&#x2F;<a href="https://www.iec.ch/">IEC</a>（国际标准化组织，国际电工委员会） 和 <a href="http://www.unicode.org/">Unicode</a> 协会（一个由多个软件制造商组成的协会），前者开发了“<a href="https://baike.baidu.com/item/ISO%2010646/1033849?fr=aladdin">ISO 10646</a> 项目”，后者开发了“<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a> 项目”。</p><p>1991 年前后, 两个项目的参与者都认识到, 世界上不需要两个不同的通用字符集，所以双方合并工作成果，为创立一个单一编码表而协同工作。虽然两个项目都独立地公布各自的标准, 但 Unicode 协会和 ISO&#x2F;IEC JTC1&#x2F;SC2 都同意保持 Unicode 和 ISO 10646 标准的码表兼容，从 Unicode 2.0 开始，Unicode 采用了与 ISO 10646-1 相同的字库和字码，ISO 也承诺，ISO 10646 将不会替超出 U+10FFFF 的 UCS-4 编码赋值，以使得两者保持一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 发展过程</span><br><span class="line"></span><br><span class="line">ASCII</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">ESCII、GB2312、GBK...</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">UCS (UCS-2、UCS-4)</span><br><span class="line">  |</span><br><span class="line">  |</span><br><span class="line">Unicode (UTF-8、UTF-16、UTF-32)</span><br></pre></td></tr></table></figure><p>Unicode 是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案，1990 年开始研发，1994 年正式公布。目前的 Unicode 字符分为 17 组编排，每组称为一个平面（Plane），每平面拥有 65536（2^16）个码位，共 1114112 个（65536 * 17）码位。</p><p>每一个码位都可以用 16 进制 xy0000 到 xyFFFF 来表示，这里的 xy 是表示一个 16 进制的值，从 00 到 10。平面 0（xy 为 00 时）被称为 BMP （基本多文种平面, Basic Multilingual Plane），它包含了最常用的字符（兼容 ISO-8859-1 字符集），码点范围从 U+0000 到 U+FFFF。剩下还有 16 个“辅助平面”，码点范围从 U+010000 一直到 U+10FFFF。</p><table><thead><tr><th>平面</th><th>始末字符值</th><th>中文名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td>0号平面</td><td>U+0000 - U+FFFF</td><td>基本多文种平面</td><td>BMP</td><td>绝大部分日常现代文字，比如英文、中文、日语、法语等</td></tr><tr><td>1号平面</td><td>U+10000 - U+1FFFF</td><td>多文种补充平面</td><td>SMP</td><td>古代字体、音符、扑克牌、麻将</td></tr><tr><td>2号平面</td><td>U+20000 - U+2FFFF</td><td>表意文字补充平面</td><td>SIP</td><td>CJKV 的增补文字，比如《康熙字典》中出现的非现代文字</td></tr><tr><td>3号平面</td><td>U+30000 - U+3FFFF</td><td>表意文字第三平面</td><td>TIP</td><td>可能存放甲骨文、金文、小篆</td></tr><tr><td>4～13号平面</td><td>U+40000 - U+DFFFF</td><td>（尚未使用）</td><td></td><td>可能存放甲骨文、金文、小篆</td></tr><tr><td>14号平面</td><td>U+E0000 - U+EFFFF</td><td>特别用途补充平面</td><td>SSP</td><td>特殊的控制字符，比如字形变换选取器</td></tr><tr><td>15号平面</td><td>U+F0000 - U+FFFFF</td><td>保留作为私人使用区（A区）</td><td>PUA-A</td><td>随意使用的私人区域</td></tr><tr><td>16号平面</td><td>U+100000 - U+10FFFF</td><td>保留作为私人使用区（B区）</td><td>PUA-B</td><td>随意使用的私人区域</td></tr></tbody></table><p>在 Unicode 5.0.0 版本中，已定义的码位只有 238605 个，分布在平面 0、平面 1、平面 2、平面 14、平面 15、平面 16。其中平面 15 和平面 16 上只是定义了两个各占 65534 个码位的专用区（Private Use Area），分别是 0xF0000-0xFFFFD 和 0x100000-0x10FFFD。所谓专用区，就是保留给大家放自定义字符的区域，可以简写为 PUA。</p><p>平面 0 也有一个专用区 0xE000-0xF8FF，有 6400 个码位。另外平面 0 的 0xD800-0xDFFF，共 2048 个码位，是一个被称作代理区（Surrogate）的特殊区域。代理区的目的是用两个 UTF-16 字符表示 BMP 以外的字符，具体参考 UTF-16 章节。</p><p>如前所述在 Unicode 5.0.0 版本中，238605-65534*2-6400-2408&#x3D;99089。余下的 99089 个已定义码位分布在平面 0、平面 1、平面 2 和平面 14 上，它们对应着 Unicode 目前定义的 99089 个字符，其中包括 71226 个汉字。平面 0、平面 1、平面 2 和平面 14 上分别定义了 52080、3419、43253 和 337 个字符。平面 2 的 43253 个字符都是汉字。平面 0 上定义了 27973 个汉字。</p><p>这 17 个平面结合起来至少需要占据 21 位的空间（0x10FFFF.toString(2).length），也就是差不多 3 个字节（24位），而辅助平面实际上是用 4 个字节表示，方便以后向后扩展。</p><p>Unicode 字符集，中文范围 4E00-9FA5（BMP 中）：</p><table><thead><tr><th>U+</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>4e00</td><td>一</td><td>丁</td><td>丂</td><td>七</td><td>丄</td><td>丅</td><td>丆</td><td>万</td><td>丈</td><td>三</td><td>上</td><td>下</td><td>丌</td><td>不</td><td>与</td><td>丏</td></tr><tr><td>4e10</td><td>丐</td><td>丑</td><td>丒</td><td>专</td><td>且</td><td>丕</td><td>世</td><td>丗</td><td>丘</td><td>丙</td><td>业</td><td>丛</td><td>东</td><td>丝</td><td>丞</td><td>丟</td></tr><tr><td>4e20</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;一&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e00</span></span><br><span class="line"><span class="string">&#x27;丑&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e11</span></span><br><span class="line"><span class="string">&#x27;丟&#x27;</span>.<span class="title function_">charCodeAt</span>().<span class="title function_">toString</span>(<span class="number">16</span>);    <span class="comment">// 4e1f</span></span><br></pre></td></tr></table></figure><p>Unicode 包含了世界上所有的语言字符的字符集，Unicode 给每个字符分配一个唯一的 <a href="https://www.unicode.org/charts/PDF/U0000.pdf">ID／码点</a> (<a href="https://unicode-table.com/cn/">中文版</a>) — 用一个十六进制数的前面加上 U+ 的 Unicode 表示，例如 “U+0041” 代表字符 “A” 。</p><p>注：Widows 下可通过 charmap (Win + R，输入 charmap) 来查看一个字符的 Unicode 编码。</p><h3 id="UCS"><a href="#UCS" class="headerlink" title="UCS"></a>UCS</h3><p><a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86">UCS 通用字符集 (Universal Character Set)</a>，是由 ISO 10646 标准所定义的标准字符集，其所对应的编码方式为 UCS-2、UCS-4。</p><p>UCS-2 用 2 个字节为字符编码，可以容纳的字符数为 65536 个（2^16），所以 UCS-2 只能编码 BMP 范围内的字符（在 Unicode 中被 UTF-16 所取代）。UCS-4 用 4 个字节为字符编码，实际上只用了 31 位，最高位必须为 0，它可以容纳的字符数为 2147483648 个（2^31，20 多个亿），但实际使用范围并不超过 0x10FFFF，并且为了兼容 Unicode 标准，ISO也承诺将不会为超出 0x10FFFF 的 UCS-4 编码赋值。UCS-2、UCS-4 都是定长的，无论是半角英文字母，还是全角汉字。</p><p>在实际使用中，UCS 已被 Unicode 所替代，二者的字符集一样，Unicode 的编码方案比 UCS 更灵活（UTF-32 等同于 UCS-4，UTF-16 是 UCS-2 的父集，UTF-8 在 UCS 中没有实现）。</p><h3 id="UTF"><a href="#UTF" class="headerlink" title="UTF"></a>UTF</h3><p>UTF (Unicode 转换格式，Unicode Transformation Format) 是 Unicode 的实现方式，是 Unicode 在计算机中的存储和传输标准。其实就是不改变字符集中各个字符的代码的情况下，建立一套新的编码方式，把字符的代码通过这个编码方式映射成传输时的编码，主要目的就是在使用 Unicode 字符集保持通用性的同时节约流量和硬盘空间。</p><p>在 Unicode 中，字符集和编码方案是分离的，Unicode 只是一个字符集，只规定了字符的码点，没有规定这个码点应该如何存储（8 bit、16 bit、32 bit）。像“Unicode 用两个字节编码”、“Unicode 中一个字符等于两个字节”，这些说法是不成立的。</p><p>之所以不对 Unicode 码点直接编码，是从“分词”和“空间”上考量的。比如，汉字“严”的 Unicode 是十六进制数 4E25，转换成二进制数足足有 15 位（100111000100101），也就是说这个符号的表示至少需要 2 个字节，表示其他更大的符号，可能需要 3 个字节或者 4 个字节。</p><ul><li>分词</li></ul><p>如何才能区别 Unicode 和 ASCII？计算机怎么知道 2 个或 4 个字节表示一个符号，而不是分别表示 2 个或 4 个符号呢？</p><ul><li>空间</li></ul><p>要编码 Unicode 那么多字符，至少要用到 2 个字节，而 UCS-2、UCS-4 这种定长的编码方案都不适合在计算机中存储和传输，原先 ASCII 码中的 0 - 127 位，如果直接使用 UCS 的码点直接存储、传输，对英语国家是种巨大的浪费（UCS-2 下 1 GB 变成 2 GB，UCS-4 下 1 GB 变成 4 GB）。</p><p>为了解决上述问题，对 Unicode 的字符码再做二次编码，这就诞生了 UTF-8、UTF-16、UTF-32 编码标准。</p><h4 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h4><p>Unicode 最直观的编码方式是每个码点使用 4 个字节表示，字节内容与码点一一对应。这种编码方法就叫做 UTF-32。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 4 个字节表示一个字符，比如，字母 a 的 UTF-32 为：</span><br><span class="line">0x00000061</span><br></pre></td></tr></table></figure><p>优点：转换规则简单直观，查找效率高，时间复杂度o(1)。缺点：浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。</p><p>UTF-32 可以看作是 UCS-4，或者它的子集（虽然 UCS-4 本身可以编码到 0x7FFFFFFF，但是 ISO 承诺，ISO 10646 将不会替超出 0x10FFFF）。</p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h4><p>UTF-8 是一种变长的编码方法（变长节省空间，一般用于外码，来进行存储和传输，而定长方便实现和处理效率高，一般用于内码，比如 JavaScript 中），字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。</p><p>UTF-8 作为最流行的编码方案，其优点有：良好的多语种支持（相对 GBK 等跟语种绑定的编码方式）；兼容 ASCII；没有字节序的问题；以英文和西文符号比较多的场景下（HTML&#x2F;XML），编码较短。</p><ul><li>UTF-8 转码规则</li></ul><p>1）对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；<br>2）对于 n 个字节的字符（n&gt;1），第一个字节的前 n 位设为 1，第 n+1 位设为 0，后面字节的前两位都设为 10，这 n 个字节的其余空位填充该字符 Unicode 码，高位用 0 补足。</p><p>UTF-8 以字节为单位对 Unicode 进行编码，从 Unicode 到 UTF-8 的编码方式如下（字母 x 表示可用编码的位）：</p><table><thead><tr><th>Unicode 编码(十六进制)</th><th>UTF-8 字节流（二进制）</th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。下面，还是以汉字“严”为例，演示如何实现 UTF-8 编码。</p><p>已知“严”的 Unicode 是 4E25，根据上表，可以发现 4E25 处在 000800-00FFFF 范围内，因此“严”的 UTF-8 编码需要三个字节，即格式是 “1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始（100 1110 0010 0101），依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，“严”的 UTF-8 编码是”11100100 10111000 10100101”，转换成十六进制就是 E4B8A5。</p><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h4><p>UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点，大部分常用字符都以固定的 2 个字节长度储存，是一种变长表示。</p><p>在 UTF-16 中，基本平面（BMP，U+0000 到 U+FFFF）的字符使用 2 个字节编码，辅助平面（U+010000 到 U+10FFFF）的字符使用 4 个字节编码。和 UTF-32 一样，UTF-16 也不兼容 ASCII 编码（都 Unicode 时代了，为什么还要兼容 ASCII）。</p><p>UTF-16 的优点：UTF-16 的前身 UCS-2 是定长的，处理起来容易，遍历速度要快，这使得 UTF-16 在编程语言内部被大量应用（Java、JavaScript、Windows 操作系统内部…）。另外空间上，UTF-16 在编码中文时比 UTF-8 要少 50%（BMP 的字符，以 UTF-16 编码时使用 2 字节，以 UTF-8 编码时使用 1 至 3 字节。超出 BMP 的字符，以 UTF-16 或 UTF-8 编码都需要 4 字节）。</p><ul><li>与 UCS-2 的区别</li></ul><p>UTF-16 可看成是 UCS-2 的父集，在 0x0000 到 0xFFFF 码位范围内，UTF-16 与 UCS-2 所指的是同一的意思（严格的说这并不正确，因为在 UTF-16 中从 U+D800 到 U+DFFF 的码位不对应于任何字符，而在使用 UCS-2 的时代，U+D800 到 U+DFFF 内的值被占用），当引入辅助平面字符后，对 0x10000 之外的字符，UCS-2 没有与之对应的编码，UTF-16 实现了编码。</p><ul><li>UTF-16 转码规则</li></ul><p>Unicode 码点转 UTF-16，首先区分这是基本平面字符，还是辅助平面字符。对于基本平面的字符，直接将码点转为对应的十六进制形式，以 2 个字节来编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U+597D = 0x597D</span><br></pre></td></tr></table></figure><p>对于辅助平面的字符，以代理对 (surrogate pair) 的形式用 4 个字节来编码。</p><p>Surrogate pair 是 UTF-16 中用于扩展字符而使用的编码方式，其采用四个字节来表示一个字符。具体的做法是取 BMP 范围里的 0xD800<del>0xDBFF 和 0xDC00</del>0xDFFF 的 code point (总范围为 D800-DFFF，这部分码点在 BMP 内是保留的，不映射到任何字符)，前者称为高位代理 high surrogates，后者称为低位代理 low surrogates，一个 high surrogate 接一个 low surrogate 拼成四个字节表示超出 BMP 的字符。</p><p>两个 surrogate range 都是 1024 个 code point，所以 surrogate pair 可以表达 1024 x 1024 &#x3D; 1048576 &#x3D; 0x100000 个字符，这就是 Unicode 的字符集范围上限是 0x10FFFF 的原因 ((0x100000 + 0xffff).toString(16) &#x3D; 0x10ffff)。为了照顾 UTF-16 以及一大堆采用了 UTF-16 的语言、操作系统（比如 Windows），这个上限不能突破。</p><p>UTF-16 对于辅助平面的编码转换，Unicode 3.0 版给出了转码公式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">H = <span class="title class_">Math</span>.<span class="title function_">floor</span>((c - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xD800</span></span><br><span class="line">L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></span><br><span class="line"></span><br><span class="line"># 比如辅助平面上的 💩，码点为 U+1f4a9（<span class="variable constant_">JS</span> 中表示为 <span class="string">&#x27;\u&#123;1f4a9&#125;&#x27;</span> 或 <span class="string">&#x27;\ud83d\udca9&#x27;</span>）</span><br><span class="line">H = <span class="title class_">Math</span>.<span class="title function_">floor</span>((<span class="number">0x1f4a9</span> - <span class="number">0x10000</span>) / <span class="number">0x400</span>)+<span class="number">0xD800</span>      <span class="comment">// 0xd83d</span></span><br><span class="line">L = (<span class="number">0x1f4a9</span> - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span>                <span class="comment">// 0xdca9</span></span><br></pre></td></tr></table></figure><p>注：辅助平面之所以采用 Surrogate pair 的方式编码，而不直接用 4 个字节编码码点，目的是为了区分 BMP 里面 2 个字节的编码，要不然不知道怎么分词。</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>BOM (Byte Order Mark)  — 字节顺序标记，用在文件的开头，用于标记大小端序的。</p><p>字节序就是数据在内存、磁盘、网络传输中存放的顺序，“多字节为编码单元”的编码方案都会存在大小端问题，比如 UTF-16 字符编码方案就分为 UTF-16BE 和 UTF-16LE，如果 BOM 是 FEFF，则表示大端序，如果 BOM 是 FFFE，则表示小端序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Little-Endian  # 小端。就是高位字节排放在内存的高地址端，低位字节排放在内存的低地址端（符合人类的感官思维）</span><br><span class="line">Big-Endian     # 大端。就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端</span><br></pre></td></tr></table></figure><p>Unicode 规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做“零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大 1。如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式，如果头两个字节是 FF FE，就表示该文件采用小端方式。</p><p>例如，一个“奎”的 Unicode 编码是 594E，“乙”的 Unicode 编码是 4E59。如果我们收到 UTF-16 字节流 “594E”，那么这是“奎”还是“乙”？如果 BOM 是大端序，那么代码点就应该是 594E，那么就是“奎”，如果 BOM 是小端序，那么代码点就应该是 4E59，就是“乙”了。</p><ul><li>UTF-16 和 UTF-32 有字节序问题，UTF-8 和 GBK 没有</li></ul><p>为什么 UTF-16 和 UTF-32 有字节序问题，而 UTF-8 和 GBK 没有？要想搞清楚这个问题，需要先搞清楚什么是 Code Unit。</p><p>Code Unit（编码单元&#x2F;码元）：是编码使用的最短比特组合单元。UTF-8 中一个编码单元是 8 bit 长，UTF-16 中一个编码单元是 16 bit 长，UTF-32 是 32 bit（UTF 后边的数字代表的就是码元的大小）。换一种说法就是 UTF-8 的是以一个字节为最小单位的，UTF-16 是以两个字节为最小单位的。</p><p>单个码元可以表示完整的码点，也可以表示码点的一部分。例如，雪人字形(☃)这个码点，在 UTF-8 中需要 3 个码元，在 UTF-16 中需要 1 个。</p><p>以单字节为编码单元的 UTF-8、GB2312 不存在字节序问题，因为字节顺序已经规定好了，不存在谁在高位、谁在低位的问题。比如 UTF-8 的处理过程是这样的：读入第一个字节，该字节中包含了该 Unicode 字符总共用几个字节编码的信息，然后根据上述信息再读入接下来的字节，由此完成一个字符的解码，以此类推。因此整个 Unicode 文件对解码器来说只是一个字节（8 bit）流，所以不涉及字节序的问题。</p><p>而以多字节为编码单元的 UTF-16、UTF-32 中，就需要考虑字节序的问题了。比如，以 2 个字节为编码单元的 UTF-16，这 2 个字节哪个存高位哪个存低位（使用大端还是小端）。Unicode 规范中没有规定字节序，这导致各个平台和 CPU 的实现不一致，有的使用大端有的使用小端，所以必须使用 BOM 来区分。</p><p>注：JavaScript 中字符串的 length 属性返回的是 UTF-16 下字符串的 Code Unit 个数，而不是 Code Point 个数。</p><ul><li>Windows 平台下特有的 UTF-8 width BOM</li></ul><p>BOM 除了标记大小端序外，还可用在 Windows 系统中（记事本）用来标记编码方案。</p><p>UTF-8 本身不存在字节序问题，Windows 记事本中给 UTF-8 带上 BOM 是为了区分编码方案。在 Windows 记事本中一段二进制编码，如何确定它是 GBK 还是 BIG5 还是 UTF-16 还是 UTF-8呢，记事本的做法是在 TXT 文件的最前面保存一个标签，如果记事本打开一个 TXT，发现这个标签，就说明是 Unicode（其中 0xFF 0xFE 代表 UTF16LE，0xFE 0xFF 代表 UTF16BE，0xEF 0xBB 0xBF 代表 UTF-8），如果没有这个标签，那么就是 ANSI，使用操作系统的默认语言编码来解释。</p><p>Unicode 标准中 BOM 只是用来标记字节序，微软用 BOM 来标记编码方案是不标准的，这是 Windows 记事本特有的，带 BOM 的 UTF-8 不但多出 3 个字节，最关键是，这样的文件在 Windows 之外的操作系统里可能会带来问题，不含 BOM 的 UTF-8 才是标准形式。</p><table><thead><tr><th>UTF 编码</th><th>Byte Order Mark (BOM)</th></tr></thead><tbody><tr><td>UTF-8 without BOM</td><td>无</td></tr><tr><td>UTF-8 with BOM</td><td>EF BB BF</td></tr><tr><td>UTF-16LE</td><td>FF FE</td></tr><tr><td>UTF-16BE</td><td>FE FF</td></tr><tr><td>UTF-32LE</td><td>FF FE 00 00</td></tr><tr><td>UTF-32BE</td><td>00 00 FE FF</td></tr></tbody></table><p>注：可以通过一个 Hex Editor 来查看一个文本文件的 BOM。</p><p>关于 Windows 记事本再多说几句，Windows notepad 另存为时编码可以选择 ANSI、Unicode、Unicode big endian、UTF-8，其含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ANSI                # ANSI 是遗留（legacy）编码</span><br><span class="line">Unicode             # UTF-16 LE</span><br><span class="line">Unicode big endian  # UTF-16 BE </span><br><span class="line">UTF-8               # UTF-8 width BOM </span><br></pre></td></tr></table></figure><p>其中，ANSI 是遗留（legacy）编码，对应当前系统 locale 遗留编码，在不同语言系统中编码不同（简中下是 GBK、繁中是 Big5、日文 Windows 操作系统中代表 Shift_JIS），微软术语叫 code page。另外，关于 UTF-8，当涉及到跨平台兼容性时，请不要用记事本编辑 UTF-8 文件，应用专业的文本编辑器保存为不带 BOM 的 UTF-8。</p><p>注：记事本下，依次采用 ANSI，Unicode，Unicode big endian 和 UTF-8 编码方式保存”啊”，然后查看其文件大小（带 BOM 的 UTF-8 会比不带 BOM 的多出 3 个字节）和观察该文件的内部十六进制编码方式。</p><ul><li>主机字节序和网络字节序</li></ul><p>主机字节序是不确定的，而网络字节序是确定的。</p><p>不同的主机有不同的字节序，如 x86 为小端字节序，Motorola 6800 为大端字节序，ARM 字节序是可配置的。</p><p>TCP&#x2F;IP 在 RFC1700 中规定使用“大端”字节序为网络字节序，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。在不使用大端的计算机中，发送数据的时候必须要将自己的主机字节序转换为网络字节序（即“大端”字节序），接收到的数据再转换为自己的主机字节序。</p><h2 id="字符的编码解码和编码转换"><a href="#字符的编码解码和编码转换" class="headerlink" title="字符的编码解码和编码转换"></a>字符的编码解码和编码转换</h2><h3 id="字符的编码解码"><a href="#字符的编码解码" class="headerlink" title="字符的编码解码"></a>字符的编码解码</h3><ul><li>Unicode</li></ul><p>JavaScript 中可通过 charCodeAt、escape 和 String.fromCharCode、unescape 来编解码 Unicode 字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 编码：字符转 Unicode 的十六进制编码</span><br><span class="line">function encodeUnicode(str) &#123;</span><br><span class="line">  let result = &#x27;&#x27;;</span><br><span class="line">  for (let i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">    let point = (&#x27;00&#x27; + str.charCodeAt(0).toString(16)).slice(-4);</span><br><span class="line">    </span><br><span class="line">    result += &#x27;\\u&#x27; + point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encodeUnicode(&#x27;严&#x27;);            // \u4e25</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 解码</span><br><span class="line">function decodeUnicode(str) &#123;  </span><br><span class="line">  str = str.replace(/\\/g, &#x27;%&#x27;);  </span><br><span class="line">  return unescape(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeUnicode(&#x27;\u4e25&#x27;);        // 严</span><br></pre></td></tr></table></figure><p>注：JavaScript 中字符使用 UTF-16 存储，charCodeAt 和 escape 其实返回的其实是 UTF-16 十六进制编码，不过在 BMP 中，UTF-16 十六进制编码和 Unicode 的 Code Point 是一样的。另外，上面的方法不支持辅助平面上的字符。</p><ul><li>UTF-8</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编码：字符转 UTF-8 的十六进制编码</span><br><span class="line">encodeURI(&#x27;严&#x27;);                 // &quot;%E4%B8%A5&quot;</span><br><span class="line"></span><br><span class="line"># 解码：UTF-8 字符的十六进制编码转字符</span><br><span class="line">decodeURI(&#x27;%E4%B8%A5&#x27;);          // 严</span><br></pre></td></tr></table></figure><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><ul><li>Unicode 和 UTF-8 互转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unicodeToUTF8</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000000</span> &amp;&amp; hex &lt;= <span class="number">0x0000007F</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> hex;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000080</span> &amp;&amp; hex &lt;= <span class="number">0x000007FF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0x7C0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0xC0</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (hex &amp; <span class="number">0x03F</span>) | <span class="number">0x80</span>;</span><br><span class="line">    <span class="keyword">return</span> r1 | r2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00000800</span> &amp;&amp; hex &lt;= <span class="number">0x0000FFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0xF000</span>) &gt;&gt; <span class="number">12</span>) | <span class="number">0xE0</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (((hex &amp; <span class="number">0x0FC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r3 = ((hex &amp; <span class="number">0x003F</span>) | <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> r1 | r2 | r3;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hex &gt;= <span class="number">0x00010000</span> &amp;&amp; hex &lt;= <span class="number">0x0010FFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = (((hex &amp; <span class="number">0x1C0000</span>) &gt;&gt; <span class="number">18</span>) | <span class="number">0xE0</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">var</span> r2 = (((hex &amp; <span class="number">0x03F000</span>) &gt;&gt; <span class="number">12</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> r3 = (((hex &amp; <span class="number">0x000FC0</span>) &gt;&gt; <span class="number">6</span>) | <span class="number">0x80</span>) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">var</span> r4 = ((hex &amp; <span class="number">0x00003F</span>) | <span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> r1 | r2 | r3 | r4;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">unicodeToUTF8</span>(<span class="number">0x4e25</span>);  <span class="comment">// 14989477，14989477..toString(16); e4b8a5</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">utf8ToUnicode</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> utf8Binary = hex.<span class="title function_">toString</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> arrItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; utf8Binary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        arrItem += utf8Binary[i];</span><br><span class="line">        <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">8</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            arr.<span class="title function_">push</span>(arrItem);</span><br><span class="line">            arrItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">            result += arr[i].<span class="title function_">slice</span>(arr.<span class="property">length</span> + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += arr[i].<span class="title function_">slice</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">utf8ToUnicode</span>(<span class="number">0xE4B8A5</span>);  <span class="comment">// 4e25</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">utf8ToUnicode</span>(<span class="params">hex</span>) &#123;    </span><br><span class="line">  <span class="keyword">let</span> utf8Binary = hex.<span class="title function_">toString</span>(<span class="number">2</span>);    </span><br><span class="line">  <span class="keyword">let</span> arr = [];    </span><br><span class="line">  <span class="keyword">let</span> arrItem = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; utf8Binary.<span class="property">length</span>; i++) &#123;       </span><br><span class="line">    arrItem += utf8Binary[i];        </span><br><span class="line">    <span class="keyword">if</span> ((i+<span class="number">1</span>) % <span class="number">8</span> === <span class="number">0</span>) &#123;            </span><br><span class="line">      arr.<span class="title function_">push</span>(arrItem);            </span><br><span class="line">      arrItem = <span class="string">&#x27;&#x27;</span>;        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;            </span><br><span class="line">      result += arr[i].<span class="title function_">slice</span>(arr.<span class="property">length</span> + <span class="number">1</span>)        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">      result += arr[i].<span class="title function_">slice</span>(<span class="number">2</span>);        </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(result, <span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">utf8ToUnicode</span>(<span class="number">0xE4B8A5</span>);  <span class="comment">// 4e25</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 设计模式</title>
      <link href="/2016/12/02/css/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/12/02/css/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>大型的 CSS 项目中，往往会遇到 CSS 结构混乱、多人协作命名冲突、没有组件化无法复用…等等问题。为了解决这些问题于是引入 CSS 设计模式，用 BEM 来解决命名空间的问题，用 SMACSS 来解决代码分层问题，用 OOCSS 来解决解构复用问题。</p><span id="more"></span><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>对于 CSS 选择器的命名空间，一般的做法是通过选择器嵌套来约束命名空间，但是这种方式带来了很多问题 – 嵌套层次深不但影响了性能也导致了重度的 DOM 依赖，还有最重要的是命名冲突。</p><p>一个优秀的 CSS 命名方案，应该要解决以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 具备 NameSpace；</span><br><span class="line">* 不能与嵌套的业务样式命名冲突；</span><br><span class="line">* 独立、对上层不过度依赖；</span><br></pre></td></tr></table></figure><p>BEM 的出现解决了上述问题。</p><p>BEM 中，B 代表 Block（Component）、E 代表 Element、M 代表 Modify。规定用 <code>__</code> 连接 E，用 <code>--</code>连接 M，用 <code>-</code> 连接单词和命名前缀。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.m-page</span><br><span class="line">.m-page__item</span><br><span class="line">.m-page__item--cur</span><br><span class="line">.m-page--center</span><br></pre></td></tr></table></figure><p>注：BEM 最多只有三层，不可能存在嵌套的 Element，比如 <code>.m-page__item__anchor--cur</code>。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS 是一个比较全面的 CSS 规范，它不但规范了命名空间，还对 CSS 进行了分层。具体到项目中，只参考它的分层。</p><h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>命名前缀用于说明 UI 类型归属，可以结合 BEM 一同使用，用于说明 Block 的类型。</p><ul><li>g-栅格</li></ul><p>简单栅格系统：用户后台 <code>g-hd</code>、<code>g-fd</code>、<code>g-bd</code>、<code>g-sd</code>、<code>g-mn</code>，前台和中间页 <code>g-head</code>、<code>g-body</code>、<code>g-foot</code>。</p><ul><li>f-原子类</li></ul><p>常用原子类：<code>f-bfc</code>、<code>f-clearfix</code>、<code>f-ellipsis</code>、<code>f-show</code>、<code>f-hide</code>、<code>f-cb</code>…。</p><p>定义原子类必须谨慎，功能性的原子类还好（<code>f-clearfix</code>、<code>f-bfc</code>），描述性的原子类必须谨慎（比如 <code>f-w100</code>）。原子类的使用场景是供后端使用的，或者前端 fix issue 时紧急使用。</p><p>原子类的缺陷：与 inline style 无异，没有做到结构与样式的分离；容易导致 class 臃肿。</p><ul><li>u-元件</li></ul><p>常用元件：<code>u-btn</code>、<code>u-ipt</code>、<code>u-select</code>、<code>u-line</code>、<code>u-link</code>…。</p><p>利用 OOCSS 来对页面元素进行抽象，是一种非常好的做法，这样可以通过继承，组合出不同的样式。但是也有导致 class 的臃肿的缺点，不过为了前者的实用性，后者的这点缺点也算不了什么。</p><ul><li>m-组件</li></ul><p>常用的 UI 组件：<code>m-tab</code>、<code>m-table</code>、<code>m-form</code>、<code>m-page</code>、<code>m-dialog</code>、<code>m-btns</code>、<code>m-select</code>、<code>m-search-box...</code>、<code>m-header</code>、<code>m-footer</code>…。</p><p>UI 的组件化也就是 HTML、CSS 的组件化。模块化、组件化的目的是封装（作用域隔离）、复用，这使得代码简洁易读易维护，按照最小组件化原则，非常有利于项目在快速迭代中的发展。</p><p>组件化原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 组件化抽象的第一原则是复用（这也是 m 与 c 最主要的区别）；</span><br><span class="line">* 各个组件独立划分，充分解耦，遵守职责单一原则；</span><br><span class="line">* 业务 m 不能与全局 m 冲突，业务 m 要带上业务前缀（比如，m-header-mall），必要时还要加上模块前缀（比如，m-title-mall-index）；</span><br></pre></td></tr></table></figure><p>自定义组件：</p><p>当组件化不满足场景时，可对 modify 进行自定义（组件不满足场景大部分是 modify 不满足）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m-page--center</span><br><span class="line">c-choiceness-stage__carousel--junior</span><br><span class="line">c-choiceness-stage__carousel--high</span><br><span class="line">c-choiceness-stage__carousel--senior</span><br></pre></td></tr></table></figure><ul><li>c-模块</li></ul><p>整个 UI 都可以被模块化，包括业务，使用 <code>c-xx</code> 来作为命名前缀（c 指代 component，表示模块，而非 custom）。</p><p>component 和 module 的区别：component 包含 module，module 是 component 的组成部分，组件一般是可高度复用，可在整个项目或者跨项目通用的，这里的 c 其实指的是不可复用的业务模块（<code>模块 - 组件 = 不可复用的业务模块</code>），主要目的是封装，不具备 m 一样的复用能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-login      # login 不能被复用，所以这里不能用 m-login</span><br></pre></td></tr></table></figure><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCSS 只是一种思想，并没有具体的规范，用 OO 的方式来对 CSS 进行解构抽象，能够达到很好的作用域封装和复用效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.u-btn .u-btn--normal .u-btn--gray</span><br><span class="line">.m-page .m-page--center</span><br><span class="line">.m-tips .m-tips--success</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/2016/12/02/javascript/Functional-Programming/"/>
      <url>/2016/12/02/javascript/Functional-Programming/</url>
      
        <content type="html"><![CDATA[<h2 id="科里化函数"><a href="#科里化函数" class="headerlink" title="科里化函数"></a>科里化函数</h2><p>科里化的关键是返回函数实现连式调用、参数收集、以及判断收集结束做最终调用。判断收集结束有很多办法：对比实参和形参的长度；判断实参的个数是否为 0（不传）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="comment">// 通过手动调用的方式（即不传参数）来判断收集结束</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">currying</span>(fn.<span class="title function_">bind</span>(<span class="literal">null</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 须手动结束调用</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><span id="more"></span><p>上面版本中，对被科里化的函数没要求，但需要手动结束调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123; <span class="comment">// 这里通过型参长度来判断是否要调用，所以 add 的参数不能使用 spread 运算符 ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...remain</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">_fn</span>(...args, ...remain);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本中，被科里化函数的形参长度必须固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>这个版本中，不需手动结束调用，但被科里化的函数的形参必须要有长度。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2016/09/05/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2016/09/05/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外循环控制几轮冒泡，内循环进行冒泡（比较大小交换位置，就像气泡一样从数组底部”冒泡”到数组的顶部）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 共进行 arr.length 轮冒泡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="comment">// 俩俩对比，最后一个元素后面没有元素了，所以减 1，已冒泡上去的元素无需再参与，所以减 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]] <span class="comment">// distribute 交换数组位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bubbleSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：在 <code>Array</code> 原型链上扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">this</span>.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[j] - <span class="variable language_">this</span>[j + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = <span class="variable language_">this</span>[j]</span><br><span class="line">        <span class="variable language_">this</span>[j] = <span class="variable language_">this</span>[j + <span class="number">1</span>]</span><br><span class="line">        <span class="variable language_">this</span>[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>].<span class="title function_">bubbleSort</span>()</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序从冒泡排序演变而来，也是交换排序，但比冒泡排序高效。快速排序基于分治策略，通过选择一个基准元素将数组分成两个子数组，然后递归地对子数组进行排序。</p><p>以第一个元素为基准元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将第一个元素为基准元素</span></span><br><span class="line">  <span class="keyword">const</span> pivot = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> left = []</span><br><span class="line">  <span class="keyword">const</span> right = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将小于基准的元素放入 left 数组，大于基准的元素放入 right 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">  <span class="keyword">const</span> sortedLeft = <span class="title function_">quickSort</span>(left)</span><br><span class="line">  <span class="keyword">const</span> sortedRight = <span class="title function_">quickSort</span>(right)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回排好序的数组：left + 基准 + right</span></span><br><span class="line">  <span class="keyword">return</span> sortedLeft.<span class="title function_">concat</span>(pivot, sortedRight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure><p>以任意元素为基准元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择任意元素为基准元素</span></span><br><span class="line">  <span class="keyword">const</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)</span><br><span class="line">  <span class="keyword">const</span> pivot = arr[pivotIndex]</span><br><span class="line">  <span class="keyword">const</span> left = []</span><br><span class="line">  <span class="keyword">const</span> right = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将小于基准的元素放入 left 数组，大于基准的元素放入 right 数组</span></span><br><span class="line">  <span class="comment">// 基准值是任意的，所以从 0 开始遍历，然后将基准值忽略即可</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== pivotIndex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">        left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序左右子数组</span></span><br><span class="line">  <span class="keyword">const</span> sortedLeft = <span class="title function_">quickSort</span>(left)</span><br><span class="line">  <span class="keyword">const</span> sortedRight = <span class="title function_">quickSort</span>(right)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回排好序的数组：left + 基准 + right</span></span><br><span class="line">  <span class="keyword">return</span> sortedLeft.<span class="title function_">concat</span>(pivot, sortedRight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种简单的排序算法，其基本思想是将数组分为两部分，已排序部分和未排序部分，且以数组第一项为默认已排序项，然后逐步将未排序部分的元素插入到已排序部分的适当位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> n = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    <span class="comment">// 存在上一项，且当前项小于上一项，则交互位置</span></span><br><span class="line">    <span class="comment">// j-- 目的是为了将当前项与所有的已排项进行对比</span></span><br><span class="line">    <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[j]</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">      arr[j - <span class="number">1</span>] = temp</span><br><span class="line">      <span class="comment">// 继续往前插入</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertionSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 类型系统</title>
      <link href="/2016/07/26/javascript/JavaScript-Type-System/"/>
      <url>/2016/07/26/javascript/JavaScript-Type-System/</url>
      
        <content type="html"><![CDATA[<p>类型动静态强调的是静态类型检测，类型强弱强调的是隐式类型转换，JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">42</span>; <span class="comment">// foo 是 number</span></span><br><span class="line">foo = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// foo 是 string</span></span><br><span class="line">foo = <span class="literal">true</span>;  <span class="comment">// foo 是 boolean</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// number 转成了 string</span></span><br><span class="line">!!<span class="number">1</span>; <span class="comment">// number 转成了 boolean</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 中一共有 8 种内置（Built-In）数据类型，其中包括 7 种原始类型和 1 种对象类型。</p><h3 id="原始类型（Primitive-types）"><a href="#原始类型（Primitive-types）" class="headerlink" title="原始类型（Primitive types）"></a>原始类型（Primitive types）</h3><p>原始类型也被称为基本类型，表示不能再细分下去的类型，具有原子性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* string: 一串表示文本值的字符序列</span><br><span class="line">* number: 整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）</span><br><span class="line">* boolean: 包含两个值 true 和 false</span><br><span class="line">* null: 只包含一个值 null</span><br><span class="line">* undefined: 只包含一个值 undefined</span><br><span class="line">* symbol: 一种实例是唯一且不可改变的数据类型</span><br><span class="line">* bigInt</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于这些类型被存储在栈内存中，也被称为值类型。又由于这些类型的值是不可变的，又被称为不可变类型，原始类型是不可变的，没有任何方法可以直接改变其值，只会生成新的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">foo.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line">foo.<span class="title function_">toLowerCase</span>(<span class="number">1</span>);</span><br><span class="line">foo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);  <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈内存原始空间中的值并没有改变，只是开辟了一块新空间，将变量名指向新的空间</span></span><br><span class="line">foo += <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>内存模型图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">&#x27;hello&#x27;            |</span><br><span class="line">foo &#x27;hello world&#x27;  |</span><br></pre></td></tr></table></figure><ul><li>Number</li></ul><p>JavaScrip 使用 <a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">IEEE 754 标准</a>的双精度（double） 64 位（64 比特 bit）浮点数来存储数字。该标准定义了浮点数的格式，最大最小范围，以及超过范围的舍入方式等规范。JavaScript 中的 <code>Number</code> 类型的实际上是双精度 64 位的浮点型。</p><p>这种表示方式使用 64 位二进制格式，共 8 个字节，其中，63 位存储符号（正负），52 到 62 存储指数，0 到 51 存储尾数（数字）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s | eee eeeeeeee | ffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff</span><br><span class="line">1        11                                  52  </span><br></pre></td></tr></table></figure><p>一个数字的范围只能在 <code>-(2^53-1)</code> 至 <code>2^53-1</code>（<code>-9007199254740991</code> ~ <code>9007199254740991</code>，即二进制 <code>0b五十三个1</code>）之间，如果十进制转为二进制，有限或无限超出了其表示范围，则会被舍入。这也是导致小数和大整数出现精度丢失的原因。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数</span></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="number">2.22</span> + <span class="number">0.1</span> <span class="comment">// 2.3200000000000003</span></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="number">0.3</span> - <span class="number">0.2</span> <span class="comment">// 0.09999999999999998</span></span><br><span class="line"><span class="number">1.5</span> - <span class="number">1.2</span> <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="number">19.9</span> * <span class="number">100</span> <span class="comment">// 1989.9999999999998，19.9 * 10 * 10 结果 位 1990</span></span><br><span class="line"><span class="number">1306377.64</span> * <span class="number">100</span> <span class="comment">// 130637763.99999999</span></span><br><span class="line"><span class="number">0.7</span> * <span class="number">180</span> <span class="comment">// 125.99999999999999</span></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> <span class="comment">// 2.9999999999999996</span></span><br><span class="line"><span class="number">0.69</span> / <span class="number">10</span> <span class="comment">// 0.06899999999999999</span></span><br><span class="line"><span class="comment">// toFixed 不会四舍五入</span></span><br><span class="line"><span class="number">1.335</span>.<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 1.33</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大整数</span></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> + <span class="number">1</span> === <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> + <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="number">99999999999999999</span> * <span class="number">1</span> <span class="comment">// 100000000000000000</span></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="number">1000000000000000128</span> === <span class="number">1000000000000000129</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">9999999999999999</span> + <span class="number">1</span> === <span class="number">9999999999999999</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>以 <code>0.1 + 0.2</code> 问题为例，十进制小数 <code>0.1</code> 和 <code>0.2</code> 正好被转成无限循环的二进制小数，为了满足规范，做舍入，最终导致精度损失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.1 =&gt; 0.0001 1001 1001 1001…（无限循环小数）</span><br><span class="line">0.2 =&gt; 0.0011 0011 0011 0011…（无限循环小数）</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>/<span class="number">2</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 0.1</span></span><br><span class="line">(<span class="number">1</span>/<span class="number">10</span>).<span class="title function_">toString</span>(<span class="number">2</span>) <span class="comment">// 0.0001100110011001100110011001100110011001100110011001101...</span></span><br></pre></td></tr></table></figure><p>所有采用 IEEE-754 浮点数标准的语言都存在这个问题，只不过 JavaScript 是一门动态类型的语言，没有静态语音那样对浮点数有严格的数据类型（比如 Java 中的 <code>flot</code>、<code>double</code>），精度误差问题显得格外突出。</p><p>注：IEEE-754 中还有单精度浮点数标准。</p><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* object</span><br></pre></td></tr></table></figure><p>声明一个对象通常有以下几种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;; <span class="comment">// 字面量形式，推荐</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// new 调用</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Object</span>(); <span class="comment">// 与 new 调用相同</span></span><br><span class="line">cosnt foo = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 空对象</span></span><br></pre></td></tr></table></figure><p>由于 <code>Array</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>… 这些对象都是 <code>Object</code> 对象的子类，所以全部归类为 <code>object</code> 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>按内存分配方式，由于对象类型被存储在堆内存中，也被称为引用类型。又由于值是可变的，又被称为可变类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = foo;</span><br><span class="line">foo.<span class="property">msg</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">bar; <span class="comment">// &#123;msg: &#x27;hello world&#x27;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">foo[foo.<span class="property">length</span>] = foo.<span class="property">length</span> + <span class="number">1</span>; <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">foo.<span class="title function_">push</span>(<span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">foo.<span class="property">length</span> = <span class="number">0</span>; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>内存模型图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）      |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">foo 0x01 ---&gt;   |  0x01 hello world</span><br><span class="line">bar 0x01 ---&gt;   |</span><br></pre></td></tr></table></figure><ul><li>包装对象</li></ul><p>基本数据类型调用对象方法或访问属性时，，。在使用完这些方法和属性后，包装对象会被销毁，</p><p>包装对象即原始类型的“包装对象（Wapper object）”。<code>string</code>、<code>number</code>、<code>boolean</code> 这三种原始类型值在引用属性和方法时，JavaScript 引擎会创建一个临时包装对象 <code>new String()</code>、<code>new Number()</code> 和 <code>new Boolean()</code>，该对象具有对应的方法和属性，一旦引用结束，便会销毁这个临时包装对象，返回原始的基本数据类型。这三个对象是引擎内部用的，不要在代码中使用。</p><p>不是所有的原始类型都有包装对象，<code>null</code> 和 <code>undefined</code> 就没有包装对象，访问它们的属性会报类型错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">42</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>(<span class="number">2</span>)) <span class="comment">// 作为基本类型的 n 没有 toFixed 方法，引擎会创建临时包装对象处理 toFixed 调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let temp = new Number(42)</span></span><br><span class="line"><span class="comment">// value = temp.toFixed(2)</span></span><br><span class="line"><span class="comment">// 删除 temp</span></span><br><span class="line"><span class="comment">// 返回 value</span></span><br></pre></td></tr></table></figure><p>不要因为原始类型可以转化为对应的包装对象，而得出 “JavaScript 中一切皆对象” 这一错误的论断，原始类型和原始类型的包装对象是两个东西。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;seymoe&#x27;</span>; <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;seymoe&#x27;</span>); <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">String</span>(<span class="string">&#x27;seymoe&#x27;</span>); <span class="comment">// &#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">foo.<span class="property">bar</span> = <span class="string">&#x27;word&#x27;</span>; <span class="comment">// foo 是原始类型，添加属性是无效的</span></span><br><span class="line">foo.<span class="property">bar</span>; <span class="comment">// 原始类型就是原始类型，如果万物皆对象这里不会返回 undefined</span></span><br></pre></td></tr></table></figure><p>注：<code>Number</code>、<code>String</code> 和 <code>Boolean</code> 只有作为构造函数调用（加 <code>new</code> 调用），才会返回包装对象，如果当作普通函数调用，返回的是字面量，这常用于将任意类型的值转为数值、字符串和布尔值。</p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符被用来检测数据的类型，其返回一个字符串，代表操作数的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1337</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;foo&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">parseInt</span> <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">127n</span> <span class="comment">// &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure><p><code>typeof</code> 能检测除 <code>null</code> 和值为 <code>function</code> 的 <code>object</code> 类型外的所有类型。<code>null</code> 由于历史设计失误，<code>typeof</code> 返回了 <code>object</code>（如果从 <code>Java</code> 的角度所有的值皆对象，<code>null</code> 是 Object 的零值，也能自洽），而 <code>function</code> 由于很特殊（构造函数）<code>typeof</code> 特殊处理返回了 <code>function</code>。</p><p><code>typeof</code> 不能检测除 <code>function</code> 外的 <code>object</code> 子类型，如果想要检测子类型，则需要使用 <code>instanceof</code> 或 <code>Object.prototype.toString</code> 方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">(<span class="function">()=&gt;</span>&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 用来检测类型有缺陷，首先它会检测整个原型链，另外，它不能在 iframe 中跨页面检测，因为不在同一个 <code>window</code> 对象下，原型链无法关联。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>[].__proto__ === Array.prototype</code>，而又 <code>Array</code> 属于 <code>Object</code> 子类型，即 <code>Array.prototype.__proto__ === Object.prototype</code>，最终 <code>[].__proto__.__proto__ === Object.prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="title function_">foo</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iframe</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data <span class="keyword">instanceof</span> <span class="title class_">Array</span>);  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>data</code> 时的 <code>Array</code> 跟 iframe 里的 <code>Array</code> 属于不同的 <code>window</code> 对象下，不是同一个类。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>终极解决方案，不但能检测基本类型，还能检测 object 子类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>); <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>); <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>); <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Symbol</span>()); <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">BigInt</span>(<span class="number">2</span>)) <span class="comment">// &quot;[object BigInt]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;); <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="function">() =&gt;</span> &#123;&#125;); <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>());</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>); <span class="comment">// &#x27;[object Math]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Set</span>()); <span class="comment">// &#x27;[object Set]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakSet</span>()); <span class="comment">// &#x27;[object WeakSet]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Map</span>()); <span class="comment">// &#x27;[object Map]&#x27;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">WeakMap</span>()); <span class="comment">// &#x27;[object WeakMap]&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>将值从一种类型转换为另一种类型被称为类型转换，JavaScript 中类型转换都属于强制类型转换，其又分为隐式强制类型转换和显式强制类型转换。参考 <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch4.md">《You Dont Know JS》</a>。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>JavaScript 中常见的隐式类型转换有：</p><ul><li><code>+</code> 运算符</li></ul><p><code>+</code> 运算符中其他所有类型会被隐式转换（<code>toString</code>）为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">1</span> <span class="comment">// 数字会隐式转换为字符串</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算符、条件语句</li></ul><p>逻辑运算符、条件语句中其他所有类型都会被隐式转换布尔值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;、||</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;1&#x27;</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>算术运算、比较运算</li></ul><p>在算术运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和比较运算符 <code>&lt;</code>、<code>&gt;</code>、<code>==</code> 中布尔值会隐式转换为数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="literal">true</span> &gt; <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> + <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + [<span class="string">&#x27;hello&#x27;</span>, <span class="number">1</span>]; <span class="comment">// 1hello,1</span></span><br><span class="line">&#123;&#125; + []; <span class="comment">// 0</span></span><br><span class="line">[] + &#123;&#125;; <span class="comment">// [object Object]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + &#123;&#125;; <span class="comment">// 2[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span> + obj; <span class="comment">// 2hello</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="number">1</span>;</span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> + <span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line">[] == ![];</span><br><span class="line">[<span class="literal">undefined</span>] == <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ul><li>toString</li></ul><p>基础类型强制转为 string 类型在规范中明确说明了，也比较符合直觉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">1</span>); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;hello&#x27;</span>)); <span class="comment">// &quot;Symbol(hello)&quot;</span></span><br></pre></td></tr></table></figure><p>object 类型在强制转换为 string 类型的时候，调用的是该类型原型上的 <code>toString</code> 方法，而 object 的各个子类型基本都重写了 <code>toString</code> 方法，所以在进行 <code>toString</code> 操作的时候表现有差异。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(&#123; <span class="attr">a</span>: <span class="number">2</span> &#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="regexp">/reg/g</span>); <span class="comment">// &quot;/reg/g&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">toString</span>(); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="title class_">String</span>(arr); <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写toString</span></span><br><span class="line">arr.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">String</span>(arr); <span class="comment">// &quot;1/2&quot;</span></span><br></pre></td></tr></table></figure><ul><li>toNumber</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;42&#x27;</span>); <span class="comment">// 42</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;123px&#x27;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="string">&#x27; &#x27;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">false</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">null</span>);  <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">ToNumber</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案</title>
      <link href="/2016/07/02/css/Adaptation-Rule/"/>
      <url>/2016/07/02/css/Adaptation-Rule/</url>
      
        <content type="html"><![CDATA[<p>在 PC 端，除了数据可视化和中后台这样一些全屏设计场景需要适配，绝大多数的网页采用的都是固定尺寸设计，由于 1366+ 的屏幕尺寸大于常用的固定设计尺寸，网页按设计尺寸 1:1 还原即可，不需要考虑适配。而在移动端，由于屏幕尺寸大小不一，且采用全屏的设计风格，则需要做适配。</p><p>目前移动端端内主流适配方案有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 流体式/弹性式；</span><br><span class="line">* Layout Viewport Scale；</span><br><span class="line">* VW + Rem；</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：适配方案还有设备独立像素和 Media Query（query 的是逻辑像素）。</p><p>抽象的设备独立像素解决的是端内高密度屏的适配（底层图形系统会根据 DPI 自动换算为物理像素），Media Query 解决的是跨端的设计风格适配，而流体、Rem、Layout Viewport Scale 解决的是端内设计要素（盒模型、字体、图片…）的适配（同一 UI 的整体缩放，没有设计上的差异）。</p><p>在设计要素适配中，“盒模型”和“字体”只需要考虑大小，而“图像”相对复杂一些，需要考虑流量、清晰度等问题，常见的解决方案有：矢量化、字体化、image-set 等。</p><h2 id="流体式"><a href="#流体式" class="headerlink" title="流体式"></a>流体式</h2><p>这是最早使用的适配方案，也是最常用的一种，特别是在响应式 UI 框架中（比如 Bootstrap）。其原理是，完美视口下，选需要兼容设备的最小宽度（一般都是 320px）来布局，垂直方向的高度和间距使用定值，水平方向用百分比、定值、flex…，最终达到“当手机屏幕变化时，横向拉伸或者填充空白的效果”。Eg：<a href="https://m.baidu.com/">百度</a>、<a href="https://www.amazon.cn/">亚马逊</a>。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 为完美视口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>步骤二，切图布局</li></ul><p>小往大适配，选需要兼容设备的最小尺寸还原设计稿（一般都是 iPhone5 的 320px，这是当前主流手机中的最小尺寸），当屏幕变宽时，简单的填充空白即可（如果从大到小，小分辨率设备上，就会出现滚动条）。</p><p>注：选主流中最小分辨率机型来进行设计（640 * 1334），<code>CSS 尺寸 = 视觉稿尺寸/dpr = 640/2 = 320</code>。前端在高清视觉稿下切图，使得图片兼容 Retain，在 CSS 中缩放；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">max-width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon</span> &#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">....</span>) no-repeat <span class="number">0</span> <span class="number">0</span>/cover;&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 简单方便；</span><br><span class="line">* 兼容第三方组件（echarts、mintUI...）；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 还原度不精确（如果以开发规范驱动设计就不会存在这个问题） --- 在分辨率不同的设备上，页面的字体大小，内容尺寸都是一样的，不同的是，大屏的内容间的空隙比小屏的大；</span><br></pre></td></tr></table></figure><h2 id="Layout-Viewport-Scale"><a href="#Layout-Viewport-Scale" class="headerlink" title="Layout Viewport Scale"></a>Layout Viewport Scale</h2><p>设计稿、页面布局、Layout Viewport 使用统一宽度，前端按设计稿的尺寸还原，使用定值单位（px、em…），利用浏览器『自身缩放』完成适配。Eg：<a href="http://c.3g.163.com/CreditMarket/default.html">网易新闻</a>。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 的宽度</li></ul><p>一般会设为 640。与流体式一样，这两种方案的核心都是视口的确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=设计稿的宽度&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该方案使用固定宽度值，需要考虑主流分辨率，确定一个合适的值，既不能选大了，也不能选小了，选大了可能会使得在小分辨率屏幕下像素丢失，选小了又可能会使得在大分辨率屏幕下模糊。</p><ul><li>步骤二，缩放</li></ul><p>正常浏览器都会将 <code>Layout Viewport</code> 自动缩放至屏内（视觉视口），不能自动缩放的浏览器要手动计算 scale 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> metaEle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>),</span><br><span class="line">    metaCon = metaEle ? metaEle.<span class="property">content</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    matchScale = metaCon.<span class="title function_">match</span>(<span class="regexp">/initial\-scale=([\d\.]+)/</span>),</span><br><span class="line">    matchWidth = metaCon.<span class="title function_">match</span>(<span class="regexp">/width=([^,\s]+)/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEle &amp;&amp; !matchScale &amp;&amp; (matchWidth &amp;&amp; matchWidth[<span class="number">1</span>] != <span class="string">&#x27;device-width&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> layoutViewportWidth = <span class="built_in">parseInt</span>(matchWidth[<span class="number">1</span>]),</span><br><span class="line">      screenWidth = screen.<span class="property">width</span>;</span><br><span class="line"></span><br><span class="line">    scale = screenWidth / layoutViewportWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      metaEle.<span class="property">content</span> += <span class="string">&#x27;,initial-scale=&#x27;</span> + scale + <span class="string">&#x27;,maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;, minimum-scale=&#x27;</span> + scale + <span class="string">&#x27;,user-scalable=no&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">viewport</span>();</span><br></pre></td></tr></table></figure><p>以下面动态生成的结果为例，640 是根据设计稿定下的，0.5(1&#x2F;dpr，或者 320&#x2F;640) 是根据屏幕宽度动态生成的。生成的 viewport 告诉浏览器网页的布局视口使用 640px，然后把页面缩放成 50%，图片、文字等等所有元素都被缩放在手机屏幕中，这是绝对的等比例缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 开发简单 --- 缩放交给浏览器，完全按视觉稿切图；</span><br><span class="line">* 还原精准 --- 绝对等比例缩放，可以精准还原视觉稿；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 像素丢失 --- 对于一些分辨率较低的手机，可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少；</span><br><span class="line">* 不兼容第三方组件和富文本数据 --- 这也是最大的问题；</span><br></pre></td></tr></table></figure><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p>“流体式”、“Layout Viewport Scale” 这两种适配方案，都存在缺陷，一个优秀的适配方案应做到以下两点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* UI 的精确还原与适配</span><br><span class="line">* 兼容第三方组件和富文本数据</span><br></pre></td></tr></table></figure><p>VW + Rem 就是这样的一个方案。其原理是，屏幕联动 html font-size vw，html font-size 联动 rem（ html font-size value &#x3D; 1 rem），来做到适配。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>定义规范</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设计规范。规定设计稿分辨率，推荐采用 1X 的设计方案（即手机 375，横屏 Pad 960，而不是 2X 的 750、1920），为了方便 figma 下，导入第三方 UI 组件</span><br><span class="line">* 基准值。规定屏幕分成 10 等分（100vw/10），html font-size 为 10vw，所以 1rem = 10vm</span><br></pre></td></tr></table></figure><p>将基准值的定义为 100vw&#x2F;10 &#x3D; 10vw，而不是 100px（除以 19.2、12.8），这仅仅是规范，10vw 体现适配原则，容易理解，而 100px 在没有转换工具的条件下，方便了计算。</p><p>在没有转换工具的情况下，为了方便计算，我们会将 html faont-size 定义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1920 的设计规范下还原的，base 为 1920px/19.2 = 100px，px 转 rem 除以 100 即可 */</span></span><br><span class="line"><span class="comment">/* calc(100vw/19.2) 不直接写成 10vw，是为了体现 1920 的设计规范 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>/<span class="number">19.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在源码里面进行转换不利于源码的维护，在现代前端开发中推荐使用工程化工具转换。</p><ul><li>使用步骤</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 步骤一：定义 html font-size 基准值（一般会定为 10vw，绝大多数适配场景都是按宽度适配，如果按高度适配也可为 10vh）</span><br><span class="line">* 步骤二：开发页面。页面在设计尺寸下开发（比如，平板 1920、手机 750），开发单位为 px</span><br><span class="line">* 步骤三：px 转 rem。这一步请用工具完成，转换算法为 px/基准值（1920 设计规范下是 192，750 设计稿是 75），一般会忽略 border，因为可能变成 0px</span><br></pre></td></tr></table></figure><ul><li>兼容处理</li></ul><p>vw 不支持 Android 4.4 以下设备，这时候就需要对 vw 做兼容处理了。这里不想通过 JS 来解决此问题，本着逐渐增强，平稳退化的原则，选一个默认分辨率处理，比如手机就选 750 的分辨率：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">37.5px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://github.com/amfe/lib-flexible">flexible</a> 就是手淘团队在 Android 4.4- 设备不支持 vw 时的一个 JS 解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(下) -- 视口</title>
      <link href="/2016/06/15/css/Pixel-Viewport-2/"/>
      <url>/2016/06/15/css/Pixel-Viewport-2/</url>
      
        <content type="html"><![CDATA[<p>视口（viewport）代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI（菜单栏等）。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><span id="more"></span><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>桌面浏览器中，视口的宽度与浏览器窗口的宽度一致，浏览器窗口就是约束 CSS 布局的视口，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度（超出部分将出现滚动条）。但是在移动端，情况就很复杂了。</p><p>在移动设备上，视口与屏幕宽度不再相关联，是完全独立的，浏览器厂商为了让传统的 PC 网页能够尽可能在移动设备上更多的展示，会把视口的宽度设置地很大（一般在 768px ~ 1024px 之间，Apple 是 980px），并且将其缩放在了屏幕（视觉视口）内。这个浏览器厂商定义的视口被称为“布局视口（Layout Viewport）”，网页的最大宽度是默认的 Layout Viewport 宽度，超出部分会出现滚动条。</p><p><img src="/images/css/layout-viewport.png" alt="layout viewport"></p><p>可通过 Meta Viewport 来设置布局视口，能设置的属性如下所示。</p><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>width</td><td>正整数或 device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或 device-height</td><td>定义视口的高度，单位为像素</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须小于或等于 maximum-scale 设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须大于或等于 minimum-scale 设置</td></tr><tr><td>user-scalable</td><td>yes&#x2F;no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS 中可通过 <code>document.documentElement.clientWidth / clientHeight</code> 获取布局视口的尺寸，CSS 中可设置 <code>html, body &#123;width: 100%&#125;</code>，通过测量 <code>body</code> 的宽度来验证默认布局视口大小。另外，CSS 中的媒体查询，查询的是布局视口的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 700px) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>用户在屏幕上能看到的网页区域被称为“视觉视口（Visual Viewport）” 。</p><p>视觉视口用于承载布局视口，其大小是视觉视口内 CSS 像素的总量，受浏览器缩放影响。用户可以在视觉视口中拖动或者缩放网页，来获得良好的浏览效果，如果用户缩小网站，视觉视口内 CSS 像素数量增多，视觉视口变大，看到的网站区域将变大，同理用户放大网站，视觉视口内 CSS 像素数量减少，视觉视口也变小，能看到的网站区域将缩小。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p><img src="/images/css/visual-viewport.png" alt="visual viewport"></p><p><code>window.innerWidth/innerHeight</code> 可以获取视觉视口的尺寸，大小是屏幕中 CSS 像素的数量。</p><h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><p>移动设备中默认 768px ~ 1024px 尺寸的布局视口对用户不友好，忽略了手机本身的尺寸，于是引入理想视口的概念。将布局视口的宽度设为屏幕的宽度，这样的布局视口被称为“理想视口（Idea Viewport）”。理想视口是移动设备上最佳的布局视口，理想视口下开发的页面不需要缩放就能够完美显示。</p><p>JS 中可通过 <code>screen.width/height</code> 获取理想视口的尺寸（有兼容性问题，可能返回的是设备像素尺寸）。将 Meta Viewport 设置如下就可以将布局视口设为理想视口了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实践中，还会设置缩放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 推荐的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0,viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>initial-scale</code>有一个隐藏的作用，它同时会将布局视口的尺寸设置为缩放后的尺寸，所以<code>initial-scale=1</code>与<code>width=device-width</code>的效果是一样的（不缩放又要求放进 Visual Layout 里，所以 <code>initial-scale=1</code> 与 <code>width=device-width</code> 等同）。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(上) -- 像素</title>
      <link href="/2016/06/10/css/Pixel-Viewport-1/"/>
      <url>/2016/06/10/css/Pixel-Viewport-1/</url>
      
        <content type="html"><![CDATA[<p>像素是影像显示的基本单位，其表现为一个个小方格。在 GUI 客户端软件开发中，像素是布局的基础，对于一个客户端开发者来说理解它很重要。其实存在两种像素，<a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html">此像素非彼像素</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设备像素</span><br><span class="line">* 设备独立像素</span><br></pre></td></tr></table></figure><span id="more"></span><p>设计师眼中的像素是设备像素，因为要考虑设计稿中非矢量元素（图片）在程序适配中的高保真，程序员眼中的像素是设备独立像素（Web 的 px，Android 的 dp，IOS 的 pt），因为要考虑适配。PC 时代的标准屏幕中，这两个像素是相等的，我们意识不到这个问题的存在，但是在高密度屏的移动时代就需要面对它了。</p><h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><p>设备像素（Device Pixels）又叫物理像素（Physical Pixel），一个设备像素是屏幕上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。跟设备像素相关概念有分辨率、屏幕尺寸、像素密度，这些参数在屏幕出厂时就固定下来了。以 iPhone 5 屏幕参数为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 屏幕分辨率 -- 640 x 1136</span><br><span class="line">* 屏幕尺寸 -- 4 英寸</span><br><span class="line">* 屏幕像素密度/解析度 -- 326dpi。</span><br></pre></td></tr></table></figure><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率可以细分为屏幕分辨率（显示分辨率）、图像分辨率、视频分辨率。其中，屏幕分辨率指一个屏幕具体由多少个像素点组成。<code>640 x 1136</code> 的屏幕分辨率指的是屏幕上水平有 640 个物理像素，垂直有 1136 个物理像素。常见分辨率中 4:3 有 <code>1024 x 768</code>、16:9 有 <code>1366 × 768</code>、<code>1920 × 1080</code>、<code>2560 x 1440</code>、<code>3860 × 2160</code>, 16:10 有 <code>1920 x 1200</code>。</p><p>也可以用 K 和 P 来描述分辨率，P 代表纵向的像素个数，K 代表横向有几个 1024 个像素。分辨率为 <code>1920 x 1080</code> 的屏幕就属于 1080P 屏幕（也被称为 FHD 全高清屏幕），横向像素超过 2048 的屏幕就属于 2K 屏，横向像素超过 4096 的屏幕就属于 4K 屏。</p><p>分辨率高不代表就清晰，还与尺寸有关，同一尺寸下分辨率越高就越清晰。</p><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸指的是屏幕对角线的物理长度，单位英寸。比如 iPhone 5 的屏幕尺寸为 4 英寸，MBP 的屏幕尺寸为 13.3 英寸。</p><h3 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h3><p>像素密度 (Pixels Per Inch) 指的是每英寸所拥有的像素数量，可用于描述屏幕的清晰度或图片的质量，单位是 ppi。理论上 PPI 越高，单位面积的像素数量就越多，画面会更细腻丰富清晰。屏幕的 PPI 可以通过屏幕分辨率和尺寸计算得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PPI = Math.sqrt(a ** 2 + b ** 2) / 4</span><br></pre></td></tr></table></figure><p>在桌面屏幕中，大部分的 PC 显示器和笔记本都还是普通密度的屏幕，不过像 Retina MBP（Apple 在 2012 年发布了第一款 Retina MBP）、2k 和 4k 这样一些高密度屏也很常见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 14 英寸笔记本（112ppi）</span><br><span class="line">Math.sqrt(1366 ** 2 + 768 ** 2) / 14;</span><br><span class="line">// 14 英寸笔记本（157ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 14;</span><br><span class="line">// 13.3 英寸 MBA (127ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 900 ** 2) / 13.3;</span><br><span class="line">// 23.8 英寸 PC 显示器（92ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 23.8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 13.3 英寸 MBP/Retina MBA (226ppi)</span><br><span class="line">Math.sqrt(2560 ** 2 + 1600 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K XPS (290ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2400 ** 2) / 15.6;</span><br><span class="line">// 13.5 英寸 Surface Book 3 (267ppi)</span><br><span class="line">Math.sqrt(2256 ** 2 + 1504 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K ThinkPad P1 (282ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2160 ** 2) / 15.6;</span><br></pre></td></tr></table></figure><p>在手机屏幕中，2010 年之前的手机分辨率都普遍低，比如，iPhone 3GS、诺基亚 5230、5800，随着智能手机发展，iPhone 4 使得智能手机进入了高密度屏时代，发布会上首次提出了 Retina Display 的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 3GS (164ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 480 ** 2) / 3.5;</span><br><span class="line">// 诺基亚 5230、5800 (223ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 640 ** 2) / 3.2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 4 (329ppi)</span><br><span class="line">Math.sqrt(640 ** 2 + 960 ** 2) / 3.5;</span><br><span class="line">// iPhone 11 (326ppi)</span><br><span class="line">Math.sqrt(828 ** 2 + 1792 ** 2) / 6.1;</span><br><span class="line">// 小米 10 (386ppi)</span><br><span class="line">Math.sqrt(1080 ** 2 + 2340 ** 2) / 6.67;</span><br><span class="line">// 华为 P40 Pro (440ppi)</span><br><span class="line">Math.sqrt(1200 ** 2 + 2640 ** 2) / 6.58;</span><br><span class="line">// 三星 Galaxy S20 (565ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 3200 ** 2) / 6.2;</span><br></pre></td></tr></table></figure><p><a href="https://support.apple.com/en-us/HT202471">Retina Display</a>（视网膜屏幕，视网膜显示器）指的是在正常视距内（iPhone 10inch，iPad 15inch）人睛不能分辨出单独像素显示效果的屏幕。为了达到这种显示效果，需要将更多的物理像素压缩进屏幕中，使屏幕成为高密度屏。</p><p>iPhone 4 发布会上，乔布斯表示当手持设备距人眼 10－12 英寸时，300ppi 是人类视力的极限，当像素密度超过 300ppi 时，人眼就无法区分出单独的像素，因此像素密度达到 329ppi 的 iPhone 4 具备非常优秀的显示功能，不会再出现颗粒感。在后来发布 The New iPad 时，Apple 更是对 Retina Display 给出了科学意义上的解释。</p><p><img src="/images/css/retina2.jpg" alt="retina display"></p><p>根据<a href="https://www.engadget.com/2012-03-01-retina-display-macs-ipads-and-hidpi-doing-the-math.html">上图</a>中视觉成像原理，能够非常容易得出下面这个三角函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tan(α/2) = h/2d</span><br><span class="line"></span><br><span class="line"># 变形公式</span><br><span class="line">α = 2tan^(-1)(h/2d) = 2arctan(h/2d)</span><br><span class="line">h = tan(α/2)*2d</span><br></pre></td></tr></table></figure><p>其中“α”代表视角，“d”代表视距，“h”代表像素间距（或一个像素的尺寸）。在对人类视力研究中发现（斯内伦测试 Snellen Test），正常人眼能辨识所视物的最小视角（识别极限，视敏度 <a href="https://baike.baidu.com/item/%E8%A7%86%E6%95%8F%E5%BA%A6">visual acuity</a>）是 1&#x2F;60 度（1 弧分度），1 弧分度数据主要基于斯内伦视力表中 20&#x2F;20 标准视力（等效于我国视力表中的 1.0）的统计样本，视力超常的（如 2.0 视力）个体无疑会有着更出色的视觉能力，能辨识所视物的最小视角会更小。</p><p>在正常视距下，当视角小于等于 1&#x2F;60 度时，即可以达到 Retina Display 的显示效果。α 大小取决于 d 和 h，而显示设备的使用视距一般是固定的，所以是否是 Retina Display 取决于 h。比如，在 10inch 的视距下，需要至少 343ppi，才能达到此显示效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">angle2rad</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * (<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="title class_">Math</span>.<span class="title function_">tan</span>(<span class="title function_">angle2rad</span>(<span class="number">1</span> / (<span class="number">2</span> * <span class="number">60</span>))) * <span class="number">2</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ppi = <span class="number">1</span> / h;  <span class="comment">// 343</span></span><br></pre></td></tr></table></figure><p>Retina Display 是 Apple 的商标，在安卓手机中没有此叫法，安卓手机中，屏幕根据 PPI 来划分为不同的等级。PPI 在 120 - 160 之间的手机被归为低密度手机，160 - 240 被归为中密度（Medium），240 - 320 被归为高密度（High），320 - 480 以上被归为超高密度，480 - 640 被归为超超高密度，640 以上被称为超超超高密度。</p><table><thead><tr><th></th><th>ldpi</th><th>mdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th><th>xxxhdpi</th></tr></thead><tbody><tr><td>密度分界</td><td>120</td><td>160</td><td>240</td><td>320</td><td>480</td><td>640</td></tr><tr><td>常见屏幕分辨率</td><td>240 * 320</td><td>320 * 480</td><td>480 * 850</td><td>640 * 960</td><td>1080 * 1920</td><td>1440 * 2560</td></tr><tr><td>默认缩放比例</td><td>0.75</td><td>1.0</td><td>1.5</td><td>2.0</td><td>3</td><td>4</td></tr></tbody></table><p>附：点密度 DPI (Dots Per Inch) 指的是每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点，图片像素点也可以是打印机的墨点，当 DPI 来描述图片和屏幕时，等价于 PPI，描述打印机时，表示打印机每英寸可以打印的点数，打印机的 DPI 越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。另外，PPI&#x2F;DPI 有时候也被称为分辨率，比如，打印分辨率、扫描分辨率。</p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><p>设备独立像素（Density-Independent Pixel）又叫逻辑像素、密度无关像素，简称为 dips，单位为 dp，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统按设备像素比转换为物理像素在屏幕上显示出来。Web 的 px、Android 的 dp、IOS 的 pt，都是对 dp 的实现，<code>1px = 1dp = 1pt</code>。</p><p>之所以使用抽象的设备独立像素而不直接使用设备像素，目的是为了适配，图形系统会自动将应用程序的抽象像素转换为适合于特定设备的物理像素。</p><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><p>在缩放程度为 100%，某一方向上（x 轴或 y 轴）物理像素和设备独立像素的比例叫做“设备像素比” (device pixel ratio)，单位 dpr。设备像素比定义了设备独立像素和设备像素的转换关系，决定了 GUI 软件的渲染尺寸，当处理标准显示器与 HiDPI 或 Rerina 显示器之间的差异时，这很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备像素比 = 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>在 JS 中 <code>window.devicePixelRatio</code> 得到，在 CSS 中，可以通过 <code>-webkit-device-pixel-ratio</code>，<code>-webkit-min-device-pixel-ratio</code> 和 <code>-webkit-max-device-pixel-ratio</code> 进行媒体查询。</p><p>设备独立像素和设备像素间的转换由两个条件决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 页面是否缩放</span><br><span class="line">* 设备像素比（屏幕是否为高密度或超高密度)</span><br></pre></td></tr></table></figure><p>页面放大，设备独立像素会跨越了更多的设备像素，缩小则相反。在排除页面缩放的情况下，他们的换算关系取决于设备像素比。比如，在 2dpr 的设备上，<code>1 个设备独立像素 = 4 个设备像素</code>，CSS 中的 <code>&#123;width: 200px&#125;</code> 需要由 800 个物理像素来显示（面积）。</p><p>在已知 dpr 和 ppi 的情况下，还可以将 dp 转为现实生活中的物理单位，比如, 在 2dpr、326ppi 下，<code>200dp = 400px = 1.23inch (400 / 326)</code>，于是 <code>1dp = 0.00615inch</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日期时间</title>
      <link href="/2016/04/08/javascript/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2016/04/08/javascript/%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="GMT、UTC、CST"><a href="#GMT、UTC、CST" class="headerlink" title="GMT、UTC、CST"></a>GMT、UTC、CST</h2><ul><li>GMT</li></ul><p>GMT (Greenwich Mean Time) 格林威治标准时间，指位于英国伦敦郊区的皇家格林威治天文台的标准时间，太阳每天经过家格林威治天文台的时间就是中午 12 点，本初子午线被定义为通过那里的经线。然而由于地球的不规则自转，导致 GMT 时间有误差，因此目前已不被当作标准时间使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toGMTString</span>()</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>UTC</li></ul><p>UTC (Coordinated Universal Time) 协调世界时间（世界标准时间、世界统一时间），是经过平均太阳时（以格林威治时间 GMT 为准）、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间。UTC 比 GMT 来得更加精准，其误差值必须保持在 0.9 秒以内，若大于 0.9 秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使 UTC 与地球自转周期一致。日常使用中，GMT 与 UTC 的功能与精确度是没有差别的。</p><p>GMT 是根据地球自转计算时间，而 UTC 是根据原子钟来计算时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toUTCString</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>() <span class="comment">// ISO 格式的 UTC 时间，toJSON 或 JSON.stringify 结果一样</span></span><br></pre></td></tr></table></figure><ul><li>地方时</li></ul><p>整个地球分为二十四时区，每个时区都有自己的本地时间，世界各国的本地时间的都是基于 UTC 的，规则为 <code>本地时间 = UTC + 偏移量 (时区差)</code>。比如，北京时间（CST，China Standard Time，古巴的标准时间和美国、澳大利亚中部时间也被称为 CST）采用东八区的地方时（<code>+0800</code>），即 <code>CST = UTC + 8</code>（北京时间是东经 120° 地方的地方时间，不是北京地方东经 116.4° 的时间），而英国伦敦的本地时与 GMT 和 UTC 相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>() <span class="comment">// RFC 2822 格式的本地时间</span></span><br></pre></td></tr></table></figure><h2 id="日期时间的表示标准"><a href="#日期时间的表示标准" class="headerlink" title="日期时间的表示标准"></a>日期时间的表示标准</h2><p>日期时间的表示标准有两种，分别是 <a href="https://www.w3.org/TR/NOTE-datetime">ISO 8601</a> 和 <a href="https://tools.ietf.org/html/rfc2822#page-14">RFC 2822</a>。前者是国际标准化组织的日期和时间表示方法，后者是 Internet 标准中关于电子邮件消息格式的标准，其中涵盖了日期时间标准。</p><h3 id="ISO-8601"><a href="#ISO-8601" class="headerlink" title="ISO 8601"></a>ISO 8601</h3><ul><li>格式</li></ul><p>年用 4 位表示，月、日用 2 位表示，时分秒用 2 位表示，时区用 4 位表示（或者 Z）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yyyy 年，比如：2016</span><br><span class="line">yyyy-mm 年月，比如：2016-03</span><br><span class="line">yyyy-mm-dd 年月日，比如：2016-03-08</span><br><span class="line">YYYY-MM-DDThh:mm:ss[.s]TZD 年月日时分秒，比如：2016-03-08T02:54:17.159Z</span><br></pre></td></tr></table></figure><p><code>T</code> 用来分割日期和时间，<code>.</code> 后面代表毫秒，<code>TZD</code> time zone designator 表示时区，值可以是 <code>Z</code>（代表 UTC 时间，即 0 时区时间）、<code>+hh:mm</code>、<code>-hh:mm</code>。如果不是 UTC 时间，比如北京时间，就需要表示为 <code>2016-03-25T06:26:01.927+08:00</code>。</p><ul><li>生成和解析</li></ul><p>JavaScript 中使用 <code>toISOString()</code>、<code>toJSON()</code>、<code>JSON.stringify()</code> 来生成 ISO 8601 格式的日期时间，使用 <code>new Date(dateString)</code> 来解析 IOS 8601 格式的时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>() <span class="comment">// 2016-03-08T02:54:17.159Z，注意这是 UTC 时间，不是本地时间</span></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2016-01-25T09:14:10.099+00:00&#x27;</span>) <span class="comment">// ISO 8601 时间格式是 UTC 时间（+00:00 表示 0 时区，跟 Z 一个概念），new Date 会自动处理为本地时区时间</span></span><br></pre></td></tr></table></figure><p>如果日期时间格式不带时区，则会以本地时区来解析。</p><p>注意：在 Chrome 中时区也可以用 <code>+0800</code> 这种 RFC2822 形式表示，然而 IE 和老的 iPhone 上不支持这种混搭写法，解析时会提示 <code>NaN</code> 异常，对于这个问题，要么后端返回标准的格式，要么前端纠正。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2016-01-25T09:14:10.099+0000&#x27;</span>).<span class="title function_">getTime</span>() <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 +0000 替换为 +00:00</span></span><br><span class="line"><span class="keyword">const</span> dateString = <span class="string">&#x27;2016-01-25T09:14:10.099+0000&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/([+-]\d&#123;2&#125;)(\d&#123;2&#125;)$/</span>, <span class="string">&#x27;$1:$2&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(dateString)</span><br></pre></td></tr></table></figure><p>注意：数据库应该始终存储 ISO 8601 格式的 UTC 日期时间，而不是本地时间，本地时间的转换交给客户端，以确保在不同地区的用户都能正确地看到适当的本地时间。</p><h3 id="RFC-2822"><a href="#RFC-2822" class="headerlink" title="RFC 2822"></a>RFC 2822</h3><ul><li>格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YYYY/MM/DD HH:MM:SS TZD(时区用4位数字表示)，比如：2016/03/08 02:54:17+0000</span><br><span class="line">[Wdy,] DD Mon YYYY HH:MM:SS TZD，比如：Fri Mar 08 2016 02:54:17 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure><p>RFC 2822 允许使用括号形式的注释。</p><ul><li>生成和解析</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>() <span class="comment">// Fri Jan 25 2016 17:14:10 GMT+0800 (中国标准时间)，返回的是 RFC 2822 格式的 LocalDate</span></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Fri Jan 25 2016 17:14:10 GMT+0800&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意：现代所有浏览器使用 <code>toString()</code> 生成日期时间，返回的都是 RFC 2822 格式，而 IE 返回的是 RFC-850&#x2F;1036 格式，另外在解析时，IE8 只支持 RFC 2822，不支持 ISO 8601。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>() <span class="comment">// IE：Fri Mar 8 17:44:13 UTC+0800 2016</span></span><br></pre></td></tr></table></figure><h2 id="Date-API"><a href="#Date-API" class="headerlink" title="Date API"></a>Date API</h2><p>JavaScript 中对日期时间的处理可以归结为解析、生成、计算和格式化这几方面。</p><h3 id="日期解析"><a href="#日期解析" class="headerlink" title="日期解析"></a>日期解析</h3><p>使用 <code>new Date</code> 解析日期时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(value) <span class="comment">// Unix 时间戳</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(datString) <span class="comment">// 符合 ISO 8601 标准或者 RFC 2822 标准的字符串时间</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(dateObject) <span class="comment">// Date 对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期验证</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isValidDate</span>(<span class="params">dateString</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dateObject = <span class="keyword">new</span> <span class="title class_">Date</span>(dateString)</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">isNaN</span>(dateObject.<span class="title function_">getTime</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isValidDate</span>(<span class="string">&#x27;2023-11-25&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isValidDate</span>(<span class="string">&#x27;invalid-date&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="日期生成"><a href="#日期生成" class="headerlink" title="日期生成"></a>日期生成</h3><ul><li>生成标准日期时间</li></ul><p><code>toISOString()、toJSON()、JSON.stringify()</code> 都能生成 ISO 8601 格式的 UTC 时间，<code>toString()</code> 会生成 RFC 2822 格式的本地时间。</p><p>需要说明一下 <code>JSON.stringify</code> 工作原理，<code>JSON.stringify</code> 在处理对象时，会调用该对象的 <code>toJSON</code> 方法，<code>Data.prototype.toJSON</code> 返回的是 ISO-8601 格式的 UTC 时间，而不是本地时间，结果比北京时间晚 8 小时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// 2016-03-08T02:54:17.159Z</span></span><br></pre></td></tr></table></figure><p>可以重载此方法，使其返回本地时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Date</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toJSON</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toLocaleString</span>() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o) <span class="comment">// 输出自定义的本地时间：“2016年6月11日 10:57:27”，与 toString 返回的数据一致</span></span><br><span class="line"></span><br><span class="line">o.<span class="title function_">toString</span>() <span class="comment">// 默认格式：“Wed Jun 11 2016 10:51:42 GMT+0800”</span></span><br></pre></td></tr></table></figure><p>对任何 Object 实例修改 <code>toJSON</code> 都会影响 <code>JSON.stringify</code> 的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toJSON</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;this is an instance of Foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="keyword">new</span> <span class="title class_">Foo</span>)</span><br></pre></td></tr></table></figure><ul><li>生成本地日期时间</li></ul><p><code>toLocaleString</code> 默认返回格式受浏览器或操作系统的语言设置影响，格式不统一，ES6 基于 <code>Intl</code> API 扩展了 <code>toLocaleString</code> 方法，可设置 option 参数统一格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">year</span>: <span class="string">&#x27;numeric&#x27;</span>,</span><br><span class="line">  <span class="attr">month</span>: <span class="string">&#x27;2-digit&#x27;</span>,</span><br><span class="line">  <span class="attr">day</span>: <span class="string">&#x27;2-digit&#x27;</span>,</span><br><span class="line">  <span class="attr">hour</span>: <span class="string">&#x27;2-digit&#x27;</span>,</span><br><span class="line">  <span class="attr">minute</span>: <span class="string">&#x27;2-digit&#x27;</span>,</span><br><span class="line">  <span class="attr">second</span>: <span class="string">&#x27;2-digit&#x27;</span>,</span><br><span class="line">  <span class="attr">hour12</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-CN&#x27;</span>, options).<span class="title function_">replace</span>(<span class="regexp">/\//g</span>, <span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>toLocaleDateString</code>、<code>toLocaleTimeString</code> 同理。</p><ul><li>获取 Unix 时间戳</li></ul><p>Unix 时间戳表示自 1970 年 1 月 1 日 00:00:00 UTC (Unix 纪元，Unix Epoch) 以来的毫秒数。在 JavaScript 中，有多种方法可以获取时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">valueOf</span>()</span><br><span class="line">+<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="title class_">Date</span>.<span class="title function_">parse</span>(dateString) <span class="comment">// 从一个字符串中读取日期，并且返回 Unix 时间戳，作用等同于 new Date(dateString).getTime()</span></span><br></pre></td></tr></table></figure><h3 id="日期计算"><a href="#日期计算" class="headerlink" title="日期计算"></a>日期计算</h3><ul><li>相对计算</li></ul><p><code>setDate</code> 方法根据本地时间来指定一个日期对象的天数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定日期之前或之后的日期</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSubtractDate</span>(<span class="params">subtractNum, date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(date)</span><br><span class="line">  d.<span class="title function_">setDate</span>(d.<span class="title function_">getDate</span>() + subtractNum)</span><br><span class="line">  <span class="keyword">return</span> d.<span class="title function_">toISOString</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSubtractDate</span>(-<span class="number">10</span>) <span class="comment">// 10 天前的日期</span></span><br><span class="line"><span class="title function_">getSubtractDate</span>(<span class="number">10</span>) <span class="comment">// 10 天后的日期</span></span><br><span class="line"><span class="title function_">getSubtractDate</span>(<span class="number">10</span>, <span class="string">&#x27;2016-04-08&#x27;</span>) <span class="comment">// 2016-04-08 10 天后的日期</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一周的开始日期</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStartOfWeek</span>(<span class="params">date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>(date)</span><br><span class="line">  <span class="keyword">const</span> dayOfWeek = today.<span class="title function_">getDay</span>()</span><br><span class="line">  <span class="keyword">const</span> startOfWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(today)</span><br><span class="line">  startOfWeek.<span class="title function_">setDate</span>(today.<span class="title function_">getDate</span>() - (dayOfWeek + <span class="number">6</span>) % <span class="number">7</span>) <span class="comment">// 调整到本周的第一天（星期一）</span></span><br><span class="line">  <span class="comment">// startOfWeek.setDate(today.getDate() - dayOfWeek) // 调整到本周的第一天（星期日）</span></span><br><span class="line">  <span class="keyword">return</span> startOfWeek</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一月的开始日期</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getStartOfMonth</span>(<span class="params">date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>(date)</span><br><span class="line">  <span class="keyword">const</span> startOfMonth = <span class="keyword">new</span> <span class="title class_">Date</span>(today.<span class="title function_">getFullYear</span>(), today.<span class="title function_">getMonth</span>(), <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> startOfMonth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setDate</code> 参数如果超出了月份的合理范围，会向上个月或下个月设置，<code>&lt;= 0</code> 时，会设置上个月的日期，<code>0</code> 是最后一天，<code>-1</code> 是倒数第二天，以此类推，超出范围的正整数同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">d.<span class="title function_">setDate</span>(<span class="number">0</span>)</span><br><span class="line">d <span class="comment">// 返回上个月最后一天日期</span></span><br></pre></td></tr></table></figure><p>可以利用这个特性来获取月份的天数和判断是否是闰年。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取月份天数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDaysInMonth</span>(<span class="params">year, month</span>) &#123;</span><br><span class="line">  <span class="comment">// new Date 第三个参数本质也是 setDate</span></span><br><span class="line">  <span class="comment">// JS 中 month 从 0 开始计算，n 月计算时实际上是 n-1 月，但由于 0 会往上一个月，所以此处无需 -1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, <span class="number">0</span>).<span class="title function_">getDate</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getDaysInMonth</span>(<span class="number">2017</span>, <span class="number">10</span>)   <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一年中所有月份天数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDaysInYear</span>(<span class="params">year</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> daysInMonth = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">12</span> &#125;, <span class="function">(<span class="params">_, month</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(year, month + <span class="number">1</span>, <span class="number">0</span>).<span class="title function_">getDate</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> daysInMonth</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getDaysInYear</span>(<span class="number">2016</span>) <span class="comment">// [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</span></span><br></pre></td></tr></table></figure><p>一年中除了 2 月，其它所有月份天数都是固定的，1、3、5、7、8、10、12 月，有 31 天，4、6、9、11 月，有 30 天。2 月通常有 28 天，然而，为了与地球公转周期相匹配，每四年有一个闰年，百年不闰，四百年再闰，这时 2 月有 29 天。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否是闰年</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isLeapYear</span>(<span class="params">year</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 2 月份天数是否为 29 来判断是否为闰年</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isLeapYear</span>(<span class="params">year</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(year, <span class="number">2</span>, <span class="number">0</span>).<span class="title function_">getDate</span>() === <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isLeapYear</span>(<span class="number">2000</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>一个闰年是能被 4 整除，但是不能被 100 整除，或者能被 400 整除的年份。例如，2016 年时闰年（能被 4 整除，但是不能被 100 整除），2000 年是闰年（能被 400 整除），而 1900年不是闰年（能被 4 整除、能被 100 整除，但不能被 400 整除）。</p><p>注意：当在同一个 <code>Date</code> 对象上连续执行 <code>setDate</code> 操作时，下一个 <code>setDate</code> 会在上一个 <code>setDate</code> 结果上进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">d.<span class="title function_">setDate</span>(<span class="number">0</span>)</span><br><span class="line">d  <span class="comment">// 2 月 28</span></span><br><span class="line"></span><br><span class="line">d.<span class="title function_">setDate</span>(-<span class="number">1</span>)</span><br><span class="line">d <span class="comment">// 在 2 月 28 基础上 setDate，结果返回 1 月 30</span></span><br></pre></td></tr></table></figure><ul><li>差异计算</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dateFrom = <span class="string">&#x27;2016-04-08T00:00:00Z&#x27;</span></span><br><span class="line"><span class="keyword">const</span> datefromTS = (<span class="keyword">new</span> <span class="title class_">Date</span>(dateFrom)).<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> nowTS = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="keyword">const</span> diff = <span class="title class_">Math</span>.<span class="title function_">abs</span>(datefromTS - nowTS)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Math.round 代替 Math.floor 来考虑某些 DST 情况</span></span><br><span class="line"><span class="comment">// 每天的毫秒数 = 24 小时/天 * 60 分钟/小时 * 60 秒/分钟 * 1000 毫秒/秒</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>(diff / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>  * <span class="number">24</span>))</span><br></pre></td></tr></table></figure><ul><li>比较大小</li></ul><p>日期对象支持 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 比较，但由于引用类型的缘故，不支持 <code>==</code> 比较，比较日期字符串也不靠谱，同一个日期在不同日期格式下显然无法对比，所以最好的办法是对比时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 08, 2016&#x27;</span>) &lt; <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 09, 2016&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 08, 2016&#x27;</span>) == <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 08, 2016&#x27;</span>) <span class="comment">// false，理性应该返回 true</span></span><br><span class="line"><span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()&#125;</span>-<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getMonth() + <span class="number">1</span>&#125;</span>-<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getDate()&#125;</span>`</span> == <span class="string">&#x27;2016-12-25&#x27;</span> <span class="comment">// 判断是否今天是否是圣诞节</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 08, 2016&#x27;</span>).<span class="title function_">getTime</span>() == <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Apr 08, 2016&#x27;</span>).<span class="title function_">getTime</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>虽然 ES6 中可通过 <code>Intl.DateTimeFormat</code> 对日期时间格式化，但这个方自定义格式选项不足，开发中还是需要手动实现格式化方法。下面简单实现格式化 <code>YYYY-MM-DDThh:mm:ss</code>、<code>YYYY/MM/DDThh:mm:ss</code> 和相对时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padZero</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;0&#x27;</span> + s).<span class="title function_">slice</span>(-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> date = d.<span class="title function_">getFullYear</span>() + <span class="string">&#x27;-&#x27;</span> + <span class="title function_">padZero</span>(d.<span class="title function_">getMonth</span>() + <span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span> + <span class="title function_">padZero</span>(d.<span class="title function_">getDate</span>())</span><br><span class="line">date += <span class="string">&#x27; &#x27;</span></span><br><span class="line">date += <span class="title function_">padZero</span>(d.<span class="title function_">getHours</span>()) + <span class="string">&#x27;:&#x27;</span> + <span class="title function_">padZero</span>(d.<span class="title function_">getMinutes</span>()) + <span class="string">&#x27;:&#x27;</span> + <span class="title function_">padZero</span>(d.<span class="title function_">getSeconds</span>())</span><br><span class="line">date <span class="comment">// 2016-04-08 09:12:53</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="comment">// 使用 join 做字符串拼接，正则补零</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">const</span> date = [</span><br><span class="line">  [d.<span class="title function_">getFullYear</span>(), d.<span class="title function_">getMonth</span>() + <span class="number">1</span>, d.<span class="title function_">getDate</span>()].<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">  [d.<span class="title function_">getHours</span>(), d.<span class="title function_">getMinutes</span>(), d.<span class="title function_">getSeconds</span>()].<span class="title function_">join</span>(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">].<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/(?=\b\d\b)/g</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">date <span class="comment">// 2016-04-08 09:25:01</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 toISOString</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">d.<span class="title function_">setMinutes</span>(d.<span class="title function_">getMinutes</span>() - d.<span class="title function_">getTimezoneOffset</span>()) <span class="comment">// 处理时区偏移</span></span><br><span class="line"><span class="keyword">const</span> date = d.<span class="title function_">toISOString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">5</span>).<span class="title function_">replace</span>(<span class="regexp">/[T]/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">date <span class="comment">// 2016-04-08 09:30:15</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatDateTime</span>(<span class="params">date, format</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> year = date.<span class="title function_">getFullYear</span>()</span><br><span class="line">  <span class="keyword">const</span> month = <span class="title function_">padZero</span>(date.<span class="title function_">getMonth</span>() + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> day = <span class="title function_">padZero</span>(date.<span class="title function_">getDate</span>())</span><br><span class="line">  <span class="keyword">const</span> hours = <span class="title function_">padZero</span>(date.<span class="title function_">getHours</span>())</span><br><span class="line">  <span class="keyword">const</span> minutes = <span class="title function_">padZero</span>(date.<span class="title function_">getMinutes</span>())</span><br><span class="line">  <span class="keyword">const</span> seconds = <span class="title function_">padZero</span>(date.<span class="title function_">getSeconds</span>())</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;yyyy&#x27;</span>, year)</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;MM&#x27;</span>, month)</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;dd&#x27;</span>, day)</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;HH&#x27;</span>, hours)</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;mm&#x27;</span>, minutes)</span><br><span class="line">  format = format.<span class="title function_">replace</span>(<span class="string">&#x27;ss&#x27;</span>, seconds)</span><br><span class="line">  <span class="keyword">return</span> format</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">formatDateTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)</span><br><span class="line"><span class="title function_">formatDateTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&#x27;yyyy/MM/dd HH:mm:ss&#x27;</span>)</span><br><span class="line"><span class="title function_">formatDateTime</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&#x27;HH:mm:ss&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间戳</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUnix</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> date.<span class="title function_">getTime</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取今天 0 点 0 分 0 秒的时间戳</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTodayUnix</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  date.<span class="title function_">setHours</span>(<span class="number">0</span>)</span><br><span class="line">  date.<span class="title function_">setMinutes</span>(<span class="number">0</span>)</span><br><span class="line">  date.<span class="title function_">setSeconds</span>(<span class="number">0</span>)</span><br><span class="line">  date.<span class="title function_">setMilliseconds</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> date.<span class="title function_">getTime</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getDate</span> = time =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(time)</span><br><span class="line">  <span class="keyword">const</span> month = <span class="string">`0<span class="subst">$&#123;date.getMonth() + <span class="number">1</span>&#125;</span>`</span>.<span class="title function_">slice</span>(-<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> day = <span class="string">`0<span class="subst">$&#123;date.getDate()&#125;</span>`</span>.<span class="title function_">slice</span>(-<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> date.<span class="title function_">getFullYear</span>() + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化相对时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getFormatTime</span> = fromTS =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> nowTS = <span class="title function_">getUnix</span>() <span class="comment">// 当前时间戳</span></span><br><span class="line">  <span class="keyword">const</span> todayTS = <span class="title function_">getTodayUnix</span>() <span class="comment">// 今天 0 点时间戳</span></span><br><span class="line">  <span class="keyword">const</span> diff = (nowTS - fromTS) / <span class="number">1000</span> <span class="comment">// 转换为秒级时间戳</span></span><br><span class="line">  <span class="keyword">let</span> tip = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tip = <span class="string">&#x27;刚刚&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / <span class="number">60</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tip = <span class="string">&#x27;刚刚&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &lt; <span class="number">3600</span>) &#123;</span><br><span class="line">    tip = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / <span class="number">60</span>) + <span class="string">&#x27;分钟前&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= <span class="number">3600</span> &amp;&amp; fromTS - todayTS &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tip = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / <span class="number">3600</span>) + <span class="string">&#x27;小时前&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff / <span class="number">86400</span> &lt;= <span class="number">31</span>) &#123;</span><br><span class="line">    tip = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(diff / <span class="number">86400</span>) + <span class="string">&#x27;天前&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tip = <span class="title function_">getDate</span>(fromTS)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Temporal-API"><a href="#Temporal-API" class="headerlink" title="Temporal API"></a>Temporal API</h2><p>Date API 设计存在问题，计算 API 缺失，日期时间计算需要手动实现，只支持 UTC 和用户 PC 时间，不支持非公历，开发中一般需要通过 moment、dayjs 这样一些第三方库使用。为了解决 Date API 的问题，TC39 提出了新的日期时间 API <a href="https://github.com/tc39/proposal-temporal">Temporal</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">仅可以创建和处理不可变 Temporal 对象</span><br><span class="line">提供用于日期和时间计算的简单 API</span><br><span class="line">支持所有时区</span><br><span class="line">从 ISO-8601 格式进行严格的日期解析</span><br><span class="line">支持非公历</span><br></pre></td></tr></table></figure><p>截止 2022 年 2 月，该 API 尚处 Stage 3 阶段。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异步编程</title>
      <link href="/2016/04/02/javascript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2016/04/02/javascript/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>异步使 JavaScript 这个单线程语言在不阻塞的情况下可以并行的执行多任务，这带来了性能的极大提升，然而异步风格也给流程控制，错误处理带来了更多的麻烦。</p><p>本文介绍处理异步的 5 种方式，Callback、Event、Promise、Generator、Async&#x2F;Await。</p><span id="more"></span><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p>回调是 JavaScript 的基础，函数可以作为参数传递并在恰当的时机执行，比如有下面的两个函数 <code>f1</code> <code>f2</code>，如果 <code>f1</code> 中存在异步操作，比如 <code>ajax</code> 请求，并且 <code>f2</code> 需要在 <code>f1</code> 执行完毕之后执行，使用回调的方式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo1</span> = (<span class="params">cb</span>) =&gt; &#123;</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      cb &amp;&amp; <span class="title function_">cb</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something after foo1 complete ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo1</span>(foo2)</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>通过回调来处理异步简单方便，但是它的缺点也很明显，可读性差，难以并发控制，难以错误处理。</p><ul><li>Callback Hell</li></ul><p>多层回调函数的嵌套形成了强耦合，流程难以管理，代码风格丑陋，陷入回调函数地狱 Callback Hell。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo1</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">foo2</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">foo3</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">foo4</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">foo5</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">foo6</span>(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// maybe more ...</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Release Zalgo</li></ul><p>可能同步也可能异步调用的回调以及包裹它的函数， 被称作是 “Zalgo” (魔鬼)，而编写这种函数的行为被称作是 “release Zalgo” (将 Zalgo 释放出来了)。因为函数的调用时间是不确定，导致行为难以预测。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  a = data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 正常应该打印 1，但是由于 foo 调用时机不确定性，还可能打印 2</span></span><br></pre></td></tr></table></figure><ul><li>异常不能被捕获</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">  <span class="comment">// 不能捕获</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try...catch</code> 只能捕获同步的异常，不能捕获异步异常。异常不能被捕获会报 <code>Uncaught Error: fail</code> 或 <code>Uncaught (in promise) fail</code> 错误。只能在异步函数内部处理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">      a = <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>另一种解决异步流程控制的传统解决方法是事件，事件驱动不但可以用于处理用户交互、也可以用来处理通信。发布订阅模式和观察者模式都是 Event 模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    <span class="title class_">Event</span>.<span class="title function_">trigger</span>(<span class="string">&#x27;loaded&#x27;</span>, argvs)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听/订阅</span></span><br><span class="line"><span class="title class_">Event</span>.<span class="title function_">on</span>(<span class="string">&#x27;loaded&#x27;</span>, <span class="function">(<span class="params">argvs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Web API 中内置了许多标准化事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Event 的缺点也很明显，事件的监听和触发散落在不同的地方，程序趋于复杂之后，复杂度也极大提高。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>在 ES6 Promise 未出现前，为了优雅的解决异步流程控制的问题，社区产出了很多方案，比如 co、async 等。</p><h3 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h3><p>&#x2F;&#x2F; <a href="https://juejin.cn/post/7263089207128850489">https://juejin.cn/post/7263089207128850489</a><br>&#x2F;&#x2F; <a href="https://blog.csdn.net/m0_58016522/article/details/119443440">https://blog.csdn.net/m0_58016522/article/details/119443440</a></p><ul><li>串行</li></ul><p>链式串行：</p><p><code>then</code>、<code>catch</code>、<code>finally</code> 方法会隐式返回一个新的 <code>Promise</code> 对象，也可显式的返回 <code>Promise</code> 对象，如果返回的是一个非 <code>Promise</code> 对象，这会被当作新 <code>Promise</code> 的 <code>resolve</code>。这也是 <code>Promise</code> 能够链式调用的原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>)  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo3</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">500</span>)  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo1: &#x27;</span>, result1)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo2</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo2: &#x27;</span>, result2)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo3</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo3: &#x27;</span>, result3)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error occurred: &#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><code>reduce</code> 串行：</p><p><code>reduce</code> 串行是链式串行的简化，本质上还是链式串行，<code>reduce</code> 本身是同步执行的，每次 <code>reduce</code> 返回的值都会作为下次 <code>reduce</code> 回调函数的第一个参数，利用这个特性，可在内存中构造出上述 <code>Promise</code> 执行队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooList = [<span class="function">() =&gt;</span> <span class="title function_">foo1</span>(), <span class="function">() =&gt;</span> <span class="title function_">foo2</span>(), <span class="function">() =&gt;</span> <span class="title function_">foo3</span>()]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数展开其实就是上面的 Promise 执行队列</span></span><br><span class="line"><span class="keyword">const</span> finallyPromise = fooList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">item</span>())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() <span class="comment">// 创建一个初始 Promise，用于链接数组内的 Promise</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">finallyPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt; Result: &#x27;</span>, res)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述代码虽然能串行，但是只返回最后一个 Promise 的结果，可将所有结果累积起来，在最后一个 Promise 返回</span></span><br><span class="line"><span class="keyword">const</span> finallyPromise = fooList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc.<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span></span><br><span class="line">    <span class="title function_">item</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> results.<span class="title function_">concat</span>(result))</span><br><span class="line">  );</span><br><span class="line">&#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]))</span><br></pre></td></tr></table></figure><p><code>await</code> 串行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooList = [<span class="function">() =&gt;</span> <span class="title function_">foo1</span>(), <span class="function">() =&gt;</span> <span class="title function_">foo2</span>(), <span class="function">() =&gt;</span> <span class="title function_">foo3</span>()]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> fooItem <span class="keyword">of</span> fooList) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fooItem</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt; Result: &#x27;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>并行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getPlayUrlList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ids = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getPlayUrl</span> = (<span class="params">id</span>) =&gt; <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">`https://zxxxx.com/<span class="subst">$&#123;id&#125;</span>.mp4`</span>)</span><br><span class="line">  <span class="keyword">const</span> promiseList = ids.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">getPlayUrl</span>(item))</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promiseList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">getPlayUrlList</span>()</span><br></pre></td></tr></table></figure><p>并发数控制，参考 <a href="https://github.com/sindresorhus/p-queue">p-queue</a>、<a href="https://github.com/sindresorhus/p-limit">p-limit</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认下每组完成后再进行下一组，也可以自定义分组间隔时间</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">executeTasksWidthConcurrency</span>(<span class="params">tasks, concurrency, interval = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> results = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tasks.<span class="property">length</span>; i += concurrency) &#123;</span><br><span class="line">    <span class="keyword">const</span> group = tasks.<span class="title function_">slice</span>(i, i + concurrency);</span><br><span class="line">    <span class="keyword">const</span> groupResults = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(group.<span class="title function_">map</span>(<span class="function">(<span class="params">task</span>) =&gt;</span> <span class="title function_">task</span>()))</span><br><span class="line">    results.<span class="title function_">push</span>(...groupResults)</span><br><span class="line">    <span class="comment">// 当前组的任务执行完成后，如果还有更多的任务，则等待指定的 interval 时间后再执行下一组任务，相当于 sleep</span></span><br><span class="line">    <span class="keyword">if</span> (i + concurrency &lt; tasks.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, interval))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ids = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> fetchList = ids.<span class="title function_">map</span>(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/?id=<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">executeTasksWidthConcurrency</span>(fetchList, <span class="number">2</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt; Result: &#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>在一个 <code>Promise</code> 链中，错误会找到后续链中最近的一个 <code>catch</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个链中 3，4 步骤会被跳过，但 catch 过后的 then 依然可以正常执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err1&#x27;</span>, err))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err2&#x27;</span>, err))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;all done&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.all</code> 中有一个 <code>Promise</code> 实例出现异常，都会导致全部结果被丢弃。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)) <span class="comment">// 只能 `catch` 错误 3，其他结果被丢弃</span></span><br></pre></td></tr></table></figure><p>如果想要所有结果，可 <code>catch</code> <code>reject</code> 返回新的 <code>promise</code> <code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> err),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">5</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可使用 map 批量 catch</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">arr</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br></pre></td></tr></table></figure><h3 id="改造-Sub-Pub-模型"><a href="#改造-Sub-Pub-模型" class="headerlink" title="改造 Sub-Pub 模型"></a>改造 Sub-Pub 模型</h3><p>使用 <code>Promise</code> 将发布订阅模型 Request-Response 模型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseMap = &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseMap.<span class="property">a</span> = &#123;</span><br><span class="line">      resolve,</span><br><span class="line">      reject</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  promiseMap.<span class="property">a</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅被触发时，resolve 被执行</span></span><br><span class="line"><span class="title function_">send</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&gt;&gt;&gt; res&#x27;</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">send</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="comment">// 实际上是以下的简写</span></span><br><span class="line">ws.<span class="title function_">send</span>()</span><br><span class="line">ws.<span class="title function_">onNoify</span>(<span class="string">&#x27;eventName&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>ws promise 封装，和 jsBridge 封装</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>相比传统的 <code>Callback</code>，<code>Promise</code> 虽然解决了 Callback Hell 的问题，但是仍需要 <code>then</code> 方法注册回调，虽然只有一层，但是多个任务队列时，<code>Promise</code> 链会显得冗长，不容易理解和维护。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo1: &#x27;</span>, result1)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo2</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo2: &#x27;</span>, result2)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo3</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Result from foo3: &#x27;</span>, result3)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error occurred: &#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><code>Generator</code> 函数是一个状态机，封装了多个内部状态。形式上，<code>Generator</code> 函数是一个普通函数，但是有两个特征。一是，<code>function</code> 关键字与函数名之间有一个星号，二是，函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态，<code>yield</code> 是暂停执行的标记。</p><p>执行 <code>Generator</code> 函数会返回一个遍历器对象（Iterator Object），该函数内部此时并不执行，使用该遍历器对象的 <code>next()</code> 方法，可以遍历 <code>Generator</code> 函数内部的每一个状态，直到 <code>return</code> 语句。</p><p><code>next()</code> 方法遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式。如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值。如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>()</span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">geneDemo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">yield</span> <span class="string">&#x27;c&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c:&#x27;</span>, c)</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">yield</span> <span class="string">&#x27;d&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;d:&#x27;</span>, d)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">geneDemo</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.<span class="title function_">next</span>(<span class="string">&#x27;e1&#x27;</span>, <span class="string">&#x27;e2&#x27;</span>)  </span><br><span class="line"><span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> r3 = g.<span class="title function_">next</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r1:&#x27;</span>, r1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r2:&#x27;</span>, r2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r3:&#x27;</span>, r3)</span><br></pre></td></tr></table></figure><p>在异步中的应用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">rep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rep)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">rep</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rep)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p><code>Generator</code> 不自带执行器，默认情况下异步请求的返回值不能作为 <code>yield</code> 的返回值，必须依靠执行器才能执行（如 <code>co</code>），执行器可以自动调用 <code>next</code>，并将上一个请求的返回值作为参数传进 <code>next</code> 中。</p><h2 id="Async、Await"><a href="#Async、Await" class="headerlink" title="Async、Await"></a>Async、Await</h2><p>ES2017 标准引入了 <code>async</code> 函数，使得异步操作变得更加方便。<code>async</code> 函数返回一个 <code>Promise</code> 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成（await 的那个函数调用），再接着执行函数体内后面的语句，async 函数内部 return 语句相当于 Promise 函数的 resolve。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 默认一个 Promise 对象</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">foo</span>()  <span class="comment">// Promise</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到 await 就会先返回，后面的代码待异步操作完成后执行</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rep = <span class="keyword">await</span> <span class="variable constant_">API</span>.<span class="property">User</span>.<span class="title function_">getUserInfo</span>()</span><br><span class="line">  <span class="keyword">return</span> rep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async</code> 默认隐式返回 <code>Promise</code>，<code>return</code> 其实是 <code>resolve</code>，要想 <code>reject</code>，<code>return Promise.reject()</code> 即可</p><p>可以通过 Promise.reject() 或 throw new Error() 处理 resolve 和 reject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (param === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>() <span class="comment">// reject 返回的是 Promise，所以需要 await</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(d, <span class="number">223</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>asnyc&#x2F;await 是 Generator 函数的语法糖，号称是异步的终极解决方案。上面 Generator 中的函数 gen 改写成 async 函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。具体的改进包括：内置执行器、更好的语义、更广的适用性、返回值是 Promise。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>异步同步化</li></ul><p>异步同步化，处理了 Callback Hell 和 Promise 链问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">login</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$API</span>.<span class="property">Auth</span>.<span class="title function_">login</span>(params);</span><br><span class="line">  token.<span class="property">timestamp</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="property">token</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可被 <code>try...catch</code></li></ul><p>异步代码同步化后，就可以使用 <code>try...catch</code> 了。但是需要注意的是只能 catch reject，不能 catch 显式的 throw 异常或隐式的执行异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;fail&#x27;</span>);  <span class="comment">// throw new Error(&#x27;fail&#x27;)</span></span><br><span class="line">&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">doSomething</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// fail</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><p>下面的错误就只能在同步中才能 catch 到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式 throw </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式执行异常</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：大部分情况下请求异常会提前拦截处理（只需提示），不需要在各个业务里面处理，不过也有特例，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">handleSwitchActivityState</span>(<span class="params">activity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> enable = activity.<span class="property">isEnable</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$API</span>.<span class="property">Coupon</span>.<span class="title function_">switchActiveState</span>(activity.<span class="property">activityId</span>, enable);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getActivityList</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    activity.<span class="property">isEnable</span> = !activity.<span class="property">isEnable</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，为了防止项目中 <code>try catch</code> 导致代码可读性问题，可采用以下方式更优雅的处理 <code>async</code> 异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">foo</span>().<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 `promise` 将 `reject` 转为 `resolve`</span></span><br><span class="line"><span class="title function_">handlePromise</span>(<span class="params">promise</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> promise.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data]).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> [err])</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> [err]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [err, res] = <span class="keyword">await</span> <span class="title function_">handlePromise</span>(foo)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法问题</title>
      <link href="/2016/01/11/algorithm/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/"/>
      <url>/2016/01/11/algorithm/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/rep/algorithm/%E9%B8%A1%E5%85%94%E5%90%8C%E7%AC%BC.html">鸡兔同笼</a></li><li><a href="/rep/algorithm/%E7%8C%B4%E5%AD%90%E5%90%83%E6%A1%83.html">猴子吃桃</a></li><li><a href="/rep/algorithm/%E7%99%BE%E9%92%B1%E4%B9%B0%E7%99%BE%E9%B8%A1.html">百钱买百鸡</a></li><li><a href="/rep/algorithm/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF.html">约瑟夫环</a></li><li><a href="/rep/algorithm/%E5%85%94%E5%AD%90%E7%B9%81%E6%AE%96%E9%97%AE%E9%A2%98.html">兔子繁殖问题</a></li></ol><p>备注：各院校 OJ 系统，<a href="http://acm.ustc.edu.cn/ustcoj/">中科大</a>、<a href="http://acm.zju.edu.cn/onlinejudge/">浙大</a>、<a href="https://dsa.cs.tsinghua.edu.cn/oj/">清华</a>、<a href="https://acm.sjtu.edu.cn/OnlineJudge/">上海交大</a>、<a href="http://acm.hdu.edu.cn/">杭电</a>、<a href="http://acm.zzuli.edu.cn/">郑州轻工业学院</a>、<a href="http://acm.hi-54.com/index.php">郑州师范学院</a>、<a href="https://vjudge.net/">Virtual Judge</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Guide</title>
      <link href="/2015/07/01/engineering/Git-Guide/"/>
      <url>/2015/07/01/engineering/Git-Guide/</url>
      
        <content type="html"><![CDATA[<p>Git 是一个分布式版本控制系统，对比 SVN 这类集中式版本控制系统，分布式版本控制系统可以完全去中心化工作，无需与远程中央服务器通信，在本地即可进行全部版本控制操作，即便是离线。</p><span id="more"></span><p>Git 使用指针管理分支，分支是指针指向某次提交，而 SVN 中的分支则是目录的拷贝，这使得 Git 拥有强大的分支管理能力，分支的切换、合并和删除等操作更迅速和灵活。Git 的提交采用快照机制来存储文件的状态，快照存储相对于 SVN 的差异存储，不需要重新计算差异或补丁，这意味着在提交、分支切换或版本回滚等操作时，效率更高，操作也更为高效和可靠。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="三大分区"><a href="#三大分区" class="headerlink" title="三大分区"></a>三大分区</h3><p>Git 项目一共有三大分区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Workspace/Working Tree/Working Directory：工作区</span><br><span class="line">* Index/Stage：暂存区、索引</span><br><span class="line">* Repository/Git Directory：版本库、仓库、资源库、Git 目录</span><br></pre></td></tr></table></figure><ul><li>工作区</li></ul><p>工作区是当前正在编辑和修改的项目目录，它包含了实际的项目文件。</p><p>暂存区是一个中间区域（在 .git&#x2F;index 文件中），用于暂时存放想要提交到版本库的更改，在 commit 之前，可以选择将工作区中的文件添加到暂存区。</p><ul><li>暂存区</li></ul><p>暂存区设计目的是提供更灵活的版本控制和工作流程。通过暂存区，开发者可以实现选择修改、组织修改、撤销修改。选择要提交的特定文件或文件某次特定修改，将多个相关的修改组织在一起提交，无需频繁地提交，另外，暂存区内的修改可随时撤销，而不会产生提交历史记录。</p><ul><li>版本库</li></ul><p>版本库是 Git 的核心部分（在 .git 目录下），它存储了项目的完整历史记录。版本库包含了所有的提交记录、分支、标签等信息。每次提交更改时，Git 会将暂存区的内容保存为一个新的提交，并更新版本库。</p><p><img src="/images/engineering/git/areas.png" alt="Git Flow 流程图"></p><p>这三大分区也对应着三种状态，分别是 untrack 和 modified、staged、committed。Git 基本的工作流程是，在工作区中修改文件，<code>git add</code> 将想要下次提交的更改选择性地暂存，<code>git commit</code> 提交更改，找到暂存区的文件，将快照永久性存储到 Git 目录。<code>git add</code> 让文件进入 staged，<code>git commit</code> 让文件进入 committed。</p><h3 id="Git-对象"><a href="#Git-对象" class="headerlink" title="Git 对象"></a>Git 对象</h3><p>Git Object 位于 .git&#x2F;objects 目录下，一共有三种对象类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* blob object: 数据对象</span><br><span class="line">* tree object: 树对象</span><br><span class="line">* commit object: 提交对象</span><br></pre></td></tr></table></figure><p>每个 Git Object 都有一个唯一的 object id (由 SHA-1 生成，40 位，分为 blob id、tree id、commit id)，这也是 object 在 Git 仓库中的唯一身份证，所有类型的 object 文件名都以 object id 命名。</p><ul><li>Blob Object</li></ul><p>blob object 存储的是文件的具体内容，对文件内容及 mate 信息做 SHA-1 计算，得到一个 blob id，通过这个 id 就能找到文件内容。</p><p>当对工作区修改或新增的文件执行 <code>git add</code> 时，文件内容被写入到对象库中的一个新的 blob object 中，而暂存区的目录树被更新，该对象的 id 被记录在暂存区的文件索引中。</p><p>以如下 Git 项目为例，Git 项目目录结构、暂存区内容以及 <code>.git/objects/</code> 目录结构分别如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree .</span><br><span class="line">.</span><br><span class="line">├── a.txt</span><br><span class="line">└── children</span><br><span class="line">    └── b.txt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --stage</span><br><span class="line">100644 9d07aa0df55c353e18eea6f1b401946b5dad7bce 0       a.txt</span><br><span class="line">100644 6dd90d24d319b452859920bf74120405fcdaa017 0       children/b.txt</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree .git/objects/</span><br><span class="line">.git/objects/</span><br><span class="line">├── 6d</span><br><span class="line">│   └── d90d24d319b452859920bf74120405fcdaa017</span><br><span class="line">├── 9d</span><br><span class="line">│   └── 07aa0df55c353e18eea6f1b401946b5dad7bce</span><br></pre></td></tr></table></figure><p><code>cat</code> object 文件返回结果是乱码，因为 Git 将信息压缩成二进制文件，需要通过 <code>git cat-file [-t] [-p]</code> 查看，<code>-t</code> 可以查看 object 的类型，<code>-p</code> 可以查看 object 储存的具体内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .git/objects/6d/d90d24d319b452859920bf74120405fcdaa017 <span class="comment"># 乱码 xK□□OR0f022□□</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 9d07 <span class="comment"># blob</span></span><br><span class="line">git cat-file -p 9d07 <span class="comment"># 111</span></span><br><span class="line"></span><br><span class="line">git cat-file -t 6dd9 <span class="comment"># blob</span></span><br><span class="line">git cat-file -p 6dd9 <span class="comment"># 222</span></span><br></pre></td></tr></table></figure><ul><li>Tree Object 和 Commit Object</li></ul><p>tree object 存储的内容是一个目录的快照，包括文件&#x2F;文件夹的权限、类型、内容对应的 SHA-1 值（blob id）、名称（从左往右），commit object 存储的内容是这个 commit 对应的快照是哪一个，以及作者、提交时间、提交信息。</p><p>当对暂存区的文件执行 <code>git commit</code> 时，暂存区的内容会在 Git 仓库中生成新的 tree object，再生成新的 commit object 指向这个 tree object，然后再将指针（HEAD、Branch Reference）指向新的 commit object 上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 8d02</span><br><span class="line">tree</span><br><span class="line"></span><br><span class="line">git cat-file -p 8d02</span><br><span class="line">100644 blob 9d07aa0df55c353e18eea6f1b401946b5dad7bce    a.txt</span><br><span class="line">040000 tree 6f70e1ef80653594b824dc4769b6b17b7db6e570    children</span><br></pre></td></tr></table></figure><p>注：<code>040000 tree ...</code> 又对其他 object 进行引用，所有的 tree object 就是一棵树结构（目录树）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 31c8</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">git cat-file -p 31c8</span><br><span class="line">tree 8d02b64862ddca88bcf103e1fd52cd82471c66e1</span><br><span class="line">author Tracy &lt;240866271@qq.com&gt; 1693535910 +0800</span><br><span class="line">committer Tracy &lt;240866271@qq.com&gt; 1693535910 +0800</span><br><span class="line"></span><br><span class="line">feat: init</span><br></pre></td></tr></table></figure><p>注：如果有父提交，还会有 parent xxx 信息，Git 也是通过这个来确定 commit 的分支归属的。</p><p><code>HEAD</code>、分支（分支也是一个引用，指向一个 commit）、<code>Tag</code>、<code>FETCH_HEAD</code> 都是指针&#x2F;引用（refs），内容都是一个 commit id，指向对应的 commit。它们被保存在 <code>.git/refs/**/*</code>、<code>.git/HEAD</code>、<code>.git/FETCH_HEAD</code> 文件中。</p><p><code>HEAD</code> 指针保存在 <code>.git/HEAD</code> 文件中，默认指向当前分支的最新提交，通过 <code>git checkout commitId</code> 可进入“头部&#x2F;头指针（HEAD）分离状态（detache HEAD state）”，即 HEAD 不再指向分支引用，而是直接指向某个 commit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-parse HEAD <span class="comment"># 查看当前 HEAD 的位置</span></span><br><span class="line">git symbolic-ref HEAD <span class="comment"># 查看当前 HEAD 所指向的分支，如果头部分离了，会提示 ref HEAD is not a symbolic ref</span></span><br><span class="line">git show-ref [branchName] <span class="comment"># 查看分支的引用</span></span><br></pre></td></tr></table></figure><p><code>FETCH_HEAD</code> 是一个特殊的指针，它指向最近一次使用 <code>git fetch</code> 命令从远程仓库获取的提交。它通常用于在合并远程分支之前查看或操作获取的提交。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 上使用 apt（或 yum） 安装 <code>sudo apt install git</code>，Windows 上可以从 Git 官网<a href="https://git-scm.com/downloads">下载安装程序</a>，Mac OS 上，Xcode 默认集成了 Git，如果没有安装 Xcode，可通过 Homebrew 单独安装。</p><p>另外，Windows 中要想在 CMD 中执行 Git，需要将 Git 添加到环境变量 path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\bin</span><br><span class="line">C:\Program Files\Git\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE] <span class="comment"># git help help 查看 help 命令如何使用</span></span><br></pre></td></tr></table></figure><p>注：Windows 版本的 Git 自带 git-gui，包括 gitk，为 Git 提供可视化界面。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 共有三级配置，优先级依次是本地配置 &gt; 全局配置 &gt; 系统配置。系统配置在 <code>/etc/gitconfig</code> 文件中（Windows 在 <code>/mingw64/etc/gitconfig</code>。Windows Git Bash 中的根目录是 Git 的安装目录），全局配置在 <code>~/.gitconfig</code> 文件中，本地配置在本地仓库的 <code>.git/config</code> 文件中。<code>cat ~/.gitconfig</code> 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = 240866271@qq.com</span><br><span class="line">name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">helper = manager</span><br><span class="line">[commit]</span><br><span class="line">template = D:/commit-template</span><br></pre></td></tr></table></figure><p>注：mingw（Minimalist GNU on Windows） 是一款 Windows 上的 GNU 工具集（含 vim、ssh client…），mingw64 是其 64 位版。Windows 版 Git 自带 mingw。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list <span class="comment"># 查看系统配置</span></span><br><span class="line">git config --global --list <span class="comment"># 查看全局配置</span></span><br><span class="line">git config --<span class="built_in">local</span> --list <span class="comment"># 查看 repository 配置</span></span><br><span class="line">git config --list <span class="comment"># 查看当前配置（配置信息会合并，结果是本地、全局、系统三者的合并）</span></span><br><span class="line">git config &lt;setting&gt; <span class="comment"># 查看特定配置，比如 git config user.name</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="设置配置信息"><a href="#设置配置信息" class="headerlink" title="设置配置信息"></a>设置配置信息</h3><p>最常见的自定义配置是用户信息（用户名和邮件地址，commit 时用）、Commit Message Template、Credential Helper。</p><ul><li>用户信息</li></ul><p>用户信息用于 commit 时标示用户身份，git log 的提交日志中可以查看，如果没有配置，在 MacOS 下会使用操作系统用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Tracy&quot;</span> <span class="comment"># 姓名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;240866271@qq.com&quot;</span> <span class="comment"># 邮箱</span></span><br></pre></td></tr></table></figure><p>注：–global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p><ul><li>提交模版</li></ul><p>Commit Message Template</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><ul><li>换行</li></ul><p>由于各操作系统文本文件所使用的换行符不一样，UNIX&#x2F;Linux&#x2F;OS X 使用的是 <code>LF</code>，Windows&#x2F;Dos 使用的 <code>CRLF</code>。Git 默认提供了一个“换行符自动转换”功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf xx <span class="comment"># true、input（推荐使用）、false</span></span><br></pre></td></tr></table></figure><p><code>true</code> 表示开启自动转换，迁入时将文件换行风格转换成 Unix 风格，迁出时根据本地系统确定是否转换成 CRLF，<code>input</code> 表示迁入的时候将换行风格转换成 Unix 风格，迁出时不做处理，<code>false</code> 表示迁入迁出都不对换行风格进行处理。</p><ul><li>其他</li></ul><p>除了上述常用配置，还有其他的配置，比如颜色、别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示颜色</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名</span></span><br><span class="line">git config --global alias.st status <span class="comment"># st 就表示 status，git st 等价于 git status</span></span><br><span class="line">git config --global alias.co checkout <span class="comment"># co 就表示 checkout</span></span><br><span class="line">git config --global alias.unstage <span class="string">&#x27;reset HEAD&#x27;</span> <span class="comment"># git unstage test.js 等价于 git reset HEAD test.js，将暂存区的修改撤销（unstage），重新放回工作区</span></span><br><span class="line">git config --global alias.last <span class="string">&#x27;log -1&#x27;</span> <span class="comment"># git last 显示最后一次提交信息</span></span><br><span class="line">git config --global alias.lg </span><br><span class="line"><span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span> <span class="comment"># log 别名</span></span><br><span class="line">git config --global init.defaultBranch main <span class="comment"># # git init 默认分支名，从 master 改为 main</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 GUI 编码为 utf-8（可用来处理 git-gui gitk 中文乱码问题）</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br></pre></td></tr></table></figure><p>注，可直接编辑配置文件来设置配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --system -e <span class="comment"># 系统配置</span></span><br><span class="line">git config --global -e <span class="comment"># 全局配置</span></span><br><span class="line">git config -e <span class="comment"># 本地配置</span></span><br></pre></td></tr></table></figure><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p>.gitignore 配置文件用于忽略文件，不被添加到版本库中，其配置语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以斜杠 / 开头表示目录</span><br><span class="line">以星号 * 通配多个字符</span><br><span class="line">以问号 ? 通配单个字符</span><br><span class="line">以方括号 [] 包含单个字符的匹配列表</span><br><span class="line">以叹号 ! 表示不忽略匹配到的文件或目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 txt 结尾的文件</span><br><span class="line">*.txt</span><br><span class="line"># 忽略 doc 目录下 所有 txt 文件，不包括子目录（doc/subdir/a.txt）</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc 目录下所有 txt 的文件，包括子目录</span><br><span class="line">doc/**/*.txt</span><br><span class="line"></span><br><span class="line"># README.txt 除外</span><br><span class="line">!README.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件（不管 build 是根目录还是子目录，都会被忽略）</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略根目录下的 TODOLIST 文件（不包括 subdir/TODOLIST）</span><br><span class="line">/TODOLIST</span><br></pre></td></tr></table></figure><p>注：Git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p><h3 id="gitattributes"><a href="#gitattributes" class="headerlink" title=".gitattributes"></a>.gitattributes</h3><ul><li>merge.ours.driver</li></ul><p>merge.ours.driver 配置在有冲突时使用 ours(当前分支) 合并策略，常用来，比如根据不同分支做不同持续集成的 .gitlab-ci.yml。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.ours.driver <span class="literal">true</span></span><br><span class="line">git config --global -l</span><br></pre></td></tr></table></figure><p>配置 .gitattributes 文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.gitlab-ci.yml merge=ours</span><br></pre></td></tr></table></figure><p>注：<code>merge.ours.driver</code> 默认就是 true，不用设置，只需要配置 .gitattributes 文件即可。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init &lt;folder&gt; <span class="comment"># 带 --bare 参数，可创建一个裸库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件添加到暂存区</span></span><br><span class="line">git add -p &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本提交（将暂存区文件添加到本地仓库中。会生成唯一的 hash 值作为 commit id，即版本号）</span></span><br><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span> <span class="comment"># 如果想要记述的更加详细，不加 -m 参数即可</span></span><br><span class="line">git commit --amend <span class="comment"># 修改最后一次 commit message（如果不是最后一次，需要组合使用 rebase 命令，才能完成）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从版本库中删除文件</span></span><br><span class="line">git <span class="built_in">rm</span> &lt;file&gt; <span class="comment"># 删除工作区文件，并删除暂存区对应文件记录</span></span><br><span class="line">git <span class="built_in">rm</span> --cached &lt;file&gt; <span class="comment"># 删除暂存区文件记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看仓库状态</span></span><br><span class="line"><span class="comment"># Git 文件的 4 种状态：untracked(未跟踪)、staged(已暂存)、unmodified/committed(已提交)、modified(已修改)，它们之间相互转换流程</span></span><br><span class="line">git status <span class="comment"># 查看所有文件状态</span></span><br><span class="line">git status [filename] <span class="comment"># 查看指定文件状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较差异</span></span><br><span class="line">git diff <span class="comment"># 比较 workspace 与 index 的差异</span></span><br><span class="line">git diff HEAD <span class="comment"># 比较 workspace 与最新提交记录的差异</span></span><br><span class="line">git diff --cached/--staged <span class="comment"># 比较 index 与 local repositorty  的差异</span></span><br><span class="line">git diff hash1 hash2 <span class="comment"># 比较两个提交记录的差异</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看记录</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment"># 查看当前分支的提交记录（从 HEAD 到第一次）。可以加参数，比如 --pretty=oneline</span></span><br><span class="line">git reflog <span class="comment"># 查看操作记录（包括被 reset 掉的）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本切换（修改 HEAD 指针到不同的提交位置）</span></span><br><span class="line">git reset [--hard | --soft | --mixed] [commitId | HEAD] [fileName] <span class="comment"># 默认参数 --mixed 和 HEAD</span></span><br><span class="line">git reset <span class="comment"># 取消暂存（to unstage），git reset --mixed HEAD 的简写，即将 HEAD 移动到最新提交（相当于没变），将差异保存到工作区</span></span><br><span class="line">git reset --hard HEAD^ <span class="comment"># 切换到上一个版本</span></span><br><span class="line">git reset --hard 130f10a <span class="comment"># 切换到指定版本</span></span><br><span class="line">git reset --mixed HEAD^ <span class="comment"># 修改最新版本（HEAD 指向了上一个版本，但差异保留在了工作区），--soft 同理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本反做</span></span><br><span class="line">git revert [-n | --no-commit] [commitId] <span class="comment"># 参数 -n|--no-commit 作用是不进入提交编辑界面，需手动提交，撤销和提交分开</span></span><br><span class="line">git revert HEAD <span class="comment"># 反做最新版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃工作区的修改，回到最近一次 git commit 或 git add 时的状态</span></span><br><span class="line">git checkout -- README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把误删的文件恢复到最新版本，checkout 其实用版本库里的版本替换工作区的版本</span></span><br><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure><p>通过哈希值指定提交记录不太方便（尽管只需要 4 位，但是也需要通过 log 查询出具体 commit id），所以 Git 引入了相对引用，<code>^</code> 表示向上移动 1 个提交记录，<code>~&lt;num&gt;</code> 表示向上移动多个提交记录。比如，<code>HEAD</code> (即 <code>HEAD~0</code>) 表示当前版本，<code>HEAD^</code> 是上一个版本，<code>HEAD^^</code> 是上上一个版本，依此类推，<code>HEAD~100</code> 表示往上第 <code>100</code> 个版本，<code>master^</code> 表示 master 分支的父提交。</p><ul><li>reset</li></ul><p><code>git reset</code> 三种模式 <code>--mixed</code>、<code>--soft</code>、<code>--hard</code> 最主要区别是对目标提交到当前提交的差异以及工作区和暂存区未提交部分处理方式不同。<code>--hard</code> 下工作区和暂存区未提交会被清除，差异也全部清除，<code>--soft</code> 下工作区和暂存区保留，差异会存入暂存区，<code>--mixed</code> 下工作区保留，差异和暂存区都会存入工作区。<code>--hard</code> 参数具破坏性的，它会永久删除工作区和暂存区中未提交的更改（已提交的可通过 <code>git reflog</code> 找回，但未提交的不能），务必小心，所以 <code>--hard</code> 常用来切换版本，<code>--mixed</code> 和 <code>--soft</code> 用来修改提交。</p><p>注意：如果本地分支已经被提交到了远程仓库，在使用了 <code>git reset</code> 后本地库 <code>HEAD</code> 指向的版本比远程库的要旧，<code>push</code> 时会报错 <code>Updates were rejected because the tip of your current branch is behind</code>，这时候需要使用 <code>git push -f</code> 强制推上去。</p><ul><li>revert</li></ul><p><code>git revert</code> 也能做到版本回滚，但是原理与 <code>git reset</code> 完全不一样，<code>git reset</code> 是在各个版本中切换，而 <code>git revert</code> 会生成新的版本。</p><p>reset 前：</p><div id="flowchart-0" class="flow-chart"></div><p>reset 后（目标版本之后的版本不见了）：</p><div id="flowchart-1" class="flow-chart"></div><p>rever 前：</p><div id="flowchart-2" class="flow-chart"></div><p>revert 后（生成了一个新的版本）：</p><div id="flowchart-3" class="flow-chart"></div><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是用来进行并行作业的。<code>git init</code> 会默认创建 <code>master</code> 主分支。<code>git commit</code> 每次提交，Git 都会自动把它们串成一条时间线，这条时间线就是一个分支。如果只有一个分支，那么也只有一条时间线。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支（当前分支前面标有 × 号）</span></span><br><span class="line">git branch <span class="comment"># 不带参数查看本地分支，-a 查看所有分支，-r 列出远程跟踪的分支（不是远程分支）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支（基于当前分支）</span></span><br><span class="line">git branch &lt;branch-name&gt; <span class="comment"># 只创建不切换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建（基于当前分支）和切换分支</span></span><br><span class="line">git checkout -b dev <span class="comment"># 相当于 git branch dev、git checkout dev</span></span><br><span class="line">git checkout --orphan dev <span class="comment"># 创建一个没有任何的提交记录的空分支，但是当前分支的内容都有，可用 git rm -rf . 删除原来代码树下的所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复文件（放弃某个文件的修改，而不是整个工作目录的所有修改）</span></span><br><span class="line">git checkout -- &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新命名分支</span></span><br><span class="line">git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支（合并指定分支到当前分支，比如当前分支是 master）</span></span><br><span class="line">git merge dev</span><br><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev <span class="comment"># --no-ff 参数，表示禁用 Fast forward</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并某一次提交</span></span><br><span class="line">git cherry-pick &lt;commit-hash&gt; <span class="comment"># commit-hash 另一个分支中的某次提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d dev <span class="comment"># 删除已合并的本地分支（但不能删除当前分支，需要切换，才能删除）。-d -r 参数删除远程追踪分支（只是删除 git branch -r 列表中的追踪分支，并不会删除远程分支）</span></span><br><span class="line">git branch -D dev <span class="comment"># 删除未合并的本地分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 看看分支的历史提交记录</span></span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制使用远程分支来覆盖本地分支</span></span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="头部分离"><a href="#头部分离" class="headerlink" title="头部分离"></a>头部分离</h3><p><code>git checkout</code> 除了常见的创建&#x2F;切换分支、切换标签、恢复文件外，还能切换提交，通过 <code>git checkout commitId</code> 或 <code>git checkout --detach branchName</code> 进入”头部&#x2F;头指针（HEAD）分离状态（detached HEAD state）“，该状态下 HEAD 不再指向任何分支，而是一个提交。</p><p>detached HEAD 不是分支，只是一种临时状态，常用于查看、修改、调试特定的提交，或者基于该 commit，创建新的分支，当然也可以回滚提交（不推荐，detached HEAD 不是具体分支，不能 push，还需要创建新分支来承载）。在 detached HEAD 上进行提交时，这些提交只是临时的，但如果切换到其他分支，这些提交可能会被丢失，因此，在 detached HEAD 状态下进行的工作完成后，需将其合并到一个具名分支上，以确保提交的持久性。</p><p>以以下场景为例，在执行完 <code>git checkout 版本二 commitId</code> 后，<code>HEAD</code> 引用指向了版本二，但是当前分支的引用仍然指向版本三，这个仓库目前处于一个头部分离状态。</p><p>执行前：</p><div id="flowchart-4" class="flow-chart"></div><p>执行后：</p><div id="flowchart-5" class="flow-chart"></div><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取远程仓库提交，但不合并（git fetch 的目的是 git merge FETCH_HEAD 合并，或者 git checkout FETCH_HEAD 切换到 FETCH_HEAD 查看）</span></span><br><span class="line">git fetch <span class="comment"># 默认下，git fetch 取回所有分支的提交，如果只想取回特定分支的提交，可以指定分支名，比如：git fetch origin master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程仓库提交，且合并（这相当于执行 git fetch 和 git merge FETCH_HEAD 两个命令）</span></span><br><span class="line">git pull [远程仓库] [远程分支名]:[本地分支名] <span class="comment"># origin 是默认的远程仓库名称</span></span><br><span class="line">git pull origin dev <span class="comment"># 如果省略本地分支名，则表示远程分支与当前分支合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向远程仓库库推送提交（git push [远程仓库] [本地分支名]:[远程分支名]）（为防止冲突，push 前要先 pull）</span></span><br><span class="line">git push -u origin master <span class="comment"># 当前分支可能与多个主机存在追踪关系（tracking），所以首次要用 -u（--set-upstream）指定一个默认主机（upstream），以后可直接 git push</span></span><br><span class="line">git push origin master <span class="comment"># 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支，如果该远程分支不存在，则会被新建</span></span><br><span class="line">git push origin :dev <span class="comment"># 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支</span></span><br><span class="line">git push origin <span class="comment"># 将当前分支推送到 origin 主机的对应分支</span></span><br><span class="line">git push <span class="comment"># 如果当前分支只有一个追踪分支，那么连主机名都可以省略</span></span><br><span class="line">git push --force <span class="comment"># --force/-f 强制推送</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete dev <span class="comment"># 删除 origin 主机的 dev 分支。注：远程的默认分支，不能为当前将要删的目标分支，如果是，需要将默认分支切换到其他分支上，再删</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程库 clone，默认情况只能看到 master 分支，需要在 dev 分支，必须创建远程 origin 的 dev 分支到本地</span></span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name <span class="comment"># 关联</span></span><br></pre></td></tr></table></figure><p>注：不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式。如果要修改这个设置，可以采用 git config 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># matching</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line"></span><br><span class="line"><span class="comment"># simple</span></span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>Git 中的标签和分支有点类似，都是引用或者说指针，不过标签的位置是固定的，在给指定提交打好标签以后，它就固定于此位置，而分支的位置是会不断变动的，随着分支的向前推移或者向后回滚，都在不断变化。分支和标签的用处也不一样，分支用于并行作业，而标签用于处理发布。</p><p>Git 标签分为两种类型：轻量型（lightweight）和附注型（annotated）。轻量标签是指向特定提交对象的引用，而附注标签则是仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。建议使用附注标签，以便保留相关信息。标签名应采用统一的格式，<code>v$&#123;MajorVersion&#125;.$&#123;MinorVersion&#125;.$&#123;FixVersion&#125;-$&#123;TypeLabel&#125;</code>，其中 TypeLabel (alpha、 beta…) 可选。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看标签</span></span><br><span class="line">git tag <span class="comment"># 查看所有 tag</span></span><br><span class="line">git tag -l v1.0.* <span class="comment"># 查看符合模式的 tag</span></span><br><span class="line">git show v1.0.0 <span class="comment"># 查看 tag 信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建标签</span></span><br><span class="line">git tag v1.0.0 <span class="comment"># 新建轻量 tag</span></span><br><span class="line">git tag v1.0.0 9fceb02 <span class="comment"># 为某个 commit 新建 tag（一般用于后期加注标签）。用 git log --pretty=oneline --abbrev-commit 查看 commit id</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;message&quot;</span> <span class="comment"># 新建带注释的 tag（用 -a 来创建一个带备注的 tag，-m 指定说明文字）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送标签</span></span><br><span class="line">git push origin v1.0.0 <span class="comment"># 推送某个具体 tag</span></span><br><span class="line">git push origin --tags <span class="comment"># 推送所有 tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换标签</span></span><br><span class="line">git checkout v1.0.0 <span class="comment"># 切换方法跟分支一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除标签</span></span><br><span class="line">git tag -d v1.0.0 <span class="comment"># 删除本地某个 tag</span></span><br><span class="line">git push origin :refs/tags/v1.0.0 <span class="comment"># 删除远端某个 tag</span></span><br></pre></td></tr></table></figure><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Stash 可用在一些特殊的工作场景中，比如，需要临时修复 Bug，可以把当前工作现场储藏起来，等 Bug 修复后恢复现场后继续工作。在 Git Flow 下，Stash 基本用不到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存存储</span></span><br><span class="line">git stash</span><br><span class="line">git stash save <span class="string">&quot;save message&quot;</span> <span class="comment"># 带注释的存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看存储列表</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看存储详情</span></span><br><span class="line">git stash show <span class="comment"># 默认查看第一个 stash，即 stash@&#123;0&#125;，可以以指定。另外，-p 参数，可以查看到具体的详情</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复存储</span></span><br><span class="line">git stash pop <span class="comment"># 恢复的同时把存储也删了，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定 git stash pop stash@&#123;$num&#125;</span></span><br><span class="line">git stash apply <span class="comment"># 恢复某个存储，但不会把存储从存储列表中删除，默认使用第一个存储，也可以指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除存储</span></span><br><span class="line">git stash drop <span class="comment"># 删除某个存储，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定</span></span><br><span class="line">git stash clear <span class="comment"># 删除所有存储</span></span><br></pre></td></tr></table></figure><h2 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程中心化仓库可用来备份存储和共享协作。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ul><li>SSH 登录</li></ul><p>使用 SSH 登录 GitHub 流程以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment"># 查看是否已经生成 ssh 密钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;any comment can be here&quot;</span> <span class="comment"># 生成密钥（注释一般为 Email，但不一定非要 GitHub 开户 Email）</span></span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub <span class="comment"># 复制 rsa，添加至 GitHub</span></span><br><span class="line">ssh -T git@github.com <span class="comment"># 测试证书登录是否设置成功</span></span><br></pre></td></tr></table></figure><p>ssh-keygen 生成的 rsa 默认命名是 id_rsa (私钥) 和 id_rsa.pub (公钥)，如果在键入上述命令回车之后，重新输入了命名，那此时生成的两个文件就是 [命名] 和 [命名].pub</p><ul><li>Git Credential</li></ul><p>除了使用 SSH 实现免密登录，还可通过 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">Git Credential</a> 保存登录名和密码（默认所有都不缓存，每一次连接都会询问你的用户名和密码），每次自动输入用户名和密码，实现免密登录，Git 使用 credential.help 来存储本地凭证，其所支持的选项如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache: cache 模式会将凭证存放在内存中一段时间，密码不会被存储在磁盘中，并且在 15 分钟后从内存中清除</span><br><span class="line">store: store 模式会将凭证用明文的形式存放在磁盘中（默认在 home 目录），永不过期</span><br><span class="line">osxkeychain: Mac 下 store 的加密版，凭证保存在用户的钥匙串中</span><br><span class="line">manager: Windows 下 store 的加密版，凭证保存在 Windows 的凭据管理器中，在 system 级别被设置（credential.helper=manager），优先于 global 和 local</span><br></pre></td></tr></table></figure><p>可通过 Git 的帮助文档来查看我们系统支持哪种 helper。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux 下</span></span><br><span class="line">git <span class="built_in">help</span> -a | grep credential</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">credential                 remote-ftps</span><br><span class="line">credential-cache           remote-ftps</span><br><span class="line">credential-cache--daemo    remote-ftps</span><br><span class="line">credential-store           remote-ftps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Window 下（CMD 使用 findstr，PowerShell 使用 sls。或者在 C:\Program Files\Git\mingw64\libexec\git-core 目录下执行 (ls).Name | sls credential）</span></span><br><span class="line">git <span class="built_in">help</span> -a | sls credential</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">git-credential-manager.exe</span><br><span class="line">git-credential-store.exe</span><br><span class="line">git-credential-wincred.exe</span><br><span class="line">git-credential.exe</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list | grep credential <span class="comment"># 查看默认配置</span></span><br></pre></td></tr></table></figure><p>Mac 默认 credential helper 是 osxkeychain，Windows 默认是 manager，而 Linux 默认不存储，需手动设置，以 store 模式为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这样，会生成 <code>~/.git-credentials</code> 文件，用户信息会以明文保存在里面，<code>https://&#123;userName&#125;:&#123;password&#125;@github.com</code>，比如 <code>https://Tracy-xu:395083226%40gh@github.com</code>。</p><p>注：要操作一个远程仓库，首先要有 Git 服务器登录权限，然后要有项目权限（项目的所有者，或者 Collaborators – 协作者）。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote url] [<span class="built_in">local</span> url] <span class="comment"># 克隆远程仓库（在 GitHub 可以使用 HTTPS 和 SSH 协议）</span></span><br><span class="line">git remote add [shortname] [url] <span class="comment"># 添加远程仓库 </span></span><br><span class="line">git remote <span class="built_in">rm</span> [remote name] <span class="comment"># 删除远程仓库</span></span><br><span class="line">git remote set-url [remote name] [new url] <span class="comment"># 修改远程仓库</span></span><br><span class="line">git remote rename [old remote name] [new remote name] <span class="comment"># 修改远程仓库名</span></span><br><span class="line">git remote <span class="comment"># 查看远程库的信息，-v 查看详细信息</span></span><br></pre></td></tr></table></figure><h2 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h2><p>SSH 作为 Git 所支持通信协议其中之一，如果想通过 SSH 来使用 Git，则需要安装 SSH Server。Linux 一般都自带 SSH，而 Windows 配置起来麻烦，所以这里以 Linux 为例。 </p><p>当然，在实际使用中不单单只会用到一个简单的非常底层的 Git 服务器，还有其他很多功能会使用到（比如，提供图形化界面的用户管理、SSH 管理、Log、Issue、Pull Request，甚至 Wiki 和持续集成），所以一般会使用 GitHub、GitLab、GitBucket 基于 Git 实现的 Git 仓库托管系统。</p><ol><li>安装 Git</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git                # CentOS 用 yum 带 -y 参数安装（-y 参数不用一步步询问）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个 Git 用户，用来运行 Git 服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br><span class="line"></span><br><span class="line"># 默认情况下 SSH 不允许空密码用户登录（可在 sshd_config 中设置，参考相关章节），所以还需给 git 这个用户设置一个密码。</span><br><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><ol start="3"><li>设置证书登录</li></ol><p>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个（参考 Linux 相关章节。在没有像 GitHub、GitLab 这样的平台来管理 authorized_keys，管理员手动管理 authorized_keys 很麻烦）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 验证证书登录是否设置成功（如果让输入密码则没有成功，如果不让输入则设置成功）</span><br><span class="line">ssh -T git@192.168.10.140</span><br><span class="line"></span><br><span class="line"># 不让输入密码，回车后，原生的 Git Service 没有任何返回，GitHub 会有返回</span><br><span class="line">ssh -T git@github.com    </span><br><span class="line">Hi Tracy-xu! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>注：<code>~/.ssh</code> 目录在用户目录下（不同用户 <code>~</code> 下输入 <code>pwd</code>，结果会是 <code>/root</code> 或者 <code>/home/xxx</code>），修改 <code>~/.ssh/authorized_keys</code> 只对当前用户生效。另外，如果不设置证书登录，默认会使用密码登录。</p><ol start="4"><li>初始化 Git 仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选定一个目录作为 Git 仓库，假定是 /srv/sample.git，在 /srv 目录下输入命令</span><br><span class="line">sudo git init --bare sample.git</span><br><span class="line"></span><br><span class="line"># 把 owner 改为 git（如果这一步不设置，push 时会报权限不足：insufficient permission for adding an object to repository databa）</span><br><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>与 <code>git init</code> 不同的是，<code>git init --bare</code> 被用来创建“裸库”，裸库没有 work tree（工作区），只有 .git 目录，记录着版本历史，一般用于公共的远程中央仓库，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区。另外，服务器上的 Git 仓库通常都以 .git 结尾。</p><ol start="5"><li>禁用 Shell 登录</li></ol><p>出于安全考虑，第二步创建的 git 账户不允许登录 Shell（GitHub 就是如此，<code>ssh git@github.com </code>），只允许 Git 相关操作，所以要把 Shell 登录改为 git-shell 登录。编辑 <code>/etc/passwd</code> 文件，为 git 用户指定的 git-shell 即可（参考 Linux passwd 相关章节）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为</span><br><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>还要复制一个名为 git-shell-commands 的目录，要不然 <code>ssh git@192.168.10.140</code> 时会报 fatal:Interactive git shell is not enabled 错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/git-1.8.3.1/contrib/git-shell-commands /home/git -R</span><br><span class="line">chown git /home/git/git-shell-commands/ -R</span><br><span class="line">chmod +x /home/git/git-shell-commands/help</span><br><span class="line">chmod +x /home/git/git-shell-commands/list</span><br></pre></td></tr></table></figure><p>现在，不管是开机登录，还是 su 切换用户登录，还是 SSH 远程登录，git 用户登录的都将是 git-shell，进来看到的是 <code>git&gt;</code> 而不是 <code>[root@localhost ~]#</code>。另外，不能将 git 账户登录权限改为 <code>/sbin/nologin</code>，禁用登录，要不然客户端在 clone 时会报 <code>fatal: protocol error: bad line length character: This</code> 错误。</p><ol start="6"><li>克隆远程仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@192.168.10.140:/srv/sample.git</span><br></pre></td></tr></table></figure><p>直接 clone 会提示这是一个空仓库。也可以在本地创建一个仓库，然后添加 remote 地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">...</span><br><span class="line">git remote add origin ssh://git@192.168.10.140:/srv/sample.git      # clone 时可以省略 ssh:// 协议，设置地址时不可省略</span><br><span class="line">git push --set-upstream origin master                               # 可以缩写为 git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>*<a href="https://git-scm.com/book/zh/v2">pro git</a><br>*<a href="https://learngitbranching.js.org/?locale=zh_CN">learngitbranching</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.3.0/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">cm1=>operation: 版本一cm2=>operation: 版本二cm3=>operation: 版本三ref=>operation: HEAD、Mastercm1(right)->cm2(right)->cm3->refcm3@>ref({"stroke":"Red"})</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">cm1=>operation: 版本一ref=>operation: HEAD、Mastercm1->refcm1@>ref({"stroke":"Red"})</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">cm1=>operation: 版本一cm2=>operation: 版本二cm3=>operation: 版本三ref=>operation: HEAD、Mastercm1(right)->cm2(right)->cm3->refcm3@>ref({"stroke":"Red"})</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">cm1=>operation: 版本一cm2=>operation: 版本二cm3=>operation: 版本三cm4=>operation: 版本四ref=>operation: HEAD、Mastercm1(right)->cm2(right)->cm3(right)->cm4->refcm4@>ref({"stroke":"Red"})</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">cm1=>operation: 版本一cm2=>operation: 版本二cm3=>operation: 版本三ref=>operation: HEAD、Mastercm1(right)->cm2(right)->cm3->refcm3@>ref({"stroke":"Red"})</textarea><textarea id="flowchart-4-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><textarea id="flowchart-5-code" style="display: none">cm1=>operation: 版本一cm2(align-next=no)=>parallel: 版本二cm3=>operation: 版本三head=>operation: HEADmaster=>operation: Mastercm1(right)->cm2cm2(path1, bottom)->headcm2(path2, right)->cm3->mastercm2@>head({"stroke":"Red"})cm3@>master({"stroke":"Red"})</textarea><textarea id="flowchart-5-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-5-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-5-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-5", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> Engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Media Query</title>
      <link href="/2015/06/02/css/Media%20Query/"/>
      <url>/2015/06/02/css/Media%20Query/</url>
      
        <content type="html"><![CDATA[<p>媒体查询（Media Query）在 CSS2 中就已经存在了，但是只能查询 Media Type，CSS3 中除了能查询 Media Type 外，还加入了 Media Feature 的查询。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询包含一个“媒体类型（Media Type）”以及至少一个测试“媒体特性（Media Feature）”的表达式，表达式和媒体类型将根据实际情况计算的到 true 或者 false。如果指定的媒体类型符合当前设备并且媒体特性表达式都为真，那当前媒体查询为真，Media Query 为 true，对应的样式规则生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [媒体类型] 媒体特性 &#123;&#125;</span><br></pre></td></tr></table></figure><p>除非使用了 <code>not</code> 或 <code>only</code> 操作符，否则 Media Type 是可选的，默认值为 <code>all</code></p><span id="more"></span><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>and</td><td>逻辑与，用于连接 Media Type、Media Feature 用于结合多个媒体特性或媒体类型</td></tr><tr><td>,</td><td>设备列表</td></tr><tr><td>not</td><td>排除某种设备</td></tr><tr><td>only</td><td>限定某种设备类型</td></tr></tbody></table><p><code>and</code> 用于结合多个媒体特性或媒体类型到一个 Media Query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Media Type 为 all 时 Media Feature 为 min-width 700 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用 and 添加限制条件 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 and 添加 Media Type，限制媒体类型为显示器 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 用于结合多个 Media Query ，任 一Media Query 为 true 时应用样式，相当于逻辑运算符中的 or。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 宽度大于 700px，或者宽度大于高度的显示器上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>not</code> 用于对整个 Media Query 结果取反，必须位于一个 Media Query 的开头。另外，在逗号分隔的多个 Media Query 中，not 只对它作用的 Media Query 生效。not 不能对单个 Media Feature 取反，只能作用于整个 Media Query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* not 将在最后求值 */</span></span><br><span class="line"><span class="comment">/* 等价于 @media not (print and (max-width:1024px))&#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> print <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">1024px</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多个 Media Query 求值 */</span></span><br><span class="line"><span class="comment">/* 求值顺序如下 @media (not (screen and (color))), print and (color) &#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">color</span>), print <span class="keyword">and</span> (<span class="attribute">color</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>only</code> 用于向早期浏览器隐藏媒体查询，<code>only</code> 必须位于 Media Query 的开头。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>无法识别媒体查询的浏览器要求获得逗号分割的媒体类型列表，规范要求：它们应该在第一个不是连字符的非数字、字母之前截断每个值。所以上面的示例解释为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为没有 <code>only</code> 这样的媒体类型，所以样式表被忽略。如果不加 only，下面的示例会被解析为 <code>@media screen &#123;&#125;</code> 这样一来即使浏览器不知道 Media Query 的真正含义，样式也会应用于所有屏幕设备。</p><p>尽管存在此行为，如果希望向其他不太常用的浏览器隐藏样式，任然建议在媒体查询前面添加 only。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体类型（Media-Type）"><a href="#媒体类型（Media-Type）" class="headerlink" title="媒体类型（Media Type）"></a>媒体类型（Media Type）</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>print</td><td>文档打印或打印预览模式</td></tr><tr><td>screen</td><td>彩色电脑屏幕</td></tr><tr><td>speech</td><td>阅读器</td></tr></tbody></table><p>注意：在 CSS2.1 和 CSS3 Media Query 中定义的 Media Type：tty、tv、projection、handheld、braille、embossed、aural，在<a href="https://www.w3.org/TR/mediaqueries-4/">media queries level 4</a> 中都废弃了，不推荐使用。</p><h3 id="媒体特性（Media-Feature）"><a href="#媒体特性（Media-Feature）" class="headerlink" title="媒体特性（Media Feature）"></a>媒体特性（Media Feature）</h3><table><thead><tr><th>媒体特性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>viewport width</td></tr><tr><td>height</td><td>viewport height</td></tr><tr><td>device-width 、 device-height</td><td>设备的宽度、高度</td></tr><tr><td>aspect-ratio</td><td>viewport 的宽高比如：16&#x2F;9</td></tr><tr><td>device-aspect-ratio</td><td>设备宽高比</td></tr><tr><td>orientation</td><td>宽度和高度的大小关系。landscape（横屏）、portrait（竖屏）</td></tr><tr><td>resolution</td><td>设备的分辨率</td></tr></tbody></table><p>上面是一些常见的 Media Feature，不是全部，Media Feature 的维度很多，但是最常用的是 viewport 的 width 和 height。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在 CSS2 中，媒体查询只使用于 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签中，以 media 属性来查询，CSS3 中可以用 @media 来查询。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/reset.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/print.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:600px) and (max-width:900px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="keyword">@import</span> url(<span class="string">&quot;css/style.css&quot;</span>);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;css/reset.css&quot;</span>) screen;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  选择器 &#123;</span><br><span class="line">    属性: 属性值;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Media-Query-常用方法"><a href="#Media-Query-常用方法" class="headerlink" title="Media Query 常用方法"></a>Media Query 常用方法</h2><ul><li>排他（exclusive）</li></ul><p>为确保在某一个条件下只有一个样式表生效，将查询条件严格划分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">401px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>覆盖（overriding）</li></ul><p>可以对元素设置相同优先级，使用样式顺序，通过覆盖，避免排他。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动优先（Mobile first）</li></ul><p>默认样式假设为移动设备宽度，然后通过 min-width 控制扩展样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootStrap 移动优先，断点分别为 768、992、1200，这三个断点的区间对应手机、平板、桌面、大桌面。</p><ul><li>PC 优先（desktop first）</li></ul><p>默认以宽屏进行样式设置，通过 max-width 控制样式覆盖。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 标签嵌套规则</title>
      <link href="/2014/06/15/html/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/"/>
      <url>/2014/06/15/html/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML4-x2F-XHTML-嵌套规则"><a href="#HTML4-x2F-XHTML-嵌套规则" class="headerlink" title="HTML4&#x2F;XHTML 嵌套规则"></a>HTML4&#x2F;XHTML 嵌套规则</h2><h3 id="Inline-Level-和-Block-Level"><a href="#Inline-Level-和-Block-Level" class="headerlink" title="Inline Level 和 Block Level"></a>Inline Level 和 Block Level</h3><p>在 HTML4&#x2F;XHTML DTD 中，将元素的分为 inline level (行内级) 和 block level (块级) 两类。</p><ul><li>inline level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span、a、dfn、abbr、cite、img、label、q、u、em、i、strong、b、big、small、sub、sup、表单类；计算机输出类(tt、kbd、code、var、samp)</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>block level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div、h1-h6、hr、ul、ol、dl、li、fieldset、address、from、table、html5 中新增的结构化语义标签、pre、blockquote、dir、menu</span><br></pre></td></tr></table></figure><p>注：HTML 中的 inline level、block level 与 CSS 中的 inline、block 意义不一样，HTML 强调的是语义和结构，而 CSS 强调的是样式。要不然无法解释：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><ul><li>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素(另，a 不能在嵌套 a)：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”#”</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<code>h1、h2、h3、h4、h5、h6、p、dt</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML5-嵌套规则"><a href="#HTML5-嵌套规则" class="headerlink" title="HTML5 嵌套规则"></a>HTML5 嵌套规则</h2><p>在 <a href="https://html.spec.whatwg.org/multipage/dom.html#element-definitions">HTML5 规范</a>中，已经不按 inline level 和 block level 来区分元素类型了，元素按 <a href="https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content">Categories</a> 分类，元素的 <a href="https://html.spec.whatwg.org/multipage/dom.html#content-models">Content Model</a> 规定了合法的元素内容类型。</p><h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><ul><li>Metadata 元数据信息元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base, link, meta, noscript, script, style, template, title</span><br></pre></td></tr></table></figure><ul><li>Flow 流式元素</li></ul><p>所有可以放在 <code>body</code> 标签内，构成文档内容的元素均属于 Flow 元素，即，除了 <code>base</code>, <code>link</code>, <code>meta</code>, <code>style</code>, <code>title</code> 等只能放在 <code>head</code> 标签内的元素外，剩下的均属 Flow 元素。</p><ul><li>Sectioning 结构元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article, aside, nav, section</span><br></pre></td></tr></table></figure><ul><li>Heading 标题元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1, h2, h3, h4, h5, h6</span><br></pre></td></tr></table></figure><ul><li>Phrasing 短语元素</li></ul><p>所有可以放在 <code>p</code> 标签内，构成段落内容的元素均属于 Phrasing 元素。HTML5 中的 Phrasing 元素大致就是 HTML4 中所定义的 inline level 元素。另外，所有 Phrasing 元素均属于 Flow 元素。</p><ul><li>Embedded 嵌入资源元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audio, video, img, canvas, svg, iframe, embed, object, math</span><br></pre></td></tr></table></figure><ul><li>Interactive 交互元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, audio, video, button, details, embed, iframe, img, input, label, object, select, textarea</span><br></pre></td></tr></table></figure><h3 id="Content-Model"><a href="#Content-Model" class="headerlink" title="Content Model"></a>Content Model</h3><p>各元素都有自己的 Content Model，比如 <a href="https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-a-element">a 元素</a>的 Content Model 为 <a href="https://html.spec.whatwg.org/multipage/dom.html#transparent-content-models">transparent</a>，这类元素本身内部可以有任何类型的内容，是否合法要看其父元素的 Content Model 和其内容的 Categories，还有 <code>p</code> 元素，其内容模型为 Phrasing, 这意味着 <code>p</code> 元素只接受 Phrasing 元素为子元素（<code>p</code> 自身 Categories 类型为 Flow content，因而 <code>p</code> 不能嵌套 <code>p</code>）。</p><p>下面例子中的嵌套都是不合法的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p&gt;ins&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ul&gt;li&gt;h4&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element">p 元素</a>的 content model 是 phrasing content，<a href="https://html.spec.whatwg.org/multipage/edits.html#the-ins-element">ins</a> 本身属于 phrasing content 故可以嵌套；<code>ins</code> 元素的 content model 是 transparent，故在此时里面是否能有 <code>a</code> 需检查 <code>p&gt;a</code> 的合法性；<code>a</code> 元素也属于 phrasing content，故 <code>p&gt;ins&gt;a</code> 合法；<code>a</code> 元素的 content model 也是 transparent，故此时里面包含 <code>div</code> 的合法性向上传递，检查 <code>ins&gt;div</code> 又向上传递，变成检查 <code>p&gt;div</code>。所以，<code>div</code> 不属于 phrasing content，这个嵌套是不合法。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 过渡与动画</title>
      <link href="/2014/05/18/css/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <url>/2014/05/18/css/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: [property duration timing-function delay]</span><br></pre></td></tr></table></figure><p><code>property</code> 默认值 <code>all</code>，<code>duration</code> 和 <code>delay</code> 默认值 <code>0</code>，<code>timing-function</code> 默认值 <code>ease</code>。可使用 <code>,</code> 分割，实现多个动画，配合 <code>duration</code>，还可实现队列动画。</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">65px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#92B901</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.4</span>;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">1s</span>, opacity <span class="number">1s</span>, background <span class="number">1s</span>, width <span class="number">1s</span>, height <span class="number">1s</span>, font-size <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#1ec7e6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>transition</code> 不会在页面加载时自动执行动画，它需要交互或异步去触发，比如 CSS 的伪类 <code>:hover</code>，JS 事件或 <code>setTimeout</code> 去执行动画。</p><p>开启硬件加速，可以使 <code>transition</code> 运行更加流畅：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>不是所有的 CSS 属性都支持 transition，<strong>属性存在中间状态，且能计算出中间状态（开始状态和结束状态是具体数值），才支持 transition</strong>。像 <code>visibility</code>、<code>display</code> 就不存在中间状态，<code>height: auto</code> 不能计算出中间状态，支持的属性常见有以下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* length/percentage: 真实的数字 如：`word-spacing`, `width`, `vertical-align`, `top`, `right`, `bottom`, `left`, `padding`, `outline-width`, `margin`, `min-width`, `min-height`, `max-width`, `max-height`, `line-height`, `height`, `border-width`, `border-spacing`, `background-position` 等；</span><br><span class="line">* number 真实的（浮点型）数值，如：`zoom`, `opacity`, `font-weight` 等；</span><br><span class="line">* color: RGB 和 Alpha 值，如：`background-color`, `border-color`, `color`, `outline-color` 等 CSS 属性；</span><br><span class="line">* shadow: x, y, blur 和 color，如：text-shadow</span><br><span class="line">* transform list</span><br></pre></td></tr></table></figure><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* ease：逐渐变慢（默认值），等同于贝塞尔曲线 (0.25, 0.1, 0.25, 1.0)；</span><br><span class="line">* linear：匀速，等同于贝塞尔曲线 (0.0, 0.0, 1.0, 1.0)；</span><br><span class="line">* ease-in：加速，等同于贝塞尔曲线 (0.42, 0, 1.0, 1.0)；</span><br><span class="line">* ease-out：减速，等同于贝塞尔曲线 (0, 0, 0.58, 1.0)；</span><br><span class="line">* ease-in-out：加速然后减速，等同于贝塞尔曲线 (0.42, 0, 0.58, 1.0)；</span><br><span class="line">* cubic-bezier (n,n,n,n)：在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。实际用到的很少，可以到工具网站中设置值 http://cubic-bezier.com；</span><br></pre></td></tr></table></figure><p>这几个贝塞尔值的区别：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease&quot;</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in&quot;</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-out&quot;</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in-out&quot;</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;linear&quot;</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ease</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">4s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ease-in</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">4s</span> ease-in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ease-out</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">4s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ease-in-out</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">4s</span> ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.linear</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">4s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transition-与-animation-区别"><a href="#transition-与-animation-区别" class="headerlink" title="transition 与 animation 区别"></a>transition 与 animation 区别</h3><p><code>transition</code> 是属性过渡动画，<code>animation</code> 是关键帧过渡动画，两种动画触发方式不一样，属性过渡必须通过交互或者异步修改属性值，而关键帧只需要应用即可，可以在交互时，也可以不在交互时。</p><p>另外，在 CSS <code>:hover</code> 中，当鼠标移出时，属性值会恢复，发生过渡，<code>transition</code> 的逆向动画被触发，而 <code>animation</code> 关键帧动画不会 <code>reverse</code>，需另声明 <code>reverse</code> 的关键帧来实现，而且需通过事件来应用，要不然进入时会发生 <code>reverse</code> 动画。</p><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: [name duration timing-function delay iteration-count direction fill-mode play-state]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* animation-name 关键帧名，默认值 none</span><br><span class="line">* animation-duration 动画时长，默认值 0</span><br><span class="line">* animation-timing-function 动画速度，默认值 ease</span><br><span class="line">* animation-delay 延迟，默认值 0</span><br><span class="line">* animation-iteration-count 播放次数，默认值 1</span><br><span class="line">* animation-direction 轮流反向播放，默认值 normal</span><br><span class="line">* animation-play-state 默认值 running（播放）、paused（暂停）</span><br><span class="line">* animation-fill-mode 默认值 none（不改变默认行为）、forwards（保持在最后一个关键帧中定义的状态）、backwards（保持在第一个关键帧中定义的状态）、both</span><br></pre></td></tr></table></figure><p><code>animation</code> 属性简写至少要有名称和时长。</p><p><code>animation</code> 使用时需先定义关键帧 <code>@keyframes</code>，再在 <code>animation</code> 中使用关键帧。关键帧中，用百分比来规定变化发生的时间，或用关键词 <code>from</code> (动画开始) 和 <code>to</code> (动画完成)，等同于 <code>0%</code> 和 <code>100%</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> fade &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">background</span>: <span class="number">#f00</span>; <span class="attribute">animation</span>: fade <span class="number">1s</span>;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2014/05/05/javascript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2014/05/05/javascript/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是一种描述字符模式（特征）的工具，是字符的高度抽象，被用于字符的搜索、匹配、替换、验证等多种场景。ESMAScript 中用 <code>RegExp</code> 类表示正则表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegExp 构造函数</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;pattern&#x27;</span>, <span class="string">&#x27;flags&#x27;</span>);  <span class="comment">// console.log(reg) 会打印输出字面量 /pattern/flags</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>RegExp</code> 构造函数下 pattern 以字符串存在，跟字面量模式不同的是，字符串下 <code>/</code> 需要做两层转义，字符串中转义一次，正则中转义一次。以 <code>&#39;\\.&#39;</code> 为例，首先 <code>\\.</code> 在字符串中被转义 <code>\.</code> ，然后作为正则表达式字面量，<code>\.</code> 又被转义为 <code>.</code>，即字符串 <code>.</code>，如果在字符串中只写 <code>\.</code>，字符串转义为 <code>.</code>，作为正则表达式被解释时就变成匹配任意字符了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/^\w+$/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;^\\w+$&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg2); <span class="comment">// 输出为字面量 /^\w+$/</span></span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>正则表达式由两种基本字符类型组成，普通文本字符和元字符（Metacharacter）。元字符是有特殊含义的字符，转义字符、字符类、量词、定位符…都是元字符，元字符使正则表达式具有处理能力。反斜杠转义后的元字符将失去特殊含义。</p><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>转移字符</td></tr><tr><td><code>[]</code></td><td>字符类</td></tr><tr><td><code>&#123;&#125;</code>、<code>?</code>、<code>*</code>、<code>+</code></td><td>量词</td></tr><tr><td><code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code></td><td>定位符</td></tr><tr><td><code>|</code></td><td>可选项</td></tr><tr><td><code>.</code></td><td>除新行（newline）外的任一字符（<code>s</code> 修饰符将使 <code>.</code> 匹配新行字符）</td></tr><tr><td><code>()</code></td><td>分组</td></tr></tbody></table><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>反斜杠 <code>\</code> 通常用作转义字符，用于改变其后紧跟的字符的含义，使其表示本身，而不是它们的特殊含义，或者反之，使其表示特殊含义。</p><p>比如，带上转移字符的 <code>\\</code>、<code>\.</code>、<code>\[</code>、<code>\]</code> 表示 <code>\</code>、<code>.</code>、<code>[</code>、<code>]</code> 字符本身，而不是它们的特殊含义。<code>\b</code>、<code>\B</code> 表示单词边界和非单词边界，<code>\n</code>、<code>\r</code>、<code>\t</code> 表示换行符，回车字符和制表符，<code>\0</code> 表示 <code>null</code> 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\?/</span>   </span><br><span class="line"><span class="comment">// 如果通过 RegExp 构造函数来使用它们 , 则都必须进行双重转义</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\?&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符类（Character-classes）"><a href="#字符类（Character-classes）" class="headerlink" title="字符类（Character classes）"></a>字符类（Character classes）</h3><p>将直接量字符放进 <code>[]</code> 方括号内就组成了字符类，一个字符类可以匹配它所包含的任意字符。由于某些字符类非常常用，因此使用了些特殊字符的转义来表示它们，例如 <code>\s</code>，方括号内也可以放这些简写的特殊转义字符，例如 <code>[\s\d]</code>。</p><table><thead><tr><th>字符类</th><th>匹配情况</th></tr></thead><tbody><tr><td><code>[abc]</code></td><td>简单类：(或) 匹配中括号中的字符集中任意字符</td></tr><tr><td><code>[a-z]</code></td><td>范围类：(到) 匹配中括号中的字符集中任意字符</td></tr><tr><td><code>[^a-z]</code></td><td>负向类：(非) 匹配非中括号中的字符集中任意字符</td></tr><tr><td><code>[^a-z0-9]</code></td><td>组合类：(组合)</td></tr><tr><td><code>.</code></td><td>预定义类：匹配除换行符外的任意字符，<code>[^\n\r]</code></td></tr><tr><td><code>\d</code></td><td>预定义类：匹配数字 <code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>预定义类：匹配非数字 <code>[^0-9]</code></td></tr><tr><td><code>\s</code></td><td>预定义类：匹配空白字符 <code>[\t\n\x0B\f\r]</code></td></tr><tr><td><code>\S</code></td><td>预定义类：匹配非空白字符 <code>[^\t\n\x0B\f\r]</code></td></tr><tr><td><code>\w</code></td><td>预定义类：匹配字母数字下划线 <code>[a-zA-Z_0-9]</code></td></tr><tr><td><code>\W</code></td><td>预定义类：匹配非字母数字下划线 <code>[^a-zA-Z_0-9]</code></td></tr><tr><td><code>[\b]</code></td><td>退格直接量（特例）</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算元音的个数</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;There was a long silence after this, and Alice could only hear whispers now and then.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[AEIOUYaeiouy]/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元音数：&#x27;</span>, str.<span class="title function_">match</span>(reg).<span class="property">length</span>);</span><br></pre></td></tr></table></figure><p>注：<code>[]</code> 字符类中，除了 <code>^</code>、<code>-</code>、<code>]</code> 是元字符外，其他都是普通字符，比如，<code>[^.]</code> 中的 <code>.</code> 是字符 <code>.</code>，而不是字符类 <code>.</code>，不要将其与 <code>[\n\r]</code> 等效了。</p><h3 id="量词（Quantifiers）"><a href="#量词（Quantifiers）" class="headerlink" title="量词（Quantifiers）"></a>量词（Quantifiers）</h3><p>量词用于指定匹配的次数。</p><table><thead><tr><th>贪婪</th><th>惰性</th><th>支配</th><th>描述</th></tr></thead><tbody><tr><td><code>?</code></td><td><code>??</code></td><td><code>?+</code></td><td>零次或一次出现</td></tr><tr><td><code>*</code></td><td><code>*?</code></td><td><code>*+</code></td><td>零次或多次出现</td></tr><tr><td><code>+</code></td><td><code>+?</code></td><td><code>++</code></td><td>一次或多次出现</td></tr><tr><td><code>&#123;n&#125;</code></td><td><code>&#123;n&#125;?</code></td><td><code>&#123;n&#125;+</code></td><td>恰好 n 次出现</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td><code>&#123;n,m&#125;?</code></td><td><code>&#123;n,m&#125;+</code></td><td>至少 n 次至多 m 次出现</td></tr><tr><td><code>&#123;n,&#125;</code></td><td><code>&#123;n,&#125;?</code></td><td><code>&#123;n,&#125;+</code></td><td>至少 n 次出现</td></tr></tbody></table><p>三种不同类型量词的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abbbaabbbaaabbb1234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/.*bbb/g</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/.*?bbb/g</span>;</span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/.*+bbb/g</span>;</span><br><span class="line"></span><br><span class="line">str.<span class="title function_">match</span>(reg1); <span class="comment">// [&quot;abbbaabbbaaabbb&quot;]</span></span><br><span class="line">str.<span class="title function_">match</span>(reg2); <span class="comment">// [&quot;abbb&quot;, &quot;aabbb&quot;, &quot;aaabbb&quot;]，reg2 包含一个惰性量词</span></span><br><span class="line">str.<span class="title function_">match</span>(reg3); <span class="comment">// []，没有返回结果，因为它是支配性的，一次测试失败，就得不到结果</span></span><br></pre></td></tr></table></figure><ul><li>贪婪量词</li></ul><p>贪婪量词先看整个的字符串是否匹配。如果没有发现匹配，则去掉该字符串中最后一个字符，并再次尝试。如果还是没有发现匹配，那么再次去掉最后一个字符，这个过程会一直重复直到发现一个匹配或者字符串不剩任何字符。</p><table><thead><tr><th>量词</th><th>含义</th></tr></thead><tbody><tr><td><code>?</code></td><td><code>&#123;0,1&#125;</code>，0 个或 1 个</td></tr><tr><td><code>*</code></td><td><code>&#123;0,&#125;</code></td></tr><tr><td><code>+</code></td><td><code>&#123;1,&#125;</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>n 个</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>最少 n 次，<code>,</code> 后没有空格</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>n 到 m 之间</td></tr><tr><td><code>&#123;,m&#125;</code></td><td>没有这种量词</td></tr></tbody></table><ul><li>惰性量词</li></ul><p>惰性量词先看字符串中的第一个字母是否匹配。如果单独这一个字符还不够，就读入下一个字符，组成两个字符的字符串。如果还是没有发现匹配，惰性量词继续从字符串中添加字符直到发现匹配或者整个字符都检查过也没有匹配。惰性量词和贪婪量词的工作方式相反。</p><p>贪婪量词后接 <code>?</code> 便是惰性量词。</p><ul><li>支配性量词</li></ul><p>支配量词只尝试匹配整个字符串，如果整个字符串不能产生匹配，不进行回溯，不做进一步尝试。支配性量词并不是所有正则表达式引擎都支持，比如，JavaScript。</p><p>贪婪量词后接 <code>+</code> 便是支配量词。</p><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符是用于指定匹配的位置而不是匹配字符本身的特殊字符。</p><table><thead><tr><th>定位符</th><th>含义</th></tr></thead><tbody><tr><td><code>^</code></td><td>行首</td></tr><tr><td><code>$</code></td><td>行尾</td></tr><tr><td><code>\b</code></td><td>单词边界</td></tr><tr><td><code>\B</code></td><td>非单词边界</td></tr></tbody></table><p>使用 <code>$</code> 和 <code>^</code>，查找字行中第一个单词和最后一个单词：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Important word is the last one.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)\.$/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// one</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Important word is the last one.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\w+)/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// Important</span></span><br></pre></td></tr></table></figure><p>也可以用单词边界实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Important word is the last one.&#x27;</span>;</span><br><span class="line"><span class="comment">// 惰性来制定在单词边界之前可以出现任何字符，且可出现一次或多次（如果使用贪婪性量词，表达式就匹配整个字符串）</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(.+?)\b/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// Important</span></span><br></pre></td></tr></table></figure><p>使用单词边界可以方便地从字符串中抽取单词：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;First second third fourth fifth sixth&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b(\S+?)\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">match</span>(reg);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;First&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;, &quot;fifth&quot;, &quot;sixth&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="修饰符（标记）"><a href="#修饰符（标记）" class="headerlink" title="修饰符（标记）"></a>修饰符（标记）</h3><table><thead><tr><th>修饰符</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td><code>i</code></td><td>ignore 不区分大小写</td><td>将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别</td></tr><tr><td><code>g</code></td><td>global 全局匹配</td><td>查找所有的匹配项</td></tr><tr><td><code>m</code></td><td>multi line 多行匹配</td><td>使边界字符 <code>^</code> 和 <code>$</code> 匹配每一行的开头和结尾，注意是多行，不是整个字符串的开头和结尾</td></tr><tr><td><code>s</code></td><td>特殊字符圆点 . 中包含换行符 <code>\n</code></td><td>默认情况下的圆点 . 是匹配除换行符 <code>\n</code> 之外的任何字符，加上 <code>s</code> 修饰符之后, . 中包含换行符 <code>\n</code></td></tr></tbody></table><p><code>m</code> 多行匹配，会让 <code>$</code> 边界匹配换行符 <code>\n</code> 以及字符串真正的结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;First second\nthird fourch\nfifth sixth&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)$/gm</span></span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">match</span>(reg);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;second&quot;, &quot;fourch&quot;, &quot;sixth&quot;]，若不指定多行模式则会返回 [&#x27;sixth&#x27;]</span></span><br></pre></td></tr></table></figure><p>多行模式同样会改变 <code>^</code> 边界的行为，这时它会匹配换行之后的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;First second\nthird fourch\nfifth sixth&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^(\w+)/gm</span></span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">match</span>(reg);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [&quot;First&quot;, &quot;third&quot;, &quot;fifth&quot;]，若不指定多行模式则会返回 [&quot;First&quot;]。</span></span><br></pre></td></tr></table></figure><h2 id="匹配模式（pattern）"><a href="#匹配模式（pattern）" class="headerlink" title="匹配模式（pattern）"></a>匹配模式（pattern）</h2><p>根据元字符的复杂程度，可将正则表达式分为简单模式和复杂模式。复杂模式不仅由字符类和量词组成，还由分组、引用、前瞻等一系列强大的正则表达式功能组成。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组是通过用一系列括号包围一系列字符、字符类以及量词来使用的。例如，假设想匹配字符串 “dogdog”。使用目前获得的知识，可能估计表达式应该类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/dogdog/g</span>;</span><br></pre></td></tr></table></figure><p>尽管这是可以的，但有是点儿浪费，如果不知道dogh在字符串中到底出现几次时该怎么办？如果 dog 重复次数过多呢？你可以使用分组来重写这个表达式，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(dog)&#123;2&#125;/g</span>;</span><br></pre></td></tr></table></figure><p>表达式中的括号的意思是字符序列“dog”将在一行上连续出现两次。但是不并不限制在分组后使用花托号，可以使用任意量词：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/(dog)?/</span>; <span class="comment">// 匹配出现零次或一次 dog</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(dog)*/</span>; <span class="comment">// 匹配出现零次或任意次 dog</span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/(dog)+/</span>; <span class="comment">// 匹配出现一次或多次 dog</span></span><br></pre></td></tr></table></figure><p>通过混合使用字符、字符类和量词，甚至可以实现一些相当复杂的分组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[(bd)ad?]*/</span>; <span class="comment">// 匹配出现零次或多次 ”ba”,”da”,”bad”,”dad”</span></span><br></pre></td></tr></table></figure><p>同时也不介意将分组放在分组中间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(mom( and dad)?)/</span>; <span class="comment">// 匹配 ”mom” 或者 ”mon and dad”</span></span><br></pre></td></tr></table></figure><p>这个表达式要求 ”mon” 是必要的，但是字符串 ” and dad” 可以出现零次或一次。分组还可以用来弥补一些 JavaScript 所缺乏的一些语言功能。</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><table><thead><tr><th>反向引用</th><th>含义</th></tr></thead><tbody><tr><td>(string)</td><td>用于反向引用的分组</td></tr><tr><td><code>\1</code> 或 <code>$1</code></td><td>匹配第一个分组中的内容</td></tr><tr><td><code>\2</code> 或 <code>$2</code></td><td>匹配第二个分组中的内容</td></tr><tr><td><code>\3</code> 或 <code>$3</code></td><td>匹配第三个分组中的内容</td></tr></tbody></table><p>反向引用是按照从左到右遇到的左括号字符的顺序进行创建和编号的。例如，表达式 <code>(A?(B?(C?)))</code> 将产生编号从 <code>1~3</code> 的三个反向引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(A?(B?(C?)))</span><br><span class="line">(B?(C?))</span><br><span class="line">(C?)</span><br></pre></td></tr></table></figure><p>反向可以有几种不同的使用方法。</p><p>使用正则表达式对象的 <code>test()</code>、<code>match()</code> 或 <code>search()</code> 方法后，反向引用的值可以从 RegExp 构造函数中获得。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;#123456789&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/#(\d+)/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// 123456789</span></span><br></pre></td></tr></table></figure><p>在 <code>test()</code> 方法后，所有的反向引用都被保存在 RegExp 构造函数中，从 <code>RegExp.$1</code>（它保存了第一个反向引用）开始，如果还有第二个反向引用，就是 <code>RegExp.$2</code>，如果第三个反向引用存在，就是 <code>RegExp.$3</code>，依此类推。因为该组匹配了 ”123456789”，所以 <code>RegExp.$1</code> 中就存储了这个字符串。</p><p>还可以直接在定义分组的表达式中包含反向引用。这可以通过使用特殊转义字符序列如 <code>\1</code>、<code>\2</code> 等等实现。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;dogdog&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(dog)\1/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>正则表达式 reg 首先创建单词 dog 的组，然后又被特殊转义序列 <code>\1</code> 引用，使得这个正则表达式等于 &#x2F;dogdog&#x2F;。</p><p>第三，反向引用可以用在 <code>replace()</code> 方法中，这通过使用特殊字符序列 <code>$1</code>、<br><code>$2</code> 等等来实现。描述这种功能的最佳例子是调换字符串中的两个单词的顺序。假设想将字符串 “1234 5678” 变成 “5678 1234”。可以通过下面的代码来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;1234 5678&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;) (\d&#123;4&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(reg,<span class="string">&#x27;$2 $1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 5678 1234</span></span><br></pre></td></tr></table></figure><p>在这个例子中，正则表达式有两个分组，每一个分组有四个数字。在 <code>replace()</code> 方法的第二个参数中，<code>$2</code> 等同于 “5678”，而 <code>$1</code> 等同于 “1234”，对应于它们在表达式中出现的顺序。</p><h3 id="候选"><a href="#候选" class="headerlink" title="候选"></a>候选</h3><p>如果要对同一个表达式同时匹配 ”red” 和 ”black” 时要怎么做呢？这些单词完全没有相同的字符，这样就要写两个不同的正则表达式，并分别对两个字符串进行匹配，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/red/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/black/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg1.<span class="title function_">test</span>(str1) || reg2.<span class="title function_">test</span>(str1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg2.<span class="title function_">test</span>(str2) || reg2.<span class="title function_">test</span>(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这虽然完成了任务，但是十分冗长。还有另一种方式就是使用正则表达式的候选操作符。</p><p>候选操作符和 ECMAScript 的二进制异或一样，是一个管道符 <code>|</code>，它放在两个单独的柜式之间。正如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(red|black)/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在这里，reg 匹配 ”red” 或者 ”black”，同时测试每个字符串都返回 true。因为两个备选项存放在一个分组中，不管哪个被匹配了，都会存在 <code>RegExp.$1</code> 中以备将来使用（同时也可以在表达式中使用 <code>\1</code>）。在第一个测试中，<code>RegExp.$1</code> 等于 ”red”，在第二个中，它等于 ”blue”。</p><p>OR 模式在实践中以一种通常的用法是从用户输入中删除不合适的单词，这对于在线论坛来说是非常重要的。通过针对这些敏感单词使用 OR 模式和 <code>replace()</code> 方法，则可以很方便地在帖子发布之前去掉敏感内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/badword|anotherbadword/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;This is a string using badword and anotherbadword&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;****&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// This is a string using **** and ****</span></span><br></pre></td></tr></table></figure><p>也可以用星号替换敏感词中每一个字母，也就是说最后出现的文本中星号的数量和敏感词中的字符数量是一样的，使用函数来作为 <code>replace()</code> 方法的第二个参数，就可以达到这个目的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/badword|anotherbadword/gi</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;This is a string using badword and anotherbadword&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(reg,<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="title function_">replace</span>(<span class="regexp">/./g</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// This is a string using ******* and **************</span></span><br></pre></td></tr></table></figure><h3 id="非捕获性分组"><a href="#非捕获性分组" class="headerlink" title="非捕获性分组"></a>非捕获性分组</h3><p>非捕获性分组即不保存反向引用的分组。在较长的正则表达式中，存储反向引用会降低匹配速度。通过使用非捕获性分组，仍然可以拥有与匹配字符串序列同样的能力，而无需存储结果的开销。创建一个非捕获性分组，只要在左括号的后面加上 <code>?:</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;#123456789&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/#(?:\d+)/</span>;</span><br><span class="line">reg.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// &#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这个例子的最后一行代码输出一个空字符，因为该分组是非捕获性的。正因如此，replace()方法就不能通过 <code>RegExp.$x</code> 变量为使用任何反向引用，或在正则表达式中使用它。看看运行下面的代码会怎样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;#123456789&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg =<span class="regexp">/#(?:\d+)/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;abcd$1&#x27;</span>)); <span class="comment">// &#x27;abcd$1&#x27;</span></span><br></pre></td></tr></table></figure><p>这段代码输出 <code>abcd$1</code> 而不是 <code>abcd123456789</code>，因为 <code>$1</code> 在这里并不被看成是一个反向引用，而被直接翻译成字符。</p><p>正则表达式有一个十分常用的方式是去掉文本中所有的 HTML 标签，尤其是在论坛和BBS上，这可以防止游客在他们的发帖中插入恶意或是无意错误的 HTML。删除HTML标记的正则表达式很简单，只要用一个简单的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;(?:.|\s)*?&gt;/g</span>;</span><br></pre></td></tr></table></figure><p>这个表达式匹配一个小括号 &lt; 后面跟着任何文本，然后跟着一个大于号 &gt;，这有效地匹配了所有的 HTML 标签，这里使用非捕获性分组是因为在小于号和大于号之间出现的内容并不重要（这些都是要删除的）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">innerHTML</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/&lt;(?:.|\s)*?&gt;/g</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">replace</span>(reg, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;b&gt;This would be bold&lt;/b&gt;&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">innerHTML</span>()); <span class="comment">// &#x27;This would be bold&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h3><p>有时候，可能希望，当某个特定的字符分组出现在另一个字符串之前时，才去捕获它。</p><p>前瞻就是告诉正则表达式运算器向前看一些字符而不移动其位置。有正向前瞻和负向前瞻。正向前瞻检查的是接下来的出现的是不是某个特定字符集。而负向前瞻则是检查接下来的不应该出现的特定字符集。</p><p>创建正向前瞻是要将模式放在 <code>(?=</code> 和 <code>)</code> 之间。注意这不是分组，虽然它也用到括号。事实上，分组不会考虑前瞻的存在（无论是正向的还是负向的）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;bedroom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;bedding&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(bed(?=room))/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str1)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// bed</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在这个例子中，reg 只匹配后面跟着 “room” 的 “bed”。因此，它能匹配 str1 而不能匹配 str2。在用表达式测试 str1 后，这段代码输出 <code>RegExp.$1</code> 的内容是 “bed”，而不是 “bedroom”。模式的 “room” 的部分是包含在前瞻中的，所以没有作为分组的一部分返回。</p><p>创建负向前瞻是要将模式放在 <code>(?!</code> 和 <code>)</code> 之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;bedroom&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;bedding&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(bed(?=room))/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str1)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// bed</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里，表达式变成只匹配后面不跟着 “room” 的 “bed”，所以模式匹配 “bedding” 而不是 “bedroom”。在测试 str2，<code>RegExp.$1</code> 还是包含 “bed”，而不是 “bedding”。<br>尽管 JavaScript 支持正则表达式前瞻，但它不支持后瞻。后瞻可以匹配这种模式：“匹配 b 当且仅汉它前面没有 a”。</p><h2 id="JavaScript-中正则表达式属性和方法"><a href="#JavaScript-中正则表达式属性和方法" class="headerlink" title="JavaScript 中正则表达式属性和方法"></a>JavaScript 中正则表达式属性和方法</h2><p><code>RegExp</code> 和 <code>String</code> 都定义了使用正则表达式进行强大的模式匹配和文本检索、替换的方法。</p><h3 id="正则表达式属性和方法"><a href="#正则表达式属性和方法" class="headerlink" title="正则表达式属性和方法"></a>正则表达式属性和方法</h3><ul><li>test</li></ul><p><code>test()</code> 方法用于检测字符串是否符合正则表达式描述的规则，返回布尔值。用该方法测试字符串时要注意“行首和行尾”，表单在验证时基本会加上行首行尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[\w-]+@[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]+\.[A-<span class="title class_">Za</span>-z]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;$/.<span class="title function_">test</span>(<span class="string">&#x27;xwblearn2008@hotmail.com&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>exec</li></ul><p><code>exec()</code> 方法也用于在字符串中查找指定正则表达式，如果 <code>exec()</code> 方法执行成功，则返回包含该查找字符串的相关信息数组，如果失败，则返回 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;a bat , a Cat , a fAt ,a baT , a faT cat&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/at/</span>; </span><br><span class="line"><span class="keyword">var</span> arr = reg.<span class="title function_">exec</span>(str); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr.<span class="property">length</span> ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>静态属性</li></ul><table><thead><tr><th>属性</th><th>短名</th><th>含义</th></tr></thead><tbody><tr><td><code>input</code></td><td><code>$_</code></td><td>当前要匹配的字符串</td></tr><tr><td><code>lastMatch</code></td><td><code>$&amp;</code></td><td>最后一次匹配字符串</td></tr><tr><td><code>lastParen</code></td><td><code>$+</code></td><td>最后一次匹配的捕获组（圆括号内）</td></tr><tr><td><code>leftContext</code></td><td><code>$&quot;</code></td><td><code>lastMatch</code> 前的子串</td></tr><tr><td><code>rightContext</code></td><td><code>$&quot;</code></td><td><code>lastMatch</code> 后的子串</td></tr><tr><td><code>multiline</code></td><td><code>$*</code></td><td>是否所有的表达式都使用多行模式，是一个布尔值</td></tr></tbody></table><p>注：每一个静态属性都对应着一个短名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;this is a google!&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/google/ig</span>; </span><br><span class="line">reg.<span class="title function_">test</span>(str); <span class="comment">// 一定要执行以下，无论是test，还是exec</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">input</span>); <span class="comment">// this is a google!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">leftContext</span>); <span class="comment">// this is a </span></span><br></pre></td></tr></table></figure><ul><li>实例属性</li></ul><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>global</code></td><td>Boolean 值，表示 g 是否已设置</td></tr><tr><td><code>ignoreCase</code></td><td>Boolean 值，表示i是否已设置</td></tr><tr><td><code>lastIndex</code></td><td>整数，代表下次匹配将从哪里字符位置开始</td></tr><tr><td><code>Multiline</code></td><td>Boolean 值，表示 m 是否已设置</td></tr><tr><td><code>Source</code></td><td>正则表达式的源字符串形式</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/google/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">global</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>字符串中支持正则表达式的方法有以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* match() --- 匹配则放回数组，没有匹配则返回 null。</span><br><span class="line">* replace() --- </span><br><span class="line">* search() --- 返回第一个匹配的位置，没有则返回-1。此方法与 indexOf() 方法类似，但它支持正则。g 全局匹配在此方法不起作用。</span><br><span class="line">* split() --- 切姜片，返回一个数组。</span><br></pre></td></tr></table></figure><h2 id="常用正则"><a href="#常用正则" class="headerlink" title="常用正则"></a>常用正则</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由字母数字下划线组成的字符串</span></span><br><span class="line">/^\w+$/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮政编码</span></span><br><span class="line"><span class="regexp">/[1-9][0-9]&#123;5&#125;/</span> <span class="comment">// 共 6 位数字，第一位不能为 0，比如 224000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件压缩包</span></span><br><span class="line"><span class="regexp">/[\w]+\.zip|rar|7zip|tgz/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="regexp">/^.*?\.(jpg|png|bmp|gif)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有空格</span></span><br><span class="line"><span class="regexp">/\s+/g</span> <span class="comment">// 比如删除所有空格 &#x27;111 222 333&#x27;.replace(reg,&#x27;&#x27;) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电子邮件</span></span><br><span class="line"><span class="regexp">/^([\w\.\-]+)@([a-zA-Z0-9]+)\.([a-zA-Z]&#123;2,4&#125;)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号</span></span><br><span class="line"><span class="regexp">/^1[3|4|5|8][0-9]\d&#123;8&#125;$/</span></span><br><span class="line"><span class="regexp">/^0?(13|15|18)[0-9]&#123;9&#125;$/</span>  </span><br><span class="line"><span class="regexp">/^1\d&#123;10&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 座机（区号和区号链接 - 可选）</span></span><br><span class="line"><span class="regexp">/((^0\d&#123;2,3&#125;)-?)?\d&#123;7,8&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机号码或座机号</span></span><br><span class="line"><span class="regexp">/^((0\d&#123;2,3&#125;)-?)?\d&#123;7,8&#125;$|^1\d&#123;10&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邮箱</span></span><br><span class="line"><span class="regexp">/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]&#123;2,4&#125;)+$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文/韩文/日文/全角字符（UTF-8，Unicode 编码范围）</span></span><br><span class="line"><span class="regexp">/[\u4e00-\u9fa5]/</span> <span class="comment">// 中文</span></span><br><span class="line"><span class="regexp">/[\x3130-\x318F]/</span> <span class="comment">// 韩文</span></span><br><span class="line"><span class="regexp">/[\xAC00-\xD7A3]/</span> <span class="comment">// 韩文</span></span><br><span class="line"><span class="regexp">/[\u0800-\u4e00]/</span> <span class="comment">// 日文</span></span><br><span class="line"><span class="regexp">/[\ufe30-\uffa0]/</span> <span class="comment">// 全角字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密码（字母、数字、@、_、~）：</span></span><br><span class="line"><span class="regexp">/^[0-9a-zA-Z@_~]&#123;1,&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// URL</span></span><br><span class="line"><span class="regexp">/(\w+):\/\/([\w.]+)\/(\S*)/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色</span></span><br><span class="line"><span class="regexp">/^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字和字母</span></span><br><span class="line"><span class="regexp">/^\d&#123;1,&#125;$/</span> <span class="comment">// 整数</span></span><br><span class="line"><span class="regexp">/^\d+(\.\d+)?$/</span> <span class="comment">// 数值(整数或者小数)</span></span><br><span class="line"><span class="regexp">/^[a-zA-Z]&#123;1,&#125;$/</span> <span class="comment">// 字母</span></span><br><span class="line"><span class="regexp">/^[0-9a-zA-Z]&#123;1,&#125;$/</span> <span class="comment">// 字母和数字的组合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首尾空格</span></span><br><span class="line"><span class="regexp">/^\s+/</span> <span class="comment">// 首空格</span></span><br><span class="line"><span class="regexp">/\s+$/</span> <span class="comment">// 尾空格</span></span><br><span class="line"><span class="regexp">/^\s*(.+?)\s*$/</span> <span class="comment">// 首尾空格，或者 /^\s*(.*?)\s*$/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 标签</span></span><br><span class="line"><span class="regexp">/&lt;[^&gt;]+&gt;/g</span></span><br><span class="line"><span class="regexp">/&lt;(?:.|\s)*?&gt;/g</span> <span class="comment">// 非捕获性分组提升分组效率，惰性匹配尽可能早的匹配到 &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HMTL 注释</span></span><br><span class="line"><span class="regexp">/&lt;!--(.*?)--&gt;/</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和谐字符</span></span><br><span class="line"><span class="keyword">var</span> blacklistReg = <span class="regexp">/badword1|badword2|anotherOne/gi</span>;</span><br><span class="line"><span class="keyword">var</span> userInput = <span class="string">&#x27;This is a string using badword1 and badword2.&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hamonyInput = userInput.<span class="title function_">replace</span>(blacklistReg, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> hamonyInput = userInput.<span class="title function_">replace</span>(blacklistReg, <span class="keyword">function</span>(<span class="params">matchStr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> matchStr.<span class="title function_">replace</span>(<span class="regexp">/./g</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除首尾空格</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\s*(.+?)\s*$/</span>; <span class="comment">// 使用非贪婪捕获</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27; google &#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + reg.<span class="title function_">exec</span>(str)[<span class="number">1</span>] + <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\s*(.+?)\s*$/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27; google &#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;$1&#x27;</span>) + <span class="string">&#x27;|&#x27;</span>); <span class="comment">// 使用分组获取</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤 HTML 标签</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;div&gt;asdf&lt;/div&gt;&#x27;</span>;</span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">innerText</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;(?:.|\s)*?&gt;/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">innerText</span>());</span><br></pre></td></tr></table></figure><p>注：也可写为 <code>/&lt;(?:[\s\S])*?&gt;/g</code> 或 <code>/&lt;(?:\S|\s)*?&gt;/g</code>，<code>[\s\S]</code>、<code>(\S|\s)</code> 表示所有字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trim</span></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">trim</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;   </span><br><span class="line">  <span class="keyword">var</span> reExt = <span class="regexp">/^\s*(.*?)\s*$/</span> ;  </span><br><span class="line">  <span class="comment">// $1 表示的就是左边表达式中括号内的字符，即第一个子匹配</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">replace</span>(reExt, <span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;  fdsa&#x27;</span>.<span class="title function_">trim</span>());   </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入千分符</span></span><br><span class="line">/\<span class="title function_">B</span>(?=(?:\d&#123;<span class="number">3</span>&#125;)+$)/g</span><br><span class="line">/(?=\<span class="title function_">B</span>(?:\d&#123;<span class="number">3</span>&#125;)+$)/g</span><br><span class="line">/(?=(?!\b)(?:\d&#123;<span class="number">3</span>&#125;)+$)/g</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;1234234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?=(?!\b)(\d&#123;3&#125;)+$)/</span>;</span><br><span class="line">str.<span class="title function_">replace</span>(reg, <span class="string">&#x27;,&#x27;</span>)  <span class="comment">// 1,234234</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 00：00--23:59</span></span><br><span class="line">/^(([<span class="number">0</span>-<span class="number">1</span>]\d)|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>])):[<span class="number">0</span>-<span class="number">5</span>]\d--(([<span class="number">0</span>-<span class="number">1</span>]\d)|(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>])):[<span class="number">0</span>-<span class="number">5</span>]\d$/</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首字母大写</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;asd asd asd&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b\w+\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.<span class="title function_">replace</span>(reg, <span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">toUpperCase</span>() + item.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串内部倒置</span></span><br><span class="line">name = <span class="string">&#x27;Doe, John&#x27;</span>;</span><br><span class="line">name.<span class="title function_">replace</span>(<span class="regexp">/(\w+)\s*, \s*(\w+)/</span>, <span class="string">&#x27;$2 $1&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续英文单词去重</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;a mo mo mo fw mo mo&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  str2 = str;</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/\s(\w+\s)\1/</span>, <span class="string">&#x27; $1&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">while</span> (str.<span class="property">length</span> != str2.<span class="property">length</span>)</span><br><span class="line"></span><br><span class="line">str = str.<span class="title function_">replace</span>(<span class="regexp">/^(\w+\s)\1/</span>, <span class="string">&#x27;$1&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/(\s\w+)\1$/</span>, <span class="string">&#x27;$1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br></pre></td></tr></table></figure><p>附：<a href="/images/javascript/reg.jpeg">正则表达式语法</a>，<a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">正则表达式快速学习指南</a>，<a href="https://regex101.com/#javascript">regex101</a> 正则表达式在线测试工具。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 单位</title>
      <link href="/2013/06/22/css/CSS%20%E5%8D%95%E4%BD%8D/"/>
      <url>/2013/06/22/css/CSS%20%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="PX"><a href="#PX" class="headerlink" title="PX"></a>PX</h2><p><code>px</code> 是一个<a href="https://www.w3.org/TR/css3-values/#lengths">绝对单位</a>，不相对于谁，只受平台 dpi 影响。<code>cm</code>、<code>pt</code> 之类的也都是绝对长度，但与 <code>px</code> 这个抽象单位不同的是它们都是物理单位，<code>1pt</code> 则是 <code>1/72</code> 英寸，而 <code>1</code> 英寸换算到公制是 <code>2.54cm</code>，在 CSS 中所有的物理单位会直接映射到像素，在 <code>96dpi</code> 下 <code>1in = 2.54cm = 96px</code> <code>1cm = 37.8px</code>。</p><span id="more"></span><h2 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h2><p><code>em</code> 是一个相对单位，相对于当前元素的 <code>font-size</code>（如果当前元素没有 <code>font-size</code> 或者 <code>font-size</code> 是相对单位，则先继承父辈的字号，再计算 <code>em</code>）。也可以说，在 <code>font-size</code> 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小。不管怎么样，要想计算 <code>em</code> 的大小，要先确定当前元素具体的 <code>font-size</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 12px; line-height: 1.5em&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block; width: 4em; font-size: 3em;&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>span</code> 先继承父元素 <code>font-size</code>，再计算自身 <code>font-size</code>，即 <code>3em * 12px = 36px</code>，width 为 <code>4 * 36px = 144px</code>。另外，对于相对单位属性的继承，要在父辈元素先计算为具体值，再继承，<code>div</code> 的 <code>line-height</code> 为 <code>1.5em * 12px = 18px</code>，所以 <code>span</code> 的 <code>line-height</code> 为 <code>18px</code>，而不是直接继承 <code>1.5em</code>。</p><p>由于 <code>em</code> 相对于当前元素的字号大小，而且字号会继承，这导致不能统一管理基础变量，且依赖追溯复杂，不适合在整个页面中使用，只适用于做局部缩放的场景。</p><p>历史上，因为 IE 不支持 <code>px</code> 为单位的缩放，故使用 <code>em</code> 来做缩放。<a href="http://clagnut.com/about">Richard Rutter</a> 在 <a href="http://clagnut.com/blog/348/">How to size text using ems</a> 和 <a href="http://alistapart.com/article/howtosizetextincss">How to Size Text in CSS</a> 中做过详细的介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;:root&#x27;</span>), <span class="literal">null</span>).<span class="property">fontSize</span>; <span class="comment">// 16px，Chrome 上最小支持的字号为 12px</span></span><br></pre></td></tr></table></figure><p>以 <code>&lt;html&gt;</code> 的 <code>font-size</code> 为基准，浏览器默认的字号为 16px，换算为 em 即 <code>1em = 16px</code>、<code>12px = 0.75em</code>、<code>10px = 0.625em</code>，为了方便 <code>font-size</code> 的换算，可将 html 字号设为 <code>font-size: 62.5%</code>（即 <code>16px * 62.5% = 10px</code>），或者直接 <code>font-size: 10px</code>，这样 <code>1em = 10px</code>、<code>1.2em = 12px</code>、<code>1.4em = 14px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">h1</span>, <span class="number">2.4em</span> × <span class="number">10</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4em</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>, <span class="number">1.4em</span> × <span class="number">10</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4em</span>;&#125;</span><br></pre></td></tr></table></figure><p>随着浏览器的更新换代，这种做法早已被淹没在历史尘埃中。</p><h2 id="Percent"><a href="#Percent" class="headerlink" title="Percent"></a>Percent</h2><p>一般情况下 <code>%</code> 相对于包含块（containing block），在应用于字体大小时，相对于父字体大小。</p><p>包含块的确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 对于普通定位元素就是父元素</span><br><span class="line">* 对于 position: absolute 的元素是相对于已定位的父元素（offset parent）</span><br><span class="line">* 对于 position: fixed 的元素是相对于 ViewPort（可视窗口）</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>padding</code>、<code>margin</code> 如果设置了百分比，会发现左右和预期一样，用的父元素宽度的百分比，但是上下用的也是宽度百分比，而不是想象中的高度的百分比。另外 <code>percent</code> 在被后代元素继承时继承的是百分比计算后的值，而不是原百分比，比如 <code>line-height 120%</code> 和 <code>1.2</code> 在被继承时。</p><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p><code>rem</code> 相对于根元素 <code>font-size</code> 的单位。引入它是为了解决 <code>em</code> 依赖追溯困难，计算复杂的问题。而 <code>rem</code> 是相对于根元素 <code>&lt;html&gt;</code>，依赖简单，只需要在根元素确定一个参考值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">1.4</span> × <span class="number">10px</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4rem</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="number">2.4</span> × <span class="number">10px</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4rem</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>em</code>、<code>rem</code> 相对于 font-size，但是并不单单只能应用于 <code>font-size</code>。另外，所有的 <code>em</code>、<code>rem</code>、<code>percent</code> 渲染的时候，都会被转为 <code>px</code>，因为 <code>px</code> 是计算机矢量图渲染成像的原理。</p><p><code>rem</code> 常用来做移动端适配。</p><h2 id="VW、VH"><a href="#VW、VH" class="headerlink" title="VW、VH"></a>VW、VH</h2><p><code>vw</code> 是 CSS3 引入的单位，相对于视口的宽度，视口被均分为 100 单位的 <code>vw</code>，<code>1vw = 1%</code> 窗口宽度。<code>vh</code> 同理。常用来配合 <code>rem</code> 做移动端适配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个单位都有各自的优缺点，取决于场景，不能脱离场景谈应用。例如 <code>em</code>、<code>rem</code>、<code>vh</code>、<code>vw</code>、 <code>percent</code> 这些相对单位，比较适合做尺寸联动适配。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2013/05/07/css/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2013/05/07/css/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>HTML Element 作为一种数据，被处理首先需要获取它，在 DOM API 中使用 <code>getElementById</code> 等一系列方法获取，而在 CSS 中使用选择器来获取。</p><span id="more"></span><h2 id="选择器分类和妙用"><a href="#选择器分类和妙用" class="headerlink" title="选择器分类和妙用"></a>选择器分类和妙用</h2><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><ul><li>基本选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 通用选择器</span><br><span class="line">E 标签选择器</span><br><span class="line">类选择器</span><br><span class="line">ID 选择器</span><br><span class="line">属性选择器</span><br></pre></td></tr></table></figure><p>其中属性选择器又分为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[attr]</span><br><span class="line">[attr=val]</span><br><span class="line">[attr|=val] 开头匹配（分词）</span><br><span class="line">[attr~=val] 包含匹配（分词）</span><br><span class="line">[attr^=val] 开头匹配</span><br><span class="line">[attr$=val] 结尾匹配</span><br><span class="line">[attr*=val] 包含匹配</span><br></pre></td></tr></table></figure><p>注：多个选择器，不加任何空格连接在一起，可实现选择器的交集。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E<span class="selector-class">.class</span> &#123;&#125;</span><br><span class="line"><span class="selector-pseudo">:hover</span> &#123;&#125;</span><br><span class="line">E<span class="selector-pseudo">:hover</span> &#123;&#125;</span><br><span class="line"><span class="selector-attr">[attr]</span> &#123;&#125;</span><br><span class="line">E<span class="selector-attr">[attr]</span> &#123;&#125;</span><br><span class="line"><span class="selector-pseudo">:first</span>-child &#123;&#125;</span><br><span class="line">E<span class="selector-pseudo">:first</span>-child &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>分组选择器</li></ul><p>使用 <code>,</code> 将不同选择器组合在一起，实现多个元素的选择。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E,F &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>关系选择器</li></ul><p>关系选择器也叫组合选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E F 后代选择器</span><br><span class="line">E&gt;F 子选择器</span><br><span class="line">E~F 相邻选择器</span><br><span class="line">E+F 相邻兄弟选择器</span><br></pre></td></tr></table></figure><ul><li>伪类选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">* 语言的伪类</span><br><span class="line">:lang</span><br><span class="line"></span><br><span class="line">* 输入状态伪类</span><br><span class="line">:enabled</span><br><span class="line">:disabled</span><br><span class="line">:checked</span><br><span class="line">:read-only</span><br><span class="line">:read-write</span><br><span class="line">:required</span><br><span class="line">:optional</span><br><span class="line">:valid</span><br><span class="line">:inlvalid</span><br><span class="line">:in-range</span><br><span class="line">:out-of-range</span><br><span class="line"></span><br><span class="line">* 位置伪类</span><br><span class="line">:link</span><br><span class="line">:visited</span><br><span class="line">:target</span><br><span class="line"></span><br><span class="line">* 树结构伪类</span><br><span class="line">:root</span><br><span class="line">:empty, E 元素中没有子节点（包含文本节点）</span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br><span class="line">:first-of-type</span><br><span class="line">:last-of-type</span><br><span class="line">:nth-child(n), 父元素中的第 n 个 E 元素，选择父元素下的所有子元素中满足指定规律的元素，不考虑元素的类型，如果不带父选择器，则从所有存在父子关系的子元素中选择</span><br><span class="line">:nth-last-child(n), 父元素中的第 n 个 E 元素，从后向前计算</span><br><span class="line">:nth-of-type(n), 选择相同类型（标签名称）的兄弟元素中指定规律的元素</span><br><span class="line">:nth-last-of-type(n)</span><br><span class="line">:only-of-type</span><br><span class="line">:only-child</span><br><span class="line"></span><br><span class="line">* 用户行为伪类</span><br><span class="line">:hover</span><br><span class="line">:active</span><br><span class="line">:focus</span><br><span class="line"></span><br><span class="line">* 函数式伪类</span><br><span class="line">:not()</span><br><span class="line">:has()</span><br><span class="line">:is()</span><br><span class="line">:where()</span><br></pre></td></tr></table></figure><p>注：带 <code>type</code> 的选择器，是在相同类型（相同标签名称）中进行选择的，比如，<code>first-of-type</code> 即相同标签类型中的第一个、<code>only-of-type</code> 即相同标签中唯一。</p><ul><li>伪元素选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::before 原始的开始</span><br><span class="line">::after 元素的结尾</span><br><span class="line">::first-letter 第一个字母</span><br><span class="line">::first-line 第一行</span><br><span class="line">::selecton 选中的内容</span><br></pre></td></tr></table></figure><p>伪元素表示的是并不真实存在的元素（特殊的位置），与伪类的主要区别是，伪类选择的是元素，而伪元素选择器选择的是伪元素。</p><h3 id="选择器的妙用"><a href="#选择器的妙用" class="headerlink" title="选择器的妙用"></a>选择器的妙用</h3><ul><li>:nth-child()</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 奇偶选择</span><br><span class="line">E<span class="selector-pseudo">:nth-child</span>(odd)</span><br><span class="line">E<span class="selector-pseudo">:nth-child</span>(even)</span><br><span class="line">E<span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n)</span><br><span class="line">E<span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 范围选择</span><br><span class="line">// 选择 <span class="number">3</span> 开始的元素</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>) &#123;&#125;</span><br><span class="line">// 选择 <span class="number">1</span> 到 <span class="number">3</span> 的元素</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>) &#123;&#125;</span><br><span class="line">// 选择 <span class="number">3</span> 到 <span class="number">6</span> 的元素</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(n+<span class="number">3</span>)<span class="selector-pseudo">:nth-child</span>(-n+<span class="number">6</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 周期选择</span><br><span class="line">nth-child(an+<span class="selector-tag">b</span>) // <span class="selector-tag">a</span>为步长，<span class="selector-tag">b</span>为偏移量</span><br></pre></td></tr></table></figure><p>注：<code>n</code> 从 <code>0</code> 开始的非负整数。</p><ul><li>:not()</li></ul><p><code>not</code> 被用来反选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>)) &#123;&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 选择除最后一个 <span class="selector-tag">li</span> 外的所有 <span class="selector-tag">li</span></span><br><span class="line">// 逗号分隔列表</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>)<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:empty</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当 <span class="selector-tag">a</span> 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;http&quot;</span>]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:has()</li></ul><p>使用 <code>has</code> 实现父选择器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 选择包含 <span class="selector-class">.child</span> 子元素的 <span class="selector-class">.parent</span> 父元素</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.child</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h2><p><a href="https://www.w3.org/TR/selectors-3/#specificity">选择器的权重</a>被分为三级 <code>a.b.c</code>，其中，通配符选择器 <code>0</code>，标签选择器、伪元素 <code>1</code>，类、伪类、属性选择器 <code>10</code>，id 选择器 <code>100</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* &#123;&#125; // <span class="number">0</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">em</span> &#123;&#125; // <span class="number">2</span></span><br><span class="line"><span class="selector-id">#wrap</span> <span class="selector-class">.waring</span> &#123;&#125; // <span class="number">110</span> </span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-line &#123;&#125; // <span class="number">2</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span>+<span class="selector-tag">li</span> &#123;&#125; // <span class="number">3</span></span><br><span class="line"><span class="selector-tag">h1</span>+*<span class="selector-attr">[rel=up]</span> &#123;&#125; // <span class="number">11</span>（一个属性选择器，一个标签）</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[id=<span class="string">&quot;a-02&quot;</span>]</span> &#123;&#125; // <span class="number">11</span>（一个属性选择器，一个标签）</span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-id">#content</span> <span class="selector-class">.data</span> <span class="selector-tag">img</span><span class="selector-pseudo">:hover</span> &#123;&#125;// <span class="number">122</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.note</span> <span class="selector-tag">em</span><span class="selector-class">.dark</span> &#123;&#125; // <span class="number">22</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. 颜色是？<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. 颜色是？<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:not</span>(<span class="selector-class">.green</span>) <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><p><code>:not(.green)</code> 伪选择器的“位”权重与 <code>.green</code> 是一样的，最后按顺序进行解析。</p><p>另外，需要注意的是 Inline Style 优先级高于 <code>style</code> 和 <code>link</code>，被 <code>!important</code> 修饰的属性拥有最高的优先级。</p><p>注：使用 <a href="https://github.com/keeganstreet/specificity">specificity</a> 工具可以计算权重，可<a href="https://specificity.keegan.st/">在线</a>使用。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
