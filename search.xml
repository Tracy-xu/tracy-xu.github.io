<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Scratch 助教</title>
      <link href="/2022/03/02/Scratch-Share/"/>
      <url>/2022/03/02/Scratch-Share/</url>
      
        <content type="html"><![CDATA[<p>在这春暖花开，万物复苏之季，非常荣幸受邀参加家长助教活动，我非常赞成这项活动，也非常感谢那些助教的家长，这也是家园共育中重要的活动。</p><p>我准备的课程主题为《少儿编程》，希望通过这节课可以让孩子们对计算机、人工智能、编程有一个轮廓上的概念，知道计算机的用途，知道现阶段的人工智能和真正的人工智能区别，知道编程中最基本的流程控制 – 循环和条件判断。</p><p>本次课程分三部分，分别是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 计算机科普</span><br><span class="line">* Scratch 编程</span><br><span class="line">* 游戏“见缝插针”</span><br></pre></td></tr></table></figure><span id="more"></span><p>在计算机科普中，我在白板上画了一台电脑，并请孩子们回答电脑的用途，然后又画了一个人类大脑，又请孩子们回答人类大脑和电脑的异同，之后又通过 PPT 介绍了计算机的种类以及人工智能。</p><p>由于计算机的运行需要程序，便引出编程，在编程环节中介绍了基本的流程控制 – 循环和条件判断，通过列举日常生活场景“红绿灯”、“跳绳”、“水族箱”、“购物”…，让孩子们理解这两个概念，然后又使用 Scratch 中循环和判断两种积木，分别实现了水族箱和购物程序。</p><p>最后在“见缝插针”的游戏环节中，邀请了所有的孩子体验游戏，游戏是提前编写的，规则是将针插到一个旋转的把上，针尖之间没有相互触碰记一分，否则游戏结束。比赛完成后通过程序算出了最高得分，并给所有参赛小朋友奖励了小奖品。</p><p>课程中，孩子们表现都很积极，我也切身体会到时代进步了，不管是科技水平，还是家园共育水平，现在的小朋友对事物的接触和了解真的非常丰富，是我们孩时完全无法相比的。在问计算机用途时，孩子们能准确的回答出“运算”、“存储记忆“，有的小朋友甚至就已经知道了 Scratch 编程…。</p><p>编程是一门逻辑严谨，且表面枯燥的学科，虽然我是一名程序员，但是要给幼儿园小朋友讲编程，这却是一种挑战，挑战不是如何让孩子们理解什么是循环、判断，而是如何控场，在他们无精打采时提升他们的情绪，在他们情绪激昂时又让他们倾听。</p><h2 id="Attachment"><a href="#Attachment" class="headerlink" title="Attachment"></a>Attachment</h2><ul><li><a href="/rep/scratch/code/%E5%8F%98%E9%87%8F.sb3">变量</a></li><li><a href="/rep/scratch/code/1%E5%8A%A0%E5%88%B0100.sb3">循环</a></li><li><a href="/rep/scratch/code/%E8%B4%AD%E7%89%A9.sb3">判断</a></li><li><a href="/rep/scratch/code/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%88%97%E8%A1%A8.sb3">数据结构–队列</a></li><li><a href="/rep/scratch/code/%E6%B5%B7%E5%BA%95%E4%B8%96%E7%95%8C.sb3">综合练习–见缝插针</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> scratch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互动直播课堂前端设计方案</title>
      <link href="/2021/10/02/Interact-Live-Class/"/>
      <url>/2021/10/02/Interact-Live-Class/</url>
      
        <content type="html"><![CDATA[<p>按同屏技术实现方式来分，课堂可分为<strong>录屏课堂</strong>和<strong>指令课堂</strong>。指令课堂的操作状态需要恢复，录屏课堂中不是必须的，不管是录屏课堂还是指令课堂，互动操作（比如，聊天、点名、授权、问答…）都要通过指令实现。指令课堂适用于面对面课堂，录屏课堂适用于远程课堂。</p><p>相比于录屏，指令同屏实现复杂，但是可以选择同屏的内容，起到保护隐私的作用。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>课堂既要满足<strong>面对面</strong>场景，又要满足<strong>远程</strong>场景。面对面课堂作为线下课堂的补充，而远程课堂可用来替代线下课堂。</p><ul><li>基础功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 黑板</span><br><span class="line">* 截图</span><br><span class="line">* 学生列表</span><br><span class="line">* 举手</span><br><span class="line">* 授权（授权书写、语音、视频）</span><br><span class="line">* 课件（上传和预览）</span><br><span class="line">* 聊天（禁言）</span><br><span class="line">* 投票</span><br><span class="line">* 点名</span><br><span class="line">* 抽人</span><br><span class="line">* 计时器</span><br><span class="line">* 同屏</span><br><span class="line">* 直播（摄像头、桌面，rtmp、hls、flv --- http cdn，rtc）</span><br><span class="line">* 录像</span><br></pre></td></tr></table></figure><p>基础版课堂，能够满足基本的直播和白板需求，适用于通用场景，比如视频会议、白板等。</p><ul><li>教学功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 课本</span><br><span class="line">* 课课清作业</span><br><span class="line">* 问答（自由题型和备课题型）</span><br><span class="line">* 抢答</span><br><span class="line">* 讲解（题目、作业、问答）</span><br></pre></td></tr></table></figure><p>注：测验的三种方式 — 问答、作业、考试。问答只能在课堂中进行，其他两种类型在课前（预习）、课中（随堂）、课后进行都可以。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul><li>登录</li></ul><p>登录</p><p>会话保持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage + http header</span><br></pre></td></tr></table></figure><p>登录刷新</p><ul><li>鉴权</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口鉴权</span><br><span class="line">前端 UI 鉴权</span><br><span class="line">前端 Router 鉴权</span><br></pre></td></tr></table></figure><p>依赖于后端接口的 UI 不需要处理，但是不依赖的呢，有些（非操作类，不会触发后续请求的接口，因为这类 UI 无法通过后端接口来处理）就需要处理</p><ul><li>课堂控制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 开始上课</span><br><span class="line">* 结束上课</span><br><span class="line">* 拖堂</span><br><span class="line">* 课堂倒计时</span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><p>恢复接口返回数据结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><p>课堂恢复的数据存在 Vuex。</p><ul><li>角色</li></ul><p>多角色设计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 老师</span><br><span class="line">* 学生</span><br><span class="line">* 助教</span><br><span class="line">* 游客</span><br></pre></td></tr></table></figure><ul><li>授权</li></ul><p>十进制的展示和传输，二进制的语义</p><p>二进制表达的目的是为了能够组合表达，这样就能够表达多种状态</p><p>黑板：1 — 001<br>音频：2 — 010<br>视频：4 — 100    # 纯视频</p><p>判断：<br>(1xx &amp; 4) &#x3D;&#x3D;&#x3D; 4 </p><p>更新：<br>6 ^ 4  &#x2F;&#x2F; 2</p><ul><li>问答</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 做题组件的设计（显示、作答、讲解）</span><br></pre></td></tr></table></figure><ul><li>讲解</li></ul><p>讲题目、讲答案、对比讲解答案、讲报告。</p><ul><li>黑板</li></ul><p>黑板配置没有做同步（老师 PC 和 老师平板），需要做吗</p><ul><li>多层窗口</li></ul><p>非模态弹框被称为窗口，由于非模态的原因，就需要考虑窗口的排序</p><ul><li>同屏</li></ul><p>应用的宽高比<br>同屏与主控比</p><p>可以按提前商定宽高适配比例适配（适用于定制设备），也可以按主控的宽高比做适配。</p><p>提前商定适配尺寸，位置数据适配比例需要转化为中间比例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scale2Server(state, getters) &#123;</span><br><span class="line">  return 768 / getters.appWidth;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">scale2Client(state, getters) &#123;</span><br><span class="line">  return getters.appWidth / 768;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果按主控来适配，直接</p><ul><li>音视频直播</li></ul><p>播放器</p><p>两路流，混流。</p><p><a href="https://www.jianshu.com/p/32417d8ee5b6">https://www.jianshu.com/p/32417d8ee5b6</a></p><ul><li>WebSocket 设计</li></ul><p>长链接实时应用熄屏</p><h3 id="Vuex-设计"><a href="#Vuex-设计" class="headerlink" title="Vuex 设计"></a>Vuex 设计</h3><h3 id="Socket-接口设计"><a href="#Socket-接口设计" class="headerlink" title="Socket 接口设计"></a>Socket 接口设计</h3><ul><li>WebSocket 库设计</li></ul><p>注：Socket 接口不一定非要用于推送，也可以当 HTTP 接口一样的用，也会有返回。</p><ul><li>数据的同步和恢复</li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>http 接口都带了 token，socket 接口没带？</p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数参数的求值策略</title>
      <link href="/2021/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
      <url>/2021/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>函数参数的<a href="https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085">求值策略 Evaluation Strategy</a> 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。</p><span id="more"></span><p>按值传递（pass by value）是指在调用函数时将实参复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实参。</p><p>引用传递（pass by reference）是指在调用函数时将实参的地址直接传递到函数中，在函数中对参数所进行的修改，将影响到实参。</p><p>按值传递传递的是原始值的复制，或内存地址值的复制（比如 JS 中的共享传递，C&#x2F;C++ 中的指针传递）。按引用传递传递的是内存地址（不是内存地址值）。</p><h2 id="JavaScript-中参数的求值策略"><a href="#JavaScript-中参数的求值策略" class="headerlink" title="JavaScript 中参数的求值策略"></a>JavaScript 中参数的求值策略</h2><p>Javascript 中函数参数求值策略是按值传递。无论是值类型还是引用类型，都会在栈上创建副本（拷贝、复制），不同是，对于值类型而言，这个副本就是整个原始值的复制，对于引用类型，由于引用类型的实例在堆中，在栈上只有它的一个地址引用值，其副本也只是这个引用值的复制，而不是整个原始对象的复制，这种策略也被称为按共享传递（传递的是地址值，可通过引用来修改原始对象的属性，重新赋值则会断开对原始对象的引用，不影响原始对象），类似于 C 中的指针传递。按共享传递是按值传递的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params">num, obj</span>) &#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  obj.<span class="property">value</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 只是引用类型的副作用，不能证明是引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = new Object(); // 断开了对 greeting 的引用</span></span><br><span class="line">  <span class="comment">// obj.value = &#x27;world&#x27;; // 如果是引用传递，改变形参 obj 的属性 value，也会反映在 greeting 变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">change</span>(a, greeting);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面例子的内存模型图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">a 10               |</span><br><span class="line">greeting 0x01 ---&gt; |  0x01 hello world</span><br><span class="line">num 10             |  </span><br><span class="line">obj 0x01      ---&gt; |</span><br></pre></td></tr></table></figure><p>如果是按引用传递，直接传递第二格的内容即可，不需要有第四格。</p><h2 id="其他语言中参数的求值策略"><a href="#其他语言中参数的求值策略" class="headerlink" title="其他语言中参数的求值策略"></a>其他语言中参数的求值策略</h2><p>Java 中参数求值策略与 JavaScript 一样，都是按值传递（含共享传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByValue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">    <span class="type">TestByValue</span> <span class="variable">testByValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestByValue</span>();</span><br><span class="line">    testByValue.change(a, greeting);</span><br><span class="line">    System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(greeting.value); <span class="comment">// hello</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> num, Greeting greeting)</span> &#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    greeting.value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// greeting = new Greeting(); // 断开了对 greeting 的引用</span></span><br><span class="line">    <span class="comment">// greeting.value = &quot;world&quot;;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">javac TestByValue.java </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">java TestByValue     </span><br></pre></td></tr></table></figure><p>PHP 既支持值传递又支持引用传递，通过 &amp; 运算符（取址运算符）实现引用传递。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">&amp;<span class="variable">$num</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$num</span> = <span class="variable">$num</span> + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出１</span></span><br><span class="line"><span class="title function_ invoke__">change</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure><p>C&#x2F;C++ 支持值传递（含指针传递）， 另外 C++ 还支持引用传递，通过 &amp; 取址运算符实现引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> &amp;num2, <span class="type">int</span> *num3)</span> </span>&#123;</span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  num2 = <span class="number">22</span>;</span><br><span class="line">  *num3 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num4 = 2;</span></span><br><span class="line">  <span class="comment">// num3 = &amp;num4; // 对指针变量赋值，会断开原先的引用，不会影响外面</span></span><br><span class="line">  <span class="comment">// printf(&quot;%p\n&quot;, num3); // 外面的 c 还是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">change</span>(a, b, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1，值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22，引用传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33 或 3，指针传递</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码需使用 <code>gcc test.cpp -lstdc++ -o test</code> 作为 C++ 编译，不能使用 <code>gcc -o test test.c</code> 作为 C 编译，C 没有按引用传递，都是按值传递，通过指针传递也可实现引用传递的效果，要想通过 C 编译，需删除引用传递。</p><p>其内存图如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 1</span><br><span class="line">b/num2 2 </span><br><span class="line">c [0x7ff7b2c49920] 3</span><br><span class="line">num1 1</span><br><span class="line">num3 [0x7ff7b2c498f8] 0x7ff7b2c49920</span><br></pre></td></tr></table></figure><p>num1 的内容是复制于 a 的原值，num2 是 b 的别名，num3 的内容是 c 的地址值，*num3 指向 c 的内容。</p><p>指针传递本质上也是值传递的方式，它所传递的是一个地址值，与 JavaScript 中的共享传递一样。C&#x2F;C++ 中通过 * 指针运算符实现指针传递。</p><p>作为指针类型数据本身，其既可使用指针传递又可使用引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *&amp;p)</span> </span>&#123; <span class="comment">// int *&amp;p 表示 p 是一个整型指针的别名，int *p 则会重新分配内存，创建新指针</span></span><br><span class="line">std::cout&lt;&lt;&amp;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*p&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  std::cout&lt;&lt;&amp;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> *b = &amp;a;</span><br><span class="line">  std::cout&lt;&lt;&amp;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">std::cout&lt;&lt;*b&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">change</span>(b);</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算子的求值策略"><a href="#算子的求值策略" class="headerlink" title="算子的求值策略"></a>算子的求值策略</h3><p>求值策略不但规定了函数参数的求值规则，也规定了算子的求值规则，比如赋值表达式中的 <code>=</code> 运算符。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> num1 = a; <span class="comment">// 值传递</span></span><br><span class="line">  <span class="type">int</span> *num2; <span class="comment">// 值传递中的指针传递</span></span><br><span class="line">  num2 = &amp;b;</span><br><span class="line">  <span class="type">int</span> &amp;num3 = c; <span class="comment">// 引用传递</span></span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  *num2 = <span class="number">22</span>;</span><br><span class="line">  num3 = <span class="number">33</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b); <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 33</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> num = a;</span><br><span class="line"><span class="keyword">const</span> obj = b; <span class="comment">// 值传递中的共享传递</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2021/04/01/TypeScript/"/>
      <url>/2021/04/01/TypeScript/</url>
      
        <content type="html"><![CDATA[<p>类型标注&#x2F;注解：变量、函数、对象、类的类型（有些类型可通过类型推断出来，不用手动标注）</p><p>静态类型的好处：</p><span id="more"></span><ul><li>编译时类型检测</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">fibonacci</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">fibonacci.<span class="title function_">push</span>(<span class="string">&#x27;8&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可防止开发中的一些语法错误</p><ul><li>接口提示、代码补全</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> copyFields&lt;T <span class="keyword">extends</span> U, U&gt;(<span class="attr">target</span>: T, <span class="attr">source</span>: U): T &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> source) &#123;</span><br><span class="line">    target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">copyFields</span>(x, &#123; <span class="attr">b</span>: <span class="number">10</span>, <span class="attr">d</span>: <span class="number">20</span> &#125;);</span><br></pre></td></tr></table></figure><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>作为 JS 的超集，TS 支持所有的 JS 数据类型，并新增了几种类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Built-in types: void、any、never</span><br><span class="line">User-defined types: enum、tuple、interface、class、array</span><br></pre></td></tr></table></figure><p>在 TS 中，string 和 String 是不同的两种类型，前者是原始类型，后者是对象类型</p><p>(window as any).foo &#x3D; 1;</p><p>(window as any).foo</p><p>&#x2F;&#x2F; 声明全局变量的”类型“</p><p>&#x2F;&#x2F; 什么要字面量</p><p>&#x2F;&#x2F; 枚举名和枚举值是相互映射的</p><p>&#x2F;&#x2F; 类型断言、声明文件、枚举</p><p>declare enum Directions {<br>    Up,<br>    Down,<br>    Left,<br>    Right<br>}</p><p><T>source 就是 source as T，把 source 断言成 T 类型</p><p>function createArray<T>(length: number, value: T): Array<T> {<br>    let result: T[] &#x3D; [];<br>    for (let i &#x3D; 0; i &lt; length; i++) {<br>        result[i] &#x3D; value;<br>    }<br>    return result;<br>}</p><p>createArray<string>(3, ‘x’); &#x2F;&#x2F; [‘x’, ‘x’, ‘x’]</p><p>第一个 T 是形参，后面的是使用 T</p><p>函数类型不写，也可被推导出来<br>interface SearchFunc {<br>  (source: string, subString: string): boolean;<br>}</p><p>let mySearch: SearchFunc;<br>mySearch &#x3D; function(source: string, subString: string) {<br>    return source.search(subString) !&#x3D;&#x3D; -1;<br>}</p><p>泛型函数、泛型接口、泛型类<br>声明全局变量的”类型“<br>什么要字面量<br>枚举名和枚举值是相互映射的</p><p>&#x2F;&#x2F; 类型断言、声明文件、枚举、泛型</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>TypeScript 能进行类型检测，对于代码风格的检查则需要用到 ESlint。</p><p>TypeScript 和 ESlint 没有可比性，一个是语言，一个是代码检测工具，要比也是 TSlint。</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS 和 CSRF</title>
      <link href="/2019/12/25/XSS/"/>
      <url>/2019/12/25/XSS/</url>
      
        <content type="html"><![CDATA[<p>Cross-site scripting 的英文首字母缩写本应为 CSS，但因为 CSS 在网页设计领域已经被广泛指层叠样式表（Cascading Style Sheets），所以将 Cross（意为“交叉”）改以交叉形的 X 做为缩写。</p><span id="more"></span><p>XSS，即 cross site script，跨站脚本攻击，缩写原本为 CSS，但为了和层叠样式表（Cascading Style Sheet）区分，所以将 Cross（意为“交叉”）改以交叉形的 X 做为缩写。</p><p>XSS 攻击是指攻击者在网站上注入恶意脚本，使用户在浏览使用网页时进行恶意操作，注入脚本除了 JavaScript，还会有 CSS、HTML 等等。</p><p><a href="https://www.zhihu.com/question/34445731">https://www.zhihu.com/question/34445731</a><br><a href="https://www.cnblogs.com/guolao/p/10530536.html">https://www.cnblogs.com/guolao/p/10530536.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a><br><a href="https://www.zhihu.com/question/34445731">https://www.zhihu.com/question/34445731</a><br><a href="https://www.zhihu.com/question/20142673">https://www.zhihu.com/question/20142673</a></p><p><a href="https://blog.csdn.net/qq_41783309/article/details/80615909">https://blog.csdn.net/qq_41783309/article/details/80615909</a><br><a href="https://www.cnblogs.com/zhang293/p/7868744.html">https://www.cnblogs.com/zhang293/p/7868744.html</a><br><a href="https://bbs.ichunqiu.com/thread-18129-1-1.html">https://bbs.ichunqiu.com/thread-18129-1-1.html</a><br><a href="https://www.zhihu.com/question/26628342">https://www.zhihu.com/question/26628342</a><br><a href="https://netsecurity.51cto.com/article/591271.html?pc">https://netsecurity.51cto.com/article/591271.html?pc</a><br><a href="https://www.jianshu.com/p/a1aac8acb940">https://www.jianshu.com/p/a1aac8acb940</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a><br><a href="http://niliu.me/articles/518.html#more-518">http://niliu.me/articles/518.html#more-518</a><br><a href="https://coolshell.cn/articles/4914.html#comments">https://coolshell.cn/articles/4914.html#comments</a></p><p><a href="https://www.secpulse.com/archives/63801.html">https://www.secpulse.com/archives/63801.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><p>注入有很多方法，比如：表单提交，URL 参数，图片上传等等。</p><p>蚂蚁森林 self xss</p><p>因为HTTP是无状态的协议，所以，几乎所有的网站都会在你的浏览器上设置cookie来记录状态，以便在其多个网页切换中检查你的登录状态。而现在的浏览器的运行方式是多页面或多窗口运行，也就是说，你在同一个父进程下开的多个页面或窗口里都可以无偿和共享使用你登录状态的。</p><ul><li>反射型</li></ul><p>反射型 XSS，非持久化，需要欺骗用户自己去点击链接才能触发 XSS 代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">domain.com?kw=alert(&#x27;xss&#x27;)</span><br><span class="line">domain.com?kw=&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">domain.com?kw=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br><span class="line">domain.com?kw=xss&gt;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;?= $kw ?&gt;&lt;/div&gt;</span><br><span class="line">&lt;input value=&quot;&lt;?= $kw ?&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>反射型 XSS 常见位置如搜索栏、用户登录入口等。</p><ul><li>存储型</li></ul><p>存储型 XSS，XSS 代码是存储在服务器中持久化的，比如 IM、留言、文章、个人信息…，这种 XSS 比较危险。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=# onerror=&quot;alert(&#x27;xss&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>注：innerHTML 中的 script 不会被执行。</p><ul><li>DOM Base</li></ul><p>这种 XSS 攻击的实现是通过对DOM树的修改而实现的</p><p>DOM XSS 是由于浏览器解析机制导致的漏洞，服务器不参与，而存储型与反射型都需要服务器响应参与</p><p>存储型 XSS 也好，反射型 XSS 也罢，XSS 的本质问题就是让对方浏览器执行你插入的 JS。</p><h3 id="XSS-和-CSRF-区别"><a href="#XSS-和-CSRF-区别" class="headerlink" title="XSS 和 CSRF 区别"></a>XSS 和 CSRF 区别</h3><p>xss 强调的是 html、javascript 注入(innerHTML 的 script、img…，eval new Function 的 javascript)，而 csrf 只会实施一个请求某资源（接口）的操作</p><p>具体表现上：xss 是盗 cookie 干坏事，而 csrf 是借 cookie 干坏事</p><p>一般情况下，CSRF 需要服务端程序员来防范，XSS 需要客户端程序员来防范（如果 View 由服务端渲染则由服务端程序员防范）</p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EditorConfig-ESlint-Prettier</title>
      <link href="/2019/11/10/EditorConfig-ESlint-Prettier/"/>
      <url>/2019/11/10/EditorConfig-ESlint-Prettier/</url>
      
        <content type="html"><![CDATA[<h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p><a href="https://editorconfig.org/">EditorConfig</a> 是编辑器&#x2F;IDE 配置工具，需要编辑器&#x2F;IDE 支持，在 VSCode 上可通过 EditorConfig for VS Code 插件支持。</p><span id="more"></span><p>.editorconfig 配置：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>indent_style</td><td>缩进风格，tab、space</td></tr><tr><td>indent_size</td><td>缩进为 space 时，缩进的字符数</td></tr><tr><td>tab_width</td><td>缩进为 tab 时，缩进的宽度</td></tr><tr><td>end_of_line</td><td>换行符类型，lf、cr、crlf</td></tr><tr><td>charset</td><td>文件的 charset，latin1、utf-8、utf-8-bom、utf-16be、utf-16le</td></tr><tr><td>trim_trailing_whitespace</td><td>是否将行位空格自动删除</td></tr><tr><td>insert_final_newline</td><td>是否使文件以一个空白行结尾</td></tr><tr><td>root</td><td>表示是最顶层的配置文件，发现值为 true 时，才会停止查找 .editorconfig 文件</td></tr></tbody></table><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h2><p>JavaScript 作为一门动态弱类型语言，没有静态类型检测且允许隐式类型转换，虽然语法简洁自由，但是失去编译器的静态检测也带来了代码质量问题，另外 JavaScript 在设计上存在一些糟粕，比如 var、eval、++&#x2F;–、with…，为保证代码质量，对代码进行类型、风格、语法和逻辑静态检测是非常重要的。</p><p>类型的检测可交由 TypeScript，风格和语法的检测则需要使用 linter。</p><p>对代码风格、语法规则和逻辑进行静态检测，目的是为了统一代码风格和避免语法和逻辑错误。最早的 JavaScript 代码检测工具是 JSLint，由 Douglas Crockford 开发，其规则不可配置，JSHint 继承自 JSLint，支持规则的可配置性，ESLint 是一个基于 AST 的 lint，由 Nicholas C. Zakas 开发，支持规则的可配置性、自定义插件和自定义解析器。</p><p>ESlint 提供自定义解析器和插件，极大的丰富了其适用范围，不但能 lint 各版本标准的 ES 语法，还能 lint 实验性和非标准语法（比如 Flow 和 TypeScript），这种设计使得他能快速的响应变化。</p><p>ESLint 的默认解析器和核心规则仅支持标准的 ECMAScript 语法，不支持 Babel 提供的实验性（例如新功能）和非标准（例如Flow或TypeScript类型）语法（Babel 的生态已经超出了 ES 标准）。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>常见内置的规则有：</p><p>语法规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no-undef</span><br><span class="line">no-const-assign</span><br><span class="line">require-await</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for-direction 无限循环</span><br></pre></td></tr></table></figure><p>推荐建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eqeqeq</span><br><span class="line">no-var</span><br><span class="line">no-unused-vars</span><br></pre></td></tr></table></figure><p>代码风格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max-len</span><br><span class="line">no-mixed-spaces-and-tabs</span><br><span class="line">keyword-spacing</span><br><span class="line">comma-style</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><ul><li>Espree</li></ul><p>ESlint 使用解析器（parser）将代码解析成抽象语法树 (AST)，然后通过 AST 来分析代码。默认 AST 解析器为 <a href="https://github.com/eslint/espree">Espree</a>，只支持标准 ES 语法和 JSX，不支持 Babel 提供的实验性和非标准（例如 Flow、TypeScript）语法。</p><ul><li>@babel&#x2F;eslint-parser</li></ul><p>@babel&#x2F;eslint-parser（babel-eslint） 是 Babel 源代码的解析器。</p><ul><li>@typescript-eslint&#x2F;parser</li></ul><p>2019 年 TypeScript 官方配套的 TS 代码检测工具 TSLint 被弃用后，TypeScript 提供了此解析器用于将 TypeScript AST 转换成为 ESTree AST，使得 ESLint 能支持 TypeScript。</p><p>TypeScript Compiler 转化出来的 AST 与 ESLint 的 AST（ESTree，AST 的某一种规范）不兼容，@typescript-eslint&#x2F;parser 会读取 ESLint 的配置，并调用 @typescript-eslint&#x2F;typescript-estree 包用 TypeScript Compiler 将 TypeScript 的 sourcecode 转换为 TypeScript AST，然后将 TypeScript AST 转换为 ESTree。</p><p>TypeScript 中使用 ESlint 有两种方案 @typescript-eslint&#x2F;parser 和 @babel&#x2F;eslint-parser。</p><p>@typescript-eslint&#x2F;parser 解析器下，ESlint 能校验 TS 语法，但是 Babel 生态下的新特性将不会被解析，会被误判为 Error。@babel&#x2F;eslint-parser 解析器下，ESLint 不会校验任何的 TS 语法，而是将 TS 特性消除掉后基于 JS 的规则校验，要想在此方案下校验 TS 语法，可以用 VSCode，VSCode 对 TS 的支持非常友好，它会自动的提示 TS 错误，也可以额外的开启一个进程，用 tsc 检测 TS 语法。</p><ul><li>vue-eslint-parser</li></ul><p><a href="https://github.com/vuejs/vue-eslint-parser">vue-eslint-parser</a> 被用来解析 .vue 文件中的 <code>&lt;template&gt;</code>，配套 <a href="https://eslint.vuejs.org/">eslint-plugin-vue</a> 插件和<a href="https://eslint.vuejs.org/rules/">规则集</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Plugins 插件用来为 ESlint 新增自定义检测规则，比如自定义 React、Vue、TypeScript 的检测规则，命名规则为 eslint-plugin-xxx 或 @scopeName&#x2F;eslint-plugin。</p><p>常用的插件有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@babel/eslint-plugin（eslint-plugin-babel）为 @babel/eslint-parser 的配套 babel 源码规则</span><br><span class="line">eslint-plugin-react 为 ESLint 添加了一系列特定于 React 的规则</span><br><span class="line">@typescript-eslint/eslint-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot; // eslint-plugin-react，eslint-plugin- 的前缀可以省略</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注：plugins 只是指定规则，规则的开启还需要通过 rules 或 extends。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &#x27;eslint-plugin-react/jsx-boolean-value&#x27;: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &#x27;eslint-plugin-react/recommended&#x27;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &quot;plugin:react/recommended&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>plugin 中的规则会对指定的 AST 节点做出校验，confings 字段可配置规则，一般的插件会自带两种最佳实践配置 all 以及 recommened。自定义 plugin 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  meta: &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      description: &#x27;一个方法的参数最大数量不能超过3个&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function (context) &#123;</span><br><span class="line">    function getFunctionParamsLoc(node) &#123;</span><br><span class="line">      const paramsLength = node.params.length;</span><br><span class="line">      return &#123;</span><br><span class="line">        start: node.params[0].loc.start,</span><br><span class="line">        end: node.params[paramsLength - 1].loc.end,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      FunctionDeclaration: (node) =&gt; &#123;</span><br><span class="line">        if (node?.params?.length &gt; 3) &#123;</span><br><span class="line">          context.report(&#123;</span><br><span class="line">            loc: getFunctionParamsLoc(node),</span><br><span class="line">            node,</span><br><span class="line">            message: &#x27;一个方法的参数最大数量不能超过3个&#x27;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>env</li></ul><p>env 用来指定环境，设定能够解析的全局变量。不同环境下，存在不同的全局变量，如果代码运行在浏览器上，那 window 就是全局变量，在 nodejs 上，那 process 就是全局变量。如果不配置环境，ESLint 在遇到这些变量的时候，会认为这些变量没有定义，触发 no-undef 规则。</p><p>官网的 <a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments">Specifying Environments</a> 上列出了 ESLint 能配置的全部环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">browser - 浏览器环境中的全局变量</span><br><span class="line">node - Node.js 全局变量和 Node.js 作用域</span><br><span class="line">es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>globals</li></ul><p>globals 也是用来设定能够解析的自定义全局变量的，作用跟 env 类似。比如 env 没有微信小程序环境，这是可通过 globals 单个配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">globals: &#123;</span><br><span class="line">  wx: true, // true 表示该变量为 writeable，而 false 表示 readonly</span><br><span class="line">  App: true,</span><br><span class="line">  Page: true,</span><br><span class="line">  Component: true,</span><br><span class="line">  getApp: true,</span><br><span class="line">  getCurrentPages: true,</span><br><span class="line">  Behavior: true,</span><br><span class="line">  global: true,</span><br><span class="line">  __wxConfig: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rules</li></ul><p>rules 用来配置规则。ESLint 中的规则很多，但是默认都不会开启，需要在 rules 中设定这些规则开关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">off 或 0：关闭规则</span><br><span class="line">warn 或 1：开启规则（warn 级别的错误）</span><br><span class="line">error 或 2：开启规则（error 级别的错误）</span><br></pre></td></tr></table></figure><ul><li>extends</li></ul><p>rules 逐条配置规则非常繁琐，因此 ESLint 设计了 extends 这个字段，用于继承别的已经配置好的的规则。在不加入任何插件的情况下，extends 可以配置为 <code>eslint: recommended</code> 或 <code>eslint: all</code>，recommended 是 ESLint 官方推荐的配置（即带对勾标记的规则），校验的规则比较少，eslint: all 则会开启全部的规则校验。</p><p>extends 扩展支持三种类型的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;eslint: recommended&quot;, // all</span><br><span class="line">    &quot;eslint-config-standard&quot;, //  eslint-config-airbnb、@vue/eslint-config-airbnb，可缩写为 standard、airbnb、@vue/airbnb</span><br><span class="line">    &quot;plugin: react/recommended&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eslint: xxx</code> 是 ESLint 官方配置包，一共有两个配置项 <code>recommended</code>、<code>all</code>。</p><p><code>eslint-config-xxx</code> <code>@scopeName/eslint-config-xxx</code> 是第三方 npm 配置包，可以简写 <code>xxx</code> 或 <code>@scopeName/xxx</code>，常用的有 <a href="https://github.com/standard/eslint-config-standard">eslint-config-standard</a>、<a href="https://github.com/airbnb/javascript">eslint-config-airbnb</a>、<a href="https://github.com/vuejs/eslint-config-airbnb">@vue&#x2F;eslint-config-airbnb</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  rules: &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plugin: xxx</code> 是插件内自带的配置包，也可以直接在 plugins 属性中进行设置，常用的有 <a href="https://github.com/jsx-eslint/eslint-plugin-react">eslint-plugin-react</a> 规则自带两种配置方案 all 以及 recommened。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configs: &#123;</span><br><span class="line">    config1: &#123;</span><br><span class="line">      plugins: [&#x27;myplugin&#x27;],</span><br><span class="line">      rules: &#123;</span><br><span class="line">        &quot;myplugin/rule1&quot;: &quot;error&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    rule1: &#123;</span><br><span class="line">      create: function (context) &#123;</span><br><span class="line">        // rule implementation ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends 是一个数组，可以配置多组规则，每个配置继承它前面的配置。实际开发中，我们会继承一些优秀的 ESLint 方案，比如 airbnb</p><ul><li>plugins</li></ul><p>见上面插件。</p><h3 id="与-VSCode-集成"><a href="#与-VSCode-集成" class="headerlink" title="与 VSCode 集成"></a>与 VSCode 集成</h3><p>ESlint npm 包是 Nodejs cli 工具，需要执行命令行才能 lint，而且 lint 信息只显示在命令行中，在 VSCode 中可通过 VSCode ESLint 插件（插件不是必需的）将 ESlint 集成至 VSCode，该插件会在项目启动的时候起一个后台任务，读取项目本地的 ESlint 配置，实时的检测代码，带来更直观的开发体验。</p><h2 id="Perttier"><a href="#Perttier" class="headerlink" title="Perttier"></a>Perttier</h2><p>ESlint 是代码检测工具，虽然 –fix 参数具有修复能力，能自动修复 max-len、no-mixed-spaces-and-tabs、keyword-spacing…等风格问题，但不能完全代替代码格式化工具，特别是换行，以下两段代码在 ESlint 中都是允许的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123;a, b, c&#125; = obj;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">a,</span><br><span class="line">  b,</span><br><span class="line">  c,</span><br><span class="line">&#125; = obj;</span><br></pre></td></tr></table></figure><p>Prettier 代码格式化工具，能保证代码风格的完全一致，其不但能格式化 JS，还能格式化 HTML、CSS、JSON、VUE、Angular、TypeScript、JSX…。</p><p>.prettierrc.js 配置说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 单行代码字符数限制</span><br><span class="line">  printWidth: 80, </span><br><span class="line">  // tab缩进大小,默认为2</span><br><span class="line">  tabWidth: 4,</span><br><span class="line">  // 使用tab缩进，默认false</span><br><span class="line">  useTabs: false,</span><br><span class="line">  // 使用分号, 默认true</span><br><span class="line">  semi: false,</span><br><span class="line">  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)</span><br><span class="line">  singleQuote: false,</span><br><span class="line">  //仅仅当必须的时候才会加上双引号</span><br><span class="line">  quoteProps: &#x27;as-needed&#x27;,</span><br><span class="line">  // 行尾逗号,默认none,可选 none|es5|all</span><br><span class="line">  // es5 包括es5中的数组、对象</span><br><span class="line">  // all 包括函数对象等所有可选</span><br><span class="line">  trailingComma: &#x27;all&#x27;,</span><br><span class="line">  // 对象中的空格 默认true</span><br><span class="line">  // true: &#123; foo: bar &#125;</span><br><span class="line">  // false: &#123;foo: bar&#125;</span><br><span class="line">  bracketSpacing: true,</span><br><span class="line">  // JSX标签闭合位置 默认false</span><br><span class="line">  // false: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125;</span><br><span class="line">  //       &gt;</span><br><span class="line">  // true: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125; &gt;</span><br><span class="line">  jsxBracketSameLine: false,</span><br><span class="line">  // 箭头函数参数括号 默认avoid 可选 avoid| always</span><br><span class="line">  // avoid 能省略括号的时候就省略 例如x =&gt; x</span><br><span class="line">  // always 总是有括号</span><br><span class="line">  arrowParens: &#x27;avoid&#x27;,</span><br><span class="line">  // vue template 中的结束标签结尾尖括号掉到了下一行</span><br><span class="line">  htmlWhitespaceSensitivity: &#x27;ignore&#x27;, </span><br><span class="line">  // .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span><br><span class="line">  vueIndentScriptAndStyle: false,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Prettier 和 ESlint 一起使用时，如果二者的格式化规则不一致会造成冲突，需要使用 eslint-config-prettier 来关闭 ESLint 中与 Prettier 冲突的规则，代码的格式化完全交给 Prettier。另外，还可通过 eslint-plugin-prettier 插件，将 Prettier 作为规则在 ESlint 中使用。</p><p>跟 ESlint 一样，Prettier 既可通过 npm 包，以工程化自动化方式使用，也可在 VSCode 中通过插件使用。</p><p>注：其实 VSCode 默认的代码格式化工具挺好用的。</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端开发规范</title>
      <link href="/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>代码规范的可通过文档约定和 CodeRevice，但这主观性太强，不容易落地，最理想的方式还是在工程化层面，借助灵活配置的工具，工程化自动化的解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ESLint + Prettier: JavaScript/TypeScript/VUE/React 代码规范</span><br><span class="line">Stylelint: CSS 代码规范</span><br><span class="line">Editorconfig: 编辑器配置工具</span><br><span class="line">Prettier: 代码格式化工具</span><br></pre></td></tr></table></figure><span id="more"></span><p><a href="https://www.cnblogs.com/Yellow-ice/p/15346883.html">https://www.cnblogs.com/Yellow-ice/p/15346883.html</a></p><h2 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h2><p>Git 工作流规范（Husky + Commitlint + Lint-staged），提交规范（Commitizen）</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 类型系统</title>
      <link href="/2019/07/26/JavaScript-Type-System/"/>
      <url>/2019/07/26/JavaScript-Type-System/</url>
      
        <content type="html"><![CDATA[<p>类型动静态（静态类型检测），类型强弱（类型转换）。</p><p>JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo = 42; // foo is now a number</span><br><span class="line">foo = &#x27;hello&#x27;; // foo is now a string</span><br><span class="line">foo = true;  // foo is now a boolean</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 + &#x27;&#x27;;</span><br><span class="line">!!1; // 这个算隐式还是显式</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的概念：xxxx。与数据结构的关系。</p><p>JavaScript 中一共有 8 种内置（Built-In）数据类型：</p><h3 id="原始类型（Primitive-types）"><a href="#原始类型（Primitive-types）" class="headerlink" title="原始类型（Primitive types）"></a>原始类型（Primitive types）</h3><p>原始类型也被称为基本类型，表示不能再细分下去的类型，具有原子性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* string: 一串表示文本值的字符序列</span><br><span class="line">* number: 整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）</span><br><span class="line">* boolean: 包含两个值 true 和 false</span><br><span class="line">* null: 只包含一个值 null</span><br><span class="line">* undefined: 只包含一个值 undefined</span><br><span class="line">* symbol: 一种实例是唯一且不可改变的数据类型</span><br><span class="line">* bigInt</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于这些类型被存储在栈内存中，也被称为值类型。</p><p>todo… 这里应该有内存图</p><p>又由于这些类型的值是不可变的，又被称为不可变类型。</p><p>原始类型是不可变的，没有任何方法可以直接改变其值，只会生成新的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#x27;hello&#x27;;</span><br><span class="line">foo.substr(1);</span><br><span class="line">foo.toLowerCase(1);</span><br><span class="line">foo[0] = 1;</span><br><span class="line">console.log(foo);  // hello</span><br><span class="line"></span><br><span class="line">// 栈内存原始空间中的值并没有改变，只是开辟了一块新空间，将变量名指向新的空间</span><br><span class="line">foo += &#x27;world&#x27;;</span><br><span class="line">console.log(foo); // hello world</span><br></pre></td></tr></table></figure><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* object</span><br></pre></td></tr></table></figure><p>声明一个对象通常有以下几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;; // 字面量形式，推荐</span><br><span class="line">const foo = new Object(); // new 调用</span><br><span class="line">const foo = Object(); // 与 new 调用相同</span><br><span class="line">cosnt foo = Object.create(null); // 空对象</span><br></pre></td></tr></table></figure><p>由于 <code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>… 这些对象都是 <code>Object</code> 对象的子类，所以全部归类为 object 类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.__proto__ === Object.prototype; // true</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于对象类型被存储在堆内存中，也被称为引用类型。</p><p>todo… 这里应该有内存图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &#x27;hello&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">const bar = foo;</span><br><span class="line">foo.msg = &#x27;hello world&#x27;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">const bar = foo;</span><br><span class="line">foo[foo.length] = foo.length + 1;</span><br></pre></td></tr></table></figure><p>又由于值是可变的，又被称为可变类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &#x27;hello&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.msg = &#x27;hello world&#x27;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">foo.push(4);</span><br><span class="line">foo.length = 0;</span><br></pre></td></tr></table></figure><ul><li>包装对象</li></ul><p>string、number、boolean 这三种原始类型值在引用属性和方法时，会通过调用 new String()、new Number() 和 new Boolean() 的方式自动转换成对象，也就是原始类型的“包装对象（Wapper object）”，一旦引用结束，便会销毁这个临时的包装对象。</p><p>不是所有的原始类型都有包装对象，null 和 undefined 就没有包装对象，访问它们的属性会报类型错误。</p><p>“JavaScript 中一切皆是对象”这是一个错误的论断，原始类型的 string、number、boolean 会转化为对应的包装对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof &#x27;seymoe&#x27;; // &#x27;string&#x27;</span><br><span class="line">typeof new String(&#x27;seymoe&#x27;); // &#x27;object&#x27;</span><br><span class="line">typeof String(&#x27;seymoe&#x27;); // &#x27;string&#x27;</span><br></pre></td></tr></table></figure><p>注：Number、String 和 Boolean 如果不作为构造函数调用（即调用时不加 new），常常用于将任意类型的值转为数值、字符串和布尔值。</p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符被用来检测数据的类型，其返回一个表示数据类型的字符串，它能检测除 <code>null</code> 和值为 <code>function</code> 的 <code>object</code> 类型外的所有类型。</p><p>null 由于历史设计失误，typeof 返回了 object（如果从类 Java 语言的角度理解），而 function 由于很特殊（构造函数）typeof 特殊处理返回了 function，</p><p>typeof 不能检测除 function 外的 object 子类型，如果想要检测子类型，则需要使用 instanceof 或 Object.prototype.toString 方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br><span class="line">(&#123;&#125;) instanceof Object // true</span><br><span class="line">(()=&gt;&#123;&#125;) instanceof Function // true</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 用来检测类型有缺陷，首先它会检测整个原型链，另外，它不能在 iframe 中跨页面检测，因为不在同一个 <code>window</code> 对象下，原型链无法关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Object; // true</span><br></pre></td></tr></table></figure><p><code>[].__proto__ === Array.prototype</code>，而又 <code>Array</code> 属于 <code>Object</code> 子类型，即 <code>Array.prototype.__proto__ === Object.prototype</code>，最终 <code>[].__proto__.__proto__ === Object.prototype</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">window.frames[0].foo(arr);</span><br><span class="line"></span><br><span class="line">// iframe</span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(data instanceof Array);  // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>data</code> 时的 <code>Array</code> 跟 iframe 里的 <code>Array</code> 属于不同的 <code>window</code> 对象下，不是同一个类。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>终极解决方案，不但能检测基本类型，还能检测 object 子类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&#x27;hello&#x27;); // &#x27;[object String]&#x27;</span><br><span class="line">Object.prototype.toString.call(1); // &#x27;[object Number]&#x27;</span><br><span class="line">Object.prototype.toString.call(true); // &#x27;[object Boolean]&#x27;</span><br><span class="line">Object.prototype.toString.call(null); // &#x27;[object Null]&#x27;</span><br><span class="line">Object.prototype.toString.call(undefined); // &#x27;[object Undefined]&#x27;</span><br><span class="line">Object.prototype.toString.call(Symbol()); // &#x27;[object Symbol]&#x27;</span><br><span class="line">Object.prototype.toString.call(BigInt(2)) // &quot;[object BigInt]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;); // &#x27;[object Object]&#x27;</span><br><span class="line">Object.prototype.toString.call([]); // &#x27;[object Array]&#x27;</span><br><span class="line">Object.prototype.toString.call(() =&gt; &#123;&#125;); // &#x27;[object Function]&#x27;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()); // &#x27;[object Date]&#x27;</span><br><span class="line">Object.prototype.toString.call(new RegExp());</span><br><span class="line">Object.prototype.toString.call(Math); // &#x27;[object Math]&#x27;</span><br><span class="line">Object.prototype.toString.call(new Set()); // &#x27;[object Set]&#x27;</span><br><span class="line">Object.prototype.toString.call(new WeakSet()); // &#x27;[object WeakSet]&#x27;</span><br><span class="line">Object.prototype.toString.call(new Map()); // &#x27;[object Map]&#x27;</span><br><span class="line">Object.prototype.toString.call(new WeakMap()); // &#x27;[object WeakMap]&#x27;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><a href="https://juejin.cn/post/6844903752332214280">https://juejin.cn/post/6844903752332214280</a></p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ul><li>toString</li></ul><p>基础类型强制转为 string 类型在规范中明确说明了，也比较符合直觉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(1); // &quot;1&quot;</span><br><span class="line">String(true); // &quot;true&quot;</span><br><span class="line">String(null); // &quot;null&quot;</span><br><span class="line">String(undefined); // &quot;undefined&quot;</span><br><span class="line">String(Symbol(&#x27;hello&#x27;)); // &quot;Symbol(hello)&quot;</span><br></pre></td></tr></table></figure><p>Object 类型在强制转换为 string 类型的时候，调用的是该类型原型上的 toString 方法，而 Object 的各个子类型基本都重写了 toString 方法，所以在进行 toString 操作的时候表现有差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String(&#123; a: 2 &#125;); // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2]); // &quot;1,2&quot;</span><br><span class="line">String(/reg/g); // &quot;/reg/g&quot;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2];</span><br><span class="line">arr.toString(); // &quot;1,2&quot;</span><br><span class="line">String(arr); // &quot;1,2&quot;</span><br><span class="line"></span><br><span class="line">// 重写toString</span><br><span class="line">arr.toString = function() &#123;</span><br><span class="line">  return this.join(&#x27;/&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">String(arr); // &quot;1/2&quot;</span><br></pre></td></tr></table></figure><ul><li>toNumber</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">true + 0;</span><br><span class="line">&#x27;1&#x27; + [&#x27;hello&#x27;, 1];</span><br><span class="line">&#123;&#125; + [];</span><br><span class="line">[] + &#123;&#125;;</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">&#x27;2&#x27; + &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#x27;hello&#x27;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x27;2&#x27; + obj;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true == 1;</span><br><span class="line">false === 0; // false</span><br><span class="line">false + false === 0; // true</span><br><span class="line">[] == ![];</span><br><span class="line">[undefined] == false;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/64446259">https://zhuanlan.zhihu.com/p/64446259</a><br><a href="https://juejin.cn/post/6844903870712283149">https://juejin.cn/post/6844903870712283149</a><br><a href="https://juejin.cn/post/6844903983429976078">https://juejin.cn/post/6844903983429976078</a><br><a href="https://juejin.cn/post/6844903854882947080">https://juejin.cn/post/6844903854882947080</a><br><a href="https://juejin.cn/post/6844903902295359502">https://juejin.cn/post/6844903902295359502</a><br><a href="https://juejin.cn/post/6844903937930346509">https://juejin.cn/post/6844903937930346509</a><br><a href="https://juejin.cn/post/6971935704938971173">https://juejin.cn/post/6971935704938971173</a><br><a href="https://juejin.cn/post/6861500194232467470">https://juejin.cn/post/6861500194232467470</a><br><a href="https://juejin.cn/post/6918892282192068622">https://juejin.cn/post/6918892282192068622</a><br><a href="https://juejin.cn/post/6844903682018902029">https://juejin.cn/post/6844903682018902029</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM 私仓</title>
      <link href="/2019/07/01/Sinopia/"/>
      <url>/2019/07/01/Sinopia/</url>
      
        <content type="html"><![CDATA[<p>npm 私仓可用于提高包的下载速度和保护内部代码，常见的 npm 私仓技术方案有以下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* npm on-site  # 缺点是收费，而且 npm 在国内访问慢</span><br><span class="line">* Git + SSH 直接引用到 GitHub 项目地址 # 缺点是不能更新（npm update），不能使用 Semver（语义化版本规范），而且 URL 不美观</span><br><span class="line">* cnpm</span><br><span class="line">* Sinopia/Verdaccio</span><br><span class="line">* Nexus</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Sinopia-x2F-Verdaccio"><a href="#Sinopia-x2F-Verdaccio" class="headerlink" title="Sinopia&#x2F;Verdaccio"></a>Sinopia&#x2F;Verdaccio</h2><p>Sinopia 是一个零配置的私有的带缓存功能的 npm 包管理工具。使用 Sinopia，不用安装 CouchDB 或 MYSQL 之类的数据库，Sinopia 有自己的迷你数据库，如果要下载的包不存在，它将自动去你配置的 npm 地址上去下载，而且硬盘中只缓存你现在过的包，以节省空间。</p><p>Sinopia 特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 不同步拉取 npm 库，占据大量硬盘，没有硬盘被撑爆的问题</span><br><span class="line">* 安装配置极其简单，不需要数据库</span><br><span class="line">* 支持配置上游 Registry 配置，一次拉取即缓存</span><br><span class="line">* 支持 Forever 及 Pm2 守护进程管理</span><br></pre></td></tr></table></figure><p>注意：由于 Sinopia 已经没人维护了，推荐使用 <a href="https://github.com/verdaccio/verdaccio">Verdaccio</a>，Verdaccio 是 Sinopia 的 Fork，安装配置基本和 Sinopia 一致。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Sinopia 前，首先要确保已经安装 Node，Linux 下安装 Node 参考具体章节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sinopia -g</span><br></pre></td></tr></table></figure><p>Sinopia 目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 程序安装目录（全局安装目录在不同配置下会不一样）</span><br><span class="line">|-- /usr/sbin/nodejs/lib/node_modules/sinopia/</span><br><span class="line"></span><br><span class="line"># 配置和存储目录</span><br><span class="line">|-- /root/.config/sinopia/</span><br><span class="line">    |-- config.yaml  # 配置文件</span><br><span class="line">    |-- htpasswd     # 用户和密码信息</span><br><span class="line">    |-- storage      # 包存储位置（除了 publish 的私包，通过 npm install xx 安装的公共包也会缓存到这个目录，安装过的包再次安装时会直接从这个目录取）</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinopia</span><br></pre></td></tr></table></figure><p>启动成功后，会有下面两行提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warn  --- config file  - /root/.config/sinopia/config.yaml</span><br><span class="line">warn  --- http address - http://0.0.0.0:4873/</span><br></pre></td></tr></table></figure><p>上面一行是 Sinopia 的配置文件所在路径，下面一行是 Sinopia 服务的域名和端口号。然后打开 <code>http://localhost:4873</code>（可通过 curl），如果能正常访问，说明安装成功。</p><ul><li>网络访问</li></ul><p>默认情况下只能本机 <code>localhost:4873</code> 访问，如果想通过 IP 让其他机器也能访问到，需要在 <code>/root/.config/sinopia/config.yaml</code> 最后一行添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure><p>好了，再试一次 <code>192.168.10.14:4873</code>，成功访问。如果还不行，可能是防火墙导致，默认情况下防火墙没有开放 4873 端口，需要开放相应的端口。CentOS 6 和 CentOS 7 不一样，以 CentOS 6 为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进入编辑防火墙配置文件（修改 OUTPUT ACCEPT 下的内容）</span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 然后加上下面这句（作用是防止防火墙占用80端口）</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 再加上下面这一句（开放 4873 端口）</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 4873 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 最后记得重启一下防火墙</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><ul><li>PM2 做守护进程</li></ul><p>Node 服务非常脆弱，一般在实际中使用都会配合守护进程。这里选用 PM2 做守护进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 PM2</span><br><span class="line">npm install -g pm2</span><br><span class="line"></span><br><span class="line"># 通过 PM2 启动 Sinopia</span><br><span class="line">pm2 start `which sinopia`</span><br></pre></td></tr></table></figure><p>注：更多 PM2 操作指南参考相关文档。另外，如果想要结束 PM2 守护的 Sinopia 进程，可使用以下方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop sinopia    # 参数也可以是具体的 PM2 id（不是 pid），比如 pm2 stop 0</span><br></pre></td></tr></table></figure><p>也可以手动结束，操作步骤如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有进程</span><br><span class="line">ps -A</span><br><span class="line"></span><br><span class="line"># 查询结果如下</span><br><span class="line">3239 ?         00:00:31 watch</span><br><span class="line">6035 ?         00:00:11 PM2 v2.10.3: Go</span><br><span class="line">27690 ?        00:00:01 sinopia</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 杀掉 watch 和 sinopia 这两个进程</span><br><span class="line">kill 3239</span><br><span class="line">kill 27690</span><br></pre></td></tr></table></figure><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the default config file. It allows all users to do anything,</span><br><span class="line"># so don&#x27;t use it on production systems.</span><br><span class="line">#</span><br><span class="line"># Look here for more config file examples:</span><br><span class="line"># https://github.com/rlidwka/sinopia/tree/master/conf</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># path to a directory with all packages</span><br><span class="line">storage: ./storage                     # npm 包存放的路径（可以将将此目录指向其他目录）</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd                   # 用于存储 npm 用户的账号和密码信息</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    #max_users: 1000                   # 最大允许的用户数量，默认值为 1000，-1 则为禁止注册</span><br><span class="line"></span><br><span class="line"># a list of other known repositories we can talk to</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/   # 上游源，默认为 npm 的官网，可以使用淘宝的 npm 镜像地址</span><br><span class="line"></span><br><span class="line">packages:                              # 配置权限管理</span><br><span class="line">  &#x27;@*/*&#x27;:</span><br><span class="line">    # scoped packages</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装。$all 所有人，$authenticated 通过验证的人，$anonymous 匿名者</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line">    proxy: npmjs                       # 默认没有这项</span><br><span class="line">    </span><br><span class="line">  &#x27;*&#x27;:</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    #</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish packages</span><br><span class="line">    # (anyone can register by default, remember?)</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry</span><br><span class="line">    proxy: npmjs                       # 如其名，这里的值是对应于 uplinks</span><br><span class="line"></span><br><span class="line"># log settings</span><br><span class="line">logs:</span><br><span class="line">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class="line">  #- &#123;type: file, path: sinopia.log, level: info&#125;</span><br><span class="line"></span><br><span class="line">listen: 0.0.0.0:4873                   # 默认没有这项，只能在本机访问，添加后可以通过外网访问</span><br></pre></td></tr></table></figure><p>部分配置字段意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">storage    # 仓库保存的路径</span><br><span class="line">auth       # 验证相关</span><br><span class="line">uplinks    # 配置上游的 npm 服务器，主要是用于请求的仓库不存在时去上游服务器拉取</span><br><span class="line">packages   # 配置模块/包的发布(publish)、下载(access)的权限等</span><br><span class="line">listen     # 配置监听端口与主机名</span><br></pre></td></tr></table></figure><ul><li>auth 配置</li></ul><p>max_users: -1 表示我们将最大用户数设置为－1，表示禁用 npm adduser 命令来创建用户，不过我们仍然可以通过当前目录下的 htpasswd 文件来初始化用户。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yorkie:&#123;SHA&#125;?????????????????=:autocreated 2016-02-05T15:33:46.238Z</span><br><span class="line">weflex:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T15:39:19.960Z</span><br><span class="line">james:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T17:59:05.041Z</span><br></pre></td></tr></table></figure><p>上面的加密算法也很简单，就是简单的 SHA1 哈稀之后再转换成 Base64 输出就好，后面跟着的只是表示时间。</p><ul><li>packages 配置</li></ul><p>配置大致分为两个部分，一个是以 <code>@*/*</code> 为开头的，另一个则是通配符 <code>*</code>。</p><p>这个当然就是对 package.json 中的 name 字段进行匹配，比如 @webassemblyjs&#x2F;<a href="mailto:&#97;&#115;&#x74;&#x40;&#49;&#46;&#51;&#46;&#x31;">&#97;&#115;&#x74;&#x40;&#49;&#46;&#51;&#46;&#x31;</a> 将匹配第一个配置，而 express 则匹配第二个。这里这么配置的意义在于：一般团队或者公司的私有项目，会采用不同的权限控制，于是这里借用了 npm 的 scoped name 即 @company 的形式，例如 @weflex&#x2F;app 即表示 WeFlex 下属的 app 项目了。</p><p>接下来，每一个命名过滤器（filter）下都有三项基本设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access    # 表示哪一类用户可以对匹配的项目进行安装(install)</span><br><span class="line">publish   # 表示哪一类用户可以对匹配的项目进行发布(publish)</span><br><span class="line">proxy     # 如其名，这里的值是对应于 uplinks 的</span><br></pre></td></tr></table></figure><p>对于 1 和 2 的值，我们通常有以下一些可选的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$all            # 表示所有人都可以执行对应的操作</span><br><span class="line">$authenticated  # 表示只有通过验证的人可以执行对应操作</span><br><span class="line">$anonymous      # 表示只有匿名者可以进行对应操作（通常无用）</span><br></pre></td></tr></table></figure><p>或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作。</p><ul><li>为 packages 中 <code>@*/*</code> 字段配置代理源</li></ul><p><code>&#39;@*/*&#39;</code> 下添加 <code>proxy: npmjs</code> 配置，给 scoped packages（<a href="https://docs.npmjs.com/misc/scope">npm 官方的定义</a>） 添加代理源，使得能够安装 scoped packages 类型的包（比如 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#x73;&#x74;&#64;&#49;&#x2e;&#51;&#x2e;&#49;">&#x61;&#x73;&#x74;&#64;&#49;&#x2e;&#51;&#x2e;&#49;</a>）。如果不配置此项，安装基本的包没有问题，但是，安装 scoped packages 包时，比如  webpack，会提示错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack</span><br><span class="line"></span><br><span class="line"># 出现以下错误</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found: @webassemblyjs/ast@1.3.1</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2018-05-09T06_26_23_190Z-debug.log</span><br></pre></td></tr></table></figure><p>这是在安装 @webassemblyjs&#x2F;<a href="mailto:&#x61;&#x73;&#x74;&#x40;&#49;&#x2e;&#x33;&#46;&#49;">&#x61;&#x73;&#x74;&#x40;&#49;&#x2e;&#x33;&#46;&#49;</a> 这个包时出的问题，sinopia 会提示 404。上面安装的包就是这类的包，常见的有 @angular @type 等。修改配置和代码后，重启 sinopia，这时再次安装就会提示成功。</p><p>如果还不成功，可能就是老版本 sinopia 的 bug 导致的（我这版中没出息这个问题），sinopia 每次向 npmjs 请求安装某个包时，请求地址都是转码后再向 npm 请求的，所以会将 @ 转码为 %40，但是 npm 不能识别 %40，所以导致 404 的错误。</p><p>这个时候只需要修改 sinopia 中的转码的地方就可以了。转码的文件是 up-storage.js,，修改 up-storage.js 中的 encode 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var encode = function (url) &#123;</span><br><span class="line">  return encodeURIComponent(url).replace(/^%40/, &#x27;@&#x27;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><p>通过服务器来新建用户。服务器上将 registry 改为 <a href="http://localhost:4873：">http://localhost:4873：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure><p>然后添加用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line"># 填写如下信息</span><br><span class="line">user: admin</span><br><span class="line">password: admin</span><br><span class="line">email: admin@admin.com</span><br></pre></td></tr></table></figure><p>这时 htpasswd(config.yaml 同目录) 文件下会生成相应的信息。</p><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://192.168.10.14:4873        # 设置 npm 源</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://192.168.10.14:4873  # 添加用户。如果不发布 npm 包，是不需要注册和登录的，登录 npm 是为了发布包</span><br><span class="line">npm login                                         # 登录 npm。注，npm adduser 成功的后默认就登陆了，所以不需要再 npm login</span><br><span class="line">npm whoami                                        # 检测身份</span><br></pre></td></tr></table></figure><p>注：推荐用 nrm 来管理 npm 源。具体的 nrm 操作查看 node 的 npm 相关章节。</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx              # 选项有 --save (-S)、--save-dev (-D)、-g</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>切换到私有仓库，登录成功之后，就可以执行 npm publish 发布到这个私有 npm 上面啦，发布包的操作跟 npm 官方发布包无差别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login                    # 登录 npm</span><br><span class="line">npm publish                  # 发包</span><br><span class="line">npm unpublish --force test   # 撤销发布。撤销 test 这个包，如果是在当前包的根目录下操作，可以省略包名</span><br></pre></td></tr></table></figure><p>发布包注意事项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 包的名称和版本就是你项目里 package.json 里的 name 和 version，author 字段可以显示包的作者，为空则表示匿名</span><br><span class="line">* 不能和已有的包的名字重名，发布前可通过 npm 的查找是否已存在相同名称的包（npm search xxx）</span><br><span class="line">* npm 对包名的限制：不能有大写字母/空格/下滑线（testPublish、test_publish 都会又报错）</span><br></pre></td></tr></table></figure><h2 id="使用-Docker-安装-Verdaccio"><a href="#使用-Docker-安装-Verdaccio" class="headerlink" title="使用 Docker 安装 Verdaccio"></a>使用 Docker 安装 Verdaccio</h2><p>参考 Docker 安装 Verdaccio <a href="https://verdaccio.org/docs/en/docker.html">文档</a>。</p><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull verdaccio/verdaccio    # 拉取 Verdaccio 的 Docker Image，不指定版本下，拉取的是 latest</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><ul><li>新建宿主机目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上新建需要挂载到的目录（路径可自选）</span><br><span class="line">mkdir /home/kpg/verdaccio</span><br><span class="line">mkdir /home/kpg/verdaccio/conf</span><br><span class="line">mkdir /home/kpg/verdaccio/storage</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取配置文件 config.yaml</span><br><span class="line">cd /home/kpg/verdaccio/conf</span><br><span class="line">git clone https://github.com/verdaccio/docker-examples</span><br><span class="line">mv docker-examples/docker-local-storage-volume/conf/config.yaml config.yaml</span><br><span class="line">rm -rf docker-examples    # config.yaml 复制好后，删除这个目录</span><br></pre></td></tr></table></figure><p>注：如果没有将 config.yaml 配置文件放在 <code>/home/kpg/verdaccio/conf/</code> 目录下，会导致浏览器将访问不了，<code>docker run</code> 看不出错误，只有通过 <code>docker logs</code> 查找日志，才能发现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps                # 找到 verdaccio container id</span><br><span class="line">docker logs containerId  # 查找日志</span><br></pre></td></tr></table></figure><ul><li>设置宿主机目录权限</li></ul><p><code>mkdir verdaccio</code> 创建的目录属主是当前宿主机用户，而每个 docker container 都会运行在自建的用户上。所以要注意挂载目录的权限，要不然 <code>npm adduser</code> 和 <code>npm install</code> 无法写入，提示 500 服务器错误，查看容器日志会有下面这样的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs --tail 20 verdaccio</span><br><span class="line">EACCES: permission denied, open &#x27;/verdaccio/conf/htpasswd&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it verdaccio sh    # 进入容器查找容器的用户 ID（进入后 Shell 前缀变成了 ~）。直接在宿主机里面 cat /etc/passwd 查找不到</span><br><span class="line">whoami                          # 查看当前用户</span><br><span class="line">cat /etc/passwd                 # 找到当前用户的 User ID (10001) 和 Group ID (65533)。docker 容器中的 uid 和 gid 和宿主机是共享的，只是没有具体名称</span><br><span class="line">exit                            # 退出容器</span><br><span class="line">chown -R 10001:65533 verdaccio  # 在宿主机下设置目录权限。-R 表示递归设置</span><br></pre></td></tr></table></figure><ul><li>挂载宿主机目录</li></ul><p>可以在启动时通过 <code>-v</code> 将宿主机目录挂载到容器内目录，也可以通过 docker-compose.yml 来配置 volumes。</p><ul><li>配置 config.yaml</li></ul><p>基本配置参考上面，storage、htpasswd 要指向容器内目录，uplinks 可以使用淘宝 npm 私仓：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">storage: /verdaccio/storage</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: /verdaccio/conf/htpasswd</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>如果将启动参数放在命令中，做成脚本文件来启动会更加方便（如果用 docker-compose 启动，将参数放在 docker-compose.yml 中也很方便）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name verdaccio \</span><br><span class="line">--restart always \</span><br><span class="line">-p 4873:4873 \</span><br><span class="line">-v /home/kpg/verdaccio/conf:/verdaccio/conf \</span><br><span class="line">-v /home/kpg/verdaccio/storage:/verdaccio/storage \</span><br><span class="line">-v /home/kpg/verdaccio/plugins:/verdaccio/plugins \</span><br><span class="line">verdaccio/verdaccio</span><br></pre></td></tr></table></figure><p><code>-v</code> 用于挂载宿主机的一个目录，<code>:</code> 前面的目录是宿主机目录，后面的目录是容器内目录。</p><ul><li>一个错误</li></ul><p><code>npm publish</code> 时出现了一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">npm ERR! code E503</span><br><span class="line">npm ERR! 503 Service Unavailable - PUT http://npm.kpg123.com/sdf - one of the uplinks is down, refuse to publish</span><br></pre></td></tr></table></figure><p>查看 <a href="https://github.com/verdaccio/verdaccio/issues/78">Issues</a> 和<a href="https://verdaccio.org/docs/en/configuration.html#offline-publish">配置文档</a>发现，By default verdaccio does not allow to publish when the client is offline, that behavior can be overridden by setting this to true.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish:</span><br><span class="line">  allow_offline: true</span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>如果 nginx 直接安装在宿主机，直接 <code>/etc/nginx/conf.d</code> 下新建 nginx.conf 文件，填入以下内容即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream npm &#123;</span><br><span class="line">    server 127.0.0.1:4873;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name npm.kpg123.com;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://npm;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端 host，然后就可以通过域名访问了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.101 npm.kpg123.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Pages</title>
      <link href="/2019/06/20/Git-Pages/"/>
      <url>/2019/06/20/Git-Pages/</url>
      
        <content type="html"><![CDATA[<p>GitHub Pages 用于介绍用户个人和托管在 GitHub 中的项目的，免费，虽然<a href="https://help.github.com/en/articles/what-is-github-pages#usage-limits">空间和流量有限制</a>（空间上限 1G、月流量上限 100G、每小时更新不超过 10 次），但绝对够用。</p><span id="more"></span><h2 id="新建-GitHub-Pages"><a href="#新建-GitHub-Pages" class="headerlink" title="新建 GitHub Pages"></a>新建 GitHub Pages</h2><p><a href="https://pages.github.com/">GitHub Pages</a> 分两类：User or Organization site (个人或组织 site) 和 Project site (项目 site)。</p><ul><li>个人或组织 site</li></ul><p>仓库名必须为 <code>username.github.io</code>（username 为用户在 github 上的用户名，比如 <code>tracy-xu.github.io</code>），分支为 master，其分支的内容将会被构建和发布在你的 GitHub Pages site 上，这样的 pages 一般一个账号只能有一个，通过 <code>username.github.io</code> 访问。</p><ul><li>项目 site</li></ul><p>可以在 gh-pages 分支上，也可以在 Settings –&gt; GitHub Pages 下设置，通过 <code>username.github.io/project-name</code> 访问。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>为 GitHub Pages 绑定域名需要两步：第一步生成 CNAME 文件，第二步域名解析。</p><h3 id="生成-CNAME-文件"><a href="#生成-CNAME-文件" class="headerlink" title="生成 CNAME 文件"></a>生成 CNAME 文件</h3><p>GitHub Pages CNAME 文件记录自定义域名，其作用是，当访问自定义域名时，会通过 DNS 解析到 GitHub 的服务器 IP，GitHub 仓库千万个，GitHub 服务器会根据 HTTP Host 匹配对应 CNAME 文件所在的仓库，如果没有这个文件，GitHub 服务器不知道返回哪个仓库，会显示 404。</p><p>在 <code>tracy-xu.github.io</code> 这个 rep 中点击 Settings，然后在 Custom domain 中填入要绑定的域名 <code>yunguxt.cn</code>。这个操作会在项目的根目录生成 CNAME 文件，里面内容就是所要绑定的域名 <code>yunguxt.cn</code>。</p><p>注：为防止在像 Hexo 这样一些博客系统中被打包覆盖，可以在 Hexo 中手动创建 CNAME。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>以阿里云为例，登陆阿里云控制台进行域名解析。记录类型有两种方式可选择：A 记录（A 将域名指向一个 IPV4 地址）、CNAME（CNAME 将域名指向另外一个域名）记录。</p><ul><li>A 记录</li></ul><p>A 记录需要找到 git pages 的 IP（ping tracy-xu.github.io 结果是 185.199.110.153），然后再进行后续设置。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>A</td><td>www</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>A</td><td>@</td><td>默认</td><td>185.199.110.153</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：主机记录 www 和 @ 都要添加，这是为了 <code>www.yunguxt.cn</code> 和 <code>yunguxt.cn</code> 都能访问到页面。</p><ul><li>CNAME 记录</li></ul><p>CNAME 记录不需要通过 IP 来绑定，记录值直接填写 <code>tracy-xu.github.io</code> 即可。</p><table><thead><tr><th>记录类型</th><th>主机记录</th><th>解析线路（isp）</th><th>记录值</th><th>MX优先级</th><th>TTL</th><th>状态</th><th>操作</th></tr></thead><tbody><tr><td>CMAME</td><td>www</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr><tr><td>CMAME</td><td>@</td><td>默认</td><td>tracy-xu.github.io</td><td>–</td><td>10 分钟</td><td>正常</td><td>修改,暂停,删除,备注</td></tr></tbody></table><p>注意：域名解析设置完成后，如果还是不能访问，这是因为在等服务商分配 DNS，等待 10 来分钟就可以了，如果还不能访问，就是因为其他原因了，比如阿里云中域名没进行实名认证不能被解析（不分配 DNS 服务器）。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>GitHub Pages 开放了自定义域名 HTTPS 支持，不用再自己买证书或借用第三方服务，就能开启网址左边的小绿锁了。</p><p>设置步骤根据你的自定义域名解析类型分为两种：A、CNAME。</p><ul><li>A 记录</li></ul><p>A 记录的话只需将解析的 ip 指向如下四个即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>其余的步骤和上面域名解析一样。</p><p>注：也可以通过 CNAME 来混合设置，设置 4 个 @ 主机记录的 A 记录和 1 个 www 主机记录的 CNAME 记录。</p><ul><li>CNAME 记录</li></ul><p>只需要在 Repositorys 设置中勾选 Enforce HTTPS 的选项即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow</title>
      <link href="/2019/04/25/Git-Flow/"/>
      <url>/2019/04/25/Git-Flow/</url>
      
        <content type="html"><![CDATA[<p>Git 工作流（Work Flow）是一种分支管理策略。在开发人员较少，项目不复杂时，可以采用简单的工作流，比如只有一个 Master 分支，但当项目庞大，迭代周期长，多人协作，多需求并行时，就需要更加严格的 Work Flow 来管理开发、测试、发布和热修复了。在 Git 中常见的工作流有 Git Flow、GitHub Flow、GitLab Flow。</p><span id="more"></span><p>2010 年 5 月，Vincent Driessen 在 “<a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>” 中介绍了一种构建在 Git 之上的软件开发模型。通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离。这种软件开发的活动模型被 Vincent 称为 “Git Flow”。</p><h2 id="Git-Flow-基本流程"><a href="#Git-Flow-基本流程" class="headerlink" title="Git Flow 基本流程"></a>Git Flow 基本流程</h2><p><img src="/images/engineering/git/git-flow.jpg" alt="Git Flow 流程图"></p><p>从 Git Flow 流程图可以看出，Git Flow 的核心是 Branch，通过在项目的不同阶段对 Branch 的不同操作（create、merge、rebase…）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类，Main Branchs（主分支） 和 Supporting Branches（辅助分支），其中 Main Branchs 包含了 Master 和 Develop，而 Supporting Branches 包含了 Feature、Release、Hotfix 以及其他自定义分支。Main Branchs 是长期分支，存活在项目的整个生命周期中，而 Supporting branches 分支是短期分支，短期分支合并后需要删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master -- 主分支</span><br><span class="line">* develop -- 开发分支</span><br><span class="line">* feature/* -- 功能分支</span><br><span class="line">* release/* -- 预发布分支</span><br><span class="line">* hotfix/* -- 热修复分支</span><br></pre></td></tr></table></figure><p>在实践中，需求的创建、提测、发布应由项目负责人完成，普通的开发人员只需要开发功能和改 Bug。也就是说，对于 Master、Develop 这两个公共分支，只有项目负责人有操作权限，普通开发人员只有 Feature、Release、Hotfix 三个辅助分支的操作权限，这样既保证了 Master 和 Develop 的整洁，而且普通开发人员也不需掌握 Git Flow。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>主分支用于发布，存放的是最稳定的正式版本。禁止在此分支上修改代码，只接受其他分支合并（Release、Hotfix）。另外，不管是用来发布 Release 还是 Hotfix，都需要打 Tag。</p><p>注：初始化时，可使用 <code>--allow-empty</code> 参数来 commit 一个空分支（<code>git flow init</code> 就是如此），<code>git commit --allow-empty -m &quot;initial commit&quot;</code>。</p><h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><p>开发分支用于日常开发，是 Feature 和 Release 分支的基础分支，存放最新的开发版（隔夜版 Nightly，是要发布到下一个 Release 的代码）。这个分支可能包含一定的 Bug（Release 还未合并的情况下），但不影响创建新的 Feature 进行新功能的开发（但是需要注意的是，假如 feature&#x2F;b 基于 feature&#x2F;a 的 Develop 创建，这时候的 feature&#x2F;b 不能比 feature&#x2F;a 早发布，如果想早发布只能将这个 feature&#x2F;b 当作一个 Hotfix 了）。</p><p>跟 Master 一样，Develop 的变动也只能是合并（Feature、Release），不能是直接修改。</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>功能分支用于开发新功能、代码重构、优化…，基于 Develop 创建，一般命名为 feature&#x2F;xxx。新功能开发完成，会合并回 Develop 分支进入下一个 Release。</p><p>Feature 分支命名规则是，分支类型&#x2F;分支发布时间-分支功能。比如：feature&#x2F;20170401-fairy-flower，时间使用年月日命名，不足 2 位补 0。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>预发布分支用于预发布（测试和测试阶段的 Bug 修复）。当需要发布一个新 Release 时，可以基于 Develop 分支创建一个 Release 分支，一般命名为 release&#x2F;v1.0.0（关于版本号的命名规则参考相关章节），完成 Release 后，需要合并到 Master 和 Develop。</p><p>版本就是在这个阶段确定的，所以这个分支的命名会加版本后缀。版本正式发布前可生成 Changelog 文档，然后再发布上线。</p><h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><p>热修复分支，用于修改线上 Bug（比如回归时的 Bug，或者用户反馈的 Bug）。基于 Master 创建，一般命名为 hotfix&#x2F;v1.0.0，测试通过后合并到 Master 分支和 Develop 分支。</p><h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的操作必然是频繁且重复的，这个时候可通过 <a href="https://github.com/nvie/gitflow">Git flow script 工具</a>来简单化复杂的 Git 命令。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">apt-get install git-flow</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br><span class="line"># Windows 上或者</span><br><span class="line">curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh</span><br><span class="line">bash gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow help          # 查看帮助</span><br><span class="line">git flow feature help  # 查看 feature 帮助</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line">git flow init                           # 初始化。会询问分支的命名，初始化完成后自动切换到了 develop 分支。支持 -f -d 参数</span><br><span class="line"></span><br><span class="line"># feature</span><br><span class="line">git flow feature start MYFEATURE        # 开始一个 feature。相当于 git checkout -b feature/MYFEATURE</span><br><span class="line">git flow feature publish MYFEATURE      # publish 一个 feature。相当于 git push</span><br><span class="line">git flow feature pull origin MYFEATURE  # 获取 publish 的 feature</span><br><span class="line">git flow feature finish MYFEATURE       # 完成一个 feature。该命令将 feature 分支合并入 develop 分支，并切换到 develop 删除 feature</span><br><span class="line"></span><br><span class="line"># release</span><br><span class="line">git flow release start MYRELEASE        # 开始一个 release。git flow release start v1.0.0，分支全称是 release/v1.0.0</span><br><span class="line">git flow release publish MYRELEASE      # publish 一个 release</span><br><span class="line">git flow release finish MYRELEASE       # 发布一个 release。该命令将 release 合并入 master 和 develop 并切换到 master，删除该 release，创建 tag</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">git flow hotfix start MYVERSION         # 开始一个 hotfix</span><br><span class="line">git flow hotfix finish MYVERSION        # 发布一个 hotfix</span><br></pre></td></tr></table></figure><p><code>git flow init</code> 会询问分支的命名，发布和预发布这两个分支名称采用默认的 master 和 develop 即可，而其他的分支需要填写前缀，比如 <code>feature/</code>。参数 <code>-f</code> 表示强制初始化（可用于重置 git flow 初始化配置），参数 <code>-d</code> 表示使用默认配置初始化。Git Flow 仓库配置是本地配置，换电脑后需要再次初始化配置，为保证各配置相同，最好是使用 <code>git flow init -d</code> 初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br><span class="line"></span><br><span class="line">Initialized empty Git repository in /Users/tracy-xu/Desktop/test/.git/</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? [] version/</span><br></pre></td></tr></table></figure><p>注：Release 和 Hotfix 命令使用和 Feature 一样，只是有些细微区别，比如 <code>git flow release finish</code> 命令将会将 Release 分支合并入 Master 和 Develop 两个分支，且会打上版本号（tag 需要有 message，要不然会创建失败）。</p><p><img src="/images/engineering/git/git-flow-commands.png" alt="git-flow-commands"></p><p>附：<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">Git-Flow 备忘清单</a></p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit Message Style Guide</title>
      <link href="/2019/04/20/Git-Commit-Message-Style-Guide/"/>
      <url>/2019/04/20/Git-Commit-Message-Style-Guide/</url>
      
        <content type="html"><![CDATA[<p>在 Git 中，我们使用 <code>git commit -m &quot;xxx&quot;</code> 来提交代码，参数 <code>-m</code> 用来指定 Commit Message（提交说明），直接执行 <code>git commit</code> 会进入编辑器模式，可提交多行说明。Commit Message 应规范化，规范化的 Commit Message 能带来很多好处：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 提交说明明确，方便快速浏览和查找，比如 git log --pretty=format:%s, git log HEAD --grep feature</span><br><span class="line">* 可以直接从 Commit Message 生成 Change Log</span><br></pre></td></tr></table></figure><p>目前，社区中有很多 Commit Message 规范，本文介绍 Angular Commit Message 规范，因其合理、系统，且有配套工具，在社区中得到来广泛的应用。</p><h2 id="Angular-Commit-Message-规范"><a href="#Angular-Commit-Message-规范" class="headerlink" title="Angular Commit Message 规范"></a>Angular Commit Message 规范</h2><p><a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines">Angular commit message guidelines</a> 中将 Commit message 分为三个部分：Header，Body 和 Footer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。<code>&lt;BLANK LINE&gt;</code> 指空行，各个部分必须由空行分割。为了避免自动换行影响美观，不管是哪一个部分，任何一行都不得超过 72 个字符（或 100 个字符）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs(changelog): update changelog to beta.5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fix(ivy): prevent templateOverrides from causing infinite loop (#29402)</span><br><span class="line"></span><br><span class="line">Previously, the transitive scope calculation could lead into re-compiling</span><br><span class="line">the same module multiple times. This fix ensures we cannot get into this loop.</span><br><span class="line">It should be fixed more completely (e.g. more cases) once FW-1178 is resolved.</span><br><span class="line"></span><br><span class="line">PR Close #29402</span><br></pre></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需）。</p><ul><li>type</li></ul><p>type 用于说明 Commit 的类别，只允许使用下面 9 个标识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* build      # 构建过程或辅助工具的变动。影响构建系统或外部依赖关系的更改（比如：Gulp、Broccoli、NPM）</span><br><span class="line">* chore      # 其他修改，比如改变构建流程，或增加依赖库、工具等</span><br><span class="line">* ci         # 配置文件（对 CI 配置文件和脚本的更改，比如：Travis、Circle、BrowserStack、SauceLabs）</span><br><span class="line">* docs       # 文档（Documentation，比如 Readme、Changelog、Contribute 等等）</span><br><span class="line">* feat       # 新功能（Feature）</span><br><span class="line">* fix        # 修复 Bug</span><br><span class="line">* prerf      # 性能（提高性能的代码更改，比如，提升性能、体验）</span><br><span class="line">* refactor   # 重构（即不是新增功能，也不是修改 bug 的代码变动）</span><br><span class="line">* style      # 格式（不影响代码运行的变动，比如：空白、换行、分号等）</span><br><span class="line">* test       # 测试（增加测试或更正现有测试）</span><br><span class="line">* revert     # 回滚（回滚到某一个版本，带上版本号）</span><br></pre></td></tr></table></figure><p>如果 type 为 feat 和 fix，则该 Commit 将肯定出现在 Change Log 之中。其他情况（docs、chore、style、refactor、test）建议不要放入 Change Log。</p><ul><li>scope</li></ul><p>scope 用于说明 Commit 影响的范围，比如框架中的数据层、控制层、视图层，或业务中某个业务模块，视具体项目的不同而不同，比如：user 用户、pay 支付、product 产品、article 文章、core 核心、router 路由、api 接口、doc 文档…</p><ul><li>subject</li></ul><p>subject 是 Commit 目的的简短描述，不超过 50 个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</span><br><span class="line">* 第一个字母小写</span><br><span class="line">* 结尾不加句号（.）</span><br></pre></td></tr></table></figure><p>常用表述语有：add、change、update、remove、delete。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 Commit 的详细描述，可以分成多行。有两个注意点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 使用第一人称现在时，比如使用 change 而不是 changed 或 changes</span><br><span class="line">* 应该说明代码变动的动机，以及与以前行为的对比</span><br></pre></td></tr></table></figure><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li>不兼容变动</li></ul><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>关闭 Issue 或 Pull requests</li></ul><p>在开源的项目中，如果当前 commit 针对某个 issue 或 pr，那么可以在 Footer 部分关闭这个 issue 或 pr。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fixes #21388</span><br><span class="line">PR Closes #234</span><br></pre></td></tr></table></figure><p>常用的表述语有 sclose、fix、resolve。</p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 Commit 用于撤销以前的 Commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 This reverts commit <hash>.，其中的 Hash 是被撤销 Commit 的 SHA 标识符。</p><p>如果当前 Commit 与被撤销的 Commit 在同一个发布（Release）里面，那么它们都不会出现在 Change Log 里面。如果两者在不同的发布，那么当前 Commit，会出现在 Change Log 的 Reverts 小标题下面。</p><h2 id="设置-Commit-Message-Template"><a href="#设置-Commit-Message-Template" class="headerlink" title="设置 Commit Message Template"></a>设置 Commit Message Template</h2><p>通过设置全局 .gitconfig 来指定 Commit Message 模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><p>TortoiseGit 中可通过依次点击 <code>settings -&gt; Git -&gt; Edit global .gitconfig</code>，然后编辑这个全局 .gitconfig 文件，在其末尾加入 commit 字段配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = xxxxxx@qq.com</span><br><span class="line">    name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">    recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">    helper = manager</span><br><span class="line">[commit]</span><br><span class="line">  template = d:/commit-template</span><br></pre></td></tr></table></figure><h2 id="生成-Change-Log"><a href="#生成-Change-Log" class="headerlink" title="生成 Change Log"></a>生成 Change Log</h2><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档。如果所有 Commit Message 都符合 Angular Commit Message 规范，那么发布新版本时，可以用 <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog</a> 这个工具自动生成 <a href="https://github.com/angular/angular/blob/master/CHANGELOG.md">CHANGELOG.md</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change Log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动。如果想要生成所有发布的 Change Log，要运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure><p>生成的文档包括以下三个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* New features</span><br><span class="line">* Bug fixes</span><br><span class="line">* Breaking changes.</span><br></pre></td></tr></table></figure><p>每个部分都会罗列相关的 Commit ，并且有指向这些 Commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。</p>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录 Date 中的两个坑</title>
      <link href="/2019/04/01/Javascript-Date-Something/"/>
      <url>/2019/04/01/Javascript-Date-Something/</url>
      
        <content type="html"><![CDATA[<h2 id="new-Date-参数-dataString-格式问题"><a href="#new-Date-参数-dataString-格式问题" class="headerlink" title="new Date 参数 dataString 格式问题"></a>new Date 参数 dataString 格式问题</h2><p>new Date(dataString) 中，参数 dataString 必须符合 ISO 8601 标准或者 RFC 2822 标准，现代主流浏览器这两个标准都支持（IE8 只支持 RFC 2822，不支持 ISO 8601）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(&#x27;2019-01-25T09:14:10.099+00:00&#x27;).getTime();    // ISO 8601 标准。返回 1548407650099</span><br><span class="line">new Date(&#x27;2019/01/25 09:14:10+0000&#x27;).getTime();         // RFC 2822 标准。返回 1548407650000</span><br></pre></td></tr></table></figure><p>然而，在实际工作中，后台（Java）返回的是格式既不是标准的 ISO 8601 也不是标准的 RFC 2822 格式，而是 ISO 8601 和 RFC 2822 混合格式，时区使用的是 RFC 2822 格式，比如，2019-01-25T09:14:10.099+0000，这个格式只有 Chrome 支持，其他浏览器都不支持（比如 iOS WebView、IE），执行 getTime 操作会返回 NaN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date(&#x27;2019-01-25T09:14:10.099+0000&#x27;).getTime();     // NaN</span><br></pre></td></tr></table></figure><span id="more"></span><p>对于这个问题，要么要求后端返回标准的日期字符串格式，要么前端将数据纠正（moment、data-fns 就做了处理）。</p><h2 id="setDate-的副作用"><a href="#setDate-的副作用" class="headerlink" title="setDate 的副作用"></a>setDate 的副作用</h2><p>setDate 参数如果超出了月份的合理范围，会向上个月或下个月设置，&lt;&#x3D; 0 时，会设置上个月的日期，0 是最后一天，-1 是倒数第二天，以此类推，超出范围的正整数同理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                            // 2 月 28</span><br></pre></td></tr></table></figure><p>我们可以利用这个特性来获取月份的天数和判断是否是闰年：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取月份天数</span><br><span class="line">function getMonthDayCount(year, month) &#123;</span><br><span class="line">  return new Date(year, month, 0).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMonthDayCount(2017, 10);   // 31</span><br><span class="line"></span><br><span class="line">// 获取一年中所有月份天数</span><br><span class="line">function getAllMonthDayCount(year) &#123;</span><br><span class="line">  var days = [31, new Date(year, 2, 0).getDate(), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</span><br><span class="line">  return days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAllMonthDayCount(2016);    // [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 是否是闰年</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样是不是更容易理解</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return new Date(year, 2, 0).getDate() === 29;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isLeapYear(2000);             // true</span><br></pre></td></tr></table></figure><ul><li>副作用</li></ul><p>但是，当在同一个 Date 对象上连续执行 setDate 操作时，不单单会偏移日期，还会连续偏移月份，这会影响后面的计算，导致结果出错。在实现 Calender 组件时发现这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                    // 2 月 28</span><br><span class="line"></span><br><span class="line">d.setDate(-1);</span><br><span class="line">d;                    // 理想希望返回 2 月 27，但是返回的是 1 月 30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 技术要点</title>
      <link href="/2018/12/15/Vue/"/>
      <url>/2018/12/15/Vue/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h2><ul><li>优点</li></ul><p>渐进式：框架设计（可以直接引入使用，仅使用核心渲染功能，也可以配合构建工具，集成路由和数据管理，采用单文件组件的开发模式）<br>声明式渲染：响应式（数据驱动视图，当数据改变后，会通知视图，不是指响应式编程 Reactive Programming），不需要传统那样命令式的操作 DOM<br>组件化：<br>工程化：Vue-cli<br>全家桶？：vuex、vue-router  集中式数据管理和客户端路由</p><p>声明式渲染（Declarative View）与之相对应的是命令式渲染（Imperative View）</p><span id="more"></span><ul><li>特点</li></ul><p><a href="https://juejin.cn/post/6857669921166491662">https://juejin.cn/post/6857669921166491662</a></p><ul><li><p>nextTicket</p></li><li><p>props</p></li></ul><p>props 的作用</p><p>props 的作用：<br>直接在视图或逻辑（注意响应式处理，watch、key + created&#x2F;mounted）中消费；<br>初始化 data（一般命名为 initXXX，注意异步的 props，组件初始化完成，异步 props 才设置，这时组件内部会失去初始化时机，需要配合 v-if 或 key）</p><p>引用类型的 props；驱动组件逻辑（watch props，需要注意的是，如果 props 的变动早于组件的初始化，这时候是无法 watch，需要配合 created）</p><p>引用类型的副作用，有时候需要规避（比如 props 中），有时候需要利用（比如修改 v-for 列表中的某条数据）</p><p>props down 和 events up 是作为组件接口(高内聚低耦合)的存在</p><ul><li>key</li></ul><p>可用来刷新组件，配合 props 可用来做数据驱动逻辑的场景</p><ul><li>watch</li></ul><p>数据驱动逻辑</p><p>watch props，watch data</p><p>课堂内有时候 watch 不触发<br>个人感觉 watch 有些心智负担</p><ul><li>coputed</li></ul><p>依赖追踪，根据一个依赖数据，算出另一个数据<br>get、set</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>sync：语法糖<br>v-module：语法糖</p><p>组件的生命周期：4 个节点(create,mount,update,destroy)，2 个状态(before,after，怎么取名呢)，共 8 个生命周期</p><p>钩子函数：由系统调用的函数（相当于 callback，比如 data 函数）</p><p>生命周期的钩子函数：生命周期的钩子函数是钩子函数里面一类，是在生命周期某个节点调用的钩子函数</p><p>注意箭头函数词法 this 的使用，有时候需要避开，有时候又需要利用</p><p>组件间的通信：event bus 作为组件间数据通信优点就是简单，但是如果滥用，也有缺点，数据流向不明确，可读性，维护性都不好。</p><ul><li>sync</li></ul><p>sync 是 prop 和 event 的语法糖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:foo=&quot;bar&quot;</span><br><span class="line">@update:foo=&quot;(val) =&gt; bar = val&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:foo&#x27;, val);</span><br></pre></td></tr></table></figure><p>JSX 中需要写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo=&#123; this.bar &#125;</span><br><span class="line">&#123; ...&#123; on: &#123; &#x27;update:foo&#x27;: (val) =&gt; &#123; this.foo = val; &#125; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>:</code> 不是 JSX 语法，所以不能写为 <code>on-update:foo=&#123; this.handleVisibleReply_Deteil &#125;</code></p><p>sync 和 v-model 有什么区别</p><ul><li>slot</li></ul><p>&lt;slot<br>  name&#x3D;”operate”<br>  :assessment&#x3D;”item”</p><blockquote></slot></blockquote><p>&lt;template #operate&#x3D;”slotProps”&gt;<br>  &lt;el-button<br>    v-if&#x3D;”showEvaluate(slotProps.assessment)”<br>    type&#x3D;”primary”<br>    size&#x3D;”mini”<br>    @click&#x3D;”handleOpenAssessment(slotProps.assessment)”</p><blockquote></blockquote><pre><code>去评价</code></pre>  </el-button>  <el-button    v-else    type="primary"    size="mini"    @click="handleOpenTeacherReport(slotProps.assessment)"  >    查看评价  </el-button></template><p>&lt;template #default&#x3D;”slotProps”&gt;<br>  …<br></template></p><p>v-slot:default 和 v-slot:operate 已经被废弃</p><p>jsx 中写法<br>父组件</p><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;this.$scopedSlots.default(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line"></span><br><span class="line">            &#123;this.$scopedSlots.operate(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;AssessmentList</span><br><span class="line">    scopedSlots=&#123;&#123;</span><br><span class="line">        default: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">        operate: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ul><li>组件风格</li></ul><p>template 组件 和 jsx 组件，tsx 组件</p><p>element-ui 以及 element-plus 组件是基于 template 风格，而 ant-design-vue、vant 则是基于 tsx 风格的（2.0 版本是基于 js&#x2F;jsx 风格）</p><p><a href="https://www.zhihu.com/question/436260027">https://www.zhihu.com/question/436260027</a><br><a href="https://github.com/hujiulong/blog/issues/11">https://github.com/hujiulong/blog/issues/11</a><br><a href="https://www.zhihu.com/question/310485097/answer/591869966">https://www.zhihu.com/question/310485097/answer/591869966</a></p><p>jsx 组件</p><p>vue 默认支持 js&#x2F;jsx 组件，比如：</p><p>Level.jsx（后缀名也可改为 js）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const Tag = `h$&#123;this.level&#125;`;</span><br><span class="line">    return &lt;Tag&gt;&#123;this.$slots.default&#125;&#123;this.message()&#125;&lt;/Tag&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    message() &#123;</span><br><span class="line">      return &lt;div&gt;我是 &#123;this.level&#125; 级标签&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>template 和 jsx 都是描述视图层的 DSL，最终都会编译伟 vdom。template 提供了插值、循环、判断，这满足了<br>一般的视图渲染要求，而 jsx 有更强的编程能力，能够使用 javascript 完整的编程能力。</p><p>有哪些东西是 template 不能做到，需要用到 jsx 的。</p><p><a href="https://www.zhihu.com/question/436260027">https://www.zhihu.com/question/436260027</a></p><p><a href="https://www.zhihu.com/question/411745998">https://www.zhihu.com/question/411745998</a></p><ul><li><p>指令</p></li><li><p>过滤器</p></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件通常用来为 Vue 添加全局功能，比如，注册全局组件、添加实例方法、添加全局指令…，可通过 use 安装 Vue.js 插件。<br>如果插件是一个对象，必须提供 install 方法，如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p><p>Vue.use 用于安装 plugin，为第三方 plugin 提供 Vue 上下文，比如 Element-ui （他们自己没有 Vue，只能消费者提供）<br>对于本地的 plugin，因为有 Vue 环境，可以不用 use，<code>import Vue from &#39;vue&#39;</code> 即可。</p><ul><li>全局组件</li></ul><p>第三方组件库的注册方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = function install(Vue) &#123;</span><br><span class="line">  components.map(component =&gt; Vue.component(component.name, component));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般组件内部也会提供 install 方法，方便按需引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Dialog from &quot;./src/Dialog.vue&quot;;</span><br><span class="line"></span><br><span class="line">Dialog.install = function install(Vue) &#123;</span><br><span class="line">  Vue.component(Dialog.name, Dialog);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>实例方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.prototype.$xxx = xxx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>全局指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.directive(&#x27;default-img&#x27;, async (el, binding) =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123; install &#125;;</span><br></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>判断路由前进还是后退</p><p>push、replace</p><p>动态路由需要有 scope，要不然匹配范围太广，比如 <code>/:id</code></p><ul><li>路由嵌套</li></ul><p>动画、嵌套路由&#x2F;子路由（各子路由可以复用父路由，以达到组件公用）</p><p>嵌套路由的目的是为了复用公共组件的引用，通过嵌套路由，就不用一个个往路由组件中引用公共组件。常见的场景有：菜单栏、头部导航…，这种结构固定的页面中。</p><p>注意：通过嵌套路由引用的组件，在与其他组件通信时又些麻烦，所以一般建议，如果有通信需求，建议还是使用手动引用。</p><ul><li>路由刷新</li></ul><p>刷新路由组件比刷页面好，不用重新加载静态资源</p><p><a href="https://www.zhihu.com/question/49863095">https://www.zhihu.com/question/49863095</a></p><ul><li>相同路由跳转</li></ul><p>Vue Router 中，跳转同一个路由组件时，即使路由参数不同（query、path），默认下为了复用，路由组件不会被刷新，这也意味着组件的生命周期钩子不会被调用，数据不会被刷新，可使用以下方法解决：</p><p>强制刷新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;$route.fullPath&quot; /&gt;</span><br></pre></td></tr></table></figure><p>通过 watch $route 或 beforeRouteUpdate 来手动刷新数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.$watch(</span><br><span class="line">    () =&gt; this.$route.params,</span><br><span class="line">    (toParams, previousParams) =&gt; &#123;</span><br><span class="line">      // 对路由变化做出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async beforeRouteUpdate(to, from) &#123;</span><br><span class="line">  // 对路由变化做出响应...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>路由缓存</li></ul><p>keep-alive：列表到详情</p><p>替代 keep-alive 方案</p><p>通过 store、url 等方式缓存数据，可达到 keep-alive 缓存组件一样的效果，比如列表到详情中，如果将查询参数放到 url 中，返回时还能定位到具体的查询条件</p><p>列表到详情返回时维持列表的状态除 keep-alive 外，还有两种解决方案：<br>1）新开页（缺点–回退时前面页不知道，不会刷新；新开页要重新加载资源，慢）<br>2）缓存数据（url 或 store）而不是组件（比如myk 商城课程列表页），这是一个非常不错的办法</p><p>查询参数放 url 还有一个好处是分享</p><ul><li>滚动条位置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    scrollBehavior(to, from, savedPosition) &#123;</span><br><span class="line">        if (savedPosition || to.meta.keepAlive) &#123; // 浏览器前进后退按钮切换路由</span><br><span class="line">            return savedPosition;</span><br><span class="line">        &#125; else &#123; // 通过&lt;router-link&gt;切换</span><br><span class="line">            return &#123;x: 0, y: 0&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果数据是异步的，滚动条需要异步滚动，否则滚动位置会不准确</p><p>scrollBehavior 在 mounted 后执行，</p><p>需要将滚动行为与异步行为（Ajax、路由动画）结合起来，有些麻烦，有写人处理不好队列任务，干脆用 setTimeout。。。</p><p><a href="https://juejin.cn/post/6844903634484854797">https://juejin.cn/post/6844903634484854797</a><br><a href="https://segmentfault.com/a/1190000022054521?utm_source=tag-newest">https://segmentfault.com/a/1190000022054521?utm_source=tag-newest</a><br><a href="https://github.com/quasarframework/quasar/issues/1466">https://github.com/quasarframework/quasar/issues/1466</a><br><a href="https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js">https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js</a></p><p><a href="https://juejin.cn/post/6844903634484854797">https://juejin.cn/post/6844903634484854797</a></p><p>beforeRouteEnter 中提前获取数据是一种选择</p><p>  beforeRouteEnter(to, from, next) {<br>    getPost(to.params.id, (err, post) &#x3D;&gt; {<br>      next(vm &#x3D;&gt; vm.setData(err, post))<br>    })<br>  },</p><ul><li>路由权限控制</li></ul><p>HOC<br>路由守卫</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个状态管理库（数据库），其特点是持久化、集中式、响应式。其作用有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基础数据的持久化：应用的生命周期内，用户信息、会话信息等基础信息的持久化</span><br><span class="line">跨级组件通信：通信有两种，数据和事件</span><br><span class="line">集中化管理：集中化的数据对象可以保证数据的一致性。课堂中，数据由发布、订阅、恢复产生，多点的生产，这要求统一的数据对象来保证一致性</span><br></pre></td></tr></table></figure><p>对于数据流比较简单的系统，也只有用户信息需要用到 Store。</p><p>注：对于跨级组件通信，个人更愿意用 Event Bus，临时私有数据放组件内部 State 会显得更内聚（可通过容器组件与展示组件解耦），且数据会随组件的销毁而销毁，不会像 Store 由于持久化的特性，需手动清空（比如课堂中关闭窗口时，需要手动 resetState）。</p><ul><li>使用原则</li></ul><p>mutation 不能有副作用，action 不但允许副作用，还能有返回。<br>action 的本质是发布订阅<br>mutation 中不能用异步，这样会造成状态的改变不可被 DevTools 追踪。</p><p>mutation type 常量</p><ul><li>配合 Storage</li></ul><p>由于 State 存储在内存，如果想要数据在应用生命周期外也能持久化（比如 Token），则需存 Storage。另外，Storage 不是响应式的，但可以通过 state 的 set get 实现响应式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    get msg() &#123;</span><br><span class="line">      return localStorage.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">    set msg(val) &#123;</span><br><span class="line">      localStorage.msg = val;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setMsg(state, payload) &#123;</span><br><span class="line">      state.msg = payload;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>store 模式</li></ul><p>可以用 Vue.observable（vue2）、reactive（vue3） 创建一个简单的可响应数据对象来进行状态管理。</p><p>store 模式没有专业 store（vuex、pinia） 的健壮和丰富的功能，比如 vuex 就提供 time-travel 调试和插件机制。</p><p>Vue3,我决定不再使用Vuex</p><p><a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86">https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86</a><br><a href="https://juejin.cn/post/6898504898380464142">https://juejin.cn/post/6898504898380464142</a><br>使用Vue.observable()进行状态管理<br><a href="https://segmentfault.com/a/1190000019292569">https://segmentfault.com/a/1190000019292569</a><br><a href="https://www.jianshu.com/p/e97502f89bde">https://www.jianshu.com/p/e97502f89bde</a><br><a href="https://www.52cik.com/2020/02/29/vue-observable.html">https://www.52cik.com/2020/02/29/vue-observable.html</a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>代理<br>mock<br>完全版 vue</p><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><p>ssr</p><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><ul><li>Vue 2 的问题</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* TypeScript 支持不好</span><br><span class="line">* 逻辑抽象能力不强：HOC 或 Mixin 下的逻辑抽象有缺陷，逻辑关注点如果不被分离，意味着组件逻辑难以复用和分治，且难以阅读和理解，当项目体量变大时，会变得难以维护</span><br></pre></td></tr></table></figure><p>注：对于第二点，在 Vue2 中往往通过更合理的组件颗粒度划分来进行组件抽象，以组件复用和分治来代替逻辑复用和分治。</p><p>关注点分离（UI 的关注点分离、逻辑的关注点分离）</p><p>Mixin 的缺陷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命名冲突：Mixin 很容易发生 property 名冲突</span><br><span class="line">隐式依赖：通过对 this 扩展的依赖，既不不显式，也不能被 linter</span><br><span class="line">扩展性差：可重用性是有限的：mixin 不能传递参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性</span><br></pre></td></tr></table></figure><p>HOC 的缺陷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure><p>为了解决上述问题，Vue 3 中</p><p><a href="https://juejin.cn/post/7055224376437784589">https://juejin.cn/post/7055224376437784589</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 TypeScript 重写 Vue，获得更好的类型支持。</span><br><span class="line">在响应式系统上，使用 Proxy 替换 Object.defineProperty。</span><br><span class="line">加入 Compositon API 来更好的抽象组件逻辑。</span><br><span class="line">优化了Virtual DOM</span><br><span class="line">更好的Tree shaking</span><br><span class="line">&lt;script setup&gt;</span><br></pre></td></tr></table></figure><ul><li>Composition API</li></ul><p>Composition API 逻辑抽象 提供了更好的代码组织和逻辑复用能力。</p><p>注意：逻辑关注点分离的目的是复用和分治，将关注点相关代码收集一起独立为 useXXX 组合式函数，然后在 <code>setup</code> 组合式 API 的入口中组合，不要把所有逻辑不加抽象、不加简化地都写在其中，这样就失去了 compostion 的意义了，代码量大很难维护，是一种反模式。</p><p>个人认为 Composition API 是对 Options API 的补充，而不是否定，如果 Geek 一点，使用 Script-Setup Sugar，可以节省很多代码量，可完全代替 Options API</p><p><a href="https://github.com/vueuse/vueuse">https://github.com/vueuse/vueuse</a></p><p>Composition API 并不是把所有的逻辑都堆砌到 setup 中，setup 是组合入口，在这里组装 useXXX 的</p><p>可以在 src 目录下建立 composables 或 hooks 目录，将所有的 useXXX 函数放此处。</p><ul><li>Function-based API</li></ul><p>vue3 使用 Function-based API 而不是  Class API 的原因</p><p><a href="https://zhuanlan.zhihu.com/p/68477600">https://zhuanlan.zhihu.com/p/68477600</a><br><a href="https://zhuanlan.zhihu.com/p/68099662">https://zhuanlan.zhihu.com/p/68099662</a><br><a href="https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos">https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos</a><br><a href="https://www.zhihu.com/question/325397290/answer/691200893">https://www.zhihu.com/question/325397290/answer/691200893</a><br><a href="https://zhuanlan.zhihu.com/p/133819602">https://zhuanlan.zhihu.com/p/133819602</a></p><p>如果用户钟情于 Class API，可使用 vue-class-component<br><a href="https://www.zhihu.com/question/451424245/answer/1886655211">https://www.zhihu.com/question/451424245/answer/1886655211</a></p><p><a href="https://www.zhihu.com/question/416652570/answer/1431359551">https://www.zhihu.com/question/416652570/answer/1431359551</a><br><a href="https://zhuanlan.zhihu.com/p/436786508">https://zhuanlan.zhihu.com/p/436786508</a><br><a href="https://www.zhihu.com/question/453332049/answer/1835420993">https://www.zhihu.com/question/453332049/answer/1835420993</a></p><p><a href="https://blog.csdn.net/u010059669/article/details/112287552">https://blog.csdn.net/u010059669/article/details/112287552</a><br><a href="https://zhuanlan.zhihu.com/p/126552443">https://zhuanlan.zhihu.com/p/126552443</a><br><a href="https://www.zhihu.com/question/328247960">https://www.zhihu.com/question/328247960</a><br><a href="https://zhuanlan.zhihu.com/p/181673485">https://zhuanlan.zhihu.com/p/181673485</a><br><a href="https://zhuanlan.zhihu.com/p/432068658">https://zhuanlan.zhihu.com/p/432068658</a><br><a href="https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html">https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html</a><br><a href="https://www.zhihu.com/question/271485214">https://www.zhihu.com/question/271485214</a><br><a href="https://zhuanlan.zhihu.com/p/111715881">https://zhuanlan.zhihu.com/p/111715881</a></p><p>注：react hook 一样，处理 class component 关注点分离和难以复用问题，处理 function component 没有状态。</p><p>注：Opetion API 也可以叫 Object API？</p><ul><li>底层变化</li></ul><p>Vue 3为什么要用 Proxy API 替代 DefineProperty API？</p><p>proxy和defineproperty区别</p><p><a href="https://blog.csdn.net/weixin_43443341/article/details/124041094">https://blog.csdn.net/weixin_43443341/article/details/124041094</a><br><a href="https://segmentfault.com/a/1190000041084082">https://segmentfault.com/a/1190000041084082</a></p><ul><li>vue 3 的正确打开方式</li></ul><p>必须要用 script-setup sugar （vue3 兼容 option 是为了兼容，最佳实际自然是抛弃历史包袱使用 setup）<br>必须要用 TS（vue3 用 ts 重写的目的就是为了加强对 ts 的支持）<br>必须要用 provide&#x2F;inject<br>必须舍弃 lifecycle hooks</p><p><a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html">https://v3.cn.vuejs.org/api/sfc-script-setup.html</a></p><ul><li>生态</li></ul><p>Vuex4 对 TypeScript 并不友好，所以我选择 Pinia<br><a href="https://www.zhihu.com/question/478752529">https://www.zhihu.com/question/478752529</a><br><a href="https://zhuanlan.zhihu.com/p/413968851">https://zhuanlan.zhihu.com/p/413968851</a></p><p>Volar<br>&lt; setup&gt; + TS + Volar &#x3D; 真香<br>Vue.js作者尤雨溪在VueConf 2021谈Vue 3 生态进展<br><a href="https://www.bilibili.com/video/BV1JK4y1G7bf">https://www.bilibili.com/video/BV1JK4y1G7bf</a><br>27:40 开始，可以说 Volar 是 Vetur 的继任者<br><a href="https://zhuanlan.zhihu.com/p/401160130">https://zhuanlan.zhihu.com/p/401160130</a></p><ul><li>vue-class-component</li></ul><p><a href="https://github.com/vuejs/vue-class-component">https://github.com/vuejs/vue-class-component</a><br><a href="https://zhuanlan.zhihu.com/p/355315790">https://zhuanlan.zhihu.com/p/355315790</a><br><a href="https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6">https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6</a></p><p>注：vue-class-component匹配Vue 3的v8版本还没有正式的文档</p><p><a href="https://github.com/vuejs/vue-class-component/tree/master/example/src/components">https://github.com/vuejs/vue-class-component/tree/master/example/src/components</a><br>注：可以是 tsx 文件 也可以是 vue 文件</p><ul><li>vue-property-decorator</li></ul><p><a href="https://github.com/kaorun343/vue-property-decorator/issues/294">https://github.com/kaorun343/vue-property-decorator/issues/294</a><br>注：应该暂时还不支持 vue3，package.json 中的 vue-class-component 版本还是 7.0</p><p>vue class component 是vue 官方出的，vue property decorator 是社区出的<br>其中 vue class component 提供了 vue component 等等<br>vue property decorator 深度依赖了 vue class component 拓展出了很多操作符 @Prop @Emit @Inject 等等 可以说是 vue class component 的一个超集<br>正常开发的时候 你只需要使用 vue property decorator 中提供的操作符即可 不用再从vue class componen 引入vue component</p><h2 id="vue-范式"><a href="#vue-范式" class="headerlink" title="vue 范式"></a>vue 范式</h2><p>JavaScript 是一个多范式的语言，支持 Class、Object、Function。Options API、Class API、Function API 。</p><p>喜欢装饰器，Class Component，Service Class 风格的选择 Angular，喜欢纯函数，Function Component，Hooks 的选择 React，没有啥偏好的使用 Vue</p><h3 id="与-React-区别"><a href="#与-React-区别" class="headerlink" title="与 React 区别"></a>与 React 区别</h3><p><a href="https://github.com/lihongxun945/myblog/issues/21">https://github.com/lihongxun945/myblog/issues/21</a><br><a href="https://www.jianshu.com/p/b7cd52868e95">https://www.jianshu.com/p/b7cd52868e95</a><br><a href="https://zhuanlan.zhihu.com/p/396229611">https://zhuanlan.zhihu.com/p/396229611</a><br><a href="https://www.zhihu.com/question/309891718/answer/2282544794">https://www.zhihu.com/question/309891718/answer/2282544794</a></p><p>响应式原理不一样<br><a href="https://blog.csdn.net/SirM2z/article/details/71195059">https://blog.csdn.net/SirM2z/article/details/71195059</a><br><a href="https://juejin.cn/post/6844904113432444942">https://juejin.cn/post/6844904113432444942</a></p><p>react 面试题</p><p><a href="https://juejin.cn/post/6844903857135304718">https://juejin.cn/post/6844903857135304718</a></p><p><a href="https://juejin.cn/post/6944863057000529933">https://juejin.cn/post/6944863057000529933</a></p><p>响应式编程不是指的 RxJS Observable 那一套吗…和依赖追踪貌似关系不太大？</p><p><a href="https://juejin.cn/post/6844904103504527374">https://juejin.cn/post/6844904103504527374</a></p><p>目前市面上的三种框架，无非是以Vue为首的响应式ui，这种框架特定就是简单，在通常意义下运行得非常快，但大规模的依赖收集和清理会带来额外的运作成本和内存消耗。第二种就是react这类，依靠f -&gt; UI这种声明式方案来更新视图，这种的好处在于它比依赖native api的响应式框架灵活太多。最后一种就是svelte，这种东西完全就是为web component而生，特点就是傻快，但没办法做dsl转换了（没vdom）。不过因为它就作用于小范围的dom，往往在编写小页面和web component时会带来的性能会远超于使用virtual dom或者增量dom的前端三框架。</p><p><a href="https://www.zhihu.com/question/446377023/answer/1756125862">https://www.zhihu.com/question/446377023/answer/1756125862</a></p><p>个人倾向于认为即便有了调度的细粒度控制，整体上 React 计算 diff 的成本仍然比响应式框架高很多……像 concurrent mode 宣传中那样去优化跨越多帧（譬如 50-100ms 量级）的计算，无论怎么可控，听起来都已经像是有问题的了</p><p>vue-cli3<br><a href="https://blog.csdn.net/qinyuhua93/article/details/104820902">https://blog.csdn.net/qinyuhua93/article/details/104820902</a></p><p><a href="https://www.zhihu.com/question/471825415">https://www.zhihu.com/question/471825415</a><br><a href="https://zhuanlan.zhihu.com/p/441467856">https://zhuanlan.zhihu.com/p/441467856</a></p><p>vue3</p><p>Naive UI<br><a href="https://www.zhihu.com/question/463736268/answer/1928879382">https://www.zhihu.com/question/463736268/answer/1928879382</a></p><p>vuex&#x2F;Pinia</p><p>Vue 3 将成为新的默认版本<br><a href="https://zhuanlan.zhihu.com/p/460055155">https://zhuanlan.zhihu.com/p/460055155</a></p><p>Vite2 + Vue3 + TypeScript + Pinia<br><a href="https://zhuanlan.zhihu.com/p/441467856">https://zhuanlan.zhihu.com/p/441467856</a></p><p>升级 vue 版本<br>npm update vue -S<br>npm update vue-template-compiler -D</p><p>vue 和 vue-template-compiler，两者的版本需要同步，如果不同步项目会报错</p><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><ul><li>ref、reactive、toRef、toRefs</li></ul><p>这几个 API 设计的目的就是为了在 setup 中使用响应式数据，setup 中不能使用 data 选项，只能通过上述方式使用响应式数据。</p><p>ref：返回一个响应式且可变（官网咖啡图）的 ref 对象。既支持原始类型，也支持引用类型，当值为引用类型时，底层使用的是 reactive。在模板中可省略 value 属性（自动解包）。</p><p>reactive：返回对象的响应式副本（基于 ES6 proxy 实现，响应式转换是“深层”的——它影响所有嵌套 property）。相当于 Vue2.x 的 Vue.observable () API（vue 2 中 data 选项的底层就是 Vue.observable，这两种方式都能创建响应式数据）。reactive 只支持将引用类型响应式，不支持原始类型。</p><p>toRef：用来将断开的响应式对象（被 reactive 包裹的对象）中某一个属性包裹成 ref 对象，并保持其和原对象的引用</p><p>toRefs：toRefs 和 toRef 功能是一致的，但是可以批量创建多个 ref 对象，注意，不支持可选 prop<br>响应式对象一旦被展开，其响应式特性会丢失，可用 toRefs 来解决</p><ul><li>attrs</li></ul><p>attrs 和 props 很相似，也是基于父子通信的数据，如果传递给组件的 attribute 或者 v-on 事件监听器，没有显式地声明在所接收组件的 props 或 emits 上，那么就会被挂到 attrs 上，且透传的 attribute 会自动添加到根元素的 attribute 中。</p><p>选项式 API 中，可通过 $attrs 访问，setup 中可通过 context 访问，setup sugar（script-setup） 中可通过 useAttrs 访问。</p><ul><li>refs</li></ul><p>选项式 API 中，可通过 $refs 访问 DOM，setup 中通过 ref 或函数绑定访问 DOM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; ref=&quot;btn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">const btn = ref(null);</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">  console.log(btn.value);</span><br><span class="line">&#125;;</span><br><span class="line">return &#123;</span><br><span class="line">  btn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; :ref=&quot;refBtn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">let btn = null;</span><br><span class="line">const refBtn = (el)=&gt; &#123;</span><br><span class="line">  btn = el;</span><br><span class="line">&#125;;</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      console.log(btn, 11);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">  refBtn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &lt;li </span><br><span class="line">v-for=&quot;(item, index) in list&quot; </span><br><span class="line">:key=&quot;index&quot;</span><br><span class="line">:ref=&quot;refLi&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> setup() &#123;</span><br><span class="line">   const list = reactive([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]);</span><br><span class="line">const elLi = reactive([]);</span><br><span class="line">const refLi = (el) =&gt; &#123;</span><br><span class="line">  elLi.push(el);</span><br><span class="line">&#125;;</span><br><span class="line">   nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(elLi, 2222);</span><br><span class="line">   &#125;);</span><br><span class="line">return &#123;</span><br><span class="line">  list,</span><br><span class="line">     refLi,</span><br><span class="line">&#125;;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>defineComponent</li></ul><p>TS 类型本身是图灵完备的，类型图灵不完备的是发展不出类型体操的。</p><p>类型体操自然也有他的作用，比如说 Vue 就通过了大量的类型体操才实现了 defineComponent 的类型推导，否则你面对的可能是大量的 unknown 或 any。</p><p>defineComponent 最重要的是：在TypeScript下，给予了组件 正确的参数类型推断 </p><p>将一个 组件用 defineComponent 包裹，仅仅只是为了 在 ts 下对传递给 option 组件 setup() 的参数进行类型推断（script setup 没有此问题，defineProps 有类型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">status</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;primary&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里的 props 被推到为 any 了</span></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emits</li></ul><p>setup 选项的 this 不指向当前实例(undefined)，只能通过 context 使用 emit（推荐使用 emits 选项来定义组件可触发的事件），setup sugar 中通过 defineEmits 的返回使用 emit</p><p>emits 或 defineEmits 用来定义组件可向其父组件触发的事件。强烈建议声明组件所 emit 的事件，这尤为重要，vue3 中移除了 .native 修饰符，任何未在 emits 中声明的事件都将默认绑定到组件的根节点上（与 .native 修饰符的作用一样），对于那些被透传的原生事件，会被触发两次，emit 一次和应用在根元素上的原生事件一次。</p><p>vue2 中，组件上的 v-on 只会监听自定义事件 (用 $emit 触发的事件)，如果要监听根元素的原生事件，可以使用 .native 修饰符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><p>以上代码，在 Vue3 中，如果组件内部没有用 emits 声明事件，则 click 事件会被。而在 Vue2 中，click 算自定义事件，如果想成为原生事件需要加 native 修饰符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click.native=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><ul><li>expose</li></ul><p>Vue3 新特性，如果是 options api 类型的组件，不声明 expose 时，默认暴露当前组件实例的全部内容，声明了 expose 选项，expose 数组内标记的才会暴露。（expose:[]则什么都不暴露，注意这个问题。也可以利用这个特性提高组件使用的规范。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  expose: [&#x27;nameA&#x27;,...], // 可以 expose 当前实例的任何内容</span><br><span class="line">  methods: &#123;</span><br><span class="line">    nameA()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> setup 语法糖的情况下，默认是封闭的，需要获取当前组件里的内容的话，必须显式 expose 出去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&#x27;ts&#x27; setup&gt;</span><br><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;;</span><br><span class="line">let refData = ref(&#x27;寒蝉鸣泣之时&#x27;)</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  refData,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>TS类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref,Ref &#125; from &quot;vue&quot;;</span><br><span class="line">//&gt; defineExpose</span><br><span class="line">interface exFace &#123;</span><br><span class="line">  ex1:Ref&lt;string&gt;,</span><br><span class="line">  ex2?:number</span><br><span class="line">&#125;</span><br><span class="line">let ex1 = ref(&#x27;1&#x27;)</span><br><span class="line">let exObj:exFace = &#123;</span><br><span class="line">  ex1,</span><br><span class="line">&#125;</span><br><span class="line">// 源码类型: const defineExpose: (exposed?: Record&lt;string, any&gt;) =&gt; void</span><br><span class="line">defineExpose(exObj)</span><br></pre></td></tr></table></figure><ul><li>jsx</li></ul><p>在 vue3 中使用 jsx，只能通过 option api 中的 render 函数或 setup 函数返回渲染函数，<code>&lt;script setup&gt;</code> 中不可使用。</p><p>const test &#x3D; {<br>  render(createElement) {  &#x2F;&#x2F; vue3 中 h 函数由 Vue 提供<br>      return createElement(<br>      ‘div’, [<br>        createElement(‘span’, ‘Heldlo’),<br>        ‘ world!’<br>      ]<br>    );<br>  }<br>};</p><p>&#x2F;&#x2F; 组件的注册<br>&#x2F;&#x2F; 全局注册<br>Vue.component(‘Test’, test)<br>&#x2F;&#x2F; 局部注册<br>components: {<br>  Test: test,<br>}</p><p> var test &#x3D; {<br>    setup() {<br>      return () &#x3D;&gt; {<br>      return h(<br>      ‘div’, [<br>        h(‘span’, ‘Heldlo’),<br>        ‘ world!’<br>      ]<br>    );<br>      }<br>  },</p><p>注意：cdn 模式下不能使用 jsx，只能使用 vdom，jsx 需要使用 Babel 插件来转译</p><p>const test &#x3D; {<br>  render(createElement) {  &#x2F;&#x2F; vue3 中 h 函数由 Vue 提供<br>      return createElement(<br>      ‘div’, [<br>        createElement(‘span’, ‘Heldlo’),<br>        ‘ world!’<br>      ]<br>    );<br>  }<br>};</p><p>&#x2F;&#x2F; 组件的注册：全局注册、局部注册<br>Vue.component(‘Test’, test)</p><h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p><code>&lt;script setup&gt;</code> 语法糖里面的代码会被编译成组件 setup() 函数的内容。</p><ul><li><code>&lt;script setup&gt;</code> 中无需 return 声明的变量、函数以及 import 引入的内容，即可在 <template/> 使用</li></ul><p>标准组件<code>&lt;script&gt;</code>需要写setup函数并繁琐retrun</p><ul><li><p><code>&lt;script setup&gt;</code>引入组件将自动注册</p></li><li><p>组件通信:在<code>&lt;script setup&gt;</code>中必须使用 defineProps 和 defineEmits API 来替代 props 和 emits</p></li><li><p><code>&lt;script setup&gt;</code>需主动向父组件暴露子组件属性 ：defineExpose</p></li></ul><p>使用 <code>&lt;script setup&gt;</code> 的组件，父组件是无法通过ref 或者 $parent 获取到子组件的ref等响应数据，需要通过defineExpose 主动暴露</p><ul><li>useSlots 和 useAttrs</li></ul><p>用于在 JSX 模式下使用 slot 和 attr，SFC 模式下，在 <template/> 通过 <slot/> 标签就可以渲染插槽</p><ul><li>useRoute 和 useRouter</li></ul><p>setup 里不能访问 this，不能再直接访问 this.$router 或 this.$route。（getCurrentInstance可以替代this但不推荐）<br>推荐：使用useRoute 函数和useRouter函数替代this.$route 和 this.$router</p><p>命名空间组件<br>Suspense<br>编译器宏：withDefaults<br><code>&lt;style&gt;</code> 特性<br>watchEffect 和 watch</p><h3 id="编译-html-字符串"><a href="#编译-html-字符串" class="headerlink" title="编译 html 字符串"></a>编译 html 字符串</h3><p><a href="https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js">https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js</a></p><p><a href="https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components">https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components</a></p><p><a href="https://cloud.tencent.com/developer/article/1467371">https://cloud.tencent.com/developer/article/1467371</a></p><p><a href="https://www.cnblogs.com/lvonve/p/12470666.html">https://www.cnblogs.com/lvonve/p/12470666.html</a><br><a href="https://www.zhihu.com/question/411745998">https://www.zhihu.com/question/411745998</a><br><a href="https://www.zhihu.com/question/436260027">https://www.zhihu.com/question/436260027</a><br><a href="https://segmentfault.com/q/1010000023534933">https://segmentfault.com/q/1010000023534933</a><br><a href="https://zhuanlan.zhihu.com/p/153387704">https://zhuanlan.zhihu.com/p/153387704</a></p><p>jsx 和 SFC template 只能在脚手架下才能被编译为 vdom，直接用 <code>&lt;script&gt;</code> 引入的 vue 下不能使用<br><code>&lt;script&gt;</code> 引入的 vue 下只能使用 template 选项和 render createElement 手动写 vdom</p><p>不使用脚手架，只 <code>&lt;script&gt;</code> 引入来使用 vue，会大打折扣？损失哪些功能，只能用哪些功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">  components: &#123; </span><br><span class="line">    App,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure><p>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p><p>意思是，要么使用完整版带 compoler 的 vue 在运行时动态编译 template，要不用 render 替换 template。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure><p>注：jsx 中使用其他组件，不需要用 components 注册</p><p>vue 项目要先编译再运行：编译  —》 运行</p><p>template 和 jsx 会预编译为 vdom（能静态分析，能提就能确定dom结构），但是对于 html 字符串（首先编译器不知道该不该编译，另外字符串不一定是静态的，可能是后台返回的），不管是 slot、v-html，mustashe 插值，都是按普通字符串处理，不会被编译，要想编译 html 字符串只能使用完整版的 vue，以 template 选项或 Vue.compiler 的方式在运行时动态编译。</p><p>这样是错误的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &#x27;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, this.world());</span><br><span class="line">    console.log(this.world()); // vNode 是 Object</span><br><span class="line">    return &lt;div domPropsInnerHTML=&#123;str&#125;&gt;&lt;/div&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    world() &#123;</span><br><span class="line">      return &lt;span&gt;world&lt;/span&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>配置 vue-cli</li></ul><p>引入完整版 vue，有 2 种配置方法。</p><p>方法 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  runtimeCompiler:true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.resolve.alias.set(&#x27;vue$&#x27;,&#x27;vue/dist/vue.esm.js&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后就可以这样写组件了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Test.js，jsx 后缀也可以</span><br><span class="line">export default &#123;</span><br><span class="line">  template: &#x27;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&lt;/div&gt;&#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      alert();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Test.jsx</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &#x27;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render(h) &#123;</span><br><span class="line">    str = this.str.replace(/,/g, &#x27;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&#x27;);</span><br><span class="line">    const render = &#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return h(render);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, &#x27;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&#x27;);</span><br><span class="line">    const Foo = Vue.extend(&#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &lt;Foo&gt;&lt;/Foo&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Greeting /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">/* eslint-disable */</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // render(h) &#123;</span><br><span class="line">  //   return h(foo, &#123;&#125;);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    aa() &#123;</span><br><span class="line">      return &lt;div&gt;cccc&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    cc() &#123;</span><br><span class="line">      // const html = &lt;button onClick=&#123;this.handleClick&#125;&gt;btn&lt;/button&gt;;</span><br><span class="line">      const dd = Vue.extend(&#123;</span><br><span class="line">        template: &#x27;&lt;div&gt;&lt;button @click=&quot;this.handleClick&quot;&gt;btn&lt;/button&gt;&lt;/div&gt;&#x27;,</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(dd, 2222);</span><br><span class="line">      // const vNode = this.aa();</span><br><span class="line">      // console.log(vNode, 232323);</span><br><span class="line">      return dd;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    &#x27;Greeting&#x27;: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &#x27;hello world&#x27;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      template: &#x27;&lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;btn&lt;/button&gt;&#123;&#123;msg&#125;&#125;&lt;Bar /&gt;&lt;/div&gt;&#x27;,</span><br><span class="line"></span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert(&#x27;ok&#x27;);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      components: &#123;</span><br><span class="line">        &#x27;Bar&#x27;: &#123;</span><br><span class="line">          data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              name: &#x27;bar&#x27;,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          created() &#123;</span><br><span class="line">            const foo = &#x27;foo&#x27;;</span><br><span class="line">            this.$options.template = `&lt;div&gt;&#123;&#123;name&#125;&#125;$&#123;foo&#125;&lt;/div&gt;`;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工作中有需要对 v-html 返回数据做数据绑定的需求，比如题干中答题，这时候要不使用原生 DOM，要不使用 vue 运行时的编译能力了</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode JavaScript Solutions</title>
      <link href="/2017/10/01/LeetCode-JavaScript-Solutions/"/>
      <url>/2017/10/01/LeetCode-JavaScript-Solutions/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="/rep/leetcode/two-sum.html">两数之和</a></li><li><a href="/rep/leetcode/valid-parentheses.html">有效的括号</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 设计模式</title>
      <link href="/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>大型的 CSS 项目中，往往会遇到 CSS 结构混乱、多人协作命名冲突、没有组件化无法复用…等等问题。为了解决这些问题于是引入 CSS 设计模式，用 BEM 来解决命名空间的问题，用 SMACSS 来解决代码分层问题，用 OOCSS 来解决解构复用问题。</p><span id="more"></span><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>对于 CSS 选择器的命名空间，一般的做法是通过选择器嵌套来约束命名空间，但是这种方式带来了很多问题 – 嵌套层次深不但影响了性能也导致了重度的 DOM 依赖，还有最重要的是命名冲突。</p><p>一个优秀的 CSS 命名方案，应该要解决以下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 具备 NameSpace；</span><br><span class="line">* 不能与嵌套的业务样式命名冲突；</span><br><span class="line">* 独立、对上层不过度依赖；</span><br></pre></td></tr></table></figure><p>BEM 的出现解决了上述问题。</p><p>BEM 中，B 代表 Block（Component）、E 代表 Element、M 代表 Modify。规定用 <code>__</code> 连接 E，用 <code>--</code>连接 M，用 <code>-</code> 连接单词和命名前缀。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.m-page</span><br><span class="line">.m-page__item</span><br><span class="line">.m-page__item--cur</span><br><span class="line">.m-page--center</span><br></pre></td></tr></table></figure><p>注：BEM 最多只有三层，不可能存在嵌套的 Element，比如 <code>.m-page__item__anchor--cur</code>。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS 是一个比较全面的 CSS 规范，它不但规范了命名空间，还对 CSS 进行了分层。具体到项目中，只参考它的分层。</p><h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>命名前缀用于说明 UI 类型归属，可以结合 BEM 一同使用，用于说明 Block 的类型。</p><ul><li>g-栅格</li></ul><p>简单栅格系统：用户后台 <code>g-hd</code>、<code>g-fd</code>、<code>g-bd</code>、<code>g-sd</code>、<code>g-mn</code>，前台和中间页 <code>g-head</code>、<code>g-body</code>、<code>g-foot</code>。</p><ul><li>f-原子类</li></ul><p>常用原子类：<code>f-bfc</code>、<code>f-clearfix</code>、<code>f-ellipsis</code>、<code>f-show</code>、<code>f-hide</code>、<code>f-cb</code>…。</p><p>定义原子类必须谨慎，功能性的原子类还好（<code>f-clearfix</code>、<code>f-bfc</code>），描述性的原子类必须谨慎（比如 <code>f-w100</code>）。原子类的使用场景是供后端使用的，或者前端 fix issue 时紧急使用。</p><p>原子类的缺陷：与 inline style 无异，没有做到结构与样式的分离；容易导致 class 臃肿。</p><ul><li>u-元件</li></ul><p>常用元件：<code>u-btn</code>、<code>u-ipt</code>、<code>u-select</code>、<code>u-line</code>、<code>u-link</code>…。</p><p>利用 OOCSS 来对页面元素进行抽象，是一种非常好的做法，这样可以通过继承，组合出不同的样式。但是也有导致 class 的臃肿的缺点，不过为了前者的实用性，后者的这点缺点也算不了什么。</p><ul><li>m-组件</li></ul><p>常用的 UI 组件：<code>m-tab</code>、<code>m-table</code>、<code>m-form</code>、<code>m-page</code>、<code>m-dialog</code>、<code>m-btns</code>、<code>m-select</code>、<code>m-search-box...</code>、<code>m-header</code>、<code>m-footer</code>…。</p><p>UI 的组件化也就是 HTML、CSS 的组件化。模块化、组件化的目的是封装（作用域隔离）、复用，这使得代码简洁易读易维护，按照最小组件化原则，非常有利于项目在快速迭代中的发展。</p><p>组件化原则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 组件化抽象的第一原则是复用（这也是 m 与 c 最主要的区别）；</span><br><span class="line">* 各个组件独立划分，充分解耦，遵守职责单一原则；</span><br><span class="line">* 业务 m 不能与全局 m 冲突，业务 m 要带上业务前缀（比如，m-header-mall），必要时还要加上模块前缀（比如，m-title-mall-index）；</span><br></pre></td></tr></table></figure><p>自定义组件：</p><p>当组件化不满足场景时，可对 modify 进行自定义（组件不满足场景大部分是 modify 不满足）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m-page--center</span><br><span class="line">c-choiceness-stage__carousel--junior</span><br><span class="line">c-choiceness-stage__carousel--high</span><br><span class="line">c-choiceness-stage__carousel--senior</span><br></pre></td></tr></table></figure><ul><li>c-模块</li></ul><p>整个 UI 都可以被模块化，包括业务，使用 <code>c-xx</code> 来作为命名前缀（c 指代 component，表示模块，而非 custom）。</p><p>component 和 module 的区别：component 包含 module，module 是 component 的组成部分，组件一般是可高度复用，可在整个项目或者跨项目通用的，这里的 c 其实指的是不可复用的业务模块（<code>模块 - 组件 = 不可复用的业务模块</code>），主要目的是封装，不具备 m 一样的复用能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-login      # login 不能被复用，所以这里不能用 m-login</span><br></pre></td></tr></table></figure><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCSS 只是一种思想，并没有具体的规范，用 OO 的方式来对 CSS 进行解构抽象，能够达到很好的作用域封装和复用效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.u-btn .u-btn--normal .u-btn--gray</span><br><span class="line">.m-page .m-page--center</span><br><span class="line">.m-tips .m-tips--success</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科里化函数</title>
      <link href="/2016/12/02/Currying/"/>
      <url>/2016/12/02/Currying/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> === <span class="number">0</span>) &#123; <span class="comment">// 通过手动调用的方式（即不传参数）来判断收集结束</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">currying</span>(fn.<span class="title function_">bind</span>(<span class="literal">null</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 须手动结束调用</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><span id="more"></span><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = []; <span class="comment">// 搜集参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;  <span class="comment">// 递归的中断条件，改为 arg.length === 0 更合适</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args); <span class="comment">// 改为 fn(...args) 更合适</span></span><br><span class="line">    &#125;</span><br><span class="line">    args = args.<span class="title function_">concat</span>(arg);  <span class="comment">// ?</span></span><br><span class="line">    <span class="keyword">return</span> foo;  <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用</p><p>有闭包的 bug</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123; <span class="comment">// 这里通过型参长度来判断是否要调用，所以add的参数不能...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args) <span class="comment">// 不需要 call，fn.call(this, ...args)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...remain</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">_fn</span>(...args, ...remain); <span class="comment">// 不需要 call，_fn.call(this, ...args, ...remain);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本中，被科里化函数的形参长度必须固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c, d</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c +d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">currying</span>(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p>这个版本中，被科里化的函数的形参必须要有长度</p><p><a href="https://zhuanlan.zhihu.com/p/296852112">https://zhuanlan.zhihu.com/p/296852112</a></p><p>科里话的关键是返回函数实现连式调用、参数收集、以及判断收集结束做最终调用</p><p>判断收集结束有很多办法：对比实参和形参的长度（这样被科里化的函数形参不能使用…）；判断实参的个数是否为 0（不传）；</p><p>call、apply、bind 的主要作用是绑定this上下文，另外 apply 还可以用来传 spread 数组，不过已经被 es6 spread 代替</p><p>数组求和。。。</p><p>var arr &#x3D; [1, 2, 3];<br>eval(arr.join(‘+’));</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7073640285904830471#heading-22">https://juejin.cn/post/7073640285904830471#heading-22</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外循环，几轮冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 共进行 arr.length 轮冒泡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="comment">// 俩俩对比，最后一个元素后面没有元素了，所以减 1，已冒泡上去的元素无需再参与，所以减 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]; <span class="comment">// distribute 交换数组位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bubbleSort</span>([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>]));</span><br></pre></td></tr></table></figure><span id="more"></span><p>可在原型链上扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bubbleSort</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">this</span>.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[j] - <span class="variable language_">this</span>[j + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = <span class="variable language_">this</span>[j];</span><br><span class="line">        <span class="variable language_">this</span>[j] = <span class="variable language_">this</span>[j + <span class="number">1</span>];</span><br><span class="line">        <span class="variable language_">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>].<span class="title function_">bubbleSort</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案</title>
      <link href="/2016/07/02/Adaptation-Rule/"/>
      <url>/2016/07/02/Adaptation-Rule/</url>
      
        <content type="html"><![CDATA[<p>在 PC 端，除了数据可视化和中后台这样一些全屏设计场景需要适配，绝大多数的网页采用的都是固定尺寸设计，由于 1366+ 的屏幕尺寸大于常用的固定设计尺寸，网页按设计尺寸 1:1 还原即可，不需要考虑适配。而在移动端，由于屏幕尺寸大小不一，且采用全屏的设计风格，则需要做适配。</p><p>目前移动端端内主流适配方案有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 流体式/弹性式；</span><br><span class="line">* Layout Viewport Scale；</span><br><span class="line">* VW + Rem；</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：适配方案还有设备独立像素和 Media Query（query 的是逻辑像素）。</p><p>抽象的设备独立像素解决的是端内高密度屏的适配（底层图形系统会根据 DPI 自动换算为物理像素），Media Query 解决的是跨端的设计风格适配，而流体、Rem、Layout Viewport Scale 解决的是端内设计要素（盒模型、字体、图片…）的适配（同一 UI 的整体缩放，没有设计上的差异）。</p><p>在设计要素适配中，“盒模型”和“字体”只需要考虑大小，而“图像”相对复杂一些，需要考虑流量、清晰度等问题，常见的解决方案有：矢量化、字体化、image-set 等。</p><h2 id="流体式"><a href="#流体式" class="headerlink" title="流体式"></a>流体式</h2><p>这是最早使用的适配方案，也是最常用的一种，特别是在响应式 UI 框架中（比如 Bootstrap）。其原理是，完美视口下，选需要兼容设备的最小宽度（一般都是 320px）来布局，垂直方向的高度和间距使用定值，水平方向用百分比、定值、flex…，最终达到“当手机屏幕变化时，横向拉伸或者填充空白的效果”。Eg：<a href="https://m.baidu.com/">百度</a>、<a href="https://www.amazon.cn/">亚马逊</a>。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 为完美视口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>步骤二，切图布局</li></ul><p>小往大适配，选需要兼容设备的最小尺寸还原设计稿（一般都是 iPhone5 的 320px，这是当前主流手机中的最小尺寸），当屏幕变宽时，简单的填充空白即可（如果从大到小，小分辨率设备上，就会出现滚动条）。</p><p>注：选主流中最小分辨率机型来进行设计（640 * 1334），<code>CSS 尺寸 = 视觉稿尺寸/dpr = 640/2 = 320</code>。前端在高清视觉稿下切图，使得图片兼容 Retain，在 CSS 中缩放；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">max-width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon</span> &#123;<span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">....</span>) no-repeat <span class="number">0</span> <span class="number">0</span>/cover;&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 简单方便；</span><br><span class="line">* 兼容第三方组件（echarts、mintUI...）；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 还原度不精确（如果以开发规范驱动设计就不会存在这个问题） --- 在分辨率不同的设备上，页面的字体大小，内容尺寸都是一样的，不同的是，大屏的内容间的空隙比小屏的大；</span><br></pre></td></tr></table></figure><h2 id="Layout-Viewport-Scale"><a href="#Layout-Viewport-Scale" class="headerlink" title="Layout Viewport Scale"></a>Layout Viewport Scale</h2><p>设计稿、页面布局、Layout Viewport 使用统一宽度，前端按设计稿的尺寸还原，使用定值单位（px、em…），利用浏览器『自身缩放』完成适配。Eg：<a href="http://c.3g.163.com/CreditMarket/default.html">网易新闻</a>。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 的宽度</li></ul><p>一般会设为 640。与流体式一样，这两种方案的核心都是视口的确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=设计稿的宽度&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该方案使用固定宽度值，需要考虑主流分辨率，确定一个合适的值，既不能选大了，也不能选小了，选大了可能会使得在小分辨率屏幕下像素丢失，选小了又可能会使得在大分辨率屏幕下模糊。</p><ul><li>步骤二，缩放</li></ul><p>正常浏览器都会将 <code>Layout Viewport</code> 自动缩放至屏内（视觉视口），不能自动缩放的浏览器要手动计算 scale 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> metaEle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>),</span><br><span class="line">    metaCon = metaEle ? metaEle.<span class="property">content</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    matchScale = metaCon.<span class="title function_">match</span>(<span class="regexp">/initial\-scale=([\d\.]+)/</span>),</span><br><span class="line">    matchWidth = metaCon.<span class="title function_">match</span>(<span class="regexp">/width=([^,\s]+)/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEle &amp;&amp; !matchScale &amp;&amp; (matchWidth &amp;&amp; matchWidth[<span class="number">1</span>] != <span class="string">&#x27;device-width&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> layoutViewportWidth = <span class="built_in">parseInt</span>(matchWidth[<span class="number">1</span>]),</span><br><span class="line">      screenWidth = screen.<span class="property">width</span>;</span><br><span class="line"></span><br><span class="line">    scale = screenWidth / layoutViewportWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      metaEle.<span class="property">content</span> += <span class="string">&#x27;,initial-scale=&#x27;</span> + scale + <span class="string">&#x27;,maximum-scale=&#x27;</span> + scale + <span class="string">&#x27;, minimum-scale=&#x27;</span> + scale + <span class="string">&#x27;,user-scalable=no&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">viewport</span>();</span><br></pre></td></tr></table></figure><p>以下面动态生成的结果为例，640 是根据设计稿定下的，0.5(1&#x2F;dpr，或者 320&#x2F;640) 是根据屏幕宽度动态生成的。生成的 viewport 告诉浏览器网页的布局视口使用 640px，然后把页面缩放成 50%，图片、文字等等所有元素都被缩放在手机屏幕中，这是绝对的等比例缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 开发简单 --- 缩放交给浏览器，完全按视觉稿切图；</span><br><span class="line">* 还原精准 --- 绝对等比例缩放，可以精准还原视觉稿；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 像素丢失 --- 对于一些分辨率较低的手机，可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少；</span><br><span class="line">* 不兼容第三方组件和富文本数据 --- 这也是最大的问题；</span><br></pre></td></tr></table></figure><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p>“流体式”、“Layout Viewport Scale” 这两种适配方案，都存在缺陷，一个优秀的适配方案应做到以下两点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* UI 的精确还原与适配</span><br><span class="line">* 兼容第三方组件和富文本数据</span><br></pre></td></tr></table></figure><p>VW + Rem 就是这样的一个方案。其原理是，屏幕联动 html font-size vw，html font-size 联动 rem（ html font-size value &#x3D; 1 rem），来做到适配。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>定义规范</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设计规范。规定设计稿分辨率，推荐采用 1X 的设计方案（即手机 375，横屏 Pad 960，而不是 2X 的 750、1920），为了方便 figma 下，导入第三方 UI 组件</span><br><span class="line">* 基准值。规定屏幕分成 10 等分（100vw/10），html font-size 为 10vw，所以 1rem = 10vm</span><br></pre></td></tr></table></figure><p>将基准值的定义为 100vw&#x2F;10 &#x3D; 10vw，而不是 100px（除以 19.2、12.8），这仅仅是规范，10vw 体现适配原则，容易理解，而 100px 在没有转换工具的条件下，方便了计算。</p><p>在没有转换工具的情况下，为了方便计算，我们会将 html faont-size 定义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1920 的设计规范下还原的，base 为 1920px/19.2 = 100px，px 转 rem 除以 100 即可 */</span></span><br><span class="line"><span class="comment">/* calc(100vw/19.2) 不直接写成 10vw，是为了体现 1920 的设计规范 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>/<span class="number">19.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在源码里面进行转换不利于源码的维护，在现代前端开发中推荐使用工程化工具转换。</p><ul><li>使用步骤</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 步骤一：定义 html font-size 基准值（一般会定为 10vw，绝大多数适配场景都是按宽度适配，如果按高度适配也可为 10vh）</span><br><span class="line">* 步骤二：开发页面。页面在设计尺寸下开发（比如，平板 1920、手机 750），开发单位为 px</span><br><span class="line">* 步骤三：px 转 rem。这一步请用工具完成，转换算法为 px/基准值（1920 设计规范下是 192，750 设计稿是 75），一般会忽略 border，因为可能变成 0px</span><br></pre></td></tr></table></figure><ul><li>兼容处理</li></ul><p>vw 不支持 Android 4.4 以下设备，这时候就需要对 vw 做兼容处理了。这里不想通过 JS 来解决此问题，本着逐渐增强，平稳退化的原则，选一个默认分辨率处理，比如手机就选 750 的分辨率：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">37.5px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://github.com/amfe/lib-flexible">flexible</a> 就是手淘团队在 Android 4.4- 设备不支持 vw 时的一个 JS 解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(下) -- 视口</title>
      <link href="/2016/06/15/Pixel-Viewport-2/"/>
      <url>/2016/06/15/Pixel-Viewport-2/</url>
      
        <content type="html"><![CDATA[<p>视口（viewport）代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI（菜单栏等）。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><span id="more"></span><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>桌面浏览器中，视口的宽度与浏览器窗口的宽度一致，浏览器窗口就是约束 CSS 布局的视口，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度（超出部分将出现滚动条）。但是在移动端，情况就很复杂了。</p><p>在移动设备上，视口与屏幕宽度不再相关联，是完全独立的，浏览器厂商为了让传统的 PC 网页能够尽可能在移动设备上更多的展示，会把视口的宽度设置地很大（一般在 768px ~ 1024px 之间，Apple 是 980px），并且将其缩放在了屏幕（视觉视口）内。这个浏览器厂商定义的视口被称为“布局视口（Layout Viewport）”，网页的最大宽度是默认的 Layout Viewport 宽度，超出部分会出现滚动条。</p><p><img src="/images/css/layout-viewport.png" alt="layout viewport"></p><p>可通过 Meta Viewport 来设置布局视口，能设置的属性如下所示。</p><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>width</td><td>正整数或 device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或 device-height</td><td>定义视口的高度，单位为像素</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须小于或等于 maximum-scale 设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须大于或等于 minimum-scale 设置</td></tr><tr><td>user-scalable</td><td>yes&#x2F;no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=640&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS 中可通过 <code>document.documentElement.clientWidth / clientHeight</code> 获取布局视口的尺寸，CSS 中可设置 <code>html, body &#123;width: 100%&#125;</code>，通过测量 <code>body</code> 的宽度来验证默认布局视口大小。另外，CSS 中的媒体查询，查询的是布局视口的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 700px) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>用户在屏幕上能看到的网页区域被称为“视觉视口（Visual Viewport）” 。</p><p>视觉视口用于承载布局视口，其大小是视觉视口内 CSS 像素的总量，受浏览器缩放影响。用户可以在视觉视口中拖动或者缩放网页，来获得良好的浏览效果，如果用户缩小网站，视觉视口内 CSS 像素数量增多，视觉视口变大，看到的网站区域将变大，同理用户放大网站，视觉视口内 CSS 像素数量减少，视觉视口也变小，能看到的网站区域将缩小。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p><img src="/images/css/visual-viewport.png" alt="visual viewport"></p><p><code>window.innerWidth/innerHeight</code> 可以获取视觉视口的尺寸，大小是屏幕中 CSS 像素的数量。</p><h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><p>移动设备中默认 768px ~ 1024px 尺寸的布局视口对用户不友好，忽略了手机本身的尺寸，于是引入理想视口的概念。将布局视口的宽度设为屏幕的宽度，这样的布局视口被称为“理想视口（Idea Viewport）”。理想视口是移动设备上最佳的布局视口，理想视口下开发的页面不需要缩放就能够完美显示。</p><p>JS 中可通过 <code>screen.width/height</code> 获取理想视口的尺寸（有兼容性问题，可能返回的是设备像素尺寸）。将 Meta Viewport 设置如下就可以将布局视口设为理想视口了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实践中，还会设置缩放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 推荐的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0,viewport-fit=cover&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>initial-scale</code>有一个隐藏的作用，它同时会将布局视口的尺寸设置为缩放后的尺寸，所以<code>initial-scale=1</code>与<code>width=device-width</code>的效果是一样的（不缩放又要求放进 Visual Layout 里，所以 <code>initial-scale=1</code> 与 <code>width=device-width</code> 等同）。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(上) -- 像素</title>
      <link href="/2016/06/10/Pixel-Viewport-1/"/>
      <url>/2016/06/10/Pixel-Viewport-1/</url>
      
        <content type="html"><![CDATA[<p>像素是影像显示的基本单位，其表现为一个个小方格。在 GUI 客户端软件开发中，像素是布局的基础，对于一个客户端开发者来说理解它很重要。其实存在两种像素，<a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html">此像素非彼像素</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设备像素</span><br><span class="line">* 设备独立像素</span><br></pre></td></tr></table></figure><span id="more"></span><p>设计师眼中的像素是设备像素，因为要考虑设计稿中非矢量元素（图片）在程序适配中的高保真，程序员眼中的像素是设备独立像素（Web 的 px，Android 的 dp，IOS 的 pt），因为要考虑适配。PC 时代的标准屏幕中，这两个像素是相等的，我们意识不到这个问题的存在，但是在高密度屏的移动时代就需要面对它了。</p><h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><p>设备像素（Device Pixels）又叫物理像素（Physical Pixel），一个设备像素是屏幕上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。跟设备像素相关概念有分辨率、屏幕尺寸、像素密度，这些参数在屏幕出厂时就固定下来了。以 iPhone 5 屏幕参数为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 屏幕分辨率 -- 640 x 1136</span><br><span class="line">* 屏幕尺寸 -- 4 英寸</span><br><span class="line">* 屏幕像素密度/解析度 -- 326dpi。</span><br></pre></td></tr></table></figure><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率可以细分为屏幕分辨率（显示分辨率）、图像分辨率、视频分辨率。其中，屏幕分辨率指一个屏幕具体由多少个像素点组成。<code>640 x 1136</code> 的屏幕分辨率指的是屏幕上水平有 640 个物理像素，垂直有 1136 个物理像素。常见分辨率中 4:3 有 <code>1024 x 768</code>、16:9 有 <code>1366 × 768</code>、<code>1920 × 1080</code>、<code>2560 x 1440</code>、<code>3860 × 2160</code>, 16:10 有 <code>1920 x 1200</code>。</p><p>也可以用 K 和 P 来描述分辨率，P 代表纵向的像素个数，K 代表横向有几个 1024 个像素。分辨率为 <code>1920 x 1080</code> 的屏幕就属于 1080P 屏幕（也被称为 FHD 全高清屏幕），横向像素超过 2048 的屏幕就属于 2K 屏，横向像素超过 4096 的屏幕就属于 4K 屏。</p><p>分辨率高不代表就清晰，还与尺寸有关，同一尺寸下分辨率越高就越清晰。</p><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸指的是屏幕对角线的物理长度，单位英寸。比如 iPhone 5 的屏幕尺寸为 4 英寸，MBP 的屏幕尺寸为 13.3 英寸。</p><h3 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h3><p>像素密度 (Pixels Per Inch) 指的是每英寸所拥有的像素数量，可用于描述屏幕的清晰度或图片的质量，单位是 ppi。理论上 PPI 越高，单位面积的像素数量就越多，画面会更细腻丰富清晰。屏幕的 PPI 可以通过屏幕分辨率和尺寸计算得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PPI = Math.sqrt(a ** 2 + b ** 2) / 4</span><br></pre></td></tr></table></figure><p>在桌面屏幕中，大部分的 PC 显示器和笔记本都还是普通密度的屏幕，不过像 Retina MBP（Apple 在 2012 年发布了第一款 Retina MBP）、2k 和 4k 这样一些高密度屏也很常见。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 14 英寸笔记本（112ppi）</span><br><span class="line">Math.sqrt(1366 ** 2 + 768 ** 2) / 14;</span><br><span class="line">// 14 英寸笔记本（157ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 14;</span><br><span class="line">// 13.3 英寸 MBA (127ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 900 ** 2) / 13.3;</span><br><span class="line">// 23.8 英寸 PC 显示器（92ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 23.8;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 13.3 英寸 MBP/Retina MBA (226ppi)</span><br><span class="line">Math.sqrt(2560 ** 2 + 1600 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K XPS (290ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2400 ** 2) / 15.6;</span><br><span class="line">// 13.5 英寸 Surface Book 3 (267ppi)</span><br><span class="line">Math.sqrt(2256 ** 2 + 1504 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K ThinkPad P1 (282ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2160 ** 2) / 15.6;</span><br></pre></td></tr></table></figure><p>在手机屏幕中，2010 年之前的手机分辨率都普遍低，比如，iPhone 3GS、诺基亚 5230、5800，随着智能手机发展，iPhone 4 使得智能手机进入了高密度屏时代，发布会上首次提出了 Retina Display 的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 3GS (164ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 480 ** 2) / 3.5;</span><br><span class="line">// 诺基亚 5230、5800 (223ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 640 ** 2) / 3.2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 4 (329ppi)</span><br><span class="line">Math.sqrt(640 ** 2 + 960 ** 2) / 3.5;</span><br><span class="line">// iPhone 11 (326ppi)</span><br><span class="line">Math.sqrt(828 ** 2 + 1792 ** 2) / 6.1;</span><br><span class="line">// 小米 10 (386ppi)</span><br><span class="line">Math.sqrt(1080 ** 2 + 2340 ** 2) / 6.67;</span><br><span class="line">// 华为 P40 Pro (440ppi)</span><br><span class="line">Math.sqrt(1200 ** 2 + 2640 ** 2) / 6.58;</span><br><span class="line">// 三星 Galaxy S20 (565ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 3200 ** 2) / 6.2;</span><br></pre></td></tr></table></figure><p><a href="https://support.apple.com/en-us/HT202471">Retina Display</a>（视网膜屏幕，视网膜显示器）指的是在正常视距内（iPhone 10inch，iPad 15inch）人睛不能分辨出单独像素显示效果的屏幕。为了达到这种显示效果，需要将更多的物理像素压缩进屏幕中，使屏幕成为高密度屏。</p><p>iPhone 4 发布会上，乔布斯表示当手持设备距人眼 10－12 英寸时，300ppi 是人类视力的极限，当像素密度超过 300ppi 时，人眼就无法区分出单独的像素，因此像素密度达到 329ppi 的 iPhone 4 具备非常优秀的显示功能，不会再出现颗粒感。在后来发布 The New iPad 时，Apple 更是对 Retina Display 给出了科学意义上的解释。</p><p><img src="/images/css/retina2.jpg" alt="retina display"></p><p>根据<a href="https://www.engadget.com/2012-03-01-retina-display-macs-ipads-and-hidpi-doing-the-math.html">上图</a>中视觉成像原理，能够非常容易得出下面这个三角函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tan(α/2) = h/2d</span><br><span class="line"></span><br><span class="line"># 变形公式</span><br><span class="line">α = 2tan^(-1)(h/2d) = 2arctan(h/2d)</span><br><span class="line">h = tan(α/2)*2d</span><br></pre></td></tr></table></figure><p>其中“α”代表视角，“d”代表视距，“h”代表像素间距（或一个像素的尺寸）。在对人类视力研究中发现（斯内伦测试 Snellen Test），正常人眼能辨识所视物的最小视角（识别极限，视敏度 <a href="https://baike.baidu.com/item/%E8%A7%86%E6%95%8F%E5%BA%A6">visual acuity</a>）是 1&#x2F;60 度（1 弧分度），1 弧分度数据主要基于斯内伦视力表中 20&#x2F;20 标准视力（等效于我国视力表中的 1.0）的统计样本，视力超常的（如 2.0 视力）个体无疑会有着更出色的视觉能力，能辨识所视物的最小视角会更小。</p><p>在正常视距下，当视角小于等于 1&#x2F;60 度时，即可以达到 Retina Display 的显示效果。α 大小取决于 d 和 h，而显示设备的使用视距一般是固定的，所以是否是 Retina Display 取决于 h。比如，在 10inch 的视距下，需要至少 343ppi，才能达到此显示效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">angle2rad</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a * (<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="title class_">Math</span>.<span class="title function_">tan</span>(<span class="title function_">angle2rad</span>(<span class="number">1</span> / (<span class="number">2</span> * <span class="number">60</span>))) * <span class="number">2</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ppi = <span class="number">1</span> / h;  <span class="comment">// 343</span></span><br></pre></td></tr></table></figure><p>Retina Display 是 Apple 的商标，在安卓手机中没有此叫法，安卓手机中，屏幕根据 PPI 来划分为不同的等级。PPI 在 120 - 160 之间的手机被归为低密度手机，160 - 240 被归为中密度（Medium），240 - 320 被归为高密度（High），320 - 480 以上被归为超高密度，480 - 640 被归为超超高密度，640 以上被称为超超超高密度。</p><p> | ldpi | mdpi | hdpi | xhdpi | xxhdpi | xxxhdpi<br>—|—|—|—|— | — | —<br>密度分界 | 120 | 160 | 240 | 320 | 480 | 640<br>常见屏幕分辨率 | 240 * 320 | 320 * 480 | 480 * 850 | 640 * 960 | 1080 * 1920 | 1440 * 2560<br>默认缩放比例 | 0.75 | 1.0 | 1.5 | 2.0 | 3 | 4</p><p>附：点密度 DPI (Dots Per Inch) 指的是每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点，图片像素点也可以是打印机的墨点，当 DPI 来描述图片和屏幕时，等价于 PPI，描述打印机时，表示打印机每英寸可以打印的点数，打印机的 DPI 越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。另外，PPI&#x2F;DPI 有时候也被称为分辨率，比如，打印分辨率、扫描分辨率。</p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><p>设备独立像素（Density-Independent Pixel）又叫逻辑像素、密度无关像素，简称为 dips，单位为 dp，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统按设备像素比转换为物理像素在屏幕上显示出来。Web 的 px、Android 的 dp、IOS 的 pt，都是对 dp 的实现，<code>1px = 1dp = 1pt</code>。</p><p>之所以使用抽象的设备独立像素而不直接使用设备像素，目的是为了适配，图形系统会自动将应用程序的抽象像素转换为适合于特定设备的物理像素。</p><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><p>在缩放程度为 100%，某一方向上（x 轴或 y 轴）物理像素和设备独立像素的比例叫做“设备像素比” (device pixel ratio)，单位 dpr。设备像素比定义了设备独立像素和设备像素的转换关系，决定了 GUI 软件的渲染尺寸，当处理标准显示器与 HiDPI 或 Rerina 显示器之间的差异时，这很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备像素比 = 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>在 JS 中 <code>window.devicePixelRatio</code> 得到，在 CSS 中，可以通过 <code>-webkit-device-pixel-ratio</code>，<code>-webkit-min-device-pixel-ratio</code> 和 <code>-webkit-max-device-pixel-ratio</code> 进行媒体查询。</p><p>设备独立像素和设备像素间的转换由两个条件决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 页面是否缩放</span><br><span class="line">* 设备像素比（屏幕是否为高密度或超高密度)</span><br></pre></td></tr></table></figure><p>页面放大，设备独立像素会跨越了更多的设备像素，缩小则相反。在排除页面缩放的情况下，他们的换算关系取决于设备像素比。比如，在 2dpr 的设备上，<code>1 个设备独立像素 = 4 个设备像素</code>，CSS 中的 <code>&#123;width: 200px&#125;</code> 需要由 800 个物理像素来显示（面积）。</p><p>在已知 dpr 和 ppi 的情况下，还可以将 dp 转为现实生活中的物理单位，比如, 在 2dpr、326ppi 下，<code>200dp = 400px = 1.23inch (400 / 326)</code>，于是 <code>1dp = 0.00615inch</code>。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Media Query</title>
      <link href="/2016/06/02/Media%20Query/"/>
      <url>/2016/06/02/Media%20Query/</url>
      
        <content type="html"><![CDATA[<p>媒体查询在 CSS2 中就已经存在了，但是只能查询 meida type，CSS3 中除了能查询 media type 外，还加入了 media feature 的查询。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询包含一个“媒体类型（media type）”以及至少一个测试“媒体特性（media feature）”的表达式，表达式和媒体类型将根据实际情况计算的到 true 或者 false。如果指定的媒体类型符合当前设备并且媒体特性表达式都为真，那当前媒体查询为真，media query 为 true，对应的样式规则生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [媒体类型] 媒体特性 &#123;&#125;    # 除非使用了 not 或者 only 操作符，否则 media type 是可选的，默认值为 <span class="attribute">all</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>and</td><td>逻辑与，用于连接 media type、meidia feature 用于结合多个媒体特性或媒体类型</td></tr><tr><td>,</td><td>设备列表</td></tr><tr><td>not</td><td>排除某种设备</td></tr><tr><td>only</td><td>限定某种设备类型</td></tr></tbody></table><p><code>and</code> 用于结合多个媒体特性或媒体类型到一个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* media type 为 all 时 media feature 为 min-width 700 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用 and 添加限制条件 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 and 添加 media type，限制媒体类型为显示器 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 用于结合多个 media query ，任 一media query 为 true 时应用样式，相当于逻辑运算符中的 or。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 宽度大于 700px，或者宽度大于高度的显示器上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>not</code> 用于对整个 media query 结果取反，必须位于一个 media query 的开头。另外，在逗号分隔的多个 media query 中，not 只对它作用的 media query 生效。not 不能对单个 media feature 取反，只能作用于整个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* not 将在最后求值 */</span></span><br><span class="line"><span class="comment">/* 等价于 @media not (print and (max-width:1024px))&#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> print <span class="keyword">and</span>(<span class="attribute">max-width</span>:<span class="number">1024px</span>)&#123;...&#125;  # </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多个 media query 求值 */</span></span><br><span class="line"><span class="comment">/* 求值顺序如下 @media (not (screen and (color))), print and (color) &#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (<span class="attribute">color</span>), print <span class="keyword">and</span> (<span class="attribute">color</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>only</code> 用于向早期浏览器隐藏媒体查询，only 必须位于 media query 的开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>无法识别媒体查询的浏览器要求获得逗号分割的媒体类型列表，规范要求：它们应该在第一个不是连字符的非数字、字母之前截断每个值。所以上面的示例解释为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为没有 <code>only</code> 这样的媒体类型，所以样式表被忽略。如果不加 only，下面的示例会被解析为 <code>@media screen &#123;&#125;</code> 这样一来即使浏览器不知道 media query 的真正含义，样式也会应用于所有屏幕设备。</p><p>尽管存在此行为，如果希望向其他不太常用的浏览器隐藏样式，任然建议在媒体查询前面添加 only。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体类型（media-type）"><a href="#媒体类型（media-type）" class="headerlink" title="媒体类型（media type）"></a>媒体类型（media type）</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>print</td><td>文档打印或打印预览模式</td></tr><tr><td>screen</td><td>彩色电脑屏幕</td></tr><tr><td>speech</td><td>阅读器</td></tr></tbody></table><p>注意：在 CSS2.1 和 CSS3 media query 中定义的 media type：tty、tv、projection、handheld、braille、embossed、aural，在<a href="https://www.w3.org/TR/mediaqueries-4/">media queries level 4</a> 中都废弃了，不推荐使用。</p><h3 id="媒体特性（media-feature）"><a href="#媒体特性（media-feature）" class="headerlink" title="媒体特性（media feature）"></a>媒体特性（media feature）</h3><table><thead><tr><th>媒体特性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>viewport width</td></tr><tr><td>height</td><td>viewport height</td></tr><tr><td>device-width 、 device-height</td><td>设备的宽度、高度</td></tr><tr><td>aspect-ratio</td><td>viewport 的宽高比如：16&#x2F;9</td></tr><tr><td>device-aspect-ratio</td><td>设备宽高比</td></tr><tr><td>orientation</td><td>宽度和高度的大小关系。landscape（横屏）、portrait（竖屏）</td></tr><tr><td>resolution</td><td>设备的分辨率</td></tr></tbody></table><p>上面是一些常见的 media feature，不是全部，media feature 的维度很多，但是最常用的是 viewport 的 width 和 height。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在 CSS2 中，媒体查询只使用于 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签中，以 media 属性来查询，CSS3 中可以用 @media 来查询。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/reset.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/print.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (min-width:600px) and (max-width:900px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="keyword">@import</span> url(<span class="string">&quot;css/style.css&quot;</span>);</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;css/reset.css&quot;</span>) screen;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  选择器 &#123;</span><br><span class="line">    属性: 属性值;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Media-Query-常用方法"><a href="#Media-Query-常用方法" class="headerlink" title="Media Query 常用方法"></a>Media Query 常用方法</h2><ul><li>排他（exclusive）</li></ul><p>为确保在某一个条件下只有一个样式表生效，将查询条件严格划分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">401px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>覆盖（overriding）</li></ul><p>可以对元素设置相同优先级，使用样式顺序，通过覆盖，避免排他。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动优先（Mobile first）</li></ul><p>默认样式假设为移动设备宽度，然后通过 min-width 控制扩展样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootStrap 移动优先，断点分别为 768、992、1200，这三个断点的区间对应手机、平板、桌面、大桌面。</p><ul><li>PC 优先（desktop first）</li></ul><p>默认以宽屏进行样式设置，通过 max-width 控制样式覆盖。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 过渡与动画</title>
      <link href="/2016/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <url>/2016/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: [property duration timing-function delay]</span><br></pre></td></tr></table></figure><p>property 默认值 all，duration 和 delay 默认值 0，timing-function 默认值 ease。可使用 <code>,</code> 分割，实现多个动画，配合 duration，还可实现队列动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">display</span>: flex; <span class="attribute">width</span>: <span class="number">65px</span>; <span class="attribute">height</span>: <span class="number">40px</span>; <span class="attribute">align-items</span>: center; <span class="attribute">justify-content</span>: center; <span class="attribute">background</span>: <span class="number">#92B901</span>; <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="attribute">opacity</span>: <span class="number">0.4</span>; <span class="attribute">transition</span>: transform <span class="number">1s</span>, opacity <span class="number">1s</span>, background <span class="number">1s</span>, width <span class="number">1s</span>, height <span class="number">1s</span>, font-size <span class="number">1s</span>;&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">width</span>: <span class="number">90px</span>; <span class="attribute">height</span>: <span class="number">60px</span>; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>); <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">opacity</span>: <span class="number">1</span>; <span class="attribute">background</span>: <span class="number">#1ec7e6</span>;&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>transition 不会在页面加载时自动执行动画，它需要交互或异步去触发，比如 CSS 的伪类 <code>:hover</code>，JS 事件或 <code>setTimeout</code> 去执行动画。</p><p>开启硬件加速，可以使 transition 运行更加流畅：<code>body&#123;transform: translate3d(0, 0, 0);&#125;</code>；</p><h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>不是所有的 CSS 属性都支持 transition，<strong>属性存在中间状态，且能计算出中间状态（开始状态和结束状态是具体数值），才支持 transition</strong>。像 <code>visibility</code>、<code>display</code> 就不存在中间状态，<code>height: auto</code> 不能计算出中间状态，支持的属性常见有以下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* length/percentage: 真实的数字 如：`word-spacing`, `width`, `vertical-align`, `top`, `right`, `bottom`, `left`, `padding`, `outline-width`, `margin`, `min-width`, `min-height`, `max-width`, `max-height`, `line-height`, `height`, `border-width`, `border-spacing`, `background-position` 等；</span><br><span class="line">* number 真实的（浮点型）数值，如：`zoom`, `opacity`, `font-weight` 等；</span><br><span class="line">* color: RGB 和 Alpha 值，如：`background-color`, `border-color`, `color`, `outline-color` 等 CSS 属性；</span><br><span class="line">* shadow: x, y, blur 和 color，如：text-shadow</span><br><span class="line">* transform list</span><br></pre></td></tr></table></figure><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* ease：逐渐变慢（默认值），等同于贝塞尔曲线 (0.25, 0.1, 0.25, 1.0)；</span><br><span class="line">* linear：匀速，等同于贝塞尔曲线 (0.0, 0.0, 1.0, 1.0)；</span><br><span class="line">* ease-in：加速，等同于贝塞尔曲线 (0.42, 0, 1.0, 1.0)；</span><br><span class="line">* ease-out：减速，等同于贝塞尔曲线 (0, 0, 0.58, 1.0)；</span><br><span class="line">* ease-in-out：加速然后减速，等同于贝塞尔曲线 (0.42, 0, 0.58, 1.0)；</span><br><span class="line">* cubic-bezier (n,n,n,n)：在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。实际用到的很少，可以到工具网站中设置值 http://cubic-bezier.com；</span><br></pre></td></tr></table></figure><p>这几个贝塞尔值的区别：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease&quot;</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in&quot;</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-out&quot;</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ease-in-out&quot;</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;linear&quot;</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> red solid; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;<span class="attribute">width</span>: <span class="number">50px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">background-color</span>: red; <span class="attribute">color</span>: <span class="number">#fff</span>;&#125;</span><br><span class="line"><span class="selector-class">.ease</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease;&#125;</span><br><span class="line"><span class="selector-class">.ease-in</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in;&#125;</span><br><span class="line"><span class="selector-class">.ease-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-out;&#125;</span><br><span class="line"><span class="selector-class">.ease-in-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in-out;&#125;</span><br><span class="line"><span class="selector-class">.linear</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> linear;&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span> &#123;<span class="attribute">margin-left</span>: <span class="number">500px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="transition-与-animation-区别"><a href="#transition-与-animation-区别" class="headerlink" title="transition 与 animation 区别"></a>transition 与 animation 区别</h3><p>transition 是属性过渡动画，animation 是关键帧过渡动画，两种动画触发方式不一样，属性过渡必须通过交互或者异步修改属性值，而关键帧只需要应用即可，可以在交互时，也可以不在交互时。</p><p>另外，在 CSS <code>:hover</code> 中，当鼠标移出时，属性值会恢复，发生过渡，transition 的逆向动画被触发，而 animation 关键帧动画不会 reverse，需另声明 reverse 的关键帧来实现，而且需通过事件来应用，要不然进入时会发生 reverse 动画。</p><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: [name duration timing-function delay iteration-count direction fill-mode play-state]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* animation-name 关键帧名，默认值 none</span><br><span class="line">* animation-duration 动画时长，默认值 0</span><br><span class="line">* animation-timing-function 动画速度，默认值 ease</span><br><span class="line">* animation-delay 延迟，默认值 0</span><br><span class="line">* animation-iteration-count 播放次数，默认值 1</span><br><span class="line">* animation-direction 轮流反向播放，默认值 normal</span><br><span class="line">* animation-play-state 默认值 running（播放）、paused（暂停）</span><br><span class="line">* animation-fill-mode 默认值 none（不改变默认行为）、forwards（保持在最后一个关键帧中定义的状态）、backwards（保持在第一个关键帧中定义的状态）、both</span><br></pre></td></tr></table></figure><p>animation 属性简写至少要有名称和时长。</p><p>animation 使用时需先定义关键帧（@keyframes），在使用关键帧（animation）。关键帧中，用百分比来规定变化发生的时间，或用关键词 from 和 to，等同于 0%（动画开始） 和 100%（动画完成）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> fade &#123;</span><br><span class="line">  <span class="number">0%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">background</span>: <span class="number">#f00</span>; <span class="attribute">animation</span>: fade <span class="number">1s</span>;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 标签嵌套规则</title>
      <link href="/2016/02/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/"/>
      <url>/2016/02/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML4-x2F-XHTML-嵌套规则"><a href="#HTML4-x2F-XHTML-嵌套规则" class="headerlink" title="HTML4&#x2F;XHTML 嵌套规则"></a>HTML4&#x2F;XHTML 嵌套规则</h2><p>在 HTML4&#x2F;XHTML DTD 中，将元素的分为 inline level (行内级) 和 block level (块级) 两类。</p><ul><li>inline level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span、a、dfn、abbr、cite、img、label、q、u、em、i、strong、b、big、small、sub、sup、表单类；计算机输出类(tt、kbd、code、var、samp)</span><br></pre></td></tr></table></figure><ul><li>block level</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div、h1-h6、hr、ul、ol、dl、li、fieldset、address、from、table、html5 中新增的结构化语义标签、pre、blockquote、dir、menu</span><br></pre></td></tr></table></figure><span id="more"></span><p>注：HTML 中的 inline level、block level 与 CSS 中的 inline、block 意义不一样，HTML 强调的是语义和结构，而 CSS 强调的是样式。要不然无法解释：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><ul><li>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素(另，a 不能在嵌套 a)：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”#”</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<code>h1、h2、h3、h4、h5、h6、p、dt</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML5-嵌套规则"><a href="#HTML5-嵌套规则" class="headerlink" title="HTML5 嵌套规则"></a>HTML5 嵌套规则</h2><p>在 <a href="https://html.spec.whatwg.org/multipage/dom.html#element-definitions">HTML5 规范</a>中，已经不按 inline level 和 block level 来区分元素类型了，元素按 <a href="https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content">Categories</a> 分类，元素的 <a href="https://html.spec.whatwg.org/multipage/dom.html#content-models">Content Model</a> 规定了合法的元素内容类型。</p><ul><li>Categories</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Metadata 元数据信息元素 base, link, meta, noscript, script, style, template, title</span><br><span class="line">* Flow 流式元素，所有可以放在 body 标签内，构成文档内容的元素均属于 Flow 元素。除 base, link, meta, style, title 等只能放在head 标签内的元素外，剩下的均属 Flow 元素</span><br><span class="line">* Sectioning 结构元素 article, aside, nav, section</span><br><span class="line">* Heading 标题元素 h1, h2, h3, h4, h5, h6</span><br><span class="line">* Phrasing 短语元素，所有可以放在 p 标签内，构成段落内容的元素均属于 Phrasing 元素。HTML5 中的 Phrasing 元素大致就是 HTML4 中所定义的 inline level 元素。另外，所有 Phrasing 元素均属于 Flow 元素</span><br><span class="line">* Embedded 嵌入资源元素 audio, video, img, canvas, svg, iframe, embed, object, math</span><br><span class="line">* Interactive 交互元素 a, audio, video, button, details, embed, iframe, img, input, label, object, select, textarea</span><br></pre></td></tr></table></figure><ul><li>Content Model</li></ul><p>各元素都有自己的 Content Model，比如 <a href="https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-a-element">a 元素</a>的 Content Model 为 <a href="https://html.spec.whatwg.org/multipage/dom.html#transparent-content-models">transparent</a>，这类元素本身内部可以有任何类型的内容，是否合法要看其父元素的 Content Model 和其内容的 Categories，还有 p 元素，其内容模型为 Phrasing, 这意味着 p 元素只接受 Phrasing 元素为子元素（p 自身 Categories 类型为 Flow content，因而 p 不能嵌套 p）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p&gt;ins&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ul&gt;li&gt;h4&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个例子都是不合法的。</p><p><a href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element">p 元素</a>的 content model 是 phrasing content，<a href="https://html.spec.whatwg.org/multipage/edits.html#the-ins-element">ins</a> 本身属于 phrasing content 故可以嵌套；ins 元素的 content model 是 transparent，故在此时里面是否能有 a 需检查 p&gt;a 的合法性；a 元素也属于 phrasing content，故 p&gt;ins&gt;a 合法；a 元素的 content model 也是 transparent，故此时里面包含 div 的合法性向上传递，检查 ins&gt;div 又向上传递，变成检查 p&gt;div。所以，div 不属于 phrasing content，这个嵌套是不合法。</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 技术文档写作规范</title>
      <link href="/2016/02/01/Markdown-Standard/"/>
      <url>/2016/02/01/Markdown-Standard/</url>
      
        <content type="html"><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>一级、二级、三级、四级…</p><p>不要超过三级标题</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>引用</li></ul><blockquote></blockquote><ul><li>代码</li></ul><pre><code>* 列表纯列表使用 使用 *，且用用 ``` 包裹，带描述的列表，列表名使用 *中英文混排时，英文中使用半角符号，连接处空格专有英文名词中单词首字母大写，句子中只需要第一个单词首字母大写。</code></pre>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Guide</title>
      <link href="/2015/07/01/Git-Guide/"/>
      <url>/2015/07/01/Git-Guide/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>分布式</li></ul><p>Git 是分布式版本控制系统，这不同于 SVN 这类集中式版本控制系统，可以完全去中心化工作，不用和中央服务器 (remote server) 进行通信，在本地即可进行全部版本控制操作，包括 commit、log、diff…，即便是离线下。</p><ul><li>快照</li></ul><p>分支在SVN中实际上是版本库中的一份copy，而git一个仓库是一个快照，所以git 切换、合并分支等操作更快速。</p><ul><li>指针</li></ul><p>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，且创建成本非常低。</p><span id="more"></span><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><p>Index</p></li><li><p>Object</p></li></ul><p>git三大对象类型: 数据对象(Blob Object) &#x2F; 树对象(Tree Object) &#x2F; 提交对象(Commit Object)</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>三大区域</li></ul><p>在 Git 项目中，存在三大区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Workspace/Working Tree/Working Directory：工作区</span><br><span class="line">Index/Stage：暂存区、索引</span><br><span class="line">Repository/Git Directory：版本库、仓库、资源库、Git 目录</span><br></pre></td></tr></table></figure><p><img src="/images/engineering/git/areas.png" alt="Git Flow 流程图"></p><p>基本的 Git 工作流程：在工作区中修改文件。<code>git add</code> 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。<code>git commit</code> 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</p><p><code>git add</code> 是让文件进入 staged，<code>git commit</code> 是让文件进入 committed。</p><p>暂存区设计目的之一，就是为了实现 add，选择性提交。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Todo……</p><p><a href="https://zhuanlan.zhihu.com/p/53750883">https://zhuanlan.zhihu.com/p/53750883</a></p><p>前三个回答：<a href="https://www.zhihu.com/question/19946553/answer/29033220">https://www.zhihu.com/question/19946553/answer/29033220</a></p><p><a href="https://zhuanlan.zhihu.com/p/96631135">https://zhuanlan.zhihu.com/p/96631135</a></p><p><a href="https://zhuanlan.zhihu.com/p/98679880">https://zhuanlan.zhihu.com/p/98679880</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 上使用 apt（或 yum） 安装 <code>sudo apt install git</code>，Windows 上可以从 Git 官网<a href="https://git-scm.com/downloads">下载安装程序</a>，Mac OS 上，Xcode 默认集成了 Git，如果没有安装 Xcode，可通过 Homebrew 单独安装。</p><p>另外，Windows 中要想在 CMD 中执行 Git，需要将 Git 添加到环境变量 path 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\bin</span><br><span class="line">C:\Program Files\Git\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]    # git help help 查看 help 命令如何使用</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 共有三级配置，优先级依次是本地配置 &gt; 全局配置 &gt; 系统配置。系统配置在 <code>/etc/gitconfig</code> 文件中（Windows 在 <code>/mingw64/etc/gitconfig</code>。Windows Git Bash 中的根目录是 Git 的安装目录），全局配置在 <code>~/.gitconfig</code> 文件中，本地配置在本地仓库的 <code>.git/config</code> 文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat ~/.gitconfig 如下所示</span><br><span class="line">[user]</span><br><span class="line">email = 240866271@qq.com</span><br><span class="line">name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">helper = manager</span><br><span class="line">[commit]</span><br><span class="line">template = D:/commit-template</span><br></pre></td></tr></table></figure><p>注：mingw（Minimalist GNU on Windows） 是一款 Windows 上的 GNU 工具集（含 vim、ssh client…），mingw64 是其 64 位版。Windows 版 Git 自带 mingw。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list    # 查看系统配置</span><br><span class="line">git config --global --list    # 查看全局配置</span><br><span class="line">git config --local --list     # 查看 repository 配置</span><br><span class="line">git config --list             # 查看当前配置（配置信息会合并，结果是本地、全局、系统三者的合并）</span><br><span class="line">git config &lt;setting&gt;          # 查看特定配置，比如 git config user.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="设置配置信息"><a href="#设置配置信息" class="headerlink" title="设置配置信息"></a>设置配置信息</h3><p>最常见的自定义配置是用户信息（用户名和邮件地址，commit 时用）、Commit Message Template、Credential Helper。</p><ul><li>用户信息</li></ul><p>用户信息用于 commit 时标示用户身份，git log 的提交日志中可以查看，如果没有配置，在 MacOS 下会使用操作系统用户名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 姓名</span><br><span class="line">git config --global user.name &quot;Tracy&quot;</span><br><span class="line"># 邮箱</span><br><span class="line">git config --global user.email &quot;240866271@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注：–global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p><ul><li>提交模版</li></ul><p>Commit Message Template</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><ul><li>换行</li></ul><p>由于各操作系统文本文件所使用的换行符不一样，UNIX&#x2F;Linux&#x2F;OS X 使用的是 LF，Windows&#x2F;Dos 使用的 CRLF。Git 默认提供了一个“换行符自动转换”功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf xx   # true、input（推荐使用）、false</span><br></pre></td></tr></table></figure><p>true 表示开启自动转换，迁入时将文件换行风格转换成 Unix 风格，迁出时根据本地系统确定是否转换成 CRLF。<br>input 表示迁入的时候将换行风格转换成 Unix 风格，迁出时不做处理。<br>false 表示迁入迁出都不对换行风格进行处理。</p><ul><li>其他</li></ul><p>除了上述常用配置，还有其他的配置，比如颜色、别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 显示颜色，会让命令输出看起来更醒目</span><br><span class="line">git config --global color.ui true</span><br><span class="line"></span><br><span class="line"># status、checkout 别名</span><br><span class="line">git config --global alias.st status            # st 就表示 status。git st 等价于 git status</span><br><span class="line">git config --global alias.co checkout          # co 就表示 checkout</span><br><span class="line"></span><br><span class="line"># unstage 别名</span><br><span class="line">git config --global alias.unstage &#x27;reset HEAD&#x27; # git unstage test.js 等价于 git reset HEAD test.js，可以把暂存区的修改撤销（unstage），重新放回工作区</span><br><span class="line"></span><br><span class="line"># 显示最后一次提交信息别名</span><br><span class="line">git config --global alias.last &#x27;log -1&#x27;        # git last 就能显示最后一次提交</span><br><span class="line"></span><br><span class="line"># log 别名</span><br><span class="line">git config --global alias.lg </span><br><span class="line">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line"># git init 默认分支名</span><br><span class="line">git config --global init.defaultBranch main    # 从 master 改为 main</span><br></pre></td></tr></table></figure><p>注，可直接编辑配置文件来设置配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --system -e    # 系统配置</span><br><span class="line">git config --global -e    # 全局配置</span><br><span class="line">git config -e             # 本地配置</span><br></pre></td></tr></table></figure><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 初始化仓库</span><br><span class="line">git init &lt;folder&gt;                  # 带 --bare 参数，可创建一个裸库</span><br><span class="line"></span><br><span class="line"># 将文件添加到暂存区</span><br><span class="line">git add -p &lt;file&gt;</span><br><span class="line"></span><br><span class="line"># 将暂存区文件添加到本地仓库中（会生成唯一的 hash 值作为 commit id）</span><br><span class="line">git commit -m &quot;add LICENSE&quot;        # 如果想要记述的更加详细，不加 -m 参数即可</span><br><span class="line"># 修改最后一次 commit message（如果不是最后一次，需要组合使用 rebase 命令，才能完成）</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"># 从版本库中删除文件</span><br><span class="line">git rm &lt;file&gt;                      # 删除工作区文件，并删除暂存区对应文件记录</span><br><span class="line">git rm --cached &lt;file&gt;             # 删除暂存区文件记录</span><br><span class="line"></span><br><span class="line"># 查看仓库状态</span><br><span class="line"># Git 文件的 4 种状态：untracked(未跟踪)、staged(已暂存)、unmodified/committed(已提交)、modified(已修改)，它们之间相互转换流程</span><br><span class="line">git status                         # 查看所有文件状态</span><br><span class="line">git status [filename]              # 查看指定文件状态</span><br><span class="line"></span><br><span class="line"># 比较差异（看懂 git diff）</span><br><span class="line">git diff              # 比较 workspace 与 index 的差异</span><br><span class="line">git diff HEAD         # 比较 workspace 与 local repository 中提交记录的差异，其中 HEAD 表示最新提交，HEAD^ 表示上一个提交，HEAD^^ 表示上上一个提交，依此类推，也可以用 HEAD~X 表示，X 代表 ^ 的个数</span><br><span class="line">git diff --cached/--staged     # 比较 index 与 local repositorty  的差异</span><br><span class="line">git diff hash1 hash2  # 比较两个提交记录的差异</span><br><span class="line"></span><br><span class="line"># 查看提交日志</span><br><span class="line">git log          # 可以加参数，比如 --pretty=oneline</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 版本回退</span><br><span class="line">git reset --hard HEAD^             # 当前版本 HEAD,上一个版本 HEAD^,上上个版本 HEAD^^</span><br><span class="line">git reset --hard 130f10a           # 或 HEAD~100</span><br><span class="line"></span><br><span class="line"># 把暂存区的修改撤销掉（to unstage）</span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line"># 查看命令记录</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 丢弃工作区的修改，回到最近一次 git commit 或 git add 时的状态</span><br><span class="line">git checkout -- README.md</span><br><span class="line"></span><br><span class="line"># 把误删的文件恢复到最新版本，checkout 其实用版本库里的版本替换工作区的版本</span><br><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure><p>廖雪峰时光穿梭机</p><p>这列的版本指的是提交记录。</p><p>这个也是我目前不太熟悉的地方，开发中常常需要将回退项目的操作，会退至某次提交</p><p>todo。。。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是用来进行并行作业的。<code>git init</code> 会默认创建 master 主分支。</p><p>以 dev 和 master 作为实例分支。</p><h3 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 查看分支（当前分支前面标有 × 号）</span><br><span class="line">git branch                                # 不带参数查看本地分支，-a 查看所有分支，-r 列出远程跟踪的分支（不是远程分支）</span><br><span class="line"></span><br><span class="line"># 创建分支（基于当前分支）</span><br><span class="line">git branch &lt;branch-name&gt;                  # 只创建不切换</span><br><span class="line"></span><br><span class="line"># 切换分支</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"># 创建（基于当前分支）和切换分支</span><br><span class="line">git checkout -b dev                       # 相当于 git branch dev、git checkout dev</span><br><span class="line">git checkout --orphan dev                 # 创建一个没有任何的提交记录的空分支，但是当前分支的内容都有，可用 git rm -rf . 删除原来代码树下的所有文件</span><br><span class="line"></span><br><span class="line"># 重新命名分支</span><br><span class="line">git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 合并分支（合并指定分支到当前分支，比如当前分支是 master）</span><br><span class="line">git merge dev</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev   # --no-ff 参数，表示禁用 Fast forward</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d dev                         # 删除已合并的本地分支（但不能删除当前分支，需要切换，才能删除）。-d -r 参数删除远程追踪分支（只是删除 git branch -r 列表中的追踪分支，并不会删除远程分支）</span><br><span class="line">git branch -D dev                         # 强行删除一个没有合并过的本地分支</span><br><span class="line"></span><br><span class="line"># 看看分支的历史提交记录</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 拉取远程仓库更新，但不合并</span><br><span class="line">git fetch                     # 默认下，git fetch 取回所有分支的更新，如果只想取回特定分支的更新，可以指定分支名，比如：git fetch origin master</span><br><span class="line"></span><br><span class="line"># 拉取远程仓库更新，且合并（git pull [远程主机名] [远程分支名]:[本地分支名]）（实质上，这等同于先做git fetch，再做git merge）</span><br><span class="line">git pull</span><br><span class="line">git pull origin dev           # 如果省略本地分支名，则表示远程分支与当前分支合并</span><br><span class="line"></span><br><span class="line"># 向远程仓库库推送更新（git push [远程主机名] [本地分支名]:[远程分支名]）（为防止冲突，push 前要先 pull）</span><br><span class="line">git push -u origin master     # 当前分支可能与多个主机存在追踪关系（tracking），所以首次要用 -u（--set-upstream）指定一个默认主机（upstream），以后可直接 git push</span><br><span class="line">git push origin master        # 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支，如果该远程分支不存在，则会被新建</span><br><span class="line">git push origin :dev          # 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支</span><br><span class="line">git push origin               # 将当前分支推送到 origin 主机的对应分支</span><br><span class="line">git push                      # 如果当前分支只有一个追踪分支，那么连主机名都可以省略</span><br><span class="line">git push --force              # --force/-f 强制推送</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete dev  # 删除 origin 主机的 dev 分支。注：远程的默认分支，不能为当前将要删的目标分支，如果是，需要将默认分支切换到其他分支上，再删</span><br><span class="line"></span><br><span class="line"># 从远程库 clone，默认情况只能看到 master 分支，需要在 dev 分支，必须创建远程 origin 的 dev 分支到本地</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name # 关联</span><br></pre></td></tr></table></figure><p>注：不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式。如果要修改这个设置，可以采用 git config 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># matching</span><br><span class="line">git config --global push.default matching</span><br><span class="line"></span><br><span class="line"># simple</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>Git 中的标签和分支有点类似，都是引用或者说指针，不过标签的位置是固定的，在给指定提交打好标签以后，它就固定于此位置，而分支的位置是会不断变动的，随着分支的向前推移或者向后回滚，都在不断变化。分支和标签的用处也不一样，分支用于并行作业，而标签用于处理发布。</p><p>Git 标签分为两种类型：轻量型（lightweight）和附注型（annotated）。轻量标签是指向特定提交对象的引用，而附注标签则是仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。建议使用附注标签，以便保留相关信息。标签名应采用统一的格式，<code>v$&#123;MajorVersion&#125;.$&#123;MinorVersion&#125;.$&#123;FixVersion&#125;-$&#123;TypeLabel&#125;</code>，其中 TypeLabel (alpha、 beta…) 可选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看标签</span><br><span class="line">git tag                                 # 查看所有 tag</span><br><span class="line">git tag -l v1.0.*                       # 查看符合模式的 tag</span><br><span class="line">git show v1.0.0                         # 查看 tag 信息</span><br><span class="line"></span><br><span class="line"># 新建标签</span><br><span class="line">git tag v1.0.0                          # 新建轻量 tag</span><br><span class="line">git tag v1.0.0 9fceb02                  # 为某个 commit 新建 tag（一般用于后期加注标签）。用 git log --pretty=oneline --abbrev-commit 查看 commit id</span><br><span class="line">git tag -a v1.0.0 -m &quot;message&quot;          # 新建带注释的 tag（用 -a 来创建一个带备注的 tag，-m 指定说明文字）</span><br><span class="line"></span><br><span class="line"># 推送标签</span><br><span class="line">git push origin v1.0.0                  # 推送某个具体 tag</span><br><span class="line">git push origin --tags                  # 推送所有 tag</span><br><span class="line"></span><br><span class="line"># 切换标签</span><br><span class="line">git checkout v1.0.0                     # 切换方法跟分支一样</span><br><span class="line"></span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d v1.0.0                       # 删除本地某个 tag</span><br><span class="line">git push origin :refs/tags/v1.0.0   # 删除远端某个 tag</span><br></pre></td></tr></table></figure><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Stash 可用在一些特殊的工作场景中，比如，需要临时修复 Bug，可以把当前工作现场储藏起来，等 Bug 修复后恢复现场后继续工作。在 Git Flow 下，Stash 基本用不到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 保存存储</span><br><span class="line">git stash</span><br><span class="line">git stash save &quot;save message&quot; # 带注释的存储</span><br><span class="line"></span><br><span class="line"># 查看存储列表</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 查看存储详情</span><br><span class="line">git stash show                          # 默认查看第一个 stash，即 stash@&#123;0&#125;，可以以指定。另外，-p 参数，可以查看到具体的详情</span><br><span class="line"></span><br><span class="line"># 恢复存储</span><br><span class="line">git stash pop                           # 恢复的同时把存储也删了，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定 git stash pop stash@&#123;$num&#125;</span><br><span class="line">git stash apply                         # 恢复某个存储，但不会把存储从存储列表中删除，默认使用第一个存储，也可以指定</span><br><span class="line"></span><br><span class="line"># 删除存储</span><br><span class="line">git stash drop                          # 删除某个存储，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定</span><br><span class="line">git stash clear                         # 删除所有存储</span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>.gitignore 配置文件用于忽略文件，不被添加到版本库中，其配置语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以斜杠 / 开头表示目录</span><br><span class="line">以星号 * 通配多个字符</span><br><span class="line">以问号 ? 通配单个字符</span><br><span class="line">以方括号 [] 包含单个字符的匹配列表</span><br><span class="line">以叹号 ! 表示不忽略匹配到的文件或目录</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 txt 结尾的文件</span><br><span class="line">*.txt</span><br><span class="line"># 忽略 doc 目录下 所有 txt 文件，不包括子目录（doc/subdir/a.txt）</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc 目录下所有 txt 的文件，包括子目录</span><br><span class="line">doc/**/*.txt</span><br><span class="line"></span><br><span class="line"># README.txt 除外</span><br><span class="line">!README.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件（不管 build 是根目录还是子目录，都会被忽略）</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略根目录下的 TODOLIST 文件（不包括 subdir/TODOLIST）</span><br><span class="line">/TODOLIST</span><br></pre></td></tr></table></figure><p>注：Git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程中心化仓库可用来备份存储和共享协作（clone、push、pull…）。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 生成私钥和公钥证书</span><br><span class="line">ssh-keygen -t rsa -C &quot;any comment can be here&quot;</span><br><span class="line"></span><br><span class="line"># 测试证书登录是否设置成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"># 克隆远程仓库</span><br><span class="line">git clone [remote url] [local url]                    # git clone git@github.com:michaelliao/gitskills.git （GitHub 可以使用 HTTPS 和 SSH 协议）</span><br><span class="line"></span><br><span class="line"># 添加远程仓库</span><br><span class="line">git remote add [shortname] [url]                      # git remote add origin git@github.com:Windrivder/Windrivder.git</span><br><span class="line"></span><br><span class="line"># 删除远程仓库</span><br><span class="line">git remote rm [remote name]</span><br><span class="line"></span><br><span class="line"># 修改远程仓库名</span><br><span class="line">git remote rename [old remote name] [new remote name]</span><br><span class="line"></span><br><span class="line"># 要查看远程库的信息</span><br><span class="line">git remote                                            # 查看已经存在的远程仓库</span><br><span class="line">git remote -v                                         # 查看已经存在的远程仓库的详细信息</span><br></pre></td></tr></table></figure><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>SSH 可通过证书来实现免密登录，然而，这对 HTTP 协议来说是不可能的，每一个连接都是需要用户名和密码的（<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">官网文档</a>）。为了不用每次都输入用户名和密码，Git 使用 credential.help 来存储本地凭证（默认所有都不缓存，每一次连接都会询问你的用户名和密码），其所支持的选项如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache        # cache 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在 15 分钟后从内存中清除</span><br><span class="line">store        # store 模式会将凭证用明文的形式存放在磁盘中（默认在 home 目录），永不过期</span><br><span class="line">osxkeychain  # Mac 下 store 的加密版，凭证保存在用户的钥匙串中</span><br><span class="line">manager      # Windows 下 store 的加密版，凭证保存在 Windows 的凭据管理器中。在 system 级别被设置（credential.helper=manager），优先于 global 和 local</span><br></pre></td></tr></table></figure><p>可通过 Git 的帮助文档来查看我们系统支持哪种 helper。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Linux 下</span><br><span class="line">git help -a | grep credential</span><br><span class="line"># 输出结果</span><br><span class="line">credential                 remote-ftps</span><br><span class="line">credential-cache           remote-ftps</span><br><span class="line">credential-cache--daemo    remote-ftps</span><br><span class="line">credential-store           remote-ftps</span><br><span class="line"></span><br><span class="line"># Window 下（CMD 使用 findstr，PowerShell 使用 sls。或者在 C:\Program Files\Git\mingw64\libexec\git-core 目录下执行 (ls).Name | sls credential）</span><br><span class="line">git help -a | sls credential</span><br><span class="line"># 输出结果</span><br><span class="line">git-credential-manager.exe</span><br><span class="line">git-credential-store.exe</span><br><span class="line">git-credential-wincred.exe</span><br><span class="line">git-credential.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看默认配置</span><br><span class="line">git config --list | grep credential</span><br></pre></td></tr></table></figure><p>Mac 默认 credential helper 是 osxkeychain，Windows 默认是 manager，而 Linux 默认不存储，需手动设置，以 store 模式为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这样，会生成 <code>~/.git-credentials</code> 文件，用户信息会以明文保存在里面，<code>https://&#123;userName&#125;:&#123;password&#125;@github.com</code>，比如 <code>https://Tracy-xu:395083226%40gh@github.com</code>。</p><p>注：要操作一个远程仓库，首先要有 Git 服务器登录权限，然后要有项目权限（项目的所有者，或者 Collaborators – 协作者）。</p><h2 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h2><p>SSH 作为 Git 所支持通信协议其中之一，如果想通过 SSH 来使用 Git，则需要安装 SSH Server。Linux 一般都自带 SSH，而 Windows 配置起来麻烦，所以这里以 Linux 为例。 </p><p>当然，在实际使用中不单单只会用到一个简单的非常底层的 Git 服务器，还有其他很多功能会使用到（比如，提供图形化界面的用户管理、SSH 管理、Log、Issue、Pull Request，甚至 Wiki 和持续集成），所以一般会使用 GitHub、GitLab、GitBucket 基于 Git 实现的 Git 仓库托管系统。</p><ol><li>安装 Git</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git                # CentOS 用 yum 带 -y 参数安装（-y 参数不用一步步询问）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个 Git 用户，用来运行 Git 服务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br><span class="line"></span><br><span class="line"># 默认情况下 SSH 不允许空密码用户登录（可在 sshd_config 中设置，参考相关章节），所以还需给 git 这个用户设置一个密码。</span><br><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><ol start="3"><li>设置证书登录</li></ol><p>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个（参考 Linux 相关章节。在没有像 GitHub、GitLab 这样的平台来管理 authorized_keys，管理员手动管理 authorized_keys 很麻烦）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 验证证书登录是否设置成功（如果让输入密码则没有成功，如果不让输入则设置成功）</span><br><span class="line">ssh -T git@192.168.10.140</span><br><span class="line"></span><br><span class="line"># 不让输入密码，回车后，原生的 Git Service 没有任何返回，GitHub 会有返回</span><br><span class="line">ssh -T git@github.com    </span><br><span class="line">Hi Tracy-xu! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>注：<code>~/.ssh</code> 目录在用户目录下（不同用户 <code>~</code> 下输入 <code>pwd</code>，结果会是 <code>/root</code> 或者 <code>/home/xxx</code>），修改 <code>~/.ssh/authorized_keys</code> 只对当前用户生效。另外，如果不设置证书登录，默认会使用密码登录。</p><ol start="4"><li>初始化 Git 仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选定一个目录作为 Git 仓库，假定是 /srv/sample.git，在 /srv 目录下输入命令</span><br><span class="line">sudo git init --bare sample.git</span><br><span class="line"></span><br><span class="line"># 把 owner 改为 git（如果这一步不设置，push 时会报权限不足：insufficient permission for adding an object to repository databa）</span><br><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>与 <code>git init</code> 不同的是，<code>git init --bare</code> 被用来创建“裸库”，裸库没有 work tree（工作区），只有 .git 目录，记录着版本历史，一般用于公共的远程中央仓库，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区。另外，服务器上的 Git 仓库通常都以 .git 结尾。</p><ol start="5"><li>禁用 Shell 登录</li></ol><p>出于安全考虑，第二步创建的 git 账户不允许登录 Shell（GitHub 就是如此，<code>ssh git@github.com </code>），只允许 Git 相关操作，所以要把 Shell 登录改为 git-shell 登录。编辑 <code>/etc/passwd</code> 文件，为 git 用户指定的 git-shell 即可（参考 Linux passwd 相关章节）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为</span><br><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>还要复制一个名为 git-shell-commands 的目录，要不然 <code>ssh git@192.168.10.140</code> 时会报 fatal:Interactive git shell is not enabled 错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/git-1.8.3.1/contrib/git-shell-commands /home/git -R</span><br><span class="line">chown git /home/git/git-shell-commands/ -R</span><br><span class="line">chmod +x /home/git/git-shell-commands/help</span><br><span class="line">chmod +x /home/git/git-shell-commands/list</span><br></pre></td></tr></table></figure><p>现在，不管是开机登录，还是 su 切换用户登录，还是 SSH 远程登录，git 用户登录的都将是 git-shell，进来看到的是 <code>git&gt;</code> 而不是 <code>[root@localhost ~]#</code>。另外，不能将 git 账户登录权限改为 <code>/sbin/nologin</code>，禁用登录，要不然客户端在 clone 时会报 <code>fatal: protocol error: bad line length character: This</code> 错误。</p><ol start="6"><li>克隆远程仓库</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@192.168.10.140:/srv/sample.git</span><br></pre></td></tr></table></figure><p>直接 clone 会提示这是一个空仓库。也可以在本地创建一个仓库，然后添加 remote 地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">...</span><br><span class="line">git remote add origin ssh://git@192.168.10.140:/srv/sample.git      # clone 时可以省略 ssh:// 协议，设置地址时不可省略</span><br><span class="line">git push --set-upstream origin master                               # 可以缩写为 git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 单位</title>
      <link href="/2013/06/22/CSS%20%E5%8D%95%E4%BD%8D/"/>
      <url>/2013/06/22/CSS%20%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px 是一个<a href="https://www.w3.org/TR/css3-values/#lengths">绝对单位</a>，不相对于谁，只受平台 dpi 影响。cm、pt 之类的也都是绝对长度，但与 px 这个抽象单位不同的是它们都是物理单位，1pt 则是 1&#x2F;72 英寸，而 1 英寸换算到公制是 2.54cm，在 CSS 中所有的物理单位会直接映射到像素，在 96dpi 下 <code>1in = 2.54cm = 96px</code> <code>1cm = 37.8px</code>。</p><span id="more"></span><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em 是一个相对单位，相对于当前元素的 font-size（如果当前元素没有 font-size 或者 font-size 是相对单位，则先继承父辈的字号，再计算 em）。也可以说，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小。不管怎么样，要想计算 em 的大小，要先确定当前元素<strong>具体</strong>的 font-size。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-size: 12px; line-height: 1.5em&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block; width: 4em; font-size: 3em;&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子中，span 先继承父元素 font-size，再计算自身 font-size，即 <code>3em * 12px = 36px</code>，width 为 <code>4 * 36px = 144px</code>。另外，对于相对单位属性的继承，要在父辈元素先计算为具体值，再继承，div 的 line-height 为 <code>1.5em * 12px = 18px</code>，所以 span 的 line-height 为 18px，而不是直接继承 1.5em。</p><p>由于 em 相对于当前元素的字号大小，而且字号会继承，这导致不能统一管理基础变量，且依赖追溯复杂，不适合在整个页面中使用，只适用于做局部缩放的场景。</p><p>历史上，因为 IE 不支持 px 为单位的缩放，故使用 em 来做缩放。<a href="http://clagnut.com/about">Richard Rutter</a> 在 <a href="http://clagnut.com/blog/348/">How to size text using ems</a> 和 <a href="http://alistapart.com/article/howtosizetextincss">How to Size Text in CSS</a> 中做过详细的介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;:root&#x27;</span>), <span class="literal">null</span>).<span class="property">fontSize</span>; <span class="comment">// 16px，Chrome 上最小支持的字号为 12px</span></span><br></pre></td></tr></table></figure><p>以 <code>&lt;html&gt;</code> 的 <code>font-size</code> 为基准，浏览器默认的字号为 16px，换算为 em 即 <code>1em = 16px</code>、<code>12px = 0.75em</code>、<code>10px = 0.625em</code>，为了方便 <code>font-size</code> 的换算，可将 html 字号设为 <code>font-size: 62.5%</code>（即 <code>16px * 62.5% = 10px</code>），或者直接 <code>font-size: 10px</code>，这样 <code>1em = 10px</code>、<code>1.2em = 12px</code>、<code>1.4em = 14px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">h1</span>, <span class="number">2.4em</span> × <span class="number">10</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4em</span>;&#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">body</span>&gt;<span class="selector-tag">p</span>, <span class="number">1.4em</span> × <span class="number">10</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4em</span>;&#125;</span><br></pre></td></tr></table></figure><p>随着浏览器的更新换代，这种做法早已被淹没在历史尘埃中。</p><h2 id="percent"><a href="#percent" class="headerlink" title="percent"></a>percent</h2><p>一般情况下 % 相对于包含块（containing block），在应用于字体大小时，相对于父字体大小。</p><p>包含块的确定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 对于普通定位元素就是父元素</span><br><span class="line">* 对于 position: absolute 的元素是相对于已定位的父元素（offset parent）</span><br><span class="line">* 对于 position: fixed 的元素是相对于 ViewPort（可视窗口）</span><br></pre></td></tr></table></figure><p>需要注意的是，padding、margin 如果设置了百分比，会发现左右和预期一样，用的父元素宽度的百分比，但是上下用的也是宽度百分比，而不是想象中的高度的百分比。另外，percent 在被后代元素继承时继承的是百分比计算后的值，而不是原百分比，比如 line-height 120% 和 1.2 在被继承时。</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem 相对于根元素 font-size 的单位。引入它是为了解决 em 依赖追溯困难，计算复杂的问题。而 rem 是相对于根元素 <code>&lt;html&gt;</code>，依赖简单，只需要在根元素确定一个参考值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">10</span> ÷ <span class="number">16</span> × <span class="number">100%</span> = <span class="number">62.5%</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">1.4</span> × <span class="number">10px</span> = <span class="number">14px</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4rem</span>;&#125;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.4</span> × <span class="number">10px</span> = <span class="number">24px</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4rem</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然 em、rem 相对于 font-size，但是并不单单只能应用于 font-size。另外，所有的 em、rem、percent 渲染的时候，都会被转为 px，因为<strong>px是计算机矢量图渲染成像的原理</strong>。</p><p>rem 一般用来做移动端适配。</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw 是 CSS3 引入的单位，相对于视口的宽度，视口被均分为 100 单位的 vw，1vw &#x3D; 1% 窗口宽度。vh同理。常用来配合 rem 做移动端适配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个单位都有各自的优缺点，取决于场景，不能脱离场景谈应用。例如，em、rem、vh、vw、 Percent 这些相对单位，比较适合做尺寸联动适配。</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2013/05/07/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2013/05/07/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>简单选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 通配符选择器</span><br><span class="line">E 标签选择器</span><br><span class="line">类选择器</span><br><span class="line">ID 选择器</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>关系选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E F 后代选择器</span><br><span class="line">E&gt;F 子选择器</span><br><span class="line">E~F 相邻选择器</span><br><span class="line">E+F 相邻兄弟选择器</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[attr]</span><br><span class="line">[attr=val]</span><br><span class="line">[attr|=val] 开头匹配（分词）</span><br><span class="line">[attr~=val] 包含匹配（分词）</span><br><span class="line">[attr^=val] 开头匹配</span><br><span class="line">[attr$=val] 结尾匹配</span><br><span class="line">[attr*=val] 包含匹配</span><br></pre></td></tr></table></figure><ul><li>伪类选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 结构性伪类选择器</span><br><span class="line">:root</span><br><span class="line">:not</span><br><span class="line">:empty                  # E 元素中没有子节点（包含文本节点）</span><br><span class="line">:target</span><br><span class="line"></span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br><span class="line">:first-of-type</span><br><span class="line">:last-of-type</span><br><span class="line">:nth-child(n)           # 父元素中的第 n 个 E 元素</span><br><span class="line">:nth-last-child(n)      # 父元素中的第 n 个 E 元素，从后向前计算</span><br><span class="line">:nth-of-type(n)</span><br><span class="line">:nth-last-of-type(n)</span><br><span class="line"></span><br><span class="line"># UI 元素状态伪类选择器</span><br><span class="line">:link</span><br><span class="line">:visited</span><br><span class="line">:hover</span><br><span class="line">:active</span><br><span class="line">:focus</span><br><span class="line"></span><br><span class="line">:enabled</span><br><span class="line">:disabled</span><br><span class="line">:checked</span><br><span class="line">:read-only</span><br><span class="line">:read-write</span><br><span class="line"></span><br><span class="line">:required</span><br><span class="line">:optional</span><br><span class="line">:valid</span><br><span class="line">:inlvalid</span><br><span class="line">:in-range</span><br><span class="line">:out-of-range</span><br><span class="line"></span><br><span class="line">:only-of-type</span><br><span class="line">:only-child</span><br><span class="line"></span><br><span class="line">:lang</span><br></pre></td></tr></table></figure><p>注2：带 <code>type</code> 的选择器，是 type（类型）里面进行筛选的，<code>first-of-type</code>（type里面的第一个）、<code>only-of-type</code>（type里面唯一）。</p><ul><li>伪元素选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::before 原始的开始</span><br><span class="line">::after 元素的结尾</span><br><span class="line">::first-letter 第一个字母</span><br><span class="line">::first-line 第一行</span><br><span class="line">::selecton 选中的内容</span><br></pre></td></tr></table></figure><p>伪元素表示的是并不真实存在的元素（特殊的位置），与伪类的主要区别是，伪类选择的是元素，而伪元素选择器选择的是伪元素。</p><h2 id="选择器的应用"><a href="#选择器的应用" class="headerlink" title="选择器的应用"></a>选择器的应用</h2><p>选择器可组合，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E.class &#123;&#125;</span><br><span class="line">:hover &#123;&#125;</span><br><span class="line">E:hover &#123;&#125;</span><br><span class="line">[attr] &#123;&#125;</span><br><span class="line">E[attr] &#123;&#125;</span><br><span class="line">:first-child &#123;&#125;</span><br><span class="line">E:first-child &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>,</code> 分割</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E,F &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>nth-child 和 not 选择器的妙用</li></ul><p>注1：n 从 1 开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:nth-child(odd)</span><br><span class="line">E:nth-child(even)</span><br><span class="line">E:nth-child(2n)</span><br></pre></td></tr></table></figure><p>选择 1 到 3 的元素并显示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 not 反选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>)) &#123;&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>逗号分隔列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:last-child</span>)<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 a 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;http&quot;</span>]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:has() 选择器是一个关系型伪类选择器，也被称为函数型伪类选择器，它和 :is()、:not() 以及 :where()函数型选择器被称为 CSS的逻辑组合选择器 ！</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 精粹</title>
      <link href="/2013/05/02/CSS%20%E7%B2%BE%E7%B2%B9/"/>
      <url>/2013/05/02/CSS%20%E7%B2%BE%E7%B2%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-的构成"><a href="#CSS-的构成" class="headerlink" title="CSS 的构成"></a>CSS 的构成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 选择器</span><br><span class="line">* 文字处理</span><br><span class="line">* 背景图像处理</span><br><span class="line">* 布局</span><br><span class="line">* 动画</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="W3C-标准"><a href="#W3C-标准" class="headerlink" title="W3C 标准"></a>W3C 标准</h3><p>W3C 的标准化进程为：<code>WD --&gt; LC --&gt; CR --&gt; PR --&gt; REC</code>。</p><ul><li>关于前缀</li></ul><p>CSS 规范一般由 W3C 组织先制定草案（WD），然后浏览器厂商各自实现，稳定后再进入标准（推荐 REC）。从 WD 到 REC 有一个过程，如果浏览器厂商提前支持，会存在风险，可能会导致未来的不兼容。</p><p>有一个经典的案例，IE6 在 <code>inline-block</code> 未进入标准前就已对其支持了，当标准出来后含义却不一样。未防止这种情况的出现，于是通过加前缀私有的方式来实现未进入标准的特性。</p><p>浏览器前缀可以加在属性上，也可以加在属性值上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line"><span class="attribute">display</span>: -webkit-flex;</span><br></pre></td></tr></table></figure><h3 id="可视化格式模型"><a href="#可视化格式模型" class="headerlink" title="可视化格式模型"></a>可视化格式模型</h3><ul><li>BFC</li></ul><p>注：overflow非visible都会激活BFC（不光光只有平时所用hidden），html根元素默认overflow:auto，所以默认下就已经是一个BFC环境，所有的block level元素在BFC中被格式化，呈纵向排布。</p><ul><li>IFC</li></ul><h3 id="CSS-Specificity"><a href="#CSS-Specificity" class="headerlink" title="CSS Specificity"></a>CSS Specificity</h3><h2 id="方法论和工具"><a href="#方法论和工具" class="headerlink" title="方法论和工具"></a>方法论和工具</h2><p>掌握几套方法论和一些常用工具，比如方法论：<code>OOCSS、BEM、SMACCSS、CSS Module…</code>；工具里面：<code>LESS、SASS、CSSLint、PostCSS…</code>。</p><p>CSS Modules</p><p>CSS in JS</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>css 在逐渐改变存在的问题</li></ul><p>表达能力变强(css3 也支持了变量)<br>父选择器</p><ul><li>sass</li></ul><p>理论上计算机中所有问题都可以通过加一个中间层来解决，sass 就可以看为一个中间层(和 ts 一样)，目的是为了提高 css 的表达能力，要是在浏览器上加入 sass 引擎，浏览器也就原生支持 sass 了。</p><ul><li>模块化</li></ul><p>模块化&#x2F;组件化的目的: 复用、分治(所以说并不是只有复用才会去做模块化,有些组件只是单纯的为了分治，不具备复用的能力，比如一些子组件，SidebarItem 就不能脱离子组件单纯拿出来用)。用到的方法是抽象。</p><p>css 命名: c 强调的是分治，m 强调的是复用</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局的传统解决方案，基于盒模型（margin、padding），依赖 display 属性 + position 属性 + float 属性。</p><ul><li>圣杯</li></ul><p>左右固定宽度，中间自适应，且中间放在文档流前面以优先渲染。</p><p>负 margin 的应用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;<span class="attribute">overflow</span>: hidden; <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.main</span>, <span class="selector-class">.right</span> &#123;<span class="attribute">position</span>: relative; <span class="attribute">float</span>: left; <span class="attribute">height</span>: <span class="number">130px</span>;&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">background</span>: <span class="number">#008000</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">left</span>: -<span class="number">200px</span>; <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">right</span>: -<span class="number">200px</span>; <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：这种布局的解法办法有很多，负 margin 的圣杯和双飞翼是其中一种，我认为最简洁的办法是绝对定位：<code>.center &#123;margin: 0 200px;&#125; .left .right 绝对定位</code>。</p><ul><li>双飞翼</li></ul><p>圣杯布局、双飞翼布局，解决的问题是一样的：左右固定宽度，中间自适应，且中间放在文档流前面以优先渲染。在解决问题的方案上，圣杯布局和双飞翼布局前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决“中间栏内容不被遮挡”问题的思路不一样。</p><p>-margin 的应用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;<span class="attribute">float</span>: left; <span class="attribute">height</span>: <span class="number">130px</span>;&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;<span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">130px</span>; <span class="attribute">background</span>: <span class="number">#008000</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;<span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;<span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>瀑布流</li></ul><p><code>float: left</code> 或 <code>position: absolute</code> 的应用。</p><ul><li>两栏等高布局</li></ul><p>Equal height columns 的解法有很多中，除负 margin 正 padding 障眼法外，table、flex、JS 也可解。</p><p>JS 的缺点是异步html数据，padding margin在firefox和ie上对正负抵消有滚动。</p><ul><li>全屏布局</li></ul><p>poition: absolute的应用。</p><ul><li>九宫格</li></ul><p>负 margin的应用。</p><ul><li>视差滚动</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 精粹</title>
      <link href="/2013/03/15/HTML%20%E7%B2%BE%E7%B2%B9/"/>
      <url>/2013/03/15/HTML%20%E7%B2%BE%E7%B2%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p><code>&lt;!DOCTYPE&gt;</code> 标签位于文档中的最前面的位置，作用相当于一个标识符，此标签可告知 Parser（排版引擎）使用哪种 <code>HTML</code> 或 <code>XHTML</code> 解析规则，和使用哪种渲染模式。</p><p>DOCTYPE 的基本结构：<code>&lt;!DOCTYPE Element-name DTD-type DTD-name DTD-url&gt;</code>，HTML5 <code>&lt;!DOCTYPE Element-name&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &lt;!DOCTYPE&gt; 是关键字，表示声明 DTD</span><br><span class="line">* Element-name 指定该 DTD 的根元素名称</span><br><span class="line">* DTD-type 指定该 DTD 是属于标准公用的还是私人定制的。若是 PUBLIC 则表示该 DTD 是标准公用的，如果设为 SYSTEM 则表示是私人定制的</span><br><span class="line">* DTD-name 指定该 DTD 的文件名称</span><br><span class="line">* DTD-url 指定该 DTD 文件所在的 URL 网址</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD 是一份规则，会被 DOCTYPE 标签所声明引用，老版本的 Parser 会根据 DTD-name 来选择对应的解析规则（到底是 4s、4t…）。现代浏览器 HTML5 规则下的 Parser，无需指定 DTD，且向下兼容。</p><p>DTD 的种类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!!xt/!!!4t XHTML1.0/HTML4.01 transitional</span><br><span class="line">!!!xs/!!!4s XHTML1.0/HTML4.01 strict</span><br><span class="line">!!!xf/!!!4f XHTML1.0/HTML4.01 frameset</span><br><span class="line">!!!xxs XHTML 1.1</span><br><span class="line">!!! HTML5</span><br></pre></td></tr></table></figure><p>例如，XHTML1.0 strict：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/XHTML1/DTD/XHTML1-strict.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的声明中，声明了文档的根元素是 <code>HTML</code>，它在公共标识符被定义为 <code>&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</code>，浏览器将明白如何寻找匹配此公共标识符的 <code>DTD</code>。</p><p>HTML5 的 Doctype 没有对 DTD 进行引用。原因：HTML5 不是基于 SGML 的，DTD 是 SGML 里概念，所以 HTML5 没有 DTD，现代浏览器的 Parser 都按照 HTML5 规范编写，HTML5 兼容所有的老版本 HTML，语法非常包容。主张开发规范由开发者自定义，而不是由 Parser 强制校验。</p><p>附：<a href="http://www.w3.org/TR/XHTML1/DTD/XHTML1-strict.dtd">xhtml1-strict</a></p><h3 id="Quirks-model、Standard-model"><a href="#Quirks-model、Standard-model" class="headerlink" title="Quirks model、Standard model"></a>Quirks model、Standard model</h3><p>Quirks model 和 Standard model 用于区分 W3C 标准网页和非 W3C 标准网页，浏览器 Parser 会根据 DOCTYPE 选择不同的渲染模式，W3C 标准网页采用 Standard model，非标准网页 Quirks model，以此来保证网页的正确显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略 DTD-name 和 DTD-url --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 省略 DTD-url --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">compatMode</span>; <span class="comment">// CSS1Compat（标准模式）、BackCompat（怪异模式）</span></span><br></pre></td></tr></table></figure><p>省略了 DTD-name 的 DOCTYPE 声明是无效的，因为它包含公共标识符关键字 PUBLIC，却没有公共标识符（指示所用 HTML 版本的名称），这将会触发怪异模式，而省略了 DTD-url 的 DOCTYPE 照常进入 Standards Model。</p><p>没有 <code>&lt;DOCTYPE&gt;</code>，<code>&lt;DOCTYPE&gt;</code> 前有其他内容或者省略 DTD-name，这都会触发 Quirks model。</p><p>注：Chrome 下测试发现，虽然 <code>document.compatMode</code> 还能返回 BackCompat，但 Parser 已经去掉了对 Quirks model 的处理，将 Quirks model 下的网页按 Standards model 处理了。</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>文档结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html HTML 文档</span><br><span class="line">head 文档信息</span><br><span class="line">body 文档主体</span><br></pre></td></tr></table></figure><!--more--><ul><li>文档元信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base 页面中所有链接的默认地址或默认目标</span><br><span class="line">title 文档的标题</span><br><span class="line">meta 文档的元信息</span><br><span class="line">link 文档与外部资源的关系</span><br><span class="line">style 文档的样式信息</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置网页关键词 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;JavaScript,CSS,HTML&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置网页简介说明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;JavaScript: The World&#x27;s Best Programming language&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网页作者信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;auther&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Insonia&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置网页编码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动跳转(重定向)和刷新页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5;url=http://www.baidu.com&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 告诉搜索引擎robots，对此网操作意图(如果不加此标签，默认的是all) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;roots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：元信息标签–可选属性有 http-equiv, name, scheme。必需的属性 content</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://static.leke.cn/images/common/header/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.leke.cn&quot;</span>&gt;</span>Leke<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div 无语义的 section</span><br><span class="line">span 无语义 inline 结构标签</span><br><span class="line">section 区块，带语义的 div</span><br><span class="line">article 独立区块 </span><br><span class="line">aside article 的辅助信息</span><br><span class="line">nav 导航</span><br><span class="line">footer 页脚</span><br><span class="line">header 页眉</span><br><span class="line">figure 媒介内容的分组</span><br><span class="line">figcaption figure 元素的标题</span><br><span class="line">address 文档作者或拥有者的联系信息</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>content<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://static.leke.cn/images/index/tiyan.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>互联网教育<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:service@strong.cn&quot;</span>&gt;</span>用户服务信箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>施强教育科技有限公司<span class="tag">&lt;<span class="name">br</span>&gt;</span>杭州市滨江区滨安路1168号<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>文本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a 锚连接</span><br><span class="line">h1 - h6 标题</span><br><span class="line">p 段落</span><br><span class="line">i 斜体字(无语义)</span><br><span class="line">b 粗体字(无语义)</span><br><span class="line">small 小号字体</span><br><span class="line">em 强调文本(带语义，且语义比strong更重)</span><br><span class="line">strong 强调文本(带语义，语义比em弱)</span><br><span class="line">del 被删除文本</span><br><span class="line">ins 被插入文本</span><br><span class="line">u 下划线</span><br><span class="line">s 删除线</span><br><span class="line">q 短的引用</span><br><span class="line">blockquote 长的引用</span><br><span class="line">cite 引用（citation）</span><br><span class="line">br 折行</span><br><span class="line">mark 标记</span><br><span class="line">wbr 软换行</span><br><span class="line">hr 水平线</span><br><span class="line">pre 预格式文本</span><br><span class="line">abbr 缩写</span><br><span class="line">dfn 定义项目</span><br><span class="line">time 日期/时间</span><br><span class="line">ruby ruby 注释（可以用来进行音注）</span><br><span class="line">rt ruby注释的解释</span><br><span class="line">rb </span><br><span class="line">rtc </span><br><span class="line">rp 若浏览器不支持 ruby 元素显示的内容</span><br><span class="line">code 计算机代码文本</span><br><span class="line">samp 计算机代码样本文本</span><br><span class="line">kbd 键盘文本</span><br><span class="line">var 文本的变量部分</span><br></pre></td></tr></table></figure><p>注：<code>i</code>、<code>b</code>、<code>u</code>、<code>small</code>，在 HTML5 中被重新定义了意义（<a href="https://www.w3.org/TR/html5-diff/">HTML5 Differences from HTML4</a>）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rb</span>&gt;</span>施强教育<span class="tag">&lt;/<span class="name">rb</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rt</span>&gt;</span>Strong Jao Yu<span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">  漢 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>Kan<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line">  字 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>ji<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">    最是那一低头的温柔，</span><br><span class="line">    象一朵水莲花不胜凉风的娇羞，</span><br><span class="line">    道一声珍重，道一声珍重，</span><br><span class="line">    那一声珍重里有甜蜜的忧愁</span><br><span class="line">  <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>---摘自<span class="tag">&lt;<span class="name">cite</span>&gt;</span>《徐志摩诗集》<span class="tag">&lt;/<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">孔子说：<span class="tag">&lt;<span class="name">q</span> <span class="attr">cite</span>=<span class="string">&quot;http://www.lunyu.com&quot;</span>&gt;</span>学而时习之，不亦说乎<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"></span><br><span class="line">More information can be found in <span class="tag">&lt;<span class="name">cite</span>&gt;</span>[ISO-0000]<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>.</span><br></pre></td></tr></table></figure><p>注：<code>blockquote</code> 和 <code>q</code> 都可以引用，比如引用一句话，一段文档摘录，很明显 <code>q</code> 表示一句话（短），<code>blockquote</code> 引用文档摘录（长），它们两个都有 cite 属性，表示引用的出处。而 <code>cite</code> 表引用时，用于引用文献。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Hypertext Markup Language&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被废弃 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acronym</span> <span class="attr">title</span>=<span class="string">&quot;World Wide Web&quot;</span>&gt;</span>WWW<span class="tag">&lt;/<span class="name">acronym</span>&gt;</span>  </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一盒有 <span class="tag">&lt;<span class="name">del</span>&gt;</span>20<span class="tag">&lt;/<span class="name">del</span>&gt;</span> <span class="tag">&lt;<span class="name">ins</span>&gt;</span>30<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>个。</span><br><span class="line">原价：<span class="tag">&lt;<span class="name">del</span>&gt;</span>120元<span class="tag">&lt;/<span class="name">del</span>&gt;</span>，折后：<span class="tag">&lt;<span class="name">ins</span>&gt;</span>60元<span class="tag">&lt;/<span class="name">ins</span>&gt;</span>。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dfn</span> <span class="attr">id</span>=<span class="string">&quot;def-internet&quot;</span>&gt;</span>The Internet<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span> is a global system of interconnected networks.</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">code</span>&gt;</span></span><br><span class="line">    (function foo(i)&#123;</span><br><span class="line">      if (i &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return i + foo(i - 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(10000);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">A simple equation: <span class="tag">&lt;<span class="name">var</span>&gt;</span>x<span class="tag">&lt;/<span class="name">var</span>&gt;</span> = <span class="tag">&lt;<span class="name">var</span>&gt;</span>y<span class="tag">&lt;/<span class="name">var</span>&gt;</span> + 2</span><br><span class="line">Save the document by pressing <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> + <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>S<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>http://this<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.is<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.a<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.really<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.long<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.example<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>.com/With<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/deeper<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/level<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>/pages<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The <span class="symbol">&amp;lt;</span>mark<span class="symbol">&amp;gt;</span> element is used to <span class="tag">&lt;<span class="name">mark</span>&gt;</span>highlight<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> text</span><br></pre></td></tr></table></figure><ul><li>嵌入内容</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img 图片</span><br><span class="line">iframe 内联框架</span><br><span class="line">embed 外部交互内容或插件</span><br><span class="line">object 内嵌对象</span><br><span class="line">param 对象的参数</span><br><span class="line">video 视频</span><br><span class="line">audio 音频</span><br><span class="line">source 媒介源</span><br><span class="line">track 媒体播放器中的文本轨道</span><br><span class="line">canvas 图形</span><br><span class="line">svg 矢量图</span><br><span class="line">map 图像映射</span><br><span class="line">area 图像映射内部的区域</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;planets.jpg&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#planetmap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;planetmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;planetmap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;180,139,14&quot;</span> <span class="attr">href</span> =<span class="string">&quot;venus.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Venus&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;129,161,10&quot;</span> <span class="attr">href</span> =<span class="string">&quot;mercur.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Mercury&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;0,0,110,260&quot;</span> <span class="attr">href</span> =<span class="string">&quot;sun.html&quot;</span> <span class="attr">target</span> =<span class="string">&quot;_blank&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Sun&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>img</code> 元素中的 “usemap” 属性引用 <code>map</code> 元素中的 “id” 或 “name” 属性（根据浏览器），所以同时向 <code>map</code> 元素添加了 “id” 和 “name” 属性。</p><ul><li>表格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table 表格</span><br><span class="line">caption 表格标题</span><br><span class="line">thread 表头</span><br><span class="line">tbody 表体</span><br><span class="line">tfoot 表尾</span><br><span class="line">tr 行</span><br><span class="line">th 单元格</span><br><span class="line">td 单元格</span><br></pre></td></tr></table></figure><ul><li>表单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">form 表单</span><br><span class="line">fieldset fieldset 元素可将表单内的相关元素分组</span><br><span class="line">legend fieldset 标题</span><br><span class="line">label 标注</span><br><span class="line">input 文本框</span><br><span class="line">button 按钮</span><br><span class="line">textarea 文本框</span><br><span class="line">select 下拉列表</span><br><span class="line">option 选项</span><br><span class="line">optgroup 选项组合</span><br><span class="line">datalist 定义下拉列表</span><br><span class="line">progress 任务进度</span><br><span class="line">meter 度量</span><br><span class="line">output</span><br></pre></td></tr></table></figure><p>注：<code>progress</code>、<code>meter</code>、<code>details</code>、<code>summary</code>、<code>dialog</code>… 这些 UI 组件元素在各浏览器上 UI 不统一，且 UI 并不一定满足所有人的审美，一般都会自己做这些组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>健康信息<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    身高：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    体重：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span>&gt;</span>3/10<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">&quot;0.6&quot;</span>&gt;</span>60%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;myCar&quot;</span> <span class="attr">list</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;BMW&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Ford&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Volvo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;Swedish Cars&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;German Cars&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;mercedes&quot;</span>&gt;</span>Mercedes<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ol 有序列表</span><br><span class="line">ul 无须列表</span><br><span class="line">dl 定义列表</span><br><span class="line">li 列表项</span><br><span class="line">dt 定义列表中的项目</span><br><span class="line">dd 定义列表中项目的描述</span><br></pre></td></tr></table></figure><ul><li>脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script 客户端脚本</span><br><span class="line">noscript 针对不支持客户端脚本的用户的替代内容</span><br></pre></td></tr></table></figure><ul><li>交互</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">details 定义元素的细节</span><br><span class="line">summary 为 details 元素定义可见的标题</span><br><span class="line">dialog 对话框</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>All pages and graphics on this web site are the property of W3School.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Web Components</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">element</span><br><span class="line">shadow</span><br><span class="line">template</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://www.w3.org/TR/html5/">官方文档</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element">MDN</a>、<a href="https://www.w3.org/TR/html5-diff/">HTML5 Differences from HTML4</a></p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>HTML5 将 HTML 从简单文档标记语言，发展到一个完整的应用程序开发平台。除最基础的标签外，HTML5 还包括用于增强存储、多媒体和硬件访问的 JavaScript APIs。HTML5 之前 HTML 规范由 <a href="https://www.w3.org/wiki/HTML/Specifications">W3C</a> 制定，HTML5 由 <a href="https://html.spec.whatwg.org/">whatwg</a> 制定。</p><p>HTML5 包括的内容有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 语义化结构标签</span><br><span class="line">* 新表单类型</span><br><span class="line">* 新属性：自定义属性 data-xxx，全局属性 placeholder...</span><br><span class="line">* 多媒体</span><br><span class="line">* Canvas</span><br><span class="line">* Web Storage</span><br><span class="line">* Application Cache</span><br><span class="line">* Web Workers</span><br><span class="line">* History API</span><br><span class="line">* User interaction（Drag and drop、document.designMode、contenteditable...）</span><br></pre></td></tr></table></figure><p><a href="https://dom.spec.whatwg.org/">DOM 规范</a>、<a href="https://websockets.spec.whatwg.org/">WebSocket 规范</a>、<a href="https://w3c.github.io/IndexedDB/">IndexedDB 规范</a>、Web SQL 规范（被废弃）、<a href="https://xhr.spec.whatwg.org/">XHR 规范</a>（含 FormData）、<a href="https://www.w3.org/TR/geolocation/">Geolocation 规范</a>、<a href="https://www.w3.org/TR/FileAPI/">FileAPI 规范</a>（Blob&#x2F;File、FileReader）、<a href="https://www.w3.org/TR/MathML3/">MathML 规范</a>、<a href="https://www.w3.org/TR/SVG2">SVG 规范</a>…都是单独制定的，不属于 HTML5 规范，Web API 没有统一的规范。</p><p>注：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN Web API</a> 文档中有说明当前 API 来源于哪个规范。</p><h3 id="标签和属性"><a href="#标签和属性" class="headerlink" title="标签和属性"></a>标签和属性</h3><ul><li>新增的标签、属性和表单类型</li></ul><p>结构化语义标签：<code>header</code>、<code>footer</code>、<code>nav</code>、<code>section</code>、<code>article</code>、<code>aside</code>、<code>figure</code>、<code>figcaption</code>。多媒体标签：<code>video</code>、<code>audio</code>、<code>embed</code>。表单类型：<code>email</code>、<code>url</code>、<code>number</code>、<code>range</code>、<code>Date Pickers(date、month、week、time、datetime、datetime-local)</code>、<code>search</code>、<code>color</code>。其他功能标签：<code>command</code>、<code>progress</code>、<code>time</code>、<code>canvas</code>、<code>details</code>、<code>datalist</code>、<code>dialog</code>、<code>ruby</code>、<code>rt</code>、<code>rp</code>、<code>wbr</code>、<code>keygen</code>、<code>output</code>、<code>mark</code>、<code>meter</code>。全局属性：<code>contenteditable</code>、<code>contextmenu</code>、<code>draggable</code>、<code>dropzone</code>、<code>spellcheck</code>、<code>hidden</code>、<code>data-*</code></p><ul><li>废除的标签和属性</li></ul><p>废除的标签：可用 CSS 代替纯表现的标签 <code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、<code>strike</code>、<code>tt</code>，不再使用 frame（包括 <code>frame</code>、<code>noframes</code>、<code>frameset</code>，但 <code>iframe</code> 还可继续使用），<code>acronym</code>（用 <code>abbr</code> 代替）、<code>applet</code>（用 <code>object</code> 代替）、<code>dir</code>（用 <code>ul</code> 代替）。废除的属性：<code>align</code>、<code>bgcolor</code>、<code>height</code>、<code>width</code>、<code>valign</code>、<code>hspace</code>、<code>vspace</code>、body 标签上的 <code>link</code>、<code>vlink</code>、<code>align</code>、<code>text</code>、iframe 元素上的 <code>scrolling</code>、table 上的 <code>cellpadding</code>、<code>cellspacing</code>、<code>border</code>。</p><p>注意：上述标签和属性由于语义或者性能上原因被废除，这只是在规范上被废除（不建议使用），但不代表 parser 不能正确解析，现代浏览器 HTML5 规范下的 Parser 非常包容（兼容所有的 HTML4 和 XHTML），要不然含有这些标签的 XHTML&#x2F;HTML4 代码，无法在 HTML5 Parser 下运行。</p><h3 id="结构化语义标签兼容处理"><a href="#结构化语义标签兼容处理" class="headerlink" title="结构化语义标签兼容处理"></a>结构化语义标签兼容处理</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>, <span class="selector-tag">aside</span>, <span class="selector-tag">details</span>, <span class="selector-tag">figcaption</span>, <span class="selector-tag">figure</span>, <span class="selector-tag">footer</span>, <span class="selector-tag">header</span>, <span class="selector-tag">hgroup</span>, <span class="selector-tag">nav</span>, <span class="selector-tag">section</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br><span class="line"><span class="selector-tag">mark</span> &#123;<span class="attribute">background</span>: <span class="number">#ff0</span>; <span class="attribute">color</span>: <span class="number">#000</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> elements = <span class="string">&#x27;article,aside,details,figcaption,figure,footer,header,hgroup,nav,section,mark&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> i = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">while</span>(i &lt; elements.<span class="property">length</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(elements[i]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  i ++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt; </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span>(!<span class="comment">/*@cc_on!@*/</span><span class="number">0</span>) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> e = <span class="string">&quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;</span>.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> i= e.<span class="property">length</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">while</span> (i--) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">createElement</span>(e[i]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)() </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="string">&#x27;section header nav aside article footer figure figcaption&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\w+/g</span>, <span class="keyword">function</span>(<span class="params">n</span>) &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">createElement</span>(n);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[<span class="keyword">if</span> lt <span class="variable constant_">IE</span> <span class="number">9</span>]&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br><span class="line">![endif]--&gt;</span><br></pre></td></tr></table></figure><p>注：上面 JS 代码必须添加在页面的 head 标签内，因为 IE 浏览器必须在元素解析前知道这个元素。</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
