<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/08/03/Axios/"/>
      <url>/2022/08/03/Axios/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Axios</p><ul><li>params</li></ul><p>config 中 params 字段是与请求一起发送的 URL 参数，支持对象或 URLSearchParams 对象，Axios 会自动序列化为 QueryString，不需要手动序列化 <code>new URLSearchParams(param).toString()</code>，对于 Get 请求，就可直接传 JSON 格式参数，Axios 会处理成 QueryString。</p><p>支持 get 参数的序列化，不需要自己手动序列化，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function getTemplateList(query) &#123;</span><br><span class="line">  return axios.get(&apos;/ces/perf/tpl&apos;, &#123;</span><br><span class="line">    params: query,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>responseType 一般默认设为 JSON，因为服务端大部分情况下返回的数据都是 JSON，如果需要（比如文件或者文本格式）也可在单个请求中设置返回数据的格式。</p><p>export function getFileCover(path) {<br>return axios.get(<code>/file/cover?path=${path}</code>, {<br>responseType: ‘text’,<br>});<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exportClazzReport(examId, clazzId) &#123;</span><br><span class="line">  return axios.get(`/goals/$&#123;examId&#125;/clazz/$&#123;clazzId&#125;/export`, &#123;</span><br><span class="line">    responseType: &apos;blob&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, // 请求头不用吧</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>paramsSerializer</li></ul><p>URL 传数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cateIds=1&amp;cateIds=2</span><br><span class="line">quizIds[]=x&amp;quizIds[]=x</span><br></pre></td></tr></table></figure><p>自定义 axios 序列化即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getCourseList(query) &#123;</span><br><span class="line">  return axios.get(&apos;/mall/shop/courses&apos;, &#123;</span><br><span class="line">    params: query,</span><br><span class="line">    paramsSerializer(params) &#123;</span><br><span class="line">      return qs.stringify(params, &#123; arrayFormat: &apos;repeat&apos; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>也可直接作为默认序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Axios = axios.create(&#123;</span><br><span class="line">  timeout: 60000,</span><br><span class="line">  responseType: &apos;json&apos;,</span><br><span class="line">  withCredentials: false,</span><br><span class="line">  paramsSerializer(params) &#123;</span><br><span class="line">    return Qs.stringify(params, &#123; arrayFormat: &apos;repeat&apos; &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function getReply(userId, quizIds) &#123;</span><br><span class="line">  const quizIdsQueryParams = quizIds.map(item =&gt; `$&#123;encodeURIComponent(&apos;quizIds[]&apos;)&#125;=$&#123;item&#125;`).join(&apos;&amp;&apos;);</span><br><span class="line">  return axios.get(`/live/quiz/user/reply?userId=$&#123;userId&#125;&amp;$&#123;quizIdsQueryParams&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://meiyike.cn/api/user/pfm/affiches/current" target="_blank" rel="noopener">https://meiyike.cn/api/user/pfm/affiches/current</a> site 是不是这个接口 redirect 的？？</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数参数的求值策略</title>
      <link href="/2022/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
      <url>/2022/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>函数参数的<a href="https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085" target="_blank" rel="noopener">求值策略 Evaluation Strategy</a> 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。</p><a id="more"></a><p>按值传递（pass by value）是指在调用函数时将实参复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实参。</p><p>引用传递（pass by reference）是指在调用函数时将实参的地址直接传递到函数中，在函数中对参数所进行的修改，将影响到实参。</p><p>按值传递传递的是原始值的复制，或内存地址值的复制（比如 JS 中的共享传递，C/C++ 中的指针传递）。按引用传递传递的是内存地址（不是内存地址值）。</p><h2 id="JavaScript-中参数的求值策略"><a href="#JavaScript-中参数的求值策略" class="headerlink" title="JavaScript 中参数的求值策略"></a>JavaScript 中参数的求值策略</h2><p>Javascript 中函数参数求值策略是按值传递。无论是值类型还是引用类型，都会在栈上创建副本（拷贝、复制），不同是，对于值类型而言，这个副本就是整个原始值的复制，对于引用类型，由于引用类型的实例在堆中，在栈上只有它的一个地址引用值，其副本也只是这个引用值的复制，而不是整个原始对象的复制，这种策略也被称为按共享传递（传递的是地址值，可通过引用来修改原始对象的属性，重新赋值则会断开对原始对象的引用，不影响原始对象），类似于 C 中的指针传递。按共享传递是按值传递的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">num, obj</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  obj.value = <span class="string">'hello'</span>; <span class="comment">// 只是引用类型的副作用，不能证明是引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = new Object(); // 断开了对 greeting 的引用</span></span><br><span class="line">  <span class="comment">// obj.value = 'world'; // 如果是引用传递，改变形参 obj 的属性 value，也会反映在 greeting 变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = &#123;</span><br><span class="line">  value: <span class="string">'hello world'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">change(a, greeting);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面例子的内存模型图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">a 10               |</span><br><span class="line">greeting 0x01 ---&gt; |  0x01 hello world</span><br><span class="line">num 10             |  </span><br><span class="line">obj 0x01      ---&gt; |</span><br></pre></td></tr></table></figure><p>如果是按引用传递，直接传递第二格的内容即可，不需要有第四格。</p><h2 id="其他语言中参数的求值策略"><a href="#其他语言中参数的求值策略" class="headerlink" title="其他语言中参数的求值策略"></a>其他语言中参数的求值策略</h2><p>Java 中参数求值策略与 JavaScript 一样，都是按值传递（含共享传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByValue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    Greeting greeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">    TestByValue testByValue = <span class="keyword">new</span> TestByValue();</span><br><span class="line">    testByValue.change(a, greeting);</span><br><span class="line">    System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(greeting.value); <span class="comment">// hello</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num, Greeting greeting)</span> </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    greeting.value = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="comment">// greeting = new Greeting(); // 断开了对 greeting 的引用</span></span><br><span class="line">    <span class="comment">// greeting.value = "world";</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  String value = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 编译</span><br><span class="line">javac TestByValue.java </span><br><span class="line"><span class="meta">#</span> 运行</span><br><span class="line">java TestByValue</span><br></pre></td></tr></table></figure><p>PHP 既支持值传递又支持引用传递，通过 &amp; 运算符（取址运算符）实现引用传递。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">(&amp;$num)</span> </span>&#123;</span><br><span class="line">  $num = $num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> $a; <span class="comment">// 输出１</span></span><br><span class="line">change($a);</span><br><span class="line"><span class="keyword">echo</span> $a; <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure><p>C/C++ 支持值传递（含指针传递）， 另外 C++ 还支持引用传递，通过 &amp; 取址运算符实现引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> &amp;num2, <span class="keyword">int</span> *num3)</span> </span>&#123;</span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  num2 = <span class="number">22</span>;</span><br><span class="line">  *num3 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num4 = 2;</span></span><br><span class="line">  <span class="comment">// num3 = &amp;num4; // 对指针变量赋值，会断开原先的引用，不会影响外面</span></span><br><span class="line">  <span class="comment">// printf("%p\n", num3); // 外面的 c 还是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">  change(a, b, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 1，值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 22，引用传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 33 或 3，指针传递</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码需使用 <code>gcc test.cpp -lstdc++ -o test</code> 作为 C++ 编译，不能使用 <code>gcc -o test test.c</code> 作为 C 编译，C 没有按引用传递，都是按值传递，通过指针传递也可实现引用传递的效果，要想通过 C 编译，需删除引用传递。</p><p>其内存图如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 1</span><br><span class="line">b/num2 2 </span><br><span class="line">c [0x7ff7b2c49920] 3</span><br><span class="line">num1 1</span><br><span class="line">num3 [0x7ff7b2c498f8] 0x7ff7b2c49920</span><br></pre></td></tr></table></figure><p>num1 的内容是复制于 a 的原值，num2 是 b 的别名，num3 的内容是 c 的地址值，*num3 指向 c 的内容。</p><p>指针传递本质上也是值传递的方式，它所传递的是一个地址值，与 JavaScript 中的共享传递一样。C/C++ 中通过 * 指针运算符实现指针传递。</p><p>作为指针类型数据本身，其既可使用指针传递又可使用引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> *&amp;p)</span> </span>&#123; <span class="comment">// int *&amp;p 表示 p 是一个整型指针的别名，int *p 则会重新分配内存，创建新指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line">change(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算子的求值策略"><a href="#算子的求值策略" class="headerlink" title="算子的求值策略"></a>算子的求值策略</h3><p>求值策略不但规定了函数参数的求值规则，也规定了算子的求值规则，比如赋值表达式中的 <code>=</code> 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num1 = a; <span class="comment">// 值传递</span></span><br><span class="line">  <span class="keyword">int</span> *num2; <span class="comment">// 值传递中的指针传递</span></span><br><span class="line">  num2 = &amp;b;</span><br><span class="line">  <span class="keyword">int</span> &amp;num3 = c; <span class="comment">// 引用传递</span></span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  *num2 = <span class="number">22</span>;</span><br><span class="line">  num3 = <span class="number">33</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 33</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> num = a;</span><br><span class="line"><span class="keyword">const</span> obj = b; <span class="comment">// 值传递中的共享传递</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程范式</title>
      <link href="/2022/04/15/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
      <url>/2022/04/15/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>正交（orthogonal）</p><p>React的设计贯彻了声明式编程</p><p>编程范式：programming paradigm</p><p>命令式（Imperative），声明式（declarative programming）），这两个是对立的。</p><p>面向过程，面向对象（Object-oriented Programming 简称 OOP），函数式（functional programming 简称 FP）</p><a id="more"></a><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程范式，与命令式编程相对立。</p><p>它描述目标的性质，让计算机明白目标，而非流程。声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。而命令式编程则需要用算法来明确的指出每一步该怎么做。</p><p>在计算机科学中，声明性编程是一种编程范式，它表达了计算的逻辑而没有描述其控制流程。</p><p>来自<a href="http://en.wikipedia.org/wiki/Declarative_programming" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Declarative_programming</a></p><p>简而言之，声明性语言更简单，因为它缺乏控制流的复杂性（循环，if语句等）。</p><p>函数式编程是声明式编程的一部分</p><p><a href="https://www.zhihu.com/question/28292740/answer/40336090" target="_blank" rel="noopener">https://www.zhihu.com/question/28292740/answer/40336090</a><br><a href="https://www.zhihu.com/question/19732025" target="_blank" rel="noopener">https://www.zhihu.com/question/19732025</a><br><a href="https://zhuanlan.zhihu.com/p/85491177" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85491177</a></p><ul><li>FP</li></ul><p>不是有个 map，reduce 函数就是函数式编程。<br>不可变数据结构有么，柯里化支持吗，函数缓存有吗，隔离副作用有吗，方法可以被当成参数传递吗，尾递归优化有吗，模式匹配、函数参数收集有吗。<br>如果都没有，或者只支持其中一两个，叫个锤子的函数式编程</p><p>只能说map, reduce算是目前被大多数语言吸纳得比较广泛的FP特征</p><ul><li>OOP 与 FP 的区别</li></ul><p>OOP 和 FP 最大的区别可能是 OOP 将对象视作一等公民，而 FP 将函数视作一等公民。</p><p>但除此之外，很难说 OOP 和 FP 有什么冲突的地方，没人告诉你用了 OOP 就不能用 map、filter、reduce，<br>更何况许多编程语言同时有 OOP 和 FP 两种编程范式的特征，想写成什么样完全看心情。<br>任何允许将函数作为参数传入的语言都可以写高阶函数，任何语言也都可以写出没有副作用的函数。你要是乐意，也可以把所有循环改写成递归。</p><p>编程范式的出现是为了减少程序员的思维负担，写出适合人类理解的语言。你可以在面向对象的代码应该加入一点map, reduce来方便理解，也可以在函数式的代码里加入一些class来简化命名。如果把编程范式之间的争论变成圣战，好像用什么编程范式就得严格遵循其规则，比如用FP就从不写循环，那未免也太过分了。</p><p>目前按照我的理解，面向对象最大的问题就是其概念已经过于臃肿了。使用面向对象，你需要尝试去理解GoF的23种设计模式，去理解继承和多态，去分辨各种各样概念之间的区别还要避免误区。面向对象还搞出了UML，尝试用没人能背下来全部规则的各类图去表示各种复杂的继承关系。UML用来打个草稿或许还是个不错的工具，但还有人走火入魔要用UML生成代码，这就显得离奇了。想要掌握面向对象，你不得不与概念的海洋斗争，然后读完十几本相关领域书籍，发现自己仍旧什么也不会。</p><p>学习面向对象最幸福的时刻是当你第一次理解了什么是类，什么是继承与多态，并成功用它让自己糊成一团的过程式代码变得简单而清晰。可惜的是你并不满足于这些，你往上套了越来越多的继承，对多态的使用越来越肆无忌惮，你很快发现自己的代码又糊成了一团。</p><p>但面向对象的代码至少比起面向过程的代码可读性高了太多，并且它的结构性很强——这使得烂程序员不至于写出太烂的代码。这就是为什么还有这么多公司用Java——它是完全面向对象的，而这很大程度上保证了程序员写出了差不多的代码。面向对象的各种概念与限制使编程不那么自由，但这正是很多大型项目需要的——它不需要所有的程序员都有极高的素养，任何并不太烂的程序员都能做出一定的贡献并且不会对代码产生毁灭性的影响。Java写出的代码也许很烂，但不至于烂到无法接受。</p><p>函数式编程是不同的。它有很多概念，这些概念或许不容易理解，但它们都很扁平，至少你在学习时不会产生学习面向对象概念时那种混乱与层层嵌套的感觉。FP不需要设计模式，不需要类图，也不需要继承和多态，当你理解了函数式编程的基本概念后你可以立刻投入工作。FP很自由，你不用被各种条条框框约束也可以写出清晰的代码。但有些人理解递归尚且十分吃力，你如何让他们轻而易举地去理解高阶函数的运算？更何况FP根本不能让人写出差不多的代码，编程素养并不算高的程序员凑在一起写出的FP大型项目肯定没法看。</p><p>OOP和FP本质上都是思维模式，只是OOP更符合直觉。即使C完全不支持OOP，也可以用各种方式写出OOP的代码，而FP的思维方式更是可以用在各种语言里。</p><p>有一个很普遍的误解： 就是函数式编程和面向对象编程是对立的，其实不然这两者是正交的（不相关，没有关系，不冲突）。<br>函数式编程的函数是指数学上的函数（不是指用函数来编程）：给定输入固定的输出，没有副作用。任何语言都可以用函数式的风格，只是难易不同罢了。很多语言都支持这两种风格的编程: 比如OCaml 和 JavaScript.举一个大家熟悉的JavaScript 的例子，来自Facebook的 ImmutableJSvar Immutable = require(‘immutable’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);</span><br><span class="line">var map2 = map1.set(&apos;b&apos;, 50);</span><br><span class="line">map1.get(&apos;b&apos;); // 2</span><br><span class="line">map2.get(&apos;b&apos;); // 50</span><br></pre></td></tr></table></figure><p>可以看到其实现是函数式的: 添加对象 不会修改原来的map 但是接口是面向对象的接口</p><p>CSS 的属性互不正交，大量的依赖与耦合难以记忆。</p><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>Reactive Programming</p><p><a href="https://zhuanlan.zhihu.com/p/104024245" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104024245</a><br><a href="https://www.jianshu.com/p/36d85f8cafdd" target="_blank" rel="noopener">https://www.jianshu.com/p/36d85f8cafdd</a><br><a href="https://blog.csdn.net/weixin_39939012/article/details/82784432" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39939012/article/details/82784432</a><br><a href="https://zhuanlan.zhihu.com/p/240287653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/240287653</a></p><p><a href="http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf" target="_blank" rel="noopener">http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf</a></p><p>Reactive Extensions (Rx)</p><p>ReactiveX</p><p>Java: RxJava<br>JavaScript: RxJS<br>C#: Rx.NET<br>C#(Unity): UniRx<br>Scala: RxScala<br>Clojure: RxClojure<br>C++: RxCpp<br>Lua: RxLua<br>Ruby: Rx.rb<br>Python: RxPY<br>Groovy: RxGroovy<br>JRuby: RxJRuby<br>Kotlin: RxKotlin<br>Swift: RxSwift<br>PHP: RxPHP</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> pl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/04/01/TypeScript/"/>
      <url>/2022/04/01/TypeScript/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>类型标注/注解：变量、函数、对象、类的类型（有些类型可通过类型推断出来，不用手动标注）</p><p>静态类型的好处：</p><a id="more"></a><ul><li>编译时类型检测（let fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push(‘8’);）</li></ul><p>可防止开发中的一些语法错误</p><ul><li>接口提示、代码补全</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">    for (let id in source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>作为 JS 的超集，TS 支持所有的 JS 数据类型，并新增了几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Built-in types: void、any、never</span><br><span class="line">User-defined types: enum、tuple、interface、class、array</span><br></pre></td></tr></table></figure><p>在 TS 中，string 和 String 是不同的两种类型，前者是原始类型，后者是对象类型</p><p>(window as any).foo = 1;</p><p>(window as any).foo</p><p>// 声明全局变量的”类型“</p><p>// 什么要字面量</p><p>// 枚举名和枚举值是相互映射的</p><p>// 类型断言、声明文件、枚举</p><p>declare enum Directions {<br>Up,<br>Down,<br>Left,<br>Right<br>}</p><p><t>source 就是 source as T，把 source 断言成 T 类型</t></p><p>function createArray<t>(length: number, value: T): Array<t>{<br>let result: T[] = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}</t></t></p><p>createArray<string>(3, ‘x’); // [‘x’, ‘x’, ‘x’]</string></p><p>第一个 T 是形参，后面的是使用 T</p><p>函数类型不写，也可被推导出来<br>interface SearchFunc {<br>(source: string, subString: string): boolean;<br>}</p><p>let mySearch: SearchFunc;<br>mySearch = function(source: string, subString: string) {<br>return source.search(subString) !== -1;<br>}</p><p>泛型函数、泛型接口、泛型类<br>声明全局变量的”类型“<br>什么要字面量<br>枚举名和枚举值是相互映射的</p><p>// 类型断言、声明文件、枚举、泛型</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>TypeScript 能进行类型检测，对于代码风格的检查则需要用到 ESlint。</p><p>TypeScript 和 ESlint 没有可比性，一个是语言，一个是代码检测工具，要比也是 TSlint。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/03/24/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2022/03/24/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>前端优化（提高网页的加载速度）</p><p>1、使用css sprites，可以有效的减少http请求数<br>2、使用缓存<br>3、压缩js，css文件，减小文件体积<br>4、使用cdn，减小服务器负担<br>5、懒加载图片<br>6、预加载css，js文件<br>7、避免dom结构的深层次嵌套<br>8、给DOM元素添加样式时，把样式放到类中，直接给元素添加类，减少重构，回流</p><p>更多详细的前端优化请看前端优化：雅虎35条或者前端性能优化—-yahoo前端性能团队总结的35条黄金定律</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Scratch 入门</title>
      <link href="/2022/03/02/Scratch/"/>
      <url>/2022/03/02/Scratch/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/weixin_43405101/article/details/102314032" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43405101/article/details/102314032</a></p><p>角色的中心点（中心点是针对角色的，每个角色都有中心点，跟位置不同，中心点一般用来描述运动的基点）和角色的位置</p><p>调整造型中心点也能改变角色在舞台中的位置</p><p><a href="https://www.jbhdq.com/jiaocheng/tuwen/45555.html" target="_blank" rel="noopener">https://www.jbhdq.com/jiaocheng/tuwen/45555.html</a></p><p><a href="https://www.huihua8.com/a/jbhjc/237634.html" target="_blank" rel="noopener">https://www.huihua8.com/a/jbhjc/237634.html</a></p><p>小绿旗子是运行（运行程序）</p><p>对角色或舞台进行编程，脚本必须在角色或舞台下</p><p>脚本可不可以应用到多个角色，对多个角色进行编程</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> scratch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化</title>
      <link href="/2022/02/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>/2022/02/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>如果一门原生语言的抽象能力不足（比如，CSS 的表达能力不足，JS 没有类型），我们可以再抽象设计一层，比如 Sass、TypsScript<br>经过编译，再将源码编译为供实际环境执行可原生代码。</p><p>只能维护源代码。</p><a id="more"></a><p>Web 工程化</p><p><a href="https://www.zhihu.com/question/433854153" target="_blank" rel="noopener">https://www.zhihu.com/question/433854153</a><br><a href="https://www.zhihu.com/question/24558375" target="_blank" rel="noopener">https://www.zhihu.com/question/24558375</a><br><a href="https://zhuanlan.zhihu.com/p/359734011" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/359734011</a></p><p>从 Browserify + Gulp 到 Parcel，从 Webpack 到 Rollup，Vite，工程化工具琳琅满目。但很多工具的实现和设计非常复杂，甚至出现了「面向 webpack 编程」的调侃。</p><p>工程化：</p><p>静态资源(JS/Sass/Less/HTML/Image/SVG/Font/CSS/JSX/TS/Vue SFC…)的检查<br>模块加载、编译、压缩、合并、打包（顾名思义）<br>浏览器自动刷新、文件监听</p><p>Node 催生了一批自动化构建工具，像 Bower，Yeoman，Grunt 等（类似于 Java 世界中的Ant或者Maven），他们都是构建在 Nodejs 之上。</p><p>自动化是工程化的特点，模块化是工程化的功能之一。</p><p>前端自动化构建（build）工具</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>前端工程化中，常见的任务有图片压缩和 Sprite 生成，CSS 压缩，Sass、Coffee、ES6、TS、JSX、Template… 编译，JS Module Loader 和 Minify Uglify，代码 Lint，文件替换监听和版本管理，自动刷新，测试、部署…。在早期，需要手工一步步处理这些任务，Gulp 的出现就是为了将这一系列任务流程自动化。</p><p>Gulp 是 Task Runner（任务执行器），通过执行一些列由 Plugin 定义的任务，来处理完成自动化。常见的 Plugins 有：gulp-webpack、gulp-css、gulp-babel 等。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是 Module Bundler（模块打包器）。</p><p>webpack 默认支持xxx</p><p>webpack 中一切皆模块，把所有的文件(css, image, js) 都用 js 来生成依赖，最后生成一个 bundle，所以 webpack 也叫做file bundler</p><ul><li>与 RequireJS Gulp 区别</li></ul><p><a href="https://survivejs.com/webpack/appendices/comparison/" target="_blank" rel="noopener">https://survivejs.com/webpack/appendices/comparison/</a></p><p>Webpack 和 RquireJS 都是模块解决方案，不同的是 RequireJS 只是一个运行时的 JavaScript Module（AMD） Loader，而 Webpack 则是 Module Bundler，不单单只进行模块加载，还会对模块进行处理（编译、压缩合并…），而且不止支持 JavaScript 模块。</p><p>Gulp 是 Task Runner，需要具体的 Plugin 才能实现 Task，比如模块加载要 gulp-browserify 或 gulp-webpack，SASS 编译要 gulp-sass…，而 Webpack 则是 Module Bundler，Module Bundler 只是众多前端工程化任务中之一。</p><p>通过 Webpack 提供的 Loader 和 Plugin 扩展，在模块打包时能实现诸如 compile、 minify、uglify… 等一系列功能，再结合 NPM Script，使得 Webpack 彻底的代替 了 Gulp。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/24/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
      <url>/2022/01/24/%E8%BD%AF%E9%94%AE%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/focusout_event" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/focusout_event</a><br><a href="https://www.cnblogs.com/ralapgao/p/10815237.html" target="_blank" rel="noopener">https://www.cnblogs.com/ralapgao/p/10815237.html</a></p><p><a href="https://www.jianshu.com/p/3d590c84e284" target="_blank" rel="noopener">https://www.jianshu.com/p/3d590c84e284</a></p><p>ios 原生的 webview 在软件盘弹起时窗口会缩小（微信 x5 特殊处理过），而 android 下窗口会顶上去</p><p>如果用到了 vh 这样的单位，在软件盘弹起时会导致页面变形，还需特殊处理，focusout 时重新计算</p><p>这个地方的是不是在进来设置一次就行了，不处理软件盘弹起来回设置？，如果要需要来回设置，ios 有不支持 resize，用 focusout 和 focusin 啊</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/24/%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/01/24/%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>场景经验</p><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul><li>登录</li></ul><p>登录，会话保持、刷新、过期处理</p><ul><li>ajax</li></ul><p>请求拦截和响应拦截</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/01/22/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>/2022/01/22/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://www.secpulse.com/archives/63801.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/63801.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a href="https://blog.csdn.net/qq_28773159/article/details/104834167" target="_blank" rel="noopener">https://blog.csdn.net/qq_28773159/article/details/104834167</a><br><a href="https://www.zhihu.com/question/20138568" target="_blank" rel="noopener">https://www.zhihu.com/question/20138568</a><br><a href="https://www.cnblogs.com/wuyongyin/archive/2021/06/12/14817142.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyongyin/archive/2021/06/12/14817142.html</a><br><a href="https://blog.csdn.net/weixin_42394911/article/details/119895911" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42394911/article/details/119895911</a></p><p>同源策略</p><p>同源策略（Same-origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，它用于限制一个源加载的文档或脚本如何与另一个源加载的资源进行交互。如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 的攻击。</p><ul><li>同源</li></ul><p>所谓同源是指”协议（protocol） + 域名（host） + 端口（port）”三者相同。</p><ul><li>源的继承</li></ul><p>在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源。</p><ul><li>源的更改</li></ul><p>满足某些限制条件的情况下，页面可以通过 document.domain 来修改源（修改为当前域或其当前域的父域）。可用来处理 iframe 跨子域问题。</p><p>浏览器会根据同源策略允许或拒绝请求某些资源</p><p>页面跨域的行为主要会分为三类，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cross-origin embedding 跨域资源嵌入</span><br><span class="line">Cross-origin writes 跨域写操作</span><br><span class="line">Cross-origin reads 跨域读操作</span><br></pre></td></tr></table></figure><p>跨域资源嵌入，比如 script、link、image、video、audio、object、embed、applet、iframe、@font-face（也有浏览器不允许跨域字体）。这些请求都不带 cookie，所以是安全的。<br>跨域写操作，比如 links，重定向以及 form 表单提交。<br>跨域读操作，比如 BOM（DOM，cookie，localStorage，indexDB）、资源（Ajax，drawImage）。</p><p>在这三种行为之中，通常情况下只有 Cross-origin read 是不被允许跨域的，其余的两种是允许的。</p><p>跨域的几种形式：跨主域、跨子域、跨端口、跨协议</p><h3 id="禁止跨域"><a href="#禁止跨域" class="headerlink" title="禁止跨域"></a>禁止跨域</h3><p>其实跨域请求本身并没有任何的安全隐患， 有安全隐患的是请求 X 网站的时候会顺便带上 X 网站的 cookie</p><p>Ajax 的同源策略主要用来防止 CSRF 攻击的，<br>BOM 的同源策略第一是为了防止父或子页面内容被串改，最重要的还是安全。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS (跨源资源共享) 要服务器和浏览器同时支</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h3 id="反代"><a href="#反代" class="headerlink" title="反代"></a>反代</h3><p>proxy</p><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>用来解决 iframe 跨子域时的 BOM 访问。</p><p>利用 document.domain 实现跨域，前提条件是这两个域名必须属于同一个基础域名，而且所用的协议，端口都要一致。</p><p>否则任何域名的子级域名地址都可以对父级发起xss攻击。</p><p>只有父子级都通过显示得设置 document.domain 才能达到跨域访问资源的目的。</p><p><a href="https://juejin.cn/post/6844903767226351623" target="_blank" rel="noopener">https://juejin.cn/post/6844903767226351623</a></p><p><a href="https://blog.csdn.net/nlznlz/article/details/79506655" target="_blank" rel="noopener">https://blog.csdn.net/nlznlz/article/details/79506655</a></p><p><a href="https://www.chromestatus.com/feature/5428079583297536" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5428079583297536</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/domain" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Document/domain</a></p><p><a href="https://juejin.cn/post/6844904135569965064" target="_blank" rel="noopener">https://juejin.cn/post/6844904135569965064</a></p><p><a href="https://mp.weixin.qq.com/s/tE2anhs0bZJv-9IWoFSphw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tE2anhs0bZJv-9IWoFSphw</a></p><p>注：某一页面的 domain 默认等于 window.location.hostname。</p><h3 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h3><p>用来解决 iframe 跨域时数据通信。</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/12/27/UI-Design-Specification/"/>
      <url>/2021/12/27/UI-Design-Specification/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>UI 设计规范。</p><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><ul><li>颜色</li><li>文字：字体、字号、行高</li><li>icon</li></ul><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件化是标准化中最重要的部分，组件化的目的是复用。表单、表格、分页、弹框…是 GUI 软件最基本组成，UI 容易组件化，特别是风格比较固定的后台系统，而前台由于展示的多样性，前台一般都不太容易完全组件化</p><ul><li>表单</li></ul><p>表单验证：对表单各字段进行验证(必填、类型[数值型]、格式[密码、手机号、邮箱])，是前后端都要做的，前端做的目的是为了更好的交互，而后端做的目的是为了保证数据安全</p><p>输入限制：现有的 type 不但受浏览器的实现，而且不好用，比如 type=”number” 不能限制整数、正整数的需求</p><ul><li>表格</li></ul><p>合并单元格，多级表头，斜线表头，固定行和列</p><ul><li>图片</li></ul><p>缺省：onerror 处理缺省图片时，需要卸载 error 来处理缺省图片 404 时引起的死循环，但 error 不太好卸载，所以最好的解决方案是用 new Img</p><p>图片预览</p><p>轮播</p><p>压缩和EXIF 信息处理</p><ul><li>弹框</li></ul><p>原生、vue visible.sync</p><ul><li>图表</li></ul><p>维度、指标</p><ul><li><p>树</p></li><li><p>分页</p></li></ul><p>移动端分页，pc 分页，点击加载更多<br>pageSize、curPage、total<br>列表项的删除</p><ul><li>面包屑</li></ul><p>面包屑用来表示当前页面或页面中资源的路径（比如页面层级，资源查询参数层级），描述页面或资源的位置</p><!-- rebuild by neat -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PWA</title>
      <link href="/2021/12/01/PWA/"/>
      <url>/2021/12/01/PWA/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Web App Manifest<br>Service Worker<br>…</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 类型系统</title>
      <link href="/2021/07/26/JavaScript-Type-System/"/>
      <url>/2021/07/26/JavaScript-Type-System/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>类型动静态（静态类型检测），类型强弱（类型转换）。</p><p>JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo = 42; // foo is now a number</span><br><span class="line">foo = &apos;hello&apos;; // foo is now a string</span><br><span class="line">foo = true;  // foo is now a boolean</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 + &apos;&apos;;</span><br><span class="line">!!1; // 这个算隐式还是显式</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的概念：xxxx。与数据结构的关系。</p><p>JavaScript 中一共有 8 种内置（Built-In）数据类型：</p><h3 id="原始类型（Primitive-types）"><a href="#原始类型（Primitive-types）" class="headerlink" title="原始类型（Primitive types）"></a>原始类型（Primitive types）</h3><p>原始类型也被称为基本类型，表示不能再细分下去的类型，具有原子性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* string: 一串表示文本值的字符序列</span><br><span class="line">* number: 整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）</span><br><span class="line">* boolean: 包含两个值 true 和 false</span><br><span class="line">* null: 只包含一个值 null</span><br><span class="line">* undefined: 只包含一个值 undefined</span><br><span class="line">* symbol: 一种实例是唯一且不可改变的数据类型</span><br><span class="line">* bigInt</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于这些类型被存储在栈内存中，也被称为值类型。</p><p>todo… 这里应该有内存图</p><p>又由于这些类型的值是不可变的，又被称为不可变类型。</p><p>原始类型是不可变的，没有任何方法可以直接改变其值，只会生成新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &apos;hello&apos;;</span><br><span class="line">foo.substr(1);</span><br><span class="line">foo.toLowerCase(1);</span><br><span class="line">foo[0] = 1;</span><br><span class="line">console.log(foo);  // hello</span><br><span class="line"></span><br><span class="line">// 栈内存原始空间中的值并没有改变，只是开辟了一块新空间，将变量名指向新的空间</span><br><span class="line">foo += &apos;world&apos;;</span><br><span class="line">console.log(foo); // hello world</span><br></pre></td></tr></table></figure><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* object</span><br></pre></td></tr></table></figure><p>声明一个对象通常有以下几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;; // 字面量形式，推荐</span><br><span class="line">const foo = new Object(); // new 调用</span><br><span class="line">const foo = Object(); // 与 new 调用相同</span><br><span class="line">cosnt foo = Object.create(null); // 空对象</span><br></pre></td></tr></table></figure><p>由于 <code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>… 这些对象都是 <code>Object</code> 对象的子类，所以全部归类为 object 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.__proto__ === Object.prototype; // true</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于对象类型被存储在堆内存中，也被称为引用类型。</p><p>todo… 这里应该有内存图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &apos;hello&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">const bar = foo;</span><br><span class="line">foo.msg = &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">const bar = foo;</span><br><span class="line">foo[foo.length] = foo.length + 1;</span><br></pre></td></tr></table></figure><p>又由于值是可变的，又被称为可变类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &apos;hello&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.msg = &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">foo.push(4);</span><br><span class="line">foo.length = 0;</span><br></pre></td></tr></table></figure><ul><li>包装对象</li></ul><p>string、number、boolean 这三种原始类型值在引用属性和方法时，会通过调用 new String()、new Number() 和 new Boolean() 的方式自动转换成对象，也就是原始类型的“包装对象（Wapper object）”，一旦引用结束，便会销毁这个临时的包装对象。</p><p>不是所有的原始类型都有包装对象，null 和 undefined 就没有包装对象，访问它们的属性会报类型错误。</p><p>“JavaScript 中一切皆是对象”这是一个错误的论断，原始类型的 string、number、boolean 会转化为对应的包装对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof &apos;seymoe&apos;; // &apos;string&apos;</span><br><span class="line">typeof new String(&apos;seymoe&apos;); // &apos;object&apos;</span><br><span class="line">typeof String(&apos;seymoe&apos;); // &apos;string&apos;</span><br></pre></td></tr></table></figure><p>注：Number、String 和 Boolean 如果不作为构造函数调用（即调用时不加 new），常常用于将任意类型的值转为数值、字符串和布尔值。</p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符被用来检测数据的类型，其返回一个表示数据类型的字符串，它能检测除 <code>null</code> 和值为 <code>function</code> 的 <code>object</code> 类型外的所有类型。</p><p>null 由于历史设计失误，typeof 返回了 object（如果从类 Java 语言的角度理解），而 function 由于很特殊（构造函数）typeof 特殊处理返回了 function，</p><p>typeof 不能检测除 function 外的 object 子类型，如果想要检测子类型，则需要使用 instanceof 或 Object.prototype.toString 方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br><span class="line">(&#123;&#125;) instanceof Object // true</span><br><span class="line">(()=&gt;&#123;&#125;) instanceof Function // true</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 用来检测类型有缺陷，首先它会检测整个原型链，另外，它不能在 iframe 中跨页面检测，因为不在同一个 <code>window</code> 对象下，原型链无法关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Object; // true</span><br></pre></td></tr></table></figure><p><code>[].__proto__ === Array.prototype</code>，而又 <code>Array</code> 属于 <code>Object</code> 子类型，即 <code>Array.prototype.__proto__ === Object.prototype</code>，最终 <code>[].__proto__.__proto__ === Object.prototype</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">window.frames[0].foo(arr);</span><br><span class="line"></span><br><span class="line">// iframe</span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(data instanceof Array);  // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>data</code> 时的 <code>Array</code> 跟 iframe 里的 <code>Array</code> 属于不同的 <code>window</code> 对象下，不是同一个类。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>终极解决方案，不但能检测基本类型，还能检测 object 子类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&apos;hello&apos;); // &apos;[object String]&apos;</span><br><span class="line">Object.prototype.toString.call(1); // &apos;[object Number]&apos;</span><br><span class="line">Object.prototype.toString.call(true); // &apos;[object Boolean]&apos;</span><br><span class="line">Object.prototype.toString.call(null); // &apos;[object Null]&apos;</span><br><span class="line">Object.prototype.toString.call(undefined); // &apos;[object Undefined]&apos;</span><br><span class="line">Object.prototype.toString.call(Symbol()); // &apos;[object Symbol]&apos;</span><br><span class="line">Object.prototype.toString.call(BigInt(2)) // &quot;[object BigInt]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;); // &apos;[object Object]&apos;</span><br><span class="line">Object.prototype.toString.call([]); // &apos;[object Array]&apos;</span><br><span class="line">Object.prototype.toString.call(() =&gt; &#123;&#125;); // &apos;[object Function]&apos;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()); // &apos;[object Date]&apos;</span><br><span class="line">Object.prototype.toString.call(new RegExp());</span><br><span class="line">Object.prototype.toString.call(Math); // &apos;[object Math]&apos;</span><br><span class="line">Object.prototype.toString.call(new Set()); // &apos;[object Set]&apos;</span><br><span class="line">Object.prototype.toString.call(new WeakSet()); // &apos;[object WeakSet]&apos;</span><br><span class="line">Object.prototype.toString.call(new Map()); // &apos;[object Map]&apos;</span><br><span class="line">Object.prototype.toString.call(new WeakMap()); // &apos;[object WeakMap]&apos;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><a href="https://juejin.cn/post/6844903752332214280" target="_blank" rel="noopener">https://juejin.cn/post/6844903752332214280</a></p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ul><li>toString</li></ul><p>基础类型强制转为 string 类型在规范中明确说明了，也比较符合直觉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(1); // &quot;1&quot;</span><br><span class="line">String(true); // &quot;true&quot;</span><br><span class="line">String(null); // &quot;null&quot;</span><br><span class="line">String(undefined); // &quot;undefined&quot;</span><br><span class="line">String(Symbol(&apos;hello&apos;)); // &quot;Symbol(hello)&quot;</span><br></pre></td></tr></table></figure><p>Object 类型在强制转换为 string 类型的时候，调用的是该类型原型上的 toString 方法，而 Object 的各个子类型基本都重写了 toString 方法，所以在进行 toString 操作的时候表现有差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String(&#123; a: 2 &#125;); // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2]); // &quot;1,2&quot;</span><br><span class="line">String(/reg/g); // &quot;/reg/g&quot;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2];</span><br><span class="line">arr.toString(); // &quot;1,2&quot;</span><br><span class="line">String(arr); // &quot;1,2&quot;</span><br><span class="line"></span><br><span class="line">// 重写toString</span><br><span class="line">arr.toString = function() &#123;</span><br><span class="line">  return this.join(&apos;/&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">String(arr); // &quot;1/2&quot;</span><br></pre></td></tr></table></figure><ul><li>toNumber</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">true + 0;</span><br><span class="line">&apos;1&apos; + [&apos;hello&apos;, 1];</span><br><span class="line">&#123;&#125; + [];</span><br><span class="line">[] + &#123;&#125;;</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">&apos;2&apos; + &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&apos;2&apos; + obj;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true == 1;</span><br><span class="line">false === 0; // false</span><br><span class="line">false + false === 0; // true</span><br><span class="line">[] == ![];</span><br><span class="line">[undefined] == false;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/64446259" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64446259</a><br><a href="https://juejin.cn/post/6844903870712283149" target="_blank" rel="noopener">https://juejin.cn/post/6844903870712283149</a><br><a href="https://juejin.cn/post/6844903983429976078" target="_blank" rel="noopener">https://juejin.cn/post/6844903983429976078</a><br><a href="https://juejin.cn/post/6844903854882947080" target="_blank" rel="noopener">https://juejin.cn/post/6844903854882947080</a><br><a href="https://juejin.cn/post/6844903902295359502" target="_blank" rel="noopener">https://juejin.cn/post/6844903902295359502</a><br><a href="https://juejin.cn/post/6844903937930346509" target="_blank" rel="noopener">https://juejin.cn/post/6844903937930346509</a><br><a href="https://juejin.cn/post/6971935704938971173" target="_blank" rel="noopener">https://juejin.cn/post/6971935704938971173</a><br><a href="https://juejin.cn/post/6861500194232467470" target="_blank" rel="noopener">https://juejin.cn/post/6861500194232467470</a><br><a href="https://juejin.cn/post/6918892282192068622" target="_blank" rel="noopener">https://juejin.cn/post/6918892282192068622</a><br><a href="https://juejin.cn/post/6844903682018902029" target="_blank" rel="noopener">https://juejin.cn/post/6844903682018902029</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2021/01/22/React/"/>
      <url>/2021/01/22/React/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>为什么 React 需要 Immutable？<br><a href="https://blog.csdn.net/KlausLily/article/details/117137249" target="_blank" rel="noopener">https://blog.csdn.net/KlausLily/article/details/117137249</a><br><a href="https://zhuanlan.zhihu.com/p/20295971" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20295971</a><br><a href="https://www.zhihu.com/question/446377023" target="_blank" rel="noopener">https://www.zhihu.com/question/446377023</a></p><a id="more"></a><p><a href="https://www.cnblogs.com/sexintercourse/p/15690013.html" target="_blank" rel="noopener">https://www.cnblogs.com/sexintercourse/p/15690013.html</a></p><p><a href="https://www.zhihu.com/question/440916294/answer/1748044978" target="_blank" rel="noopener">https://www.zhihu.com/question/440916294/answer/1748044978</a><br><a href="https://www.zhihu.com/question/475858982/answer/2029148759" target="_blank" rel="noopener">https://www.zhihu.com/question/475858982/answer/2029148759</a><br><a href="https://zhuanlan.zhihu.com/p/279600842" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/279600842</a></p><p>react 还要 immutable.js 吗</p><p>vue是否需要immutability</p><p><a href="https://www.zhihu.com/question/47171917" target="_blank" rel="noopener">https://www.zhihu.com/question/47171917</a></p><p>mobx</p><p>mobx6 开始不支持装饰器</p><p>mobx6: <a href="https://mobx.js.org/enabling-decorators.html" target="_blank" rel="noopener">https://mobx.js.org/enabling-decorators.html</a><br><a href="https://zhuanlan.zhihu.com/p/342648174" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/342648174</a></p><p>mobx4/5: <a href="https://cn.mobx.js.org/intro/overview.html" target="_blank" rel="noopener">https://cn.mobx.js.org/intro/overview.html</a><br><a href="https://www.cnblogs.com/xiaozhumaopao/p/14422260.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozhumaopao/p/14422260.html</a></p><p>React 天然和 mobx mutable 设计相违背: <a href="https://www.zhihu.com/question/328612405/answer/2073843986" target="_blank" rel="noopener">https://www.zhihu.com/question/328612405/answer/2073843986</a></p><ul><li>重要版本号</li></ul><p>react 在<br>0.13.0 加入了 ES6 classes components 支持<br>0.14.0 加入了对 Stateless functional components 支持<br>15.6.0 开始不再推荐 createClass，并在 16 开始废弃了对 createClass 的支持（如果想继续使用 createClass 方法创建组件,需要引入create-react-class<br>）<br>在 16.8 加入了 hook</p><p>0.14.8 一下升到了 15.0.0，<a href="https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html" target="_blank" rel="noopener">new-versioning-scheme</a></p><p>主要目的是为了表明对稳定性的承诺（15.0.0 比 1.0.0 更适合），另外也是为了更好的利用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver 语义化版本规范</a>灵活地在次要版本中添加新的向后兼容功能。</p><p>JSX 其实是一个 JavaScript 对象，JSX 被编译后，是一个函数调用，返回值为 JS 对象。可以用 Babel 编译 <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel 在线编译</a>后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&quot;xxx.png&quot; /&gt;</span><br><span class="line">    &lt;p&gt;Content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123; true ? 1 : 2 &#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/29711902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29711902</a></p><p>createClass 和 es6 class<br><a href="https://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes" target="_blank" rel="noopener">https://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes</a><br><a href="https://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html" target="_blank" rel="noopener">https://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html</a><br><a href="https://www.cnblogs.com/aivnfjgj/p/6507344.html" target="_blank" rel="noopener">https://www.cnblogs.com/aivnfjgj/p/6507344.html</a><br><a href="https://daveceddia.com/react-es5-createclass-vs-es6-classes/" target="_blank" rel="noopener">https://daveceddia.com/react-es5-createclass-vs-es6-classes/</a></p><p>dan 的 github<br><a href="https://github.com/gaearon" target="_blank" rel="noopener">https://github.com/gaearon</a></p><p>react 为什么要推崇函数式组件<br><a href="https://www.zhihu.com/question/343314784/answer/937174224" target="_blank" rel="noopener">https://www.zhihu.com/question/343314784/answer/937174224</a></p><ul><li>setState</li></ul><ul><li>React 全家桶搭建</li></ul><p><a href="https://juejin.cn/post/6844904055840440334" target="_blank" rel="noopener">https://juejin.cn/post/6844904055840440334</a></p><p><a href="https://umijs.org/zh-CN/docs/use-umi-ui" target="_blank" rel="noopener">https://umijs.org/zh-CN/docs/use-umi-ui</a></p><p><a href="https://juejin.cn/post/6926359111126908936" target="_blank" rel="noopener">https://juejin.cn/post/6926359111126908936</a></p><h2 id="CRA"><a href="#CRA" class="headerlink" title="CRA"></a>CRA</h2><p>cra 怎么选择 react 版本</p><h2 id="react-devtools"><a href="#react-devtools" class="headerlink" title="react-devtools"></a>react-devtools</h2><p>灰色、蓝色、红色</p><p>Edge 和 FireFox 应用商店不需要翻墙，Chrome 应用商店则需要翻墙，如果不能翻墙也可在本地打包编译。</p><ul><li>v3.3.2</li></ul><p>github 中下载 <a href="https://github.com/facebook/react-devtools/tree/v3.3.2" target="_blank" rel="noopener">v3.3.2</a> 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/react-devtools.git</span><br><span class="line">npm install --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>打包编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:extension:chrome</span><br></pre></td></tr></table></figure><p>编译成功后，会在项目的项目根目录下生成文件夹 ./shells/chrome/build/unpacked</p><p>在 chrome://extensions/ 中点击“加载已解压的扩展程序”，指定到这个目录安装即可。</p><p>注意：react-devtools v3 不支持 react 17+，报错 <code>Uncaught TypeError: Cannot read properties of undefined (reading &#39;forEach&#39;)</code></p><ul><li>v4</li></ul><p>从 v4 开始，react devtools 被合并到 <a href="https://github.com/facebook/react" target="_blank" rel="noopener">react</a> 主项目中。项目根目录 packages 目录下两个文件夹：react-devtools 和 react-devtools-extensions，前者是基于 electron 版，不但能调试 React DOM，还能调试 React Native，后者是 react-devtools 浏览器插件版。</p><p>本地编译安装，需要下载整个 react 仓库，具体操作流程如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/react.git</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><p>注意：如果报这种错 <code>@typescript-eslint/parser-v5@5.0.0-alpha.25: The engine &quot;node&quot; is incompatible</code> ，执行一下 <code>yarn config set ignore-engines true</code> 即可。</p><p>项目根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build-for-devtools</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd packages/react-devtools-extensions/</span><br><span class="line">yarn build:chrome</span><br></pre></td></tr></table></figure><p>编译成功后，会在 packages/react-devtools-extensions/chrome 下生成 packages/react-devtools-extensions/chrome/build/unpacked 文件，浏览器插件管理中指定 unpacked 目录安装即可。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科里化</title>
      <link href="/2020/12/02/Currying/"/>
      <url>/2020/12/02/Currying/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><ul><li>版本 1</li></ul><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123; <span class="comment">// 通过手动调用的方式（即不传参数）来判断收集结束</span></span><br><span class="line">      <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currying(fn.bind(<span class="literal">null</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须手动结束调用</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>版本 2</li></ul><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用</p><p>有闭包的 bug</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []; <span class="comment">// 搜集参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;  <span class="comment">// 递归的中断条件，改为 arg.length === 0 更合适</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args); <span class="comment">// 改为 fn(...args) 更合适</span></span><br><span class="line">    &#125;</span><br><span class="line">    args = args.concat(arg);  <span class="comment">// ?</span></span><br><span class="line">    <span class="keyword">return</span> foo;  <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>版本 3</li></ul><p>这个版本中，被科里化的函数的形参必须要有长度</p><p><a href="https://zhuanlan.zhihu.com/p/296852112" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/296852112</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123; <span class="comment">// 这里通过型参长度来判断是否要调用，所以add的参数不能...</span></span><br><span class="line">      <span class="keyword">return</span> fn(...args) <span class="comment">// 不需要 call，fn.call(this, ...args)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...remain</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _fn(...args, ...remain); <span class="comment">// 不需要 call，_fn.call(this, ...args, ...remain);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本中，被科里化函数的形参长度必须固定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c +d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>科里话的关键是返回函数实现连式调用、参数收集、以及判断收集结束做最终调用</p><p>判断收集结束有很多办法：对比实参和形参的长度（这样被科里化的函数形参不能使用…）；判断实参的个数是否为 0（不传）；</p><p>call、apply、bind 的主要作用是绑定this上下文，另外 apply 还可以用来传 spread 数组，不过已经被 es6 spread 代替</p><p>数组求和。。。</p><p>var arr = [1, 2, 3];<br>eval(arr.join(‘+’));</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 技术要点</title>
      <link href="/2020/10/15/Vue/"/>
      <url>/2020/10/15/Vue/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:12 GMT+0800 (中国标准时间) --><h2 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h2><ul><li>优点</li></ul><p>渐进式：框架设计（可以直接引入使用，仅使用核心渲染功能，也可以配合构建工具，集成路由和数据管理，采用单文件组件的开发模式）<br>声明式渲染：响应式（数据驱动视图，当数据改变后，会通知视图，不是指响应式编程 Reactive Programming），不需要传统那样命令式的操作 DOM<br>组件化：<br>工程化：Vue-cli<br>全家桶？：vuex、vue-router 集中式数据管理和客户端路由</p><p>声明式渲染（Declarative View）与之相对应的是命令式渲染（Imperative View）</p><a id="more"></a><ul><li>特点</li></ul><p><a href="https://juejin.cn/post/6857669921166491662" target="_blank" rel="noopener">https://juejin.cn/post/6857669921166491662</a></p><ul><li>nextTicket</li></ul><ul><li>props</li></ul><p>props 的作用</p><p>props 的作用：<br>直接在视图或逻辑（注意响应式处理，watch、key + created/mounted）中消费；<br>初始化 data（一般命名为 initXXX，注意异步的 props，组件初始化完成，异步 props 才设置，这时组件内部会失去初始化时机，需要配合 v-if 或 key）</p><p>引用类型的 props；驱动组件逻辑（watch props，需要注意的是，如果 props 的变动早于组件的初始化，这时候是无法 watch，需要配合 created）</p><p>引用类型的副作用，有时候需要规避（比如 props 中），有时候需要利用（比如修改 v-for 列表中的某条数据）</p><p>props down 和 events up 是作为组件接口(高内聚低耦合)的存在</p><ul><li>key</li></ul><p>可用来刷新组件，配合 props 可用来做数据驱动逻辑的场景</p><ul><li>watch</li></ul><p>数据驱动逻辑</p><p>watch props，watch data</p><p>课堂内有时候 watch 不触发<br>个人感觉 watch 有些心智负担</p><ul><li>coputed</li></ul><p>依赖追踪，根据一个依赖数据，算出另一个数据<br>get、set</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>sync：语法糖<br>v-module：语法糖</p><p>组件的生命周期：4 个节点(create,mount,update,destroy)，2 个状态(before,after，怎么取名呢)，共 8 个生命周期</p><p>钩子函数：由系统调用的函数（相当于 callback，比如 data 函数）</p><p>生命周期的钩子函数：生命周期的钩子函数是钩子函数里面一类，是在生命周期某个节点调用的钩子函数</p><p>注意箭头函数词法 this 的使用，有时候需要避开，有时候又需要利用</p><p>组件间的通信：event bus 作为组件间数据通信优点就是简单，但是如果滥用，也有缺点，数据流向不明确，可读性，维护性都不好。</p><ul><li>sync</li></ul><p>sync 是 prop 和 event 的语法糖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:foo=&quot;bar&quot;</span><br><span class="line">@update:foo=&quot;(val) =&gt; bar = val&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:foo&apos;, val);</span><br></pre></td></tr></table></figure><p>JSX 中需要写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo=&#123; this.bar &#125;</span><br><span class="line">&#123; ...&#123; on: &#123; &apos;update:foo&apos;: (val) =&gt; &#123; this.foo = val; &#125; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>:</code> 不是 JSX 语法，所以不能写为 <code>on-update:foo={ this.handleVisibleReply_Deteil }</code></p><p>sync 和 v-model 有什么区别</p><ul><li>slot</li></ul><slot name="operate" :assessment="item"></slot><template #operate="slotProps"><br><el-button v-if="showEvaluate(slotProps.assessment)" type="primary" size="mini" @click="handleOpenAssessment(slotProps.assessment)"><br>去评价<br></el-button><br><el-button v-else type="primary" size="mini" @click="handleOpenTeacherReport(slotProps.assessment)"><br>查看评价<br></el-button><br></template><template #default="slotProps"><br>…<br></template><p>v-slot:default 和 v-slot:operate 已经被废弃</p><p>jsx 中写法<br>父组件</p><p>子组件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;this.$scopedSlots.default(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line"></span><br><span class="line">            &#123;this.$scopedSlots.operate(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>父组件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;AssessmentList</span><br><span class="line">    scopedSlots=&#123;&#123;</span><br><span class="line">        default: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">        operate: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p></p><ul><li>组件风格</li></ul><p>template 组件 和 jsx 组件，tsx 组件</p><p>element-ui 以及 element-plus 组件是基于 template 风格，而 ant-design-vue、vant 则是基于 tsx 风格的（2.0 版本是基于 js/jsx 风格）</p><p><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a><br><a href="https://github.com/hujiulong/blog/issues/11" target="_blank" rel="noopener">https://github.com/hujiulong/blog/issues/11</a><br><a href="https://www.zhihu.com/question/310485097/answer/591869966" target="_blank" rel="noopener">https://www.zhihu.com/question/310485097/answer/591869966</a></p><p>jsx 组件</p><p>vue 默认支持 js/jsx 组件，比如：</p><p>Level.jsx（后缀名也可改为 js）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const Tag = `h$&#123;this.level&#125;`;</span><br><span class="line">    return &lt;Tag&gt;&#123;this.$slots.default&#125;&#123;this.message()&#125;&lt;/Tag&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    message() &#123;</span><br><span class="line">      return &lt;div&gt;我是 &#123;this.level&#125; 级标签&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>template 和 jsx 都是描述视图层的 DSL，最终都会编译伟 vdom。template 提供了插值、循环、判断，这满足了<br>一般的视图渲染要求，而 jsx 有更强的编程能力，能够使用 javascript 完整的编程能力。</p><p>有哪些东西是 template 不能做到，需要用到 jsx 的。</p><p><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a></p><p><a href="https://www.zhihu.com/question/411745998" target="_blank" rel="noopener">https://www.zhihu.com/question/411745998</a></p><ul><li><p>指令</p></li><li><p>过滤器</p></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件通常用来为 Vue 添加全局功能，比如，注册全局组件、添加实例方法、添加全局指令…，可通过 use 安装 Vue.js 插件。<br>如果插件是一个对象，必须提供 install 方法，如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p><p>Vue.use 用于安装 plugin，为第三方 plugin 提供 Vue 上下文，比如 Element-ui （他们自己没有 Vue，只能消费者提供）<br>对于本地的 plugin，因为有 Vue 环境，可以不用 use，<code>import Vue from &#39;vue&#39;</code> 即可。</p><ul><li>全局组件</li></ul><p>第三方组件库的注册方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = function install(Vue) &#123;</span><br><span class="line">  components.map(component =&gt; Vue.component(component.name, component));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般组件内部也会提供 install 方法，方便按需引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Dialog from &quot;./src/Dialog.vue&quot;;</span><br><span class="line"></span><br><span class="line">Dialog.install = function install(Vue) &#123;</span><br><span class="line">  Vue.component(Dialog.name, Dialog);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>实例方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.prototype.$xxx = xxx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>全局指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.directive(&apos;default-img&apos;, async (el, binding) =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123; install &#125;;</span><br></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>判断路由前进还是后退</p><p>push、replace</p><p>动态路由需要有 scope，要不然匹配范围太广，比如 <code>/:id</code></p><ul><li>路由嵌套</li></ul><p>动画、嵌套路由/子路由（各子路由可以复用父路由，以达到组件公用）</p><p>嵌套路由的目的是为了复用公共组件的引用，通过嵌套路由，就不用一个个往路由组件中引用公共组件。常见的场景有：菜单栏、头部导航…，这种结构固定的页面中。</p><p>注意：通过嵌套路由引用的组件，在与其他组件通信时又些麻烦，所以一般建议，如果有通信需求，建议还是使用手动引用。</p><ul><li>路由刷新</li></ul><p>刷新路由组件比刷页面好，不用重新加载静态资源</p><p><a href="https://www.zhihu.com/question/49863095" target="_blank" rel="noopener">https://www.zhihu.com/question/49863095</a></p><ul><li>相同路由跳转</li></ul><p>Vue Router 中，跳转同一个路由组件时，即使路由参数不同（query、path），默认下为了复用，路由组件不会被刷新，这也意味着组件的生命周期钩子不会被调用，数据不会被刷新，可使用以下方法解决：</p><p>强制刷新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;$route.fullPath&quot; /&gt;</span><br></pre></td></tr></table></figure><p>通过 watch $route 或 beforeRouteUpdate 来手动刷新数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.$watch(</span><br><span class="line">    () =&gt; this.$route.params,</span><br><span class="line">    (toParams, previousParams) =&gt; &#123;</span><br><span class="line">      // 对路由变化做出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async beforeRouteUpdate(to, from) &#123;</span><br><span class="line">  // 对路由变化做出响应...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>路由缓存</li></ul><p>keep-alive：列表到详情</p><p>替代 keep-alive 方案</p><p>通过 store、url 等方式缓存数据，可达到 keep-alive 缓存组件一样的效果，比如列表到详情中，如果将查询参数放到 url 中，返回时还能定位到具体的查询条件</p><p>列表到详情返回时维持列表的状态除 keep-alive 外，还有两种解决方案：<br>1）新开页（缺点–回退时前面页不知道，不会刷新；新开页要重新加载资源，慢）<br>2）缓存数据（url 或 store）而不是组件（比如myk 商城课程列表页），这是一个非常不错的办法</p><p>查询参数放 url 还有一个好处是分享</p><ul><li>滚动条位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    scrollBehavior(to, from, savedPosition) &#123;</span><br><span class="line">        if (savedPosition || to.meta.keepAlive) &#123; // 浏览器前进后退按钮切换路由</span><br><span class="line">            return savedPosition;</span><br><span class="line">        &#125; else &#123; // 通过&lt;router-link&gt;切换</span><br><span class="line">            return &#123;x: 0, y: 0&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</span><br></pre></td></tr></table></figure><p>如果数据是异步的，滚动条需要异步滚动，否则滚动位置会不准确</p><p>scrollBehavior 在 mounted 后执行，</p><p>需要将滚动行为与异步行为（Ajax、路由动画）结合起来，有些麻烦，有写人处理不好队列任务，干脆用 setTimeout。。。</p><p><a href="https://juejin.cn/post/6844903634484854797" target="_blank" rel="noopener">https://juejin.cn/post/6844903634484854797</a><br><a href="https://segmentfault.com/a/1190000022054521?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022054521?utm_source=tag-newest</a><br><a href="https://github.com/quasarframework/quasar/issues/1466" target="_blank" rel="noopener">https://github.com/quasarframework/quasar/issues/1466</a><br><a href="https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js" target="_blank" rel="noopener">https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js</a></p><p><a href="https://juejin.cn/post/6844903634484854797" target="_blank" rel="noopener">https://juejin.cn/post/6844903634484854797</a></p><p>beforeRouteEnter 中提前获取数据是一种选择</p><p>beforeRouteEnter(to, from, next) {<br>getPost(to.params.id, (err, post) =&gt; {<br>next(vm =&gt; vm.setData(err, post))<br>})<br>},</p><ul><li>路由权限控制</li></ul><p>HOC<br>路由守卫</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个状态管理库（数据库），其特点是持久化、集中式、响应式。其作用有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基础数据的持久化：应用的生命周期内，用户信息、会话信息等基础信息的持久化</span><br><span class="line">跨级组件通信：通信有两种，数据和事件</span><br><span class="line">集中化管理：集中化的数据对象可以保证数据的一致性。课堂中，数据由发布、订阅、恢复产生，多点的生产，这要求统一的数据对象来保证一致性</span><br></pre></td></tr></table></figure><p>对于数据流比较简单的系统，也只有用户信息需要用到 Store。</p><p>注：对于跨级组件通信，个人更愿意用 Event Bus，临时私有数据放组件内部 State 会显得更内聚（可通过容器组件与展示组件解耦），且数据会随组件的销毁而销毁，不会像 Store 由于持久化的特性，需手动清空（比如课堂中关闭窗口时，需要手动 resetState）。</p><ul><li>使用原则</li></ul><p>mutation 不能有副作用，action 不但允许副作用，还能有返回。<br>action 的本质是发布订阅<br>mutation 中不能用异步，这样会造成状态的改变不可被 DevTools 追踪。</p><p>mutation type 常量</p><ul><li>配合 Storage</li></ul><p>由于 State 存储在内存，如果想要数据在应用生命周期外也能持久化（比如 Token），则需存 Storage。另外，Storage 不是响应式的，但可以通过 state 的 set get 实现响应式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    get msg() &#123;</span><br><span class="line">      return localStorage.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">    set msg(val) &#123;</span><br><span class="line">      localStorage.msg = val;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setMsg(state, payload) &#123;</span><br><span class="line">      state.msg = payload;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>store 模式</li></ul><p>可以用 Vue.observable（vue2）、reactive（vue3） 创建一个简单的可响应数据对象来进行状态管理。</p><p>store 模式没有专业 store（vuex、pinia） 的健壮和丰富的功能，比如 vuex 就提供 time-travel 调试和插件机制。</p><p>Vue3,我决定不再使用Vuex</p><p><a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86</a><br><a href="https://juejin.cn/post/6898504898380464142" target="_blank" rel="noopener">https://juejin.cn/post/6898504898380464142</a><br>使用Vue.observable()进行状态管理<br><a href="https://segmentfault.com/a/1190000019292569" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019292569</a><br><a href="https://www.jianshu.com/p/e97502f89bde" target="_blank" rel="noopener">https://www.jianshu.com/p/e97502f89bde</a><br><a href="https://www.52cik.com/2020/02/29/vue-observable.html" target="_blank" rel="noopener">https://www.52cik.com/2020/02/29/vue-observable.html</a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>代理<br>mock<br>完全版 vue</p><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><p>ssr</p><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><ul><li>Vue 2 的问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* TypeScript 支持不好</span><br><span class="line">* 逻辑抽象能力不强：HOC 或 Mixin 下的逻辑抽象有缺陷，逻辑关注点如果不被分离，意味着组件逻辑难以复用和分治，且难以阅读和理解，当项目体量变大时，会变得难以维护</span><br></pre></td></tr></table></figure><p>注：对于第二点，在 Vue2 中往往通过更合理的组件颗粒度划分来进行组件抽象，以组件复用和分治来代替逻辑复用和分治。</p><p>关注点分离（UI 的关注点分离、逻辑的关注点分离）</p><p>Mixin 的缺陷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命名冲突：Mixin 很容易发生 property 名冲突</span><br><span class="line">隐式依赖：通过对 this 扩展的依赖，既不不显式，也不能被 linter</span><br><span class="line">扩展性差：可重用性是有限的：mixin 不能传递参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性</span><br></pre></td></tr></table></figure><p>HOC 的缺陷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure><p>为了解决上述问题，Vue 3 中</p><p><a href="https://juejin.cn/post/7055224376437784589" target="_blank" rel="noopener">https://juejin.cn/post/7055224376437784589</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 TypeScript 重写 Vue，获得更好的类型支持。</span><br><span class="line">在响应式系统上，使用 Proxy 替换 Object.defineProperty。</span><br><span class="line">加入 Compositon API 来更好的抽象组件逻辑。</span><br><span class="line">优化了Virtual DOM</span><br><span class="line">更好的Tree shaking</span><br><span class="line">&lt;script setup&gt;</span><br></pre></td></tr></table></figure><ul><li>Composition API</li></ul><p>Composition API 逻辑抽象 提供了更好的代码组织和逻辑复用能力。</p><p>注意：逻辑关注点分离的目的是复用和分治，将关注点相关代码收集一起独立为 useXXX 组合式函数，然后在 <code>setup</code> 组合式 API 的入口中组合，不要把所有逻辑不加抽象、不加简化地都写在其中，这样就失去了 compostion 的意义了，代码量大很难维护，是一种反模式。</p><p>个人认为 Composition API 是对 Options API 的补充，而不是否定，如果 Geek 一点，使用 Script-Setup Sugar，可以节省很多代码量，可完全代替 Options API</p><p><a href="https://github.com/vueuse/vueuse" target="_blank" rel="noopener">https://github.com/vueuse/vueuse</a></p><p>Composition API 并不是把所有的逻辑都堆砌到 setup 中，setup 是组合入口，在这里组装 useXXX 的</p><p>可以在 src 目录下建立 composables 或 hooks 目录，将所有的 useXXX 函数放此处。</p><ul><li>Function-based API</li></ul><p>vue3 使用 Function-based API 而不是 Class API 的原因</p><p><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68477600</a><br><a href="https://zhuanlan.zhihu.com/p/68099662" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68099662</a><br><a href="https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos" target="_blank" rel="noopener">https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos</a><br><a href="https://www.zhihu.com/question/325397290/answer/691200893" target="_blank" rel="noopener">https://www.zhihu.com/question/325397290/answer/691200893</a><br><a href="https://zhuanlan.zhihu.com/p/133819602" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/133819602</a></p><p>如果用户钟情于 Class API，可使用 vue-class-component<br><a href="https://www.zhihu.com/question/451424245/answer/1886655211" target="_blank" rel="noopener">https://www.zhihu.com/question/451424245/answer/1886655211</a></p><p><a href="https://www.zhihu.com/question/416652570/answer/1431359551" target="_blank" rel="noopener">https://www.zhihu.com/question/416652570/answer/1431359551</a><br><a href="https://zhuanlan.zhihu.com/p/436786508" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/436786508</a><br><a href="https://www.zhihu.com/question/453332049/answer/1835420993" target="_blank" rel="noopener">https://www.zhihu.com/question/453332049/answer/1835420993</a></p><p><a href="https://blog.csdn.net/u010059669/article/details/112287552" target="_blank" rel="noopener">https://blog.csdn.net/u010059669/article/details/112287552</a><br><a href="https://zhuanlan.zhihu.com/p/126552443" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126552443</a><br><a href="https://www.zhihu.com/question/328247960" target="_blank" rel="noopener">https://www.zhihu.com/question/328247960</a><br><a href="https://zhuanlan.zhihu.com/p/181673485" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181673485</a><br><a href="https://zhuanlan.zhihu.com/p/432068658" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/432068658</a><br><a href="https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html" target="_blank" rel="noopener">https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html</a><br><a href="https://www.zhihu.com/question/271485214" target="_blank" rel="noopener">https://www.zhihu.com/question/271485214</a><br><a href="https://zhuanlan.zhihu.com/p/111715881" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111715881</a></p><p>注：react hook 一样，处理 class component 关注点分离和难以复用问题，处理 function component 没有状态。</p><p>注：Opetion API 也可以叫 Object API？</p><ul><li>底层变化</li></ul><p>Vue 3为什么要用 Proxy API 替代 DefineProperty API？</p><p>proxy和defineproperty区别</p><p><a href="https://blog.csdn.net/weixin_43443341/article/details/124041094" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43443341/article/details/124041094</a><br><a href="https://segmentfault.com/a/1190000041084082" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041084082</a></p><ul><li>vue 3 的正确打开方式</li></ul><p>必须要用 script-setup sugar （vue3 兼容 option 是为了兼容，最佳实际自然是抛弃历史包袱使用 setup）<br>必须要用 TS（vue3 用 ts 重写的目的就是为了加强对 ts 的支持）<br>必须要用 provide/inject<br>必须舍弃 lifecycle hooks</p><p><a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html" target="_blank" rel="noopener">https://v3.cn.vuejs.org/api/sfc-script-setup.html</a></p><ul><li>生态</li></ul><p>Vuex4 对 TypeScript 并不友好，所以我选择 Pinia<br><a href="https://www.zhihu.com/question/478752529" target="_blank" rel="noopener">https://www.zhihu.com/question/478752529</a><br><a href="https://zhuanlan.zhihu.com/p/413968851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/413968851</a></p><p>Volar<br>&lt; setup&gt; + TS + Volar = 真香<br>Vue.js作者尤雨溪在VueConf 2021谈Vue 3 生态进展<br><a href="https://www.bilibili.com/video/BV1JK4y1G7bf" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1JK4y1G7bf</a><br>27:40 开始，可以说 Volar 是 Vetur 的继任者<br><a href="https://zhuanlan.zhihu.com/p/401160130" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/401160130</a></p><ul><li>vue-class-component</li></ul><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">https://github.com/vuejs/vue-class-component</a><br><a href="https://zhuanlan.zhihu.com/p/355315790" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355315790</a><br><a href="https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6</a></p><p>注：vue-class-component匹配Vue 3的v8版本还没有正式的文档</p><p><a href="https://github.com/vuejs/vue-class-component/tree/master/example/src/components" target="_blank" rel="noopener">https://github.com/vuejs/vue-class-component/tree/master/example/src/components</a><br>注：可以是 tsx 文件 也可以是 vue 文件</p><ul><li>vue-property-decorator</li></ul><p><a href="https://github.com/kaorun343/vue-property-decorator/issues/294" target="_blank" rel="noopener">https://github.com/kaorun343/vue-property-decorator/issues/294</a><br>注：应该暂时还不支持 vue3，package.json 中的 vue-class-component 版本还是 7.0</p><p>vue class component 是vue 官方出的，vue property decorator 是社区出的<br>其中 vue class component 提供了 vue component 等等<br>vue property decorator 深度依赖了 vue class component 拓展出了很多操作符 @Prop @Emit @Inject 等等 可以说是 vue class component 的一个超集<br>正常开发的时候 你只需要使用 vue property decorator 中提供的操作符即可 不用再从vue class componen 引入vue component</p><h2 id="vue-范式"><a href="#vue-范式" class="headerlink" title="vue 范式"></a>vue 范式</h2><p>JavaScript 是一个多范式的语言，支持 Class、Object、Function。Options API、Class API、Function API 。</p><p>喜欢装饰器，Class Component，Service Class 风格的选择 Angular，喜欢纯函数，Function Component，Hooks 的选择 React，没有啥偏好的使用 Vue</p><h3 id="与-React-区别"><a href="#与-React-区别" class="headerlink" title="与 React 区别"></a>与 React 区别</h3><p><a href="https://github.com/lihongxun945/myblog/issues/21" target="_blank" rel="noopener">https://github.com/lihongxun945/myblog/issues/21</a><br><a href="https://www.jianshu.com/p/b7cd52868e95" target="_blank" rel="noopener">https://www.jianshu.com/p/b7cd52868e95</a><br><a href="https://zhuanlan.zhihu.com/p/396229611" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/396229611</a><br><a href="https://www.zhihu.com/question/309891718/answer/2282544794" target="_blank" rel="noopener">https://www.zhihu.com/question/309891718/answer/2282544794</a></p><p>响应式原理不一样<br><a href="https://blog.csdn.net/SirM2z/article/details/71195059" target="_blank" rel="noopener">https://blog.csdn.net/SirM2z/article/details/71195059</a><br><a href="https://juejin.cn/post/6844904113432444942" target="_blank" rel="noopener">https://juejin.cn/post/6844904113432444942</a></p><p>react 面试题</p><p><a href="https://juejin.cn/post/6844903857135304718" target="_blank" rel="noopener">https://juejin.cn/post/6844903857135304718</a></p><p><a href="https://juejin.cn/post/6944863057000529933" target="_blank" rel="noopener">https://juejin.cn/post/6944863057000529933</a></p><p>响应式编程不是指的 RxJS Observable 那一套吗…和依赖追踪貌似关系不太大？</p><p><a href="https://juejin.cn/post/6844904103504527374" target="_blank" rel="noopener">https://juejin.cn/post/6844904103504527374</a></p><p>目前市面上的三种框架，无非是以Vue为首的响应式ui，这种框架特定就是简单，在通常意义下运行得非常快，但大规模的依赖收集和清理会带来额外的运作成本和内存消耗。第二种就是react这类，依靠f -&gt; UI这种声明式方案来更新视图，这种的好处在于它比依赖native api的响应式框架灵活太多。最后一种就是svelte，这种东西完全就是为web component而生，特点就是傻快，但没办法做dsl转换了（没vdom）。不过因为它就作用于小范围的dom，往往在编写小页面和web component时会带来的性能会远超于使用virtual dom或者增量dom的前端三框架。</p><p><a href="https://www.zhihu.com/question/446377023/answer/1756125862" target="_blank" rel="noopener">https://www.zhihu.com/question/446377023/answer/1756125862</a></p><p>个人倾向于认为即便有了调度的细粒度控制，整体上 React 计算 diff 的成本仍然比响应式框架高很多……像 concurrent mode 宣传中那样去优化跨越多帧（譬如 50-100ms 量级）的计算，无论怎么可控，听起来都已经像是有问题的了</p><p>vue-cli3<br><a href="https://blog.csdn.net/qinyuhua93/article/details/104820902" target="_blank" rel="noopener">https://blog.csdn.net/qinyuhua93/article/details/104820902</a></p><p><a href="https://www.zhihu.com/question/471825415" target="_blank" rel="noopener">https://www.zhihu.com/question/471825415</a><br><a href="https://zhuanlan.zhihu.com/p/441467856" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/441467856</a></p><p>vue3</p><p>Naive UI<br><a href="https://www.zhihu.com/question/463736268/answer/1928879382" target="_blank" rel="noopener">https://www.zhihu.com/question/463736268/answer/1928879382</a></p><p>vuex/Pinia</p><p>Vue 3 将成为新的默认版本<br><a href="https://zhuanlan.zhihu.com/p/460055155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/460055155</a></p><p>Vite2 + Vue3 + TypeScript + Pinia<br><a href="https://zhuanlan.zhihu.com/p/441467856" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/441467856</a></p><p>升级 vue 版本<br>npm update vue -S<br>npm update vue-template-compiler -D</p><p>vue 和 vue-template-compiler，两者的版本需要同步，如果不同步项目会报错</p><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><ul><li>ref、reactive、toRef、toRefs</li></ul><p>这几个 API 设计的目的就是为了在 setup 中使用响应式数据，setup 中不能使用 data 选项，只能通过上述方式使用响应式数据。</p><p>ref：返回一个响应式且可变（官网咖啡图）的 ref 对象。既支持原始类型，也支持引用类型，当值为引用类型时，底层使用的是 reactive。在模板中可省略 value 属性（自动解包）。</p><p>reactive：返回对象的响应式副本（基于 ES6 proxy 实现，响应式转换是“深层”的——它影响所有嵌套 property）。相当于 Vue2.x 的 Vue.observable () API（vue 2 中 data 选项的底层就是 Vue.observable，这两种方式都能创建响应式数据）。reactive 只支持将引用类型响应式，不支持原始类型。</p><p>toRef：用来将断开的响应式对象（被 reactive 包裹的对象）中某一个属性包裹成 ref 对象，并保持其和原对象的引用</p><p>toRefs：toRefs 和 toRef 功能是一致的，但是可以批量创建多个 ref 对象，注意，不支持可选 prop<br>响应式对象一旦被展开，其响应式特性会丢失，可用 toRefs 来解决</p><ul><li>attrs</li></ul><p>attrs 和 props 很相似，也是基于父子通信的数据，如果传递给组件的 attribute 或者 v-on 事件监听器，没有显式地声明在所接收组件的 props 或 emits 上，那么就会被挂到 attrs 上，且透传的 attribute 会自动添加到根元素的 attribute 中。</p><p>选项式 API 中，可通过 $attrs 访问，setup 中可通过 context 访问，setup sugar（script-setup） 中可通过 useAttrs 访问。</p><ul><li>refs</li></ul><p>选项式 API 中，可通过 $refs 访问 DOM，setup 中通过 ref 或函数绑定访问 DOM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; ref=&quot;btn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">const btn = ref(null);</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">  console.log(btn.value);</span><br><span class="line">&#125;;</span><br><span class="line">return &#123;</span><br><span class="line">  btn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; :ref=&quot;refBtn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">let btn = null;</span><br><span class="line">const refBtn = (el)=&gt; &#123;</span><br><span class="line">  btn = el;</span><br><span class="line">&#125;;</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      console.log(btn, 11);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">  refBtn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &lt;li </span><br><span class="line">v-for=&quot;(item, index) in list&quot; </span><br><span class="line">:key=&quot;index&quot;</span><br><span class="line">:ref=&quot;refLi&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> setup() &#123;</span><br><span class="line">   const list = reactive([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</span><br><span class="line">const elLi = reactive([]);</span><br><span class="line">const refLi = (el) =&gt; &#123;</span><br><span class="line">  elLi.push(el);</span><br><span class="line">&#125;;</span><br><span class="line">   nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(elLi, 2222);</span><br><span class="line">   &#125;);</span><br><span class="line">return &#123;</span><br><span class="line">  list,</span><br><span class="line">     refLi,</span><br><span class="line">&#125;;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>defineComponent</li></ul><p>TS 类型本身是图灵完备的，类型图灵不完备的是发展不出类型体操的。</p><p>类型体操自然也有他的作用，比如说 Vue 就通过了大量的类型体操才实现了 defineComponent 的类型推导，否则你面对的可能是大量的 unknown 或 any。</p><p>defineComponent 最重要的是：在TypeScript下，给予了组件 正确的参数类型推断</p><p>将一个 组件用 defineComponent 包裹，仅仅只是为了 在 ts 下做类型推断</p><p>对传递给 setup() 的参数进行类型推断</p><ul><li>emits</li></ul><p>setup 选项的 this 不指向当前实例(undefined)，只能通过 context 使用 emit（推荐使用 emits 选项来定义组件可触发的事件），setup sugar 中通过 defineEmits 的返回使用 emit</p><p>emits 或 defineEmits 用来定义组件可向其父组件触发的事件。强烈建议声明组件所 emit 的事件，这尤为重要，vue3 中移除了 .native 修饰符，任何未在 emits 中声明的事件都将默认绑定到组件的根节点上（与 .native 修饰符的作用一样），对于那些被透传的原生事件，会被触发两次，emit 一次和应用在根元素上的原生事件一次。</p><p>vue2 中，组件上的 v-on 只会监听自定义事件 (用 $emit 触发的事件)，如果要监听根元素的原生事件，可以使用 .native 修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><p>以上代码，在 Vue3 中，如果组件内部没有用 emits 声明事件，则 click 事件会被。而在 Vue2 中，click 算自定义事件，如果想成为原生事件需要加 native 修饰符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click.native=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><ul><li>expose</li></ul><p>Vue3 新特性，如果是 options api 类型的组件，不声明 expose 时，默认暴露当前组件实例的全部内容，声明了 expose 选项，expose 数组内标记的才会暴露。（expose:[]则什么都不暴露，注意这个问题。也可以利用这个特性提高组件使用的规范。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  expose: [&apos;nameA&apos;,...], // 可以 expose 当前实例的任何内容</span><br><span class="line">  methods: &#123;</span><br><span class="line">    nameA()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> setup 语法糖的情况下，默认是封闭的，需要获取当前组件里的内容的话，必须显式 expose 出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&apos;ts&apos; setup&gt;</span><br><span class="line">import &#123;ref&#125; from &apos;vue&apos;;</span><br><span class="line">let refData = ref(&apos;寒蝉鸣泣之时&apos;)</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  refData,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>TS类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref,Ref &#125; from &quot;vue&quot;;</span><br><span class="line">//&gt; defineExpose</span><br><span class="line">interface exFace &#123;</span><br><span class="line">  ex1:Ref&lt;string&gt;,</span><br><span class="line">  ex2?:number</span><br><span class="line">&#125;</span><br><span class="line">let ex1 = ref(&apos;1&apos;)</span><br><span class="line">let exObj:exFace = &#123;</span><br><span class="line">  ex1,</span><br><span class="line">&#125;</span><br><span class="line">// 源码类型: const defineExpose: (exposed?: Record&lt;string, any&gt;) =&gt; void</span><br><span class="line">defineExpose(exObj)</span><br></pre></td></tr></table></figure><ul><li>jsx</li></ul><p>在 vue3 中使用 jsx，只能通过 option api 中的 render 函数或 setup 函数返回渲染函数，<code>&lt;script setup&gt;</code> 中不可使用。</p><p>const test = {<br>render(createElement) { // vue3 中 h 函数由 Vue 提供<br>return createElement(<br>‘div’, [<br>createElement(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>};</p><p>// 组件的注册<br>// 全局注册<br>Vue.component(‘Test’, test)<br>// 局部注册<br>components: {<br>Test: test,<br>}</p><p>var test = {<br>setup() {<br>return () =&gt; {<br>return h(<br>‘div’, [<br>h(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>},</p><p>注意：cdn 模式下不能使用 jsx，只能使用 vdom，jsx 需要使用 Babel 插件来转译</p><p>const test = {<br>render(createElement) { // vue3 中 h 函数由 Vue 提供<br>return createElement(<br>‘div’, [<br>createElement(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>};</p><p>// 组件的注册：全局注册、局部注册<br>Vue.component(‘Test’, test)</p><h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p><code>&lt;script setup&gt;</code> 语法糖里面的代码会被编译成组件 setup() 函数的内容。</p><ul><li><code>&lt;script setup&gt;</code> 中无需 return 声明的变量、函数以及 import 引入的内容，即可在<template>使用</template></li></ul><p>标准组件<code>&lt;script&gt;</code>需要写setup函数并繁琐retrun</p><ul><li><p><code>&lt;script setup&gt;</code>引入组件将自动注册</p></li><li><p>组件通信:在<code>&lt;script setup&gt;</code>中必须使用 defineProps 和 defineEmits API 来替代 props 和 emits</p></li><li><p><code>&lt;script setup&gt;</code>需主动向父组件暴露子组件属性 ：defineExpose</p></li></ul><p>使用 <code>&lt;script setup&gt;</code> 的组件，父组件是无法通过ref 或者 $parent 获取到子组件的ref等响应数据，需要通过defineExpose 主动暴露</p><ul><li>useSlots 和 useAttrs</li></ul><p>用于在 JSX 模式下使用 slot 和 attr，SFC 模式下，在<template>通过<slot>标签就可以渲染插槽</slot></template></p><ul><li>useRoute 和 useRouter</li></ul><p>setup 里不能访问 this，不能再直接访问 this.$router 或 this.$route。（getCurrentInstance可以替代this但不推荐）<br>推荐：使用useRoute 函数和useRouter函数替代this.$route 和 this.$router</p><p>命名空间组件<br>Suspense<br>编译器宏：withDefaults<br><code>&lt;style&gt;</code> 特性<br>watchEffect 和 watch</p><h3 id="编译-html-字符串"><a href="#编译-html-字符串" class="headerlink" title="编译 html 字符串"></a>编译 html 字符串</h3><p><a href="https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js" target="_blank" rel="noopener">https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js</a></p><p><a href="https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components" target="_blank" rel="noopener">https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components</a></p><p><a href="https://cloud.tencent.com/developer/article/1467371" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1467371</a></p><p><a href="https://www.cnblogs.com/lvonve/p/12470666.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvonve/p/12470666.html</a><br><a href="https://www.zhihu.com/question/411745998" target="_blank" rel="noopener">https://www.zhihu.com/question/411745998</a><br><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a><br><a href="https://segmentfault.com/q/1010000023534933" target="_blank" rel="noopener">https://segmentfault.com/q/1010000023534933</a><br><a href="https://zhuanlan.zhihu.com/p/153387704" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/153387704</a></p><p>jsx 和 SFC template 只能在脚手架下才能被编译为 vdom，直接用 <code>&lt;script&gt;</code> 引入的 vue 下不能使用<br><code>&lt;script&gt;</code> 引入的 vue 下只能使用 template 选项和 render createElement 手动写 vdom</p><p>不使用脚手架，只 <code>&lt;script&gt;</code> 引入来使用 vue，会大打折扣？损失哪些功能，只能用哪些功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; </span><br><span class="line">    App,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p><p>意思是，要么使用完整版带 compoler 的 vue 在运行时动态编译 template，要不用 render 替换 template。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>注：jsx 中使用其他组件，不需要用 components 注册</p><p>vue 项目要先编译再运行：编译 —》 运行</p><p>template 和 jsx 会预编译为 vdom（能静态分析，能提就能确定dom结构），但是对于 html 字符串（首先编译器不知道该不该编译，另外字符串不一定是静态的，可能是后台返回的），不管是 slot、v-html，mustashe 插值，都是按普通字符串处理，不会被编译，要想编译 html 字符串只能使用完整版的 vue，以 template 选项或 Vue.compiler 的方式在运行时动态编译。</p><p>这样是错误的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, this.world());</span><br><span class="line">    console.log(this.world()); // vNode 是 Object</span><br><span class="line">    return &lt;div domPropsInnerHTML=&#123;str&#125;&gt;&lt;/div&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    world() &#123;</span><br><span class="line">      return &lt;span&gt;world&lt;/span&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>配置 vue-cli</li></ul><p>引入完整版 vue，有 2 种配置方法。</p><p>方法 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  runtimeCompiler:true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.resolve.alias.set(&apos;vue$&apos;,&apos;vue/dist/vue.esm.js&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后就可以这样写组件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Test.js，jsx 后缀也可以</span><br><span class="line">export default &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&lt;/div&gt;&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      alert();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Test.jsx</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render(h) &#123;</span><br><span class="line">    str = this.str.replace(/,/g, &apos;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&apos;);</span><br><span class="line">    const render = &#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return h(render);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, &apos;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&apos;);</span><br><span class="line">    const Foo = Vue.extend(&#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &lt;Foo&gt;&lt;/Foo&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Greeting /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">/* eslint-disable */</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // render(h) &#123;</span><br><span class="line">  //   return h(foo, &#123;&#125;);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    aa() &#123;</span><br><span class="line">      return &lt;div&gt;cccc&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    cc() &#123;</span><br><span class="line">      // const html = &lt;button onClick=&#123;this.handleClick&#125;&gt;btn&lt;/button&gt;;</span><br><span class="line">      const dd = Vue.extend(&#123;</span><br><span class="line">        template: &apos;&lt;div&gt;&lt;button @click=&quot;this.handleClick&quot;&gt;btn&lt;/button&gt;&lt;/div&gt;&apos;,</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(dd, 2222);</span><br><span class="line">      // const vNode = this.aa();</span><br><span class="line">      // console.log(vNode, 232323);</span><br><span class="line">      return dd;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    &apos;Greeting&apos;: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &apos;hello world&apos;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      template: &apos;&lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;btn&lt;/button&gt;&#123;&#123;msg&#125;&#125;&lt;Bar /&gt;&lt;/div&gt;&apos;,</span><br><span class="line"></span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert(&apos;ok&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      components: &#123;</span><br><span class="line">        &apos;Bar&apos;: &#123;</span><br><span class="line">          data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              name: &apos;bar&apos;,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          created() &#123;</span><br><span class="line">            const foo = &apos;foo&apos;;</span><br><span class="line">            this.$options.template = `&lt;div&gt;&#123;&#123;name&#125;&#125;$&#123;foo&#125;&lt;/div&gt;`;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>工作中有需要对 v-html 返回数据做数据绑定的需求，比如题干中答题，这时候要不使用原生 DOM，要不使用 vue 运行时的编译能力了</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>互动直播课堂前端技术设计</title>
      <link href="/2020/10/01/Interact-Live-Class/"/>
      <url>/2020/10/01/Interact-Live-Class/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>按同屏的技术实现方式来划分，课堂分为<strong>录屏课堂</strong>和<strong>指令课堂</strong>。指令课堂的操作状态需要恢复，录屏课堂中不是必须的，不管是录屏课堂还是指令课堂，互动操作（比如，聊天、点名、授权、问答…）都要通过指令实现。指令课堂适用于面对面课堂，录屏课堂适用于远程课堂。</p><p>指令同屏中可以选择同屏的内容，这样可以保护隐私。</p><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>按使用场景来划分，课堂又分为<strong>面对面课堂</strong>和<strong>远程课堂</strong>。面对面课堂作为线下课堂的补充，而远程课堂可用来替代线下课堂。</p><ul><li>基础功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 黑板（截图）</span><br><span class="line">* 音视频直播(摄像头、桌面，rtmp、hls、flv --- http cdn，rtc)</span><br><span class="line">* 学生列表（支持授权还有举手列表）</span><br><span class="line">* 授权（授权书写、语音、视频）</span><br><span class="line">* 课件（预览、上传，支持二维码上传，img、ppt、pdf、doc、media）</span><br><span class="line">* 聊天（可禁言）</span><br><span class="line">* 投票</span><br><span class="line">* 点名</span><br><span class="line">* 抽人</span><br><span class="line">* 计时器</span><br><span class="line">* 录像</span><br></pre></td></tr></table></figure><p>基础版课堂，能够满足基本的直播和白板需求，适用于远程教学、视频会议、白板等场景。</p><ul><li>K12 教学功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 问答（自由题目和备课题目）</span><br><span class="line">* 讲解题目/问答/作业</span><br></pre></td></tr></table></figure><p>注：测验的三种方式 — 问答、作业、考试。问答只能在课堂中进行，其他两种类型在课前（预习）、课中（随堂）、课后进行都可以。</p><h2 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h2><ul><li>登录</li></ul><p>登录</p><p>会话保持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage + http header</span><br></pre></td></tr></table></figure><p>登录刷新</p><ul><li>鉴权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口鉴权</span><br><span class="line">前端 UI 鉴权</span><br><span class="line">前端 Router 鉴权</span><br></pre></td></tr></table></figure><p>依赖于后端接口的 UI 不需要处理，但是不依赖的呢，有些（非操作类，不会触发后续请求的接口，因为这类 UI 无法通过后端接口来处理）就需要处理</p><ul><li>课堂控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 开始上课</span><br><span class="line">* 结束上课</span><br><span class="line">* 拖堂</span><br><span class="line">* 课堂倒计时</span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><p>恢复接口返回数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><p>课堂恢复的数据存在 Vuex。</p><ul><li>角色</li></ul><p>多角色设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 老师</span><br><span class="line">* 学生</span><br><span class="line">* 助教</span><br><span class="line">* 游客</span><br></pre></td></tr></table></figure><ul><li>授权</li></ul><p>十进制的展示和传输，二进制的语义</p><p>二进制表达的目的是为了能够组合表达，这样就能够表达多种状态</p><p>黑板：1 — 001<br>音频：2 — 010<br>视频：4 — 100 # 纯视频</p><p>判断：<br>(1xx &amp; 4) === 4</p><p>更新：<br>6 ^ 4 // 2</p><ul><li>问答</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 做题组件的设计（显示、作答、讲解）</span><br></pre></td></tr></table></figure><ul><li>讲解</li></ul><p>讲题目、讲答案、对比讲解答案、讲报告。</p><ul><li>黑板</li></ul><p>黑板配置没有做同步（老师 PC 和 老师平板），需要做吗</p><h2 id="技术设计"><a href="#技术设计" class="headerlink" title="技术设计"></a>技术设计</h2><ul><li>窗口</li></ul><p>非模态弹框被称为窗口，由于非模态的原因，就需要考虑窗口的排序</p><ul><li>同屏</li></ul><p>应用的宽高比<br>同屏与主控比</p><p>可以按提前商定宽高适配比例适配（适用于定制设备），也可以按主控的宽高比做适配。</p><p>提前商定适配尺寸，位置数据适配比例需要转化为中间比例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scale2Server(state, getters) &#123;</span><br><span class="line">  return 768 / getters.appWidth;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">scale2Client(state, getters) &#123;</span><br><span class="line">  return getters.appWidth / 768;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果按主控来适配，直接</p><ul><li>音视频直播</li></ul><p>播放器</p><p>两路流，混流。</p><p><a href="https://www.jianshu.com/p/32417d8ee5b6" target="_blank" rel="noopener">https://www.jianshu.com/p/32417d8ee5b6</a></p><ul><li>WebSocket 设计</li></ul><p>长链接实时应用熄屏</p><h3 id="Ajax-接口设计和调用"><a href="#Ajax-接口设计和调用" class="headerlink" title="Ajax 接口设计和调用"></a>Ajax 接口设计和调用</h3><ul><li>API 管理</li></ul><p>按业务模块划分，再由一个文件同意导出，方便管理。</p><ul><li>Axios 的设置</li></ul><p>Websorket 直接返回的是服务端数据，不管是成功还是错误。但是经 Axios 的 Ajax 返回被包裹了一层。</p><p>/lesson/xxx 开头的接口用的是 lesson_token，其他用的都是 lesson_access_token</p><p>其实大部分情况下，调的都是课外接口</p><ul><li>catch</li></ul><p>服务器端异常提示，统一在 Axios 响应拦截器里拦截，不需要调用接口时一个个 catch（参考 Promise 章节），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api.usHandUp().then(response =&gt; &#123;</span><br><span class="line">  this.handUpStatus = true;</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  this.$message(&#123;</span><br><span class="line">    message: error.msg,</span><br><span class="line">    type: &apos;warning&apos;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vuex-设计"><a href="#Vuex-设计" class="headerlink" title="Vuex 设计"></a>Vuex 设计</h3><h3 id="Socket-接口设计"><a href="#Socket-接口设计" class="headerlink" title="Socket 接口设计"></a>Socket 接口设计</h3><ul><li>WebSocket 库设计</li></ul><p>注：Socket 接口不一定非要用于推送，也可以当 HTTP 接口一样的用，也会有返回。</p><ul><li>数据的同步和恢复</li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>http 接口都带了 token，socket 接口没带？</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>游客快速问答的恢复</li><li>移除 Ajax 接口业务中的 catch</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K12 需求概要</title>
      <link href="/2020/06/15/K12/"/>
      <url>/2020/06/15/K12/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">个人老师</span><br><span class="line">机构学校</span><br><span class="line">培训中心</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="需求概要"><a href="#需求概要" class="headerlink" title="需求概要"></a>需求概要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 基础功能</span><br><span class="line">门户首页</span><br><span class="line">登录、注册</span><br><span class="line">用户管理</span><br><span class="line">个人、机构入驻</span><br><span class="line">消息公告</span><br><span class="line"></span><br><span class="line"># 核心业务</span><br><span class="line">资源库</span><br><span class="line">作业</span><br><span class="line">排课</span><br><span class="line">备课</span><br><span class="line">课堂</span><br><span class="line">云笔记</span><br><span class="line">阅卷</span><br><span class="line">商城</span><br><span class="line">支付</span><br><span class="line">学情</span><br><span class="line">激励</span><br><span class="line">录播</span><br><span class="line">语音测评</span><br><span class="line">乐答</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line">升学规划</span><br><span class="line"></span><br><span class="line"># 数据分析</span><br><span class="line">监控</span><br></pre></td></tr></table></figure><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p>资源库是用来备课（课堂中会用到）和做作业的。</p><ul><li>资源类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">试题</span><br><span class="line">试卷</span><br><span class="line">课件</span><br><span class="line">微课</span><br></pre></td></tr></table></figure><ul><li>试题类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单选、多选</span><br><span class="line">判读</span><br><span class="line">填空</span><br><span class="line">问答</span><br><span class="line">材料      # 复合题，由上述几种类型的子题组合而成</span><br><span class="line">完形填空   # 完形填空其实数据材料题的一种，但是由于其子题没有题干，所以独立为一种题型</span><br><span class="line">阅读理解   # 道理同完形填空</span><br></pre></td></tr></table></figure><ul><li>试题结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题干</span><br><span class="line">选项</span><br><span class="line">答案</span><br><span class="line">解析</span><br></pre></td></tr></table></figure><p>注：填空题下划线入题时是一个下划线，渲染时需要注意一下。</p><ul><li>试题出现的场景</li></ul><p>作为抽象依据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看  # 资源库</span><br><span class="line">做  # 学生（表现微试卷）</span><br><span class="line">看  # 学生做完，老师要批改（表现为试卷）</span><br></pre></td></tr></table></figure><ul><li>筛选组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学段（stage）</span><br><span class="line">学科（subject）</span><br><span class="line">教材版本（edition）</span><br><span class="line">教材章节树（chapter）</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node 面试题</title>
      <link href="/2020/06/01/Interview-Node/"/>
      <url>/2020/06/01/Interview-Node/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法面试题</title>
      <link href="/2020/05/10/Interview-Algorithms/"/>
      <url>/2020/05/10/Interview-Algorithms/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写一个函数，列出一个整数所有的分解类型，比如对于数字4，可以做拆分得到下列字符串</p><p>1111<br>112<br>121<br>13<br>211<br>22<br>31<br>4</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Decrease-and-conquer</span><br><span class="line">// f(1) = 0^f(1)=[[1]]</span><br><span class="line">// f(2) = 1^f(1) U 0^f(2) = [[1,1],[2]]</span><br><span class="line">// f(3) = 2^f(1) U 1^f(2) U 0^(3) = [[2,1],[1,1,1],[1,2],[3]]</span><br><span class="line">var resolve = (function ()&#123;</span><br><span class="line">    var table = [[],[[1]]];</span><br><span class="line">    //closure for cache</span><br><span class="line">    return function (number)&#123;</span><br><span class="line">        //recursion function</span><br><span class="line">        var callee = arguments.callee;</span><br><span class="line">        if (!table[number])&#123;</span><br><span class="line">            var arr = [];</span><br><span class="line">            for (var i=1;i&lt;number ;i++ )&#123;</span><br><span class="line">                //recursion for sub result</span><br><span class="line">                var subs = callee(number-i);</span><br><span class="line">                subs.forEach(function (sub)&#123;</span><br><span class="line">                    arr.push(sub.concat([i]));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push([number]);</span><br><span class="line">            //cache result</span><br><span class="line">            table[number] = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        return table[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123; <span class="comment">// n &lt;= 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n + add(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><ul><li>按时间从小到大排序输出每个分数大于 60 分的人的姓名和对应分数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  A: &#123;</span><br><span class="line">    name: <span class="string">'aaa'</span>,</span><br><span class="line">    score: <span class="number">60</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2016 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  B: &#123;</span><br><span class="line">    name: <span class="string">'bbb'</span>,</span><br><span class="line">    score: <span class="number">50</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2017 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  C: &#123;</span><br><span class="line">    name: <span class="string">'ccc'</span>,</span><br><span class="line">    score: <span class="number">90</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2018 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  D: &#123;</span><br><span class="line">    name: <span class="string">'ddd'</span>,</span><br><span class="line">    score: <span class="number">80</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2014 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  E: &#123;</span><br><span class="line">    name: <span class="string">'eee'</span>,</span><br><span class="line">    score: <span class="number">81</span>,</span><br><span class="line">    time: <span class="string">'Mon May 15 2014 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.values(obj)</span><br><span class="line">  .filter(<span class="function">(<span class="params">&#123; score &#125;</span>) =&gt;</span> score &gt; <span class="number">60</span>)</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>(a.time).getTime() -<span class="keyword">new</span> <span class="built_in">Date</span>(b.time).getTime());</span><br></pre></td></tr></table></figure><ul><li>已知后台返回树形数据如下所示，将其处理为一个树形结构。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">56</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">81</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">74</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">76</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">63</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">80</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">87</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">62</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">86</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>树形结构如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  id: <span class="number">74</span>,</span><br><span class="line">  parentId: <span class="literal">null</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">62</span>,</span><br><span class="line">      parentId: <span class="number">74</span></span><br><span class="line">      children: [</span><br><span class="line">      ...</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentEl</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i].id === id) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.parentId) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = findParentEl(el.parentId);</span><br><span class="line">  parentEl.children = [...(parentEl.children || []), el];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(root);</span><br></pre></td></tr></table></figure><p>以空间换时间，可将上面的算法时间复杂度由 O(n^2) 优化到 O(n)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idMap = data.reduce(<span class="function">(<span class="params">acc, el, i</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[el.id] = i;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.parentId) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = data[idMap[el.parentId]];</span><br><span class="line">  parentEl.children = [...(parentEl.children || []), el]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web 面试题</title>
      <link href="/2020/03/22/Interview-Web/"/>
      <url>/2020/03/22/Interview-Web/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><ul><li>Tab</li></ul><p>Tab效果的实现以及插件封装</p><ul><li><p>拖拽</p></li><li><p>轮播</p></li><li><p>对一个接口进行连续的 Ajax 请求时（比如 input 事件），怎么保证最后一次请求的有效性（不会被前面返回慢的请求覆盖）。（input 举例有问题，因为这个场景下用 debounce 就可以规避这个 bug）</p></li><li><p>怎么往后端提交数据格式为 queryString、JSON、JPG 的数据。</p></li><li><p>前后端分离</p></li></ul><p>会话保持、权限认证（会话校验）<br>前端数据管理</p><p>有一个场景：移动端单页应用中，有 A、B、C 三个页面，A 和 B 分别是带分页的列表页（滑动分页），C 是 A 的详情页。C 回 A，要求保存 A 的分页状态，A 与 B 切换不保存状态。</p><ul><li><p>实现 getElementsByClassName</p></li><li><p>如何实现仅加载可视区域内的图片</p></li></ul><ol><li>一个淘宝页面，你如何取得这个页面用到哪几种标签？</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tags = [];</span><br><span class="line"><span class="keyword">const</span> labelType = &#123;&#125;;</span><br><span class="line">tags.push.apply(tags, <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>));</span><br><span class="line">tags.forEach(<span class="function">(<span class="params">tag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (tag.nodeType == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (labelType[tag.nodeName] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      labelType[tag.nodeName] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      labelType[tag.nodeName] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(labelType);</span><br></pre></td></tr></table></figure><ul><li>查看一个网页的层次结构</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123; <span class="comment">// 可 Array.from 或 spread 先转为数组</span></span><br><span class="line">  item.style.outline = <span class="string">`1px solid #<span class="subst">$&#123;(~~(<span class="built_in">Math</span>.random() * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>))).toString(<span class="number">16</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>)).map(<span class="function">(<span class="params">&#123; tagName &#125;</span>) =&gt;</span> tagName.toLowerCase())));</span><br></pre></td></tr></table></figure><ol start="2"><li>从 URL 输入到页面展现发生了什么?</li></ol><p>请描述一下cookies，sessionStorage和localStorage的区别？</p><ol start="3"><li>事件冒泡和事件捕获</li></ol><p>事件委托</p><ol start="4"><li>跨域</li></ol><ol start="5"><li>JavaScript 事件模型</li></ol><p>原始事件模型，捕获型事件模型，冒泡事件模型，</p><p>原始事件模型就是ele.onclick=function(){}这种类型的事件模型</p><p>冒泡事件模型是指事件从事件的发生地（目标元素），一直向上传递，直到document，</p><p>捕获型则恰好相反，事件是从document向下传递，直到事件的发生地（目标元素）</p><p>IE是只支持冒泡事件模型的，下面是兼容各个浏览器的事件监听代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">EventUtil = &#123;</span><br><span class="line">    addListener: <span class="function"><span class="keyword">function</span>(<span class="params">target, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">            target.addEventListener(type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">            target.attach(<span class="string">"on"</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                handler.call(target);               <span class="comment">// 让handler中的this指向目标元素</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeListener: <span class="function"><span class="keyword">function</span>(<span class="params">target, type, handler</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target.removeEventListener) &#123;</span><br><span class="line">            target.removeEventListener(type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.detachEvent) &#123;</span><br><span class="line">            target.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;                         <span class="comment">// 获取事件对象</span></span><br><span class="line">        <span class="keyword">var</span> evt = <span class="built_in">window</span>.event || e;</span><br><span class="line">        <span class="keyword">return</span> evt;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;                        <span class="comment">// 获得目标对象</span></span><br><span class="line">        <span class="keyword">var</span> evt = EventUtil.getEvent(e);</span><br><span class="line">        <span class="keyword">var</span> target;</span><br><span class="line">        <span class="keyword">if</span> (evt.target) &#123; target = evt.target; &#125; <span class="keyword">else</span> &#123; target = evt.srcElement; &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;                  <span class="comment">// 停止冒泡</span></span><br><span class="line">        <span class="keyword">var</span> evt = EventUtil.getEvent(e);</span><br><span class="line">        <span class="keyword">if</span> (evt.stopPropagation) &#123; evt.stopPropagation(); &#125; <span class="keyword">else</span> &#123; evt.cancelBubble = <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;                    <span class="comment">// 阻值默认行为的发生</span></span><br><span class="line">        <span class="keyword">var</span> evt = EventUtil.getEvent(e);</span><br><span class="line">        <span class="keyword">if</span> (evt.preventDefault) &#123; evt.preventDefault(); &#125; <span class="keyword">else</span> &#123; e.returnValue = <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>websocket</p></li><li><p>web worker</p></li></ul><p>web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p><ul><li>缓存</li></ul><p>浏览器的缓存策略，啥是协商缓存？</p><ul><li>从用户在浏览器里面输入地址敲击回车到页面完全展示出来经历了哪些过程</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>为什么利用多个域名来提供网站资源会更有效</li></ul><p>###</p><ul><li>什么是会话 cookie,什么是持久cookie?</li></ul><p>cookie 是服务器返回的，指定了expire time（有效期）的是持久 cookie，没有指定的是会话 cookie。会话 cookie 存储在内存中，当浏览器关闭时，将删除，持久性 cookie 存储在磁盘中，在指定的到期日期，cookie 将从磁盘中删除。</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><ul><li>如何中断 Ajax 请求</li></ul><p>一种是设置超时时间让 ajax 自动断开，另一种是手动停止 ajax 请求，其核心是调用 XML 对象的 abort 方法，ajax.abort()</p><ul><li>跨域</li></ul><p>CORS</p><ul><li>json数据格式和xml格式的优劣</li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 节点创建、添加、移除、移动、复制、查找</p><ul><li>事件代理</li></ul><p>事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulEl.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">  <span class="keyword">if</span>(!!target &amp;&amp; target.nodeName.toUpperCase() === <span class="string">'LI'</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>浏览器渲染页面的一般过程</li></ul><p>1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。<br>2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。<br>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。<br>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。<br>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。<br>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><ul><li>优雅降级和渐进增强</li></ul><p>优雅降级和渐进增强是处理浏览器兼容性的一种原则，在保证低版本浏览器上功能不受影响下，在高版本浏览器中有更好的体验。</p><p>比如低版本浏览器中用 iframe 代替 ajax 做上传，又比如轮询和 websocket，又比如 border-radius。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML、CSS 面试题</title>
      <link href="/2020/03/03/Interview-HTML-CSS/"/>
      <url>/2020/03/03/Interview-HTML-CSS/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>通过 translate 来移动元素和用 left top 移动元素有何区别？分别有何优劣？<br>一个未知宽高的块元素如何在屏幕中水平垂直居中？说明原理</p><p>三列布局，中间宽度固定，两侧宽度自适应屏幕？说明原理<br>三列布局，中间自适应屏幕，两侧固定宽度，要求至少两种方式完成</p><a id="more"></a><p>解释一下 box-model：全部属性，各个属性取值类型，范围，计算值方式，负值作用，box-sizing概念。<br>BFC(Block Formatting Context)是什么？有哪些应用？<br>如何要求容器在宽度自由很缩的情况下，A/B/C的宽度始终是1:1:1，如何实现，写出两种方法（图略）。<br>实现A元素水平、垂直均相对于父元素居中（A若宽高已知、A高度未知）（图略）。</p><p>如何实现汉字两端对齐？比如 “用户名” 和 “密码” 对齐。</p><p>主流浏览器分别是什么内核：IE（Trident）、Firefox（Gecko）、Chrome（早期 Webkit，后来转到了自己的 Blink）、Safari（Webkit）、Opera（Presto）。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ul><li>可视化格式模型</li></ul><p>BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><p>触发条件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根元素</span><br><span class="line">position: absolute/fixed</span><br><span class="line">display: inline-block / table</span><br><span class="line">float 元素</span><br><span class="line">ovevflow !== visible</span><br></pre></td></tr></table></figure><p>规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属于同一个 BFC 的两个相邻 Box 垂直排列</span><br><span class="line">属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</span><br><span class="line">BFC 的区域不会与 float 的元素区域重叠</span><br><span class="line">计算 BFC 的高度时，浮动子元素也参与计算</span><br><span class="line">文字层不会被浮动层覆盖，环绕于周围</span><br></pre></td></tr></table></figure><ul><li>选择权的权重</li></ul><p><a href="https://www.w3.org/TR/selectors-3/#specificity" target="_blank" rel="noopener">选择器的权重</a>被分为三级 a.b.c，其中，通配符选择器 0，标签选择器、伪元素 1，类、伪类、属性选择器 10，id 选择器 100。</p><p>另外，inline style 优先级高于 style 和 link，被 !important 修饰的属性拥有最高的优先级。</p><p>有一个工具 <a href="https://github.com/keeganstreet/specificity" target="_blank" rel="noopener">specificity</a> 可以计算权重，可<a href="https://specificity.keegan.st/" target="_blank" rel="noopener">在线</a>使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* &#123;&#125; // 权重 0</span><br><span class="line">p em &#123;&#125; // 权重 2</span><br><span class="line">#wrap .waring &#123;&#125; // 权重 110 </span><br><span class="line">li:first-line &#123;&#125; // 权重 2</span><br><span class="line">ul ol+li &#123;&#125; // 权重 3</span><br><span class="line">h1+*[rel=up] &#123;&#125; // 权重 11（一个属性选择器，一个标签）</span><br><span class="line">a[id="a-02"] &#123;&#125; // 权重 11（一个属性选择器，一个标签）</span><br><span class="line">body #content .data img:hover &#123;&#125;// 权重 122</span><br><span class="line">p.note em.dark &#123;&#125; // 权重 22</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"green"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. 颜色是？<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"green"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>1. 颜色是？<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:not(.green)</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"><span class="selector-class">.green</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure><p>:not(.green) 伪选择器的“位”权重与 .green 是一样的，最后按顺序进行解析。</p><ul><li>盒模型</li></ul><p>盒模型的组成，由里向外 content、padding、border、margin。</p><p>box-sizing: content-box（默认）/border-box</p><p>margin collapse</p><p>一个div为margin-bottom:10px，一个div为margin-top:5px，为什么2个div之间的间距是10px而不是15px?</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>position</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relative、absolute、fixed 的定位原点</span><br></pre></td></tr></table></figure><p>不加 <code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code> 的 <code>absolute</code> 定位规则，相对于 normal flow 下自身的位置。</p><ul><li>float</li></ul><p>列举不同的清除浮动的技巧，并指出他们各自的使用场景</p><p>clear: both<br>BFC</p><ul><li>margin</li></ul><p>margin负值简单的几个应用</p><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>1rem、1em、1vw、1vh、1px 各自代表的含义？</p><p>rem 是全部的长度都相对于根元素 <code>&lt;html&gt;</code> 元素。通常做法是给 html 元素设置一个字体大小，然后其他元素的长度单位就为 rem。</p><p>em 相对于父元素字体大小</p><p>vw、vh 全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度。1vw 1vh 相当于屏幕宽度和高度的 1%。</p><p>px 像素（Pixel），相对长度单位。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul><li>一淘的九宫格面试题</li></ul><p>实现如图布局，border-width: 5px，格子大小是 50px*50px，hover 时边框变成红色，需要考虑 IE6+ 和语义化的结构。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;<span class="attribute">width</span>:<span class="number">140px</span>; <span class="attribute">height</span>:<span class="number">140px</span>; <span class="attribute">margin</span>:<span class="number">100px</span> auto;&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span>&#123;<span class="attribute">float</span>:left; <span class="attribute">width</span>:<span class="number">40px</span>; <span class="attribute">height</span>:<span class="number">40px</span>; <span class="attribute">margin</span>:<span class="number">0</span> -<span class="number">5px</span> -<span class="number">5px</span> <span class="number">0</span>; <span class="attribute">border</span>:<span class="number">5px</span> <span class="number">#ddd</span> solid;&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">position</span>:relative; <span class="attribute">z-index</span>:<span class="number">1</span>; <span class="attribute">border-color</span>:<span class="number">#75e700</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.box&gt;ul&gt;li*9</span><br></pre></td></tr></table></figure><ul><li>css 实现水平垂直居中</li></ul><p>水平居中</p><p>行内元素: text-align: center<br>块级元素: margin: 0 auto<br>position:absolute + left:50% + transform:translateX(-50%)<br>display:flex + justify-content: center<br>垂直居中</p><p>设置line-height 等于height<br>position：absolute + top:50% + transform:translateY(-50%)<br>display: flex + align-items: center<br>display: table+display:table-cell + vertical-align: middle;</p><p>已知宽高元素的上下左右居中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.outer&#123;position:relative; ...&#125;</span><br><span class="line">.inner&#123;position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; ...&#125;</span><br></pre></td></tr></table></figure><p>一个不定高度元素的垂直居中</p><p>方案有很多种：table-cell、vertical-align、flex…，transform 也是解法之一。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个mixin更方便使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> vertical-align&#123;</span><br><span class="line">  <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line">  <span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line">  <span class="selector-tag">transform</span><span class="selector-pseudo">:translateY(-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.element</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  @include vertical-align;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>圣杯布局和双飞燕（双飞翼）布局</li></ul><p>自适应宽度，左右两栏固定宽度，中间栏优先加载：浮动（双飞翼、圣杯）和绝对定位都可以解决。</p><ul><li><p>画三角形</p></li><li><p>box-shadow</p></li></ul><p>box-shadow 能够在 1 个 DOM 上画出任何图形了(其实都是位图的原理，比如 box-shadow 画的蒙娜丽莎)。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>BEM、OOCSS</p><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><p>postcss</p><h2 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h2><p>什么是 FOUC（无样式内容闪烁 Flash Of Unstyled Content）？如何避免<br>不要使用 @import 导入样式；只在 head 中引入样式，不在页面其他位置引入</p><p>超出容器的文字显示为省略号</p><p>CSS Sprite</p><p><a href="https://www.w3.org/" target="_blank" rel="noopener">https://www.w3.org/</a></p><p><a href="https://whatwg.org/" target="_blank" rel="noopener">https://whatwg.org/</a></p><p><a href="https://zhuanlan.zhihu.com/p/425615281" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/425615281</a></p><p><a href="https://www.zhihu.com/question/371400222/answer/1087761258" target="_blank" rel="noopener">https://www.zhihu.com/question/371400222/answer/1087761258</a></p><p><a href="https://www.zhihu.com/question/327705039/answer/705161602" target="_blank" rel="noopener">https://www.zhihu.com/question/327705039/answer/705161602</a></p><p>针对移动浏览器端开发页面，不期望用户放大屏幕，且要求“视口（viewport）”宽度等于屏幕宽度，视口高度等于设备高度，如何设置？<br>data-xxx 属性的作用是什么？</p><p>Doctype 的作用？什么时候浏览器的标准模式（standards mode）和怪异模式（quirks mode）</p><ul><li><p>Quirks Module、Standards Module</p></li><li><p>Inline Level Element、Block Level Element</p></li></ul><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>label</li></ul><h2 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h2><p>DOCTYPE的作用？如何触发严格模式与混杂模式，区分它们有何意义。</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><ul><li>语义化标签</li></ul><p>header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签</p><p>标签语义化的好处就是结构良好，便于阅读，方便威化，也有利于爬虫的查找，提高搜索率。</p><ul><li><p>嵌套规则</p></li><li><p>音视频元素</p></li></ul><p>video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。</p><ul><li>webstorage</li></ul><p>webstorage 是本地存储，存储在客户端，包括localeStorage和sessionStorage，比cookie的存储大小要大有8m，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，</p><ul><li>from</li></ul><p>form中的input可以设置为readonly和disable，请问2者有什么区别：readonly不可编辑，但可以选择和复制；值可以传递到后台，disabled不能编辑，不能复制，不能选择；值不可以传递到后台。</p><p>表单序列化和提交</p><ul><li>iframe</li></ul><p>iframe 有那些缺点？</p><ul><li>mete</li></ul><p>mete 元素的作用：用于指定关于HTML文档的信息。</p><ul><li>a</li></ul><p>在a页面点击一个连接b.html后如何将页面以无刷新的方式切换到b，且url为b.html，主要就是用HTML5里的history.pushState。</p><p>a 标签默样式：未被访问的链接带有下划线而且是蓝色的、已被访问的链接带有下划线而且是紫色的、活动链接带有下划线而且是红色的。</p><ul><li>img</li></ul><p>跨站脚本攻击<br>img 还可探测网速，做监控</p><p>iframe和img都是可以做异步的，如何用这两个元素做跨域传输.</p><ul><li>h1-h6</li></ul><p>h1~h6在搜索引擎爬行的时候，到底他们站什么样的地位</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开放性面试题</title>
      <link href="/2020/03/02/Interview-Open/"/>
      <url>/2020/03/02/Interview-Open/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>前端面试</p><ul><li>计算机网络：HTTP</li><li>数据结构与算法：</li><li>编程语言：JS、Node、CSS、HTML</li><li>Web：Web API、安全</li><li>经验：input 频繁发送请求、button 重复发送请求</li><li>工程化：构建, 规范, 模块化(这个其实算语言中，只是早期 js 不支持由工具支持了)</li><li>优化：</li><li>运维：linux、docker、nginx</li><li>项目管理：Git</li><li>产品、需求、业务：</li></ul><ul><li><p>自我介绍 工作经历 项目经历</p></li><li><p>介绍一下现在做的产品，前端在这个项目中的职责，有什么亮点和缺点需要优化的地方，碰到最难的问题是什么。</p></li><li><p>聊一聊 你觉得做的最有挑战性的(最自豪、最失败)的项目?</p></li></ul><p>Tips:</p><p>可以从以下几个方面回答</p><p>是什么项目<br>这个项目做的是什么, 能线上预览更好<br>涉及的技术栈<br>中间遇到了哪些问题，你是如何解决的<br>项目收益或者通过项目学到了什么</p><ul><li>简述如何设计一个能创建流程图的页面（类似visio，xmind）</li></ul><p>来自华为面试</p><p>有没有做过类似功能的页面，有的话，怎么改进？没有的话，讲讲思路。（我没有做过，因此接着问下面的问题）<br>基本功能（拖拽，连线）如何实现？<br>怎样变成可复用的插件？<br>如何实现扩展（考官未细指扩展的方向）？</p><p>对于一个大型网站静态页面的制作，谈谈你对HTML结构的设计、CSS样式表规划及重用性的思考。</p><ul><li>Web 前端技术的展望</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 面试题</title>
      <link href="/2020/03/01/Interview-Javascript/"/>
      <url>/2020/03/01/Interview-Javascript/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算符</li></ul><p>计算器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculator</span>(<span class="params">operator, value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isNumber(value1) || !isNumber(value2)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请输入数字！'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">      <span class="keyword">return</span> value1 + value2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">      <span class="keyword">return</span> value1 - value2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">      <span class="keyword">return</span> value1 * value2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">      <span class="keyword">if</span> (value2 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value1 / value2;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^\d+(\.\d+)?$/</span>.test(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return eval(</code>${value1} ${operator} ${value2}<code>)</code> 更简单。</p><ul><li>位运算符</li></ul><p><code>~</code>的作用是什么? <code>~4</code>的结果是多少？为什么?</p><p><code>~</code>操作符 转换成二进制后 取反数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 转成二进制</span><br><span class="line">00000000000000000000000000000100</span><br><span class="line">`~` 按位取反</span><br><span class="line">11111111111111111111111111111011</span><br><span class="line">-5</span><br></pre></td></tr></table></figure><a id="more"></a><p><a href="http://wjhsh.net/minorf-p-13225505.html" target="_blank" rel="noopener">http://wjhsh.net/minorf-p-13225505.html</a><br><a href="https://blog.csdn.net/yexudengzhidao/article/details/90242318" target="_blank" rel="noopener">https://blog.csdn.net/yexudengzhidao/article/details/90242318</a></p><p><code>~~</code> 取反再取反，可以将浮点数变成整数，类似 <code>Math.trunc</code>。</p><ul><li>!! 和 ,</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = !!<span class="string">'Hello'</span> + (!<span class="string">'world'</span>, !!<span class="string">'from here!!'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="number">2.</span>.valueOf() + (&#123;<span class="attr">z</span> : <span class="number">10</span>, <span class="attr">x</span> : <span class="number">20</span>&#125;).x);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure><p><code>2..valueOf()</code> 中用到两个点是因为JS对数字后面的第一个点识别为小数点，第二个点识别为运算符，<code>.valueOf()</code> 得出的结果是数字 2。</p><ul><li>typeof</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">typeof</span>(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// boolean</span></span><br><span class="line">result = <span class="keyword">typeof</span> <span class="keyword">typeof</span>(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// string</span></span><br><span class="line">result = <span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="keyword">typeof</span>(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//string</span></span><br></pre></td></tr></table></figure><ul><li>运算符优先级</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object1 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'object1'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'object2'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((object2 &gt; object1 +-- object1) + <span class="literal">true</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>object1</code> 和 <code>object2</code> 都是对象，所以运算的时候会调用 <code>valueOf</code> 方法，所以得到：<code>(2 &gt; 1 + --1) + true)</code>，<code>--1</code> 为前递减所以为 0，<code>2 &gt; 1</code> 为 true 得到：<code>(true + 0) + true)</code></p><p>布尔值在运算时会自动转为数字 true 转为 1 false 转为 0，得到：<code>(1+ 0) + 1)</code>，所以结果是 2。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;; </span><br><span class="line">a.x = a ;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// &#123;n: 2, x: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">var</span> b = a;  </span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x); <span class="comment">// &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>赋值运算顺序是从右往左的，<code>.</code> 是优先级最高的运算符，所以这行代码先计算了 <code>a.x</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.x           --&gt; A 对象 &#123;n: 1, x: undefined&#125;</span><br><span class="line">a = &#123;n: 2&#125;    --&gt; a 被重新赋值为一个新对象 B</span><br><span class="line">a.x = &#123;n: 2&#125;  --&gt; A 对象 &#123;n: 1, x: &#123;n: 2&#125;&#125;</span><br><span class="line"></span><br><span class="line">a.x           --&gt; 后面的 a 都是重新被赋值过的对象，没有 x 属性</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/liuzhaoting/articles/8659955.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuzhaoting/articles/8659955.html</a></p><ul><li>比较运算符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  d = <span class="string">'2'</span>,</span><br><span class="line">  e = <span class="string">'11'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([a == b, a === b, a &gt; c, a &lt; c, d &gt; e]); <span class="comment">// [false, false, false, true, true]</span></span><br></pre></td></tr></table></figure><p>引用类型在进行 <code>==</code>、<code>===</code> 比较运算时，比较的是引用。引用类型在进行 <code>&gt;</code>、<code>&lt;</code> 比较运算时，会转为原始类型的值，算法是先调用 <code>valueOf</code> 方法，如果返回的还是对象，再接着调用 <code>toString</code> 方法。字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].valueOf().toString(); <span class="comment">// '1,2,3'</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>].valueOf().toString(); <span class="comment">// '1,2,4'</span></span><br></pre></td></tr></table></figure><p>转换后比较字符串 ‘1,2,3’ 和 ‘1,2,4’ 即可。</p><p>字符串按照字典顺序进行比较。JavaScript 引擎内部首先比较首字符的 Unicode 码点，如果相等，再比较第二个字符的 Unicode 码点，以此类推。所以这里 <code>&#39;1,2,3&#39; &lt; &#39;1,2,4&#39;</code>，输出 true ，因为前面字符的 Unicode 码点都相等，所以最后比较 3 和 4 的码点。而 3 的 Unicode 码点是 51，4 的 Unicode 码点是 52，所以 <code>a &lt; c</code>。<code>&#39;2&#39; &gt; &#39;11&#39;</code> 同理。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li>打印 99 乘法表</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    table += <span class="string">`<span class="subst">$&#123;i&#125;</span>*<span class="subst">$&#123;j&#125;</span>=<span class="subst">$&#123;i * j&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  table += <span class="string">'\n'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(table);</span><br></pre></td></tr></table></figure><ul><li>for 循环的结构</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ([initialization]; [condition]; [final-expression])</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure><p>三个表达式都是可选的，其中 final-expression 是每次循环的最后执行的，执行时机是在下一次 condition 的计算之前。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j; j = arr[i++];) &#123; <span class="comment">// 改为 ++i，是另外一个结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(j); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'---------'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0; j = arr[0] = 1; 打印 1</span><br><span class="line">i = 1; j = arr[1] = 2; 打印 2</span><br><span class="line">i = 2; j = arr[2] = 3; 打印 3</span><br><span class="line">i = 3; j = arr[3] = undefined; undefined 转为 false 结束循环</span><br></pre></td></tr></table></figure><h2 id="Built-in-Object"><a href="#Built-in-Object" class="headerlink" title="Built-in Object"></a>Built-in Object</h2><ul><li>parseInt</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="built_in">parseInt</span>); <span class="comment">//  [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure><ul><li>Math</li></ul><p>在特定范围获取一个随机数</p><p>Math.floor(Math.random() * 可能值的总数 + 第一个可能值)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)  + min);</span><br></pre></td></tr></table></figure><ul><li>eval</li></ul><p><code>eval</code> 是什么，谈谈对它的理解</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>Javascript 数据类型有哪些？怎么类型判断</p></li><li><p>null 和 undefined 的区别</p></li><li><p>以下表达式的输出结果</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'100px'</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'100px'</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'12a83'</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="literal">NaN</span> * <span class="number">4</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">void</span>(<span class="number">0</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'5'</span> + <span class="number">4</span>; <span class="comment">// '54'</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="string">'4'</span> - <span class="number">3</span> <span class="comment">// 31</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + + <span class="string">'4'</span> - <span class="number">3</span> <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>; <span class="comment">// 'function'</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">' '</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">''</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>解析 URL</p></li><li><p>重写 toLowerCase</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.toLowerCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> ascii = <span class="keyword">this</span>.charCodeAt(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ascii &gt;=<span class="number">65</span> &amp;&amp; ascii &lt;= <span class="number">90</span>)&#123;</span><br><span class="line">      res += <span class="built_in">String</span>.fromCharCode(<span class="keyword">this</span>[i].charCodeAt(<span class="number">0</span>) + <span class="number">32</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res += <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCD'</span>.toLowerCase()); <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.toLowerCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/[A-Z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">0</span></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode($<span class="number">0.</span>charCodeAt(<span class="number">0</span>) + <span class="number">32</span>); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCD'</span>.toLowerCase()); <span class="comment">// abcd</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.toLowerCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dic = &#123;<span class="string">'A'</span>:<span class="string">'a'</span>, <span class="string">'B'</span>:<span class="string">'b'</span>, <span class="string">'C'</span>:<span class="string">'c'</span>, <span class="string">'D'</span>:<span class="string">'d'</span>, <span class="string">'......'</span> : <span class="string">'.....'</span>&#125;;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="string">''</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> word = <span class="keyword">this</span>[i];</span><br><span class="line">    res += dic[word] ? dic[word] : word;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'ABCD'</span>.toLowerCase());   <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure><ul><li>转驼峰</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'border-top-color'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCamelCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, ($<span class="number">0</span>, $<span class="number">1</span>) =&gt; $<span class="number">1.</span>toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toCamelCase(str); <span class="comment">// borderTopColor</span></span><br></pre></td></tr></table></figure><p>注：也可以 <code>split(&#39;-&#39;)</code> 为数组，<code>return index === 0 ? item : item[0].toUpperCase()+item.slice(1)</code> 处理完后再 <code>join</code> 回即可。</p><p>反过来驼峰转下划线一样 <code>/([A-Z])/g</code> <code>_${$1.toLowerCase()}</code>。</p><ul><li><p>编写一个方法，求一个字符串的字节长度</p></li><li><p>实现一个方法，该方法能够判断两个字符串是否匹配</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">isMatch(<span class="string">'something'</span>, <span class="string">'ginhtemos'</span>); <span class="comment">// true</span></span><br><span class="line">isMatch(<span class="string">'aaa'</span>, <span class="string">'aa'</span>); <span class="comment">// false</span></span><br><span class="line">isMatch(<span class="string">'abb'</span>, <span class="string">'baa'</span>); <span class="comment">// false</span></span><br><span class="line">isMatch(<span class="string">'hello'</span>, <span class="string">'olelh'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isMatch</span>(<span class="params">str1, str2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str1.split(<span class="string">''</span>).sort().join(<span class="string">''</span>) === str2.split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>挑选</li></ul><p>从数组中随机挑选一个除指定元素外的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">arr, except</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (arr.length - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> exceptIndex = arr.indexOf(except);</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  </span><br><span class="line">  arr.splice(exceptIndex, <span class="number">1</span>);</span><br><span class="line">  result = arr[randomIndex];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pick(arr, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure><ul><li>最大值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">Math</span>.max(...arr);</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span> , arr);</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'Math.max('</span> + arr.toString() + <span class="string">')'</span>);</span><br></pre></td></tr></table></figure><p>最小值同理。</p><ul><li>排序</li></ul><p>给 Object 数组按属性个数进行排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  id: <span class="number">111</span>,</span><br><span class="line">  price: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  id: <span class="number">222</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [obj1, obj2];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="built_in">Object</span>.keys(a).length - <span class="built_in">Object</span>.keys(b).length);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>原始位置 <code>[b, a]</code>，当对比函数返回正数，b 排在 a 的前面（即不动），返回负数，b 排在 a 的后面（交互位置），返回 0 不动。</p><ul><li>填充</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span>&#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  value: <span class="string">''</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>).fill(&#123;<span class="attr">value</span>: <span class="string">''</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>去重</li></ul><p>方法一：indexOf/includes</p><p>检查结果数组<br>也可用 find、findIndex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用 reduce 改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> list = [].concat(...arguments);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> list.reduce(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.includes(item) ? acc : [...acc, item];</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：下标</p><p>检查原始数组</p><p>检测数组项下标出现的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前元素是第一次出现</span></span><br><span class="line">    <span class="keyword">if</span> (index === arr.indexOf(item)) &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可简写如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.indexOf(item) === index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检查原始数组–删除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arr.length 没有保存，会自动更新长度</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.indexOf(arr[i]) !== i) &#123;</span><br><span class="line">      arr.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：双重循环</p><p>检查结果数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 检查结果数组</span></span><br><span class="line">    <span class="keyword">let</span> isRepeat = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[j] === arr[i]) &#123;</span><br><span class="line">        isRepeat = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepeat) &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查原始数组–双重循环对比–删除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="comment">// 检查是否重复</span></span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        <span class="comment">// 重复就将后面元素从数组中删除</span></span><br><span class="line">        arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// splice方法会改变数组长度，所以要将数组长度 len 和下标 j 减一</span></span><br><span class="line">        <span class="comment">// arr.length 不保存到 len，就不用 len-- 了，</span></span><br><span class="line">        len--;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：splice 的元素可以收集起来，这样就知道了那些元素是重复元素了。</p><p>方法四：排序</p><p>先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。<br>注：这种方法的缺点—因为在去重前进行了排序，所以最后返回的去重结果也是排序后的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// sort 是 mutable 的，不用保存</span></span><br><span class="line">  arr.sort();</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序后，如果有重复，删除重复元素<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.sort();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">      arr.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方法五：Set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr)); <span class="comment">// 可简写为 [...new Set(arr)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法六：Object/Map 键值对</p><p>上面的 indexOf/includes、双重循环 ===、排序 ===、Set 方法只支持基础类型，如果要支持复杂数据类型的去重，则需用 Object/Map 键值对方法。</p><p>检查中间对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'1'</span>, <span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>], [<span class="number">1</span>], &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="string">'1'</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unique = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> temp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// arr[i] 数组项不能直接往 temp 中存，对象字面量的key都是字符串，数字也会被转为字符串，这样就无法区分 "1" 和 1 了，如果想支持复杂类型可用 typeof(arr[i]) + JSON.stringify(arr[i])</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="keyword">typeof</span>(arr[i]) + arr[i];</span><br><span class="line">    <span class="keyword">if</span> (!temp[key]) &#123;</span><br><span class="line">      temp[key] = <span class="literal">true</span>;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检查中间对象 – Map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !seen.has(item) &amp;&amp; seen.set(item, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item);</span><br><span class="line">    <span class="keyword">return</span> !seen.has(key) &amp;&amp; seen.set(key, <span class="number">1</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item);</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(key) ? <span class="literal">false</span> : (obj[key] = <span class="literal">true</span>); <span class="comment">// 可使用短路运算</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：JSON.stringify 也只支持 JSON 通用数据类型，NaN、Infinity、undefined、function 等 JS 特殊类型不支持。</p><ul><li>扁平</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">6</span>], <span class="number">5</span>]]]];</span><br><span class="line">arr.flat(<span class="literal">Infinity</span>); <span class="comment">// 深度默认 1，Infinity 表示不限深度</span></span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flat(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, item</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(item) ? flat(item) : item);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>JSON 字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flat = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(arr);</span><br><span class="line">  str = str.replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>);</span><br><span class="line">  str = <span class="string">`[<span class="subst">$&#123;str&#125;</span>]`</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.toString().split(<span class="string">','</span>);</span><br></pre></td></tr></table></figure><ul><li>转对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'watermelon'</span>];</span><br><span class="line"><span class="keyword">var</span> fruitsObj = &#123;...fruits&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(fruitsObj);</span><br></pre></td></tr></table></figure><ul><li>求交集</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> duplicatedValues = [...new <span class="built_in">Set</span>(arr1)].filter(<span class="function"><span class="params">item</span> =&gt;</span> arr2.includes(item));</span><br><span class="line"><span class="built_in">console</span>.log(duplicatedValues);</span><br></pre></td></tr></table></figure><ul><li>删除假值</li></ul><p>在 JavaScript 中，假值是 <code>false</code>、<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>NaN</code>、<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="string">'blue'</span>, <span class="string">''</span>, <span class="literal">NaN</span>, <span class="number">9</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="string">'white'</span>, <span class="literal">false</span>];</span><br><span class="line"><span class="keyword">var</span> trueArr = arr.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log(trueArr); <span class="comment">// ['blue', 9, true, 'white']</span></span><br></pre></td></tr></table></figure><ul><li>ArrayLike</li></ul><p>ArrayLike Object（伪数组/类数组对象）指的是拥有 length 属性，值能够被索引（使用数字作为属性名），但是不支持数组原生方法的对象，常见的 ArrayLike 有 Argument、NodeList、HTMLCollection。</p><p>用 TypeScript 接口可描述为。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArrayLike &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">any</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪数组转数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">[...arrayLike];</span><br><span class="line">[].slice.call(arrayLike)</span><br></pre></td></tr></table></figure><ul><li>toString</li></ul><p>Array 对象覆盖了 Object 的 toString 方法。对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。</p><ul><li>splice</li></ul><p>语法：array.splice(start, deleteCount, item1, item2, …)，splice用来从数组中删除 items，不过 deleteCount 可以为 0</p><ul><li>深浅拷贝</li></ul><p>对象数组</p><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul><li><p>正则实现验证身份证的验证</p></li><li><p>封装一个函数正则匹配获取当前页面中的 class 类名</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClassName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [];</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>).innerHTML;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/class=['|"]?([\w+\s]+)['|"]?/g</span>;</span><br><span class="line">  str.replace(reg, ($<span class="number">0</span>, $<span class="number">1</span>) =&gt; &#123;</span><br><span class="line">    arr.push($<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数中的 arguments 是什么？是数组吗？若不是，如何将它转化为真正的数组？</p></li><li><p>参数的求值策略</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'jirengu'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">age</span>: <span class="number">2</span>&#125;;</span><br><span class="line">swap(obj1, obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: 'jirengu'&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;age: 2&#125;</span></span><br></pre></td></tr></table></figure><ul><li>Hosting</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>hosting阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">--- a = undefined</span><br><span class="line">--- function foo</span><br><span class="line">local</span><br><span class="line">--- a = undefined</span><br></pre></td></tr></table></figure><p>执行阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">foo()</span><br><span class="line">--- foo local:</span><br><span class="line">------ a = 100</span><br><span class="line">------ console.log(a)         // 100</span><br><span class="line">------ console.log(this.a)    // 10</span><br><span class="line">------ console.log(a)         // 100</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 函数声明改为函数表达式结果会不一样</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">  &#125;;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 20、30</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi() + <span class="number">10</span>); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">sayHi();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = a + <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// NaN、NaN</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(sayHi() + <span class="number">10</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><ul><li>词法作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 5</span></span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  fn3();</span><br><span class="line">  fn2();</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 6</span></span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)  <span class="comment">// 1</span></span><br><span class="line">  a = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(++a); <span class="comment">// NaN</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(++a); <span class="comment">// 6</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 100</span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><ul><li>闭包</li></ul><p>什么是闭包，有哪些作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getValue() &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.getValue(); <span class="comment">// 1</span></span><br><span class="line">foo.getValue(); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bar'</span>, n);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = foo();    </span><br><span class="line"><span class="keyword">var</span> result2 = foo();    </span><br><span class="line"></span><br><span class="line">result1(); <span class="comment">// 999</span></span><br><span class="line">result2(); <span class="comment">// 999</span></span><br><span class="line">bar();  <span class="comment">// 它实际上操作的是result2的闭包作用域</span></span><br><span class="line">result1(); <span class="comment">// 999</span></span><br><span class="line">result2(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>要想打印出期望值，既可以使用 <code>let</code> 声明局部作用域变量，也可使用闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; link.length; i++) &#123;</span><br><span class="line">  link[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想打印出期望值可使用 let，或者闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; link.length; i++) &#123;</span><br><span class="line">  link[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包在外面也行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  link[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">  &#125;,<span class="literal">false</span>);</span><br><span class="line">&#125;)(i);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> j = i;</span><br><span class="line">  link[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(j);</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>科里化</li></ul><p>请实现以下函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">//运行结果为 7</span></span><br><span class="line">add(<span class="number">2</span>)(<span class="number">5</span>); <span class="comment">//运行结果为 7</span></span><br></pre></td></tr></table></figure><p>如果仅仅只是针对此题，其实只需要实现一层连式调用即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123; <span class="comment">// 实参的个数，add.length 行参个数 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果不需要支持多参数，直接这样就可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> a + b + c;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>继承的实现和原理</li></ul><p>多重继承</p><ul><li><p>new 操作符具体干了什么</p></li><li><p>原型链</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">var b = Object.prototype;</span><br><span class="line">[a.prototype === b, Object.getPrototypeOf(a) === b];</span><br></pre></td></tr></table></figure><ul><li>实现如下语法的功能：var a = (5).plus(3).minus(6)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.plus =  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span>  + a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>.prototype.minus =  <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">this</span>  - a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  a = (<span class="number">5</span>).plus(<span class="number">3</span>).minus(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.length); <span class="comment">// 10、1 和 10、2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">5</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>](); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.method(fn);</span><br><span class="line">obj.method(fn, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  scope: <span class="string">'inner'</span>,</span><br><span class="line">  getScope: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.scope)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getScope(); <span class="comment">// inner</span></span><br><span class="line"><span class="keyword">var</span> getScope = obj.getScope;</span><br><span class="line">getScope(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wahaha = <span class="string">'哇哈哈'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(wahaha);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.wahaha);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wahaha = <span class="keyword">new</span> ClassA();</span><br><span class="line">ClassA();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName(); <span class="comment">// 2</span></span><br><span class="line">getName(); <span class="comment">// 4</span></span><br><span class="line">Foo().getName(); <span class="comment">// 1</span></span><br><span class="line">getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> a() <span class="keyword">instanceof</span> a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>new</code> 操作符会隐式 <code>return this</code>，但此例显式 <code>return a</code> 了，得到的不是 a 的实例，而是 a 本身。</p><ul><li>继承</li></ul><p>继承的几种方式及优缺点</p><ul><li><p>Function 中的 call、apply、bind 的区别是什么</p></li><li><p>写一个函数 isEmptyObject，判断一个对象是不是空对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo...</span></span><br><span class="line">&#125;</span><br><span class="line">isEmptyObject(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line">isEmptyObject(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">    　  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  　&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'obj need to be an object'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj) === <span class="built_in">JSON</span>.stringify(&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj.constructor === <span class="built_in">Object</span> &amp;&amp; <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul><li><p>同步和异步的区别</p></li><li><p>循环中的异步</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 10 个 10</span></span><br><span class="line">  &#125;, <span class="number">0</span>);  <span class="comment">// time 可改为 i * 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望打印出 0-9，除了使用 <code>let</code> 外，还可以使用闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> j = i;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(end - start);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt; <span class="number">2000</span>); <span class="comment">// 1000 与 2000 对调试试</span></span><br></pre></td></tr></table></figure><p>delay 参数不是指多少秒后执行，而是多少秒后放入 EventLoop，callback 具体什么时候执行，既要看同步代码堵塞情况，又要看 EventLoop 排队情况。</p><ul><li>宏任务和微任务</li></ul><p>宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。<br>微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。<br>宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>CommonJs，AMD，CMD，ES Module</p><p>export和export default的区别</p><p>谈谈对前端模块化的理解</p><p>前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范，最后出现了webpack，webpack就是前端模块话的一种解决方案，基本上大公司都会使用webpack，想要详细的学习webpack的话请看webpack简明使用教程</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>ES5中“严格模式”与“非严格模式”的区别</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XSS 和 CSRF</title>
      <link href="/2019/12/25/XSS/"/>
      <url>/2019/12/25/XSS/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Cross-site scripting 的英文首字母缩写本应为 CSS，但因为 CSS 在网页设计领域已经被广泛指层叠样式表（Cascading Style Sheets），所以将 Cross（意为“交叉”）改以交叉形的 X 做为缩写。</p><a id="more"></a><p>XSS，即 cross site script，跨站脚本攻击，缩写原本为 CSS，但为了和层叠样式表（Cascading Style Sheet）区分，所以将 Cross（意为“交叉”）改以交叉形的 X 做为缩写。</p><p>XSS 攻击是指攻击者在网站上注入恶意脚本，使用户在浏览使用网页时进行恶意操作，注入脚本除了 JavaScript，还会有 CSS、HTML 等等。</p><p><a href="https://www.zhihu.com/question/34445731" target="_blank" rel="noopener">https://www.zhihu.com/question/34445731</a><br><a href="https://www.cnblogs.com/guolao/p/10530536.html" target="_blank" rel="noopener">https://www.cnblogs.com/guolao/p/10530536.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a><br><a href="https://www.zhihu.com/question/34445731" target="_blank" rel="noopener">https://www.zhihu.com/question/34445731</a><br><a href="https://www.zhihu.com/question/20142673" target="_blank" rel="noopener">https://www.zhihu.com/question/20142673</a></p><p><a href="https://blog.csdn.net/qq_41783309/article/details/80615909" target="_blank" rel="noopener">https://blog.csdn.net/qq_41783309/article/details/80615909</a><br><a href="https://www.cnblogs.com/zhang293/p/7868744.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhang293/p/7868744.html</a><br><a href="https://bbs.ichunqiu.com/thread-18129-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-18129-1-1.html</a><br><a href="https://www.zhihu.com/question/26628342" target="_blank" rel="noopener">https://www.zhihu.com/question/26628342</a><br><a href="https://netsecurity.51cto.com/article/591271.html?pc" target="_blank" rel="noopener">https://netsecurity.51cto.com/article/591271.html?pc</a><br><a href="https://www.jianshu.com/p/a1aac8acb940" target="_blank" rel="noopener">https://www.jianshu.com/p/a1aac8acb940</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a><br><a href="http://niliu.me/articles/518.html#more-518" target="_blank" rel="noopener">http://niliu.me/articles/518.html#more-518</a><br><a href="https://coolshell.cn/articles/4914.html#comments" target="_blank" rel="noopener">https://coolshell.cn/articles/4914.html#comments</a></p><p><a href="https://www.secpulse.com/archives/63801.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/63801.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p><p>注入有很多方法，比如：表单提交，URL 参数，图片上传等等。</p><p>蚂蚁森林 self xss</p><p>因为HTTP是无状态的协议，所以，几乎所有的网站都会在你的浏览器上设置cookie来记录状态，以便在其多个网页切换中检查你的登录状态。而现在的浏览器的运行方式是多页面或多窗口运行，也就是说，你在同一个父进程下开的多个页面或窗口里都可以无偿和共享使用你登录状态的。</p><ul><li>反射型</li></ul><p>反射型 XSS，非持久化，需要欺骗用户自己去点击链接才能触发 XSS 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">domain.com?kw=alert(&apos;xss&apos;)</span><br><span class="line">domain.com?kw=&lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">domain.com?kw=&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br><span class="line">domain.com?kw=xss&gt;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&lt;?= $kw ?&gt;&lt;/div&gt;</span><br><span class="line">&lt;input value=&quot;&lt;?= $kw ?&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>反射型 XSS 常见位置如搜索栏、用户登录入口等。</p><ul><li>存储型</li></ul><p>存储型 XSS，XSS 代码是存储在服务器中持久化的，比如 IM、留言、文章、个人信息…，这种 XSS 比较危险。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=# onerror=&quot;alert(&apos;xss&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>注：innerHTML 中的 script 不会被执行。</p><ul><li>DOM Base</li></ul><p>这种 XSS 攻击的实现是通过对DOM树的修改而实现的</p><p>DOM XSS 是由于浏览器解析机制导致的漏洞，服务器不参与，而存储型与反射型都需要服务器响应参与</p><p>存储型 XSS 也好，反射型 XSS 也罢，XSS 的本质问题就是让对方浏览器执行你插入的 JS。</p><h3 id="XSS-和-CSRF-区别"><a href="#XSS-和-CSRF-区别" class="headerlink" title="XSS 和 CSRF 区别"></a>XSS 和 CSRF 区别</h3><p>xss 强调的是 html、javascript 注入(innerHTML 的 script、img…，eval new Function 的 javascript)，而 csrf 只会实施一个请求某资源（接口）的操作</p><p>具体表现上：xss 是盗 cookie 干坏事，而 csrf 是借 cookie 干坏事</p><p>一般情况下，CSRF 需要服务端程序员来防范，XSS 需要客户端程序员来防范（如果 View 由服务端渲染则由服务端程序员防范）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EditorConfig-ESlint-Prettier</title>
      <link href="/2019/11/10/EditorConfig-ESlint-Prettier/"/>
      <url>/2019/11/10/EditorConfig-ESlint-Prettier/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p><a href="https://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a> 是编辑器/IDE 配置工具，需要编辑器/IDE 支持，在 VSCode 上可通过 EditorConfig for VS Code 插件支持。</p><a id="more"></a><p>.editorconfig 配置：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>indent_style</td><td>缩进风格，tab、space</td></tr><tr><td>indent_size</td><td>缩进为 space 时，缩进的字符数</td></tr><tr><td>tab_width</td><td>缩进为 tab 时，缩进的宽度</td></tr><tr><td>end_of_line</td><td>换行符类型，lf、cr、crlf</td></tr><tr><td>charset</td><td>文件的 charset，latin1、utf-8、utf-8-bom、utf-16be、utf-16le</td></tr><tr><td>trim_trailing_whitespace</td><td>是否将行位空格自动删除</td></tr><tr><td>insert_final_newline</td><td>是否使文件以一个空白行结尾</td></tr><tr><td>root</td><td>表示是最顶层的配置文件，发现值为 true 时，才会停止查找 .editorconfig 文件</td></tr></tbody></table><h2 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h2><p>JavaScript 作为一门动态弱类型语言，没有静态类型检测且允许隐式类型转换，虽然语法简洁自由，但是失去编译器的静态检测也带来了代码质量问题，另外 JavaScript 在设计上存在一些糟粕，比如 var、eval、++/–、with…，为保证代码质量，对代码进行类型、风格、语法和逻辑静态检测是非常重要的。</p><p>类型的检测可交由 TypeScript，风格和语法的检测则需要使用 linter。</p><p>对代码风格、语法规则和逻辑进行静态检测，目的是为了统一代码风格和避免语法和逻辑错误。最早的 JavaScript 代码检测工具是 JSLint，由 Douglas Crockford 开发，其规则不可配置，JSHint 继承自 JSLint，支持规则的可配置性，ESLint 是一个基于 AST 的 lint，由 Nicholas C. Zakas 开发，支持规则的可配置性、自定义插件和自定义解析器。</p><p>ESlint 提供自定义解析器和插件，极大的丰富了其适用范围，不但能 lint 各版本标准的 ES 语法，还能 lint 实验性和非标准语法（比如 Flow 和 TypeScript），这种设计使得他能快速的响应变化。</p><p>ESLint 的默认解析器和核心规则仅支持标准的 ECMAScript 语法，不支持 Babel 提供的实验性（例如新功能）和非标准（例如Flow或TypeScript类型）语法（Babel 的生态已经超出了 ES 标准）。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>常见内置的规则有：</p><p>语法规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no-undef</span><br><span class="line">no-const-assign</span><br><span class="line">require-await</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for-direction 无限循环</span><br></pre></td></tr></table></figure><p>推荐建议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eqeqeq</span><br><span class="line">no-var</span><br><span class="line">no-unused-vars</span><br></pre></td></tr></table></figure><p>代码风格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max-len</span><br><span class="line">no-mixed-spaces-and-tabs</span><br><span class="line">keyword-spacing</span><br><span class="line">comma-style</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><ul><li>Espree</li></ul><p>ESlint 使用解析器（parser）将代码解析成抽象语法树 (AST)，然后通过 AST 来分析代码。默认 AST 解析器为 <a href="https://github.com/eslint/espree" target="_blank" rel="noopener">Espree</a>，只支持标准 ES 语法和 JSX，不支持 Babel 提供的实验性和非标准（例如 Flow、TypeScript）语法。</p><ul><li>@babel/eslint-parser</li></ul><p>@babel/eslint-parser（babel-eslint） 是 Babel 源代码的解析器。</p><ul><li>@typescript-eslint/parser</li></ul><p>2019 年 TypeScript 官方配套的 TS 代码检测工具 TSLint 被弃用后，TypeScript 提供了此解析器用于将 TypeScript AST 转换成为 ESTree AST，使得 ESLint 能支持 TypeScript。</p><p>TypeScript Compiler 转化出来的 AST 与 ESLint 的 AST（ESTree，AST 的某一种规范）不兼容，@typescript-eslint/parser 会读取 ESLint 的配置，并调用 @typescript-eslint/typescript-estree 包用 TypeScript Compiler 将 TypeScript 的 sourcecode 转换为 TypeScript AST，然后将 TypeScript AST 转换为 ESTree。</p><p>TypeScript 中使用 ESlint 有两种方案 @typescript-eslint/parser 和 @babel/eslint-parser。</p><p>@typescript-eslint/parser 解析器下，ESlint 能校验 TS 语法，但是 Babel 生态下的新特性将不会被解析，会被误判为 Error。@babel/eslint-parser 解析器下，ESLint 不会校验任何的 TS 语法，而是将 TS 特性消除掉后基于 JS 的规则校验，要想在此方案下校验 TS 语法，可以用 VSCode，VSCode 对 TS 的支持非常友好，它会自动的提示 TS 错误，也可以额外的开启一个进程，用 tsc 检测 TS 语法。</p><ul><li>vue-eslint-parser</li></ul><p><a href="https://github.com/vuejs/vue-eslint-parser" target="_blank" rel="noopener">vue-eslint-parser</a> 被用来解析 .vue 文件中的 <code>&lt;template&gt;</code>，配套 <a href="https://eslint.vuejs.org/" target="_blank" rel="noopener">eslint-plugin-vue</a> 插件和<a href="https://eslint.vuejs.org/rules/" target="_blank" rel="noopener">规则集</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Plugins 插件用来为 ESlint 新增自定义检测规则，比如自定义 React、Vue、TypeScript 的检测规则，命名规则为 eslint-plugin-xxx 或 @scopeName/eslint-plugin。</p><p>常用的插件有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@babel/eslint-plugin（eslint-plugin-babel）为 @babel/eslint-parser 的配套 babel 源码规则</span><br><span class="line">eslint-plugin-react 为 ESLint 添加了一系列特定于 React 的规则</span><br><span class="line">@typescript-eslint/eslint-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;plugins&quot;: [</span><br><span class="line">    &quot;react&quot; // eslint-plugin-react，eslint-plugin- 的前缀可以省略</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注：plugins 只是指定规则，规则的开启还需要通过 rules 或 extends。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">  &apos;eslint-plugin-react/jsx-boolean-value&apos;: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &apos;eslint-plugin-react/recommended&apos;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line">&quot;extends&quot;: [</span><br><span class="line">  &quot;plugin:react/recommended&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>plugin 中的规则会对指定的 AST 节点做出校验，confings 字段可配置规则，一般的插件会自带两种最佳实践配置 all 以及 recommened。自定义 plugin 格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  meta: &#123;</span><br><span class="line">    docs: &#123;</span><br><span class="line">      description: &apos;一个方法的参数最大数量不能超过3个&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  create: function (context) &#123;</span><br><span class="line">    function getFunctionParamsLoc(node) &#123;</span><br><span class="line">      const paramsLength = node.params.length;</span><br><span class="line">      return &#123;</span><br><span class="line">        start: node.params[0].loc.start,</span><br><span class="line">        end: node.params[paramsLength - 1].loc.end,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      FunctionDeclaration: (node) =&gt; &#123;</span><br><span class="line">        if (node?.params?.length &gt; 3) &#123;</span><br><span class="line">          context.report(&#123;</span><br><span class="line">            loc: getFunctionParamsLoc(node),</span><br><span class="line">            node,</span><br><span class="line">            message: &apos;一个方法的参数最大数量不能超过3个&apos;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>env</li></ul><p>env 用来指定环境，设定能够解析的全局变量。不同环境下，存在不同的全局变量，如果代码运行在浏览器上，那 window 就是全局变量，在 nodejs 上，那 process 就是全局变量。如果不配置环境，ESLint 在遇到这些变量的时候，会认为这些变量没有定义，触发 no-undef 规则。</p><p>官网的 <a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments" target="_blank" rel="noopener">Specifying Environments</a> 上列出了 ESLint 能配置的全部环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">browser - 浏览器环境中的全局变量</span><br><span class="line">node - Node.js 全局变量和 Node.js 作用域</span><br><span class="line">es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>globals</li></ul><p>globals 也是用来设定能够解析的自定义全局变量的，作用跟 env 类似。比如 env 没有微信小程序环境，这是可通过 globals 单个配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">globals: &#123;</span><br><span class="line">  wx: true, // true 表示该变量为 writeable，而 false 表示 readonly</span><br><span class="line">  App: true,</span><br><span class="line">  Page: true,</span><br><span class="line">  Component: true,</span><br><span class="line">  getApp: true,</span><br><span class="line">  getCurrentPages: true,</span><br><span class="line">  Behavior: true,</span><br><span class="line">  global: true,</span><br><span class="line">  __wxConfig: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>rules</li></ul><p>rules 用来配置规则。ESLint 中的规则很多，但是默认都不会开启，需要在 rules 中设定这些规则开关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">off 或 0：关闭规则</span><br><span class="line">warn 或 1：开启规则（warn 级别的错误）</span><br><span class="line">error 或 2：开启规则（error 级别的错误）</span><br></pre></td></tr></table></figure><ul><li>extends</li></ul><p>rules 逐条配置规则非常繁琐，因此 ESLint 设计了 extends 这个字段，用于继承别的已经配置好的的规则。在不加入任何插件的情况下，extends 可以配置为 <code>eslint: recommended</code> 或 <code>eslint: all</code>，recommended 是 ESLint 官方推荐的配置（即带对勾标记的规则），校验的规则比较少，eslint: all 则会开启全部的规则校验。</p><p>extends 扩展支持三种类型的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;eslint: recommended&quot;, // all</span><br><span class="line">    &quot;eslint-config-standard&quot;, //  eslint-config-airbnb、@vue/eslint-config-airbnb，可缩写为 standard、airbnb、@vue/airbnb</span><br><span class="line">    &quot;plugin: react/recommended&quot;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eslint: xxx</code> 是 ESLint 官方配置包，一共有两个配置项 <code>recommended</code>、<code>all</code>。</p><p><code>eslint-config-xxx</code> <code>@scopeName/eslint-config-xxx</code> 是第三方 npm 配置包，可以简写 <code>xxx</code> 或 <code>@scopeName/xxx</code>，常用的有 <a href="https://github.com/standard/eslint-config-standard" target="_blank" rel="noopener">eslint-config-standard</a>、<a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">eslint-config-airbnb</a>、<a href="https://github.com/vuejs/eslint-config-airbnb" target="_blank" rel="noopener">@vue/eslint-config-airbnb</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  rules: &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plugin: xxx</code> 是插件内自带的配置包，也可以直接在 plugins 属性中进行设置，常用的有 <a href="https://github.com/jsx-eslint/eslint-plugin-react" target="_blank" rel="noopener">eslint-plugin-react</a> 规则自带两种配置方案 all 以及 recommened。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configs: &#123;</span><br><span class="line">    config1: &#123;</span><br><span class="line">      plugins: [&apos;myplugin&apos;],</span><br><span class="line">      rules: &#123;</span><br><span class="line">        &quot;myplugin/rule1&quot;: &quot;error&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    rule1: &#123;</span><br><span class="line">      create: function (context) &#123;</span><br><span class="line">        // rule implementation ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extends 是一个数组，可以配置多组规则，每个配置继承它前面的配置。实际开发中，我们会继承一些优秀的 ESLint 方案，比如 airbnb</p><ul><li>plugins</li></ul><p>见上面插件。</p><h3 id="与-VSCode-集成"><a href="#与-VSCode-集成" class="headerlink" title="与 VSCode 集成"></a>与 VSCode 集成</h3><p>ESlint npm 包是 Nodejs cli 工具，需要执行命令行才能 lint，而且 lint 信息只显示在命令行中，在 VSCode 中可通过 VSCode ESLint 插件（插件不是必需的）将 ESlint 集成至 VSCode，该插件会在项目启动的时候起一个后台任务，读取项目本地的 ESlint 配置，实时的检测代码，带来更直观的开发体验。</p><h2 id="Perttier"><a href="#Perttier" class="headerlink" title="Perttier"></a>Perttier</h2><p>ESlint 是代码检测工具，虽然 –fix 参数具有修复能力，能自动修复 max-len、no-mixed-spaces-and-tabs、keyword-spacing…等风格问题，但不能完全代替代码格式化工具，特别是换行，以下两段代码在 ESlint 中都是允许的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123;a, b, c&#125; = obj;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">a,</span><br><span class="line">  b,</span><br><span class="line">  c,</span><br><span class="line">&#125; = obj;</span><br></pre></td></tr></table></figure><p>Prettier 代码格式化工具，能保证代码风格的完全一致，其不但能格式化 JS，还能格式化 HTML、CSS、JSON、VUE、Angular、TypeScript、JSX…。</p><p>.prettierrc.js 配置说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 单行代码字符数限制</span><br><span class="line">  printWidth: 80, </span><br><span class="line">  // tab缩进大小,默认为2</span><br><span class="line">  tabWidth: 4,</span><br><span class="line">  // 使用tab缩进，默认false</span><br><span class="line">  useTabs: false,</span><br><span class="line">  // 使用分号, 默认true</span><br><span class="line">  semi: false,</span><br><span class="line">  // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)</span><br><span class="line">  singleQuote: false,</span><br><span class="line">  //仅仅当必须的时候才会加上双引号</span><br><span class="line">  quoteProps: &apos;as-needed&apos;,</span><br><span class="line">  // 行尾逗号,默认none,可选 none|es5|all</span><br><span class="line">  // es5 包括es5中的数组、对象</span><br><span class="line">  // all 包括函数对象等所有可选</span><br><span class="line">  trailingComma: &apos;all&apos;,</span><br><span class="line">  // 对象中的空格 默认true</span><br><span class="line">  // true: &#123; foo: bar &#125;</span><br><span class="line">  // false: &#123;foo: bar&#125;</span><br><span class="line">  bracketSpacing: true,</span><br><span class="line">  // JSX标签闭合位置 默认false</span><br><span class="line">  // false: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125;</span><br><span class="line">  //       &gt;</span><br><span class="line">  // true: &lt;div</span><br><span class="line">  //          className=&quot;&quot;</span><br><span class="line">  //          style=&#123;&#123;&#125;&#125; &gt;</span><br><span class="line">  jsxBracketSameLine: false,</span><br><span class="line">  // 箭头函数参数括号 默认avoid 可选 avoid| always</span><br><span class="line">  // avoid 能省略括号的时候就省略 例如x =&gt; x</span><br><span class="line">  // always 总是有括号</span><br><span class="line">  arrowParens: &apos;avoid&apos;,</span><br><span class="line">  // vue template 中的结束标签结尾尖括号掉到了下一行</span><br><span class="line">  htmlWhitespaceSensitivity: &apos;ignore&apos;, </span><br><span class="line">  // .vue 文件，不缩进 &lt;script&gt; 和 &lt;style&gt; 里的内容</span><br><span class="line">  vueIndentScriptAndStyle: false,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Prettier 和 ESlint 一起使用时，如果二者的格式化规则不一致会造成冲突，需要使用 eslint-config-prettier 来关闭 ESLint 中与 Prettier 冲突的规则，代码的格式化完全交给 Prettier。另外，还可通过 eslint-plugin-prettier 插件，将 Prettier 作为规则在 ESlint 中使用。</p><p>跟 ESlint 一样，Prettier 既可通过 npm 包，以工程化自动化方式使用，也可在 VSCode 中通过插件使用。</p><p>注：其实 VSCode 默认的代码格式化工具挺好用的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端开发规范</title>
      <link href="/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2019/10/05/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><ul><li>代码规范</li></ul><p>代码规范的可通过文档约定和 CodeRevice，但这主观性太强，不容易落地，最理想的方式还是在工程化层面，借助灵活配置的工具，工程化自动化的解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ESLint + Prettier: JavaScript/TypeScript/VUE/React 代码规范</span><br><span class="line">Stylelint: CSS 代码规范</span><br><span class="line">Editorconfig: 编辑器配置工具</span><br><span class="line">Prettier: 代码格式化工具</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/Yellow-ice/p/15346883.html" target="_blank" rel="noopener">https://www.cnblogs.com/Yellow-ice/p/15346883.html</a></p><ul><li>Git 规范</li></ul><p>Git 工作流规范（Husky + Commitlint + Lint-staged），提交规范（Commitizen）</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web 设计规范</title>
      <link href="/2019/10/02/Web-Design-Rule/"/>
      <url>/2019/10/02/Web-Design-Rule/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>其实有了 user-scalable=no，无需设置 minimum-scale 和 maximum-scale</p><h2 id="设计尺寸"><a href="#设计尺寸" class="headerlink" title="设计尺寸"></a>设计尺寸</h2><p>需要考虑，设计师设计视觉稿时使用什么样的宽度，才能既满足设计本身的需求又能让前端方便的还原与适配。</p><p>ui 设计稿按目标屏幕的分辨率做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># PC</span><br><span class="line">固定尺寸（1200）</span><br><span class="line">全屏尺寸</span><br><span class="line">  1440 中后台全屏设计，这样既可以向上照顾 1920，又可以向下照顾到 1366</span><br><span class="line">  1920 可视化全屏设计尺寸</span><br><span class="line"></span><br><span class="line"># 手机</span><br><span class="line">全屏尺寸</span><br><span class="line">  640</span><br><span class="line">  375（兼容流体？）</span><br><span class="line">  320</span><br><span class="line"></span><br><span class="line"># Pad</span><br><span class="line">2048</span><br><span class="line">1920</span><br></pre></td></tr></table></figure><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>颜色</li><li>字号</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据</title>
      <link href="/2019/07/01/Data/"/>
      <url>/2019/07/01/Data/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>主要讲 GUI 程序中数据的流程：数据采集–》数据处理–》数据应用（数据结构、数据类型，数据有哪些，另讲，DOM 算不算数据？不算吧，HTML 是一种标记语言，JS 和 HTML 的关系，只是两种语言间的关系，只是 JS 的 Web API 能操作 HTML，跟 NodeJS 能操作数据库关系一样）</p><p>注：JS 标准库其实也只能处理数据，应用于平台上才具有平台能力，JS 在浏览器中有操作 DOM 和 BOM 的能力（Web API），JS 在 Node 中有操作数据库和操作系统的能力。</p><p>跟人类大脑一样，计算机是用来处理数据的，数据是计算机的核心。处理需要用算法（广义），这也正好对应了程序 = 数据结构 + 算法之说。</p><h2 id="数据的消费和生产"><a href="#数据的消费和生产" class="headerlink" title="数据的消费和生产"></a>数据的消费和生产</h2><p>计算机数据的输入/采集设备，可通过键盘鼠标麦克风显示器，也可通过传感器和机械臂（机器人）</p><p>在 GUI 程序中（比如 Web），产生数据的两种方式：交互(click、input、change、mousemove…)生成，或接口返回</p><p>原生交互元素：form（包括 button、input…）、video、audio、canvas，当然也可以自定义交互组件，比如下拉按钮</p><p>数据生产时，生产的数据需要校验</p><p>关于数据的校验: 如果数据是由表单产生，由表单校验即可，如果是其他方式产生，一般提交时 toast 校验即可</p><p>生产数据很多时候都需要提前消费数据，比如选择学生，比如创建模板</p><p>数据消费时，如果接口返回的格式不能满足消费需求时，需要处理数据，生产同理</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>数据构造<br>数据转换(forEach、map、reduce)：<a href="https://segmentfault.com/a/1190000020221170" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020221170</a><br>后端数据结构转为前端数据结构，前端数据结构转为后端数据结构<br>空数据(缺省设置)，某个字段为空<br>排序、去重</p><p>数据的初始化不能用有业务意义的数据，比如分页数据的初始化不能使用 []（代表无数据），而应使用 null，否则会造成缺省提示的闪烁。</p><p>map、reduce 用来构造数据，every、some 用来验证数据</p><h2 id="数据应用"><a href="#数据应用" class="headerlink" title="数据应用"></a>数据应用</h2><p>电脑和手机中数据以文本、图片、音视频…的形式通过屏幕显示的方式来使用，供人类使用，机器人则通过机械臂。</p><p>计算机数据的输入/采集和输出设备，可通过键盘鼠标麦克风显示器，也可通过传感器和机械臂（机器人）</p><h2 id="最懂业务的人"><a href="#最懂业务的人" class="headerlink" title="最懂业务的人"></a>最懂业务的人</h2><p>数据库里数据是对业务（产品、需求）的最高抽象，所以服务端是最了解业务的人。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express</title>
      <link href="/2019/07/01/Express/"/>
      <url>/2019/07/01/Express/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Express</p><p><a href="https://juejin.cn/post/6844904023380721678" target="_blank" rel="noopener">https://juejin.cn/post/6844904023380721678</a><br><a href="https://juejin.cn/post/6844904198551666701" target="_blank" rel="noopener">https://juejin.cn/post/6844904198551666701</a><br><a href="https://juejin.cn/post/6914891222884564999" target="_blank" rel="noopener">https://juejin.cn/post/6914891222884564999</a></p><a id="more"></a><ul><li>async/await</li></ul><p><a href="https://juejin.cn/post/6935701501008412708" target="_blank" rel="noopener">https://juejin.cn/post/6935701501008412708</a><br><a href="https://blog.csdn.net/yuyongkun4519/article/details/85856619" target="_blank" rel="noopener">https://blog.csdn.net/yuyongkun4519/article/details/85856619</a><br><a href="https://segmentfault.com/a/1190000011462752" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011462752</a></p><ul><li>Express 和 Koa 区别</li></ul><p>区别在异步中间件的处理上，KOA 遵守的是严格的洋葱模型，Express 并非严格按照洋葱模型。</p><p><a href="https://juejin.cn/post/6844903968041091080" target="_blank" rel="noopener">https://juejin.cn/post/6844903968041091080</a><br><a href="https://blog.csdn.net/qq_43293207/article/details/116331223" target="_blank" rel="noopener">https://blog.csdn.net/qq_43293207/article/details/116331223</a></p><p>Express CMS<br>Express Blog</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM 私仓</title>
      <link href="/2019/07/01/Sinopia/"/>
      <url>/2019/07/01/Sinopia/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>npm 私仓可用于提高包的下载速度和保护内部代码，常见的 npm 私仓技术方案有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* npm on-site  # 缺点是收费，而且 npm 在国内访问慢</span><br><span class="line">* Git + SSH 直接引用到 GitHub 项目地址 # 缺点是不能更新（npm update），不能使用 Semver（语义化版本规范），而且 URL 不美观</span><br><span class="line">* cnpm</span><br><span class="line">* Sinopia/Verdaccio</span><br><span class="line">* Nexus</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Sinopia-Verdaccio"><a href="#Sinopia-Verdaccio" class="headerlink" title="Sinopia/Verdaccio"></a>Sinopia/Verdaccio</h2><p>Sinopia 是一个零配置的私有的带缓存功能的 npm 包管理工具。使用 Sinopia，不用安装 CouchDB 或 MYSQL 之类的数据库，Sinopia 有自己的迷你数据库，如果要下载的包不存在，它将自动去你配置的 npm 地址上去下载，而且硬盘中只缓存你现在过的包，以节省空间。</p><p>Sinopia 特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 不同步拉取 npm 库，占据大量硬盘，没有硬盘被撑爆的问题</span><br><span class="line">* 安装配置极其简单，不需要数据库</span><br><span class="line">* 支持配置上游 Registry 配置，一次拉取即缓存</span><br><span class="line">* 支持 Forever 及 Pm2 守护进程管理</span><br></pre></td></tr></table></figure><p>注意：由于 Sinopia 已经没人维护了，推荐使用 <a href="https://github.com/verdaccio/verdaccio" target="_blank" rel="noopener">Verdaccio</a>，Verdaccio 是 Sinopia 的 Fork，安装配置基本和 Sinopia 一致。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Sinopia 前，首先要确保已经安装 Node，Linux 下安装 Node 参考具体章节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sinopia -g</span><br></pre></td></tr></table></figure><p>Sinopia 目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 程序安装目录（全局安装目录在不同配置下会不一样）</span><br><span class="line">|-- /usr/sbin/nodejs/lib/node_modules/sinopia/</span><br><span class="line"></span><br><span class="line"># 配置和存储目录</span><br><span class="line">|-- /root/.config/sinopia/</span><br><span class="line">    |-- config.yaml  # 配置文件</span><br><span class="line">    |-- htpasswd     # 用户和密码信息</span><br><span class="line">    |-- storage      # 包存储位置（除了 publish 的私包，通过 npm install xx 安装的公共包也会缓存到这个目录，安装过的包再次安装时会直接从这个目录取）</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinopia</span><br></pre></td></tr></table></figure><p>启动成功后，会有下面两行提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warn  --- config file  - /root/.config/sinopia/config.yaml</span><br><span class="line">warn  --- http address - http://0.0.0.0:4873/</span><br></pre></td></tr></table></figure><p>上面一行是 Sinopia 的配置文件所在路径，下面一行是 Sinopia 服务的域名和端口号。然后打开 <code>http://localhost:4873</code>（可通过 curl），如果能正常访问，说明安装成功。</p><ul><li>网络访问</li></ul><p>默认情况下只能本机 <code>localhost:4873</code> 访问，如果想通过 IP 让其他机器也能访问到，需要在 <code>/root/.config/sinopia/config.yaml</code> 最后一行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen: 0.0.0.0:4873</span><br></pre></td></tr></table></figure><p>好了，再试一次 <code>192.168.10.14:4873</code>，成功访问。如果还不行，可能是防火墙导致，默认情况下防火墙没有开放 4873 端口，需要开放相应的端口。CentOS 6 和 CentOS 7 不一样，以 CentOS 6 为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进入编辑防火墙配置文件（修改 OUTPUT ACCEPT 下的内容）</span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 然后加上下面这句（作用是防止防火墙占用80端口）</span><br><span class="line">-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 再加上下面这一句（开放 4873 端口）</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 4873 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># 最后记得重启一下防火墙</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><ul><li>PM2 做守护进程</li></ul><p>Node 服务非常脆弱，一般在实际中使用都会配合守护进程。这里选用 PM2 做守护进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 全局安装 PM2</span><br><span class="line">npm install -g pm2</span><br><span class="line"></span><br><span class="line"># 通过 PM2 启动 Sinopia</span><br><span class="line">pm2 start `which sinopia`</span><br></pre></td></tr></table></figure><p>注：更多 PM2 操作指南参考相关文档。另外，如果想要结束 PM2 守护的 Sinopia 进程，可使用以下方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop sinopia    # 参数也可以是具体的 PM2 id（不是 pid），比如 pm2 stop 0</span><br></pre></td></tr></table></figure><p>也可以手动结束，操作步骤如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有进程</span><br><span class="line">ps -A</span><br><span class="line"></span><br><span class="line"># 查询结果如下</span><br><span class="line">3239 ?         00:00:31 watch</span><br><span class="line">6035 ?         00:00:11 PM2 v2.10.3: Go</span><br><span class="line">27690 ?        00:00:01 sinopia</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 杀掉 watch 和 sinopia 这两个进程</span><br><span class="line">kill 3239</span><br><span class="line">kill 27690</span><br></pre></td></tr></table></figure><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><h3 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the default config file. It allows all users to do anything,</span><br><span class="line"># so don&apos;t use it on production systems.</span><br><span class="line">#</span><br><span class="line"># Look here for more config file examples:</span><br><span class="line"># https://github.com/rlidwka/sinopia/tree/master/conf</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># path to a directory with all packages</span><br><span class="line">storage: ./storage                     # npm 包存放的路径（可以将将此目录指向其他目录）</span><br><span class="line"></span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd                   # 用于存储 npm 用户的账号和密码信息</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.</span><br><span class="line">    # You can set this to -1 to disable registration.</span><br><span class="line">    #max_users: 1000                   # 最大允许的用户数量，默认值为 1000，-1 则为禁止注册</span><br><span class="line"></span><br><span class="line"># a list of other known repositories we can talk to</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/   # 上游源，默认为 npm 的官网，可以使用淘宝的 npm 镜像地址</span><br><span class="line"></span><br><span class="line">packages:                              # 配置权限管理</span><br><span class="line">  &apos;@*/*&apos;:</span><br><span class="line">    # scoped packages</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装。$all 所有人，$authenticated 通过验证的人，$anonymous 匿名者</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line">    proxy: npmjs                       # 默认没有这项</span><br><span class="line">    </span><br><span class="line">  &apos;*&apos;:</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    #</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin)</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot;</span><br><span class="line">    access: $all                       # 表示哪一类用户可以对匹配的项目进行安装</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish packages</span><br><span class="line">    # (anyone can register by default, remember?)</span><br><span class="line">    publish: $authenticated            # 表示哪一类用户可以对匹配的项目进行发布</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &apos;npmjs&apos; registry</span><br><span class="line">    proxy: npmjs                       # 如其名，这里的值是对应于 uplinks</span><br><span class="line"></span><br><span class="line"># log settings</span><br><span class="line">logs:</span><br><span class="line">  - &#123;type: stdout, format: pretty, level: http&#125;</span><br><span class="line">  #- &#123;type: file, path: sinopia.log, level: info&#125;</span><br><span class="line"></span><br><span class="line">listen: 0.0.0.0:4873                   # 默认没有这项，只能在本机访问，添加后可以通过外网访问</span><br></pre></td></tr></table></figure><p>部分配置字段意义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">storage    # 仓库保存的路径</span><br><span class="line">auth       # 验证相关</span><br><span class="line">uplinks    # 配置上游的 npm 服务器，主要是用于请求的仓库不存在时去上游服务器拉取</span><br><span class="line">packages   # 配置模块/包的发布(publish)、下载(access)的权限等</span><br><span class="line">listen     # 配置监听端口与主机名</span><br></pre></td></tr></table></figure><ul><li>auth 配置</li></ul><p>max_users: -1 表示我们将最大用户数设置为－1，表示禁用 npm adduser 命令来创建用户，不过我们仍然可以通过当前目录下的 htpasswd 文件来初始化用户。</p><p>示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yorkie:&#123;SHA&#125;?????????????????=:autocreated 2016-02-05T15:33:46.238Z</span><br><span class="line">weflex:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T15:39:19.960Z</span><br><span class="line">james:&#123;SHA&#125;????????????????=:autocreated 2016-02-05T17:59:05.041Z</span><br></pre></td></tr></table></figure><p></p><p>上面的加密算法也很简单，就是简单的 SHA1 哈稀之后再转换成 Base64 输出就好，后面跟着的只是表示时间。</p><ul><li>packages 配置</li></ul><p>配置大致分为两个部分，一个是以 <code>@*/*</code> 为开头的，另一个则是通配符 <code>*</code>。</p><p>这个当然就是对 package.json 中的 name 字段进行匹配，比如 @<a href="mailto:webassemblyjs/ast@1.3.1" target="_blank" rel="noopener">webassemblyjs/ast@1.3.1</a> 将匹配第一个配置，而 express 则匹配第二个。这里这么配置的意义在于：一般团队或者公司的私有项目，会采用不同的权限控制，于是这里借用了 npm 的 scoped name 即 @company 的形式，例如 @weflex/app 即表示 WeFlex 下属的 app 项目了。</p><p>接下来，每一个命名过滤器（filter）下都有三项基本设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">access    # 表示哪一类用户可以对匹配的项目进行安装(install)</span><br><span class="line">publish   # 表示哪一类用户可以对匹配的项目进行发布(publish)</span><br><span class="line">proxy     # 如其名，这里的值是对应于 uplinks 的</span><br></pre></td></tr></table></figure><p>对于 1 和 2 的值，我们通常有以下一些可选的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$all            # 表示所有人都可以执行对应的操作</span><br><span class="line">$authenticated  # 表示只有通过验证的人可以执行对应操作</span><br><span class="line">$anonymous      # 表示只有匿名者可以进行对应操作（通常无用）</span><br></pre></td></tr></table></figure><p>或者也可以指定对应于之前我们配置的用户表 htpasswd 中的一个或多个用户，这样就明确地指定哪些用户可以执行匹配的操作。</p><ul><li>为 packages 中 <code>@*/*</code> 字段配置代理源</li></ul><p><code>&#39;@*/*&#39;</code> 下添加 <code>proxy: npmjs</code> 配置，给 scoped packages（<a href="https://docs.npmjs.com/misc/scope" target="_blank" rel="noopener">npm 官方的定义</a>） 添加代理源，使得能够安装 scoped packages 类型的包（比如 @<a href="mailto:webassemblyjs/ast@1.3.1" target="_blank" rel="noopener">webassemblyjs/ast@1.3.1</a>）。如果不配置此项，安装基本的包没有问题，但是，安装 scoped packages 包时，比如 webpack，会提示错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack</span><br><span class="line"></span><br><span class="line"># 出现以下错误</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found: @webassemblyjs/ast@1.3.1</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2018-05-09T06_26_23_190Z-debug.log</span><br></pre></td></tr></table></figure><p>这是在安装 @<a href="mailto:webassemblyjs/ast@1.3.1" target="_blank" rel="noopener">webassemblyjs/ast@1.3.1</a> 这个包时出的问题，sinopia 会提示 404。上面安装的包就是这类的包，常见的有 @angular @type 等。修改配置和代码后，重启 sinopia，这时再次安装就会提示成功。</p><p>如果还不成功，可能就是老版本 sinopia 的 bug 导致的（我这版中没出息这个问题），sinopia 每次向 npmjs 请求安装某个包时，请求地址都是转码后再向 npm 请求的，所以会将 @ 转码为 %40，但是 npm 不能识别 %40，所以导致 404 的错误。</p><p>这个时候只需要修改 sinopia 中的转码的地方就可以了。转码的文件是 up-storage.js,，修改 up-storage.js 中的 encode 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var encode = function (url) &#123;</span><br><span class="line">  return encodeURIComponent(url).replace(/^%40/, &apos;@&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><p>通过服务器来新建用户。服务器上将 registry 改为 <a href="http://localhost:4873：" target="_blank" rel="noopener">http://localhost:4873：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://localhost:4873</span><br></pre></td></tr></table></figure><p>然后添加用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://localhost:4873</span><br><span class="line"></span><br><span class="line"># 填写如下信息</span><br><span class="line">user: admin</span><br><span class="line">password: admin</span><br><span class="line">email: admin@admin.com</span><br></pre></td></tr></table></figure><p>这时 htpasswd(config.yaml 同目录) 文件下会生成相应的信息。</p><h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry http://192.168.10.14:4873        # 设置 npm 源</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser --registry http://192.168.10.14:4873  # 添加用户。如果不发布 npm 包，是不需要注册和登录的，登录 npm 是为了发布包</span><br><span class="line">npm login                                         # 登录 npm。注，npm adduser 成功的后默认就登陆了，所以不需要再 npm login</span><br><span class="line">npm whoami                                        # 检测身份</span><br></pre></td></tr></table></figure><p>注：推荐用 nrm 来管理 npm 源。具体的 nrm 操作查看 node 的 npm 相关章节。</p><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install xxx              # 选项有 --save (-S)、--save-dev (-D)、-g</span><br></pre></td></tr></table></figure><h3 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h3><p>切换到私有仓库，登录成功之后，就可以执行 npm publish 发布到这个私有 npm 上面啦，发布包的操作跟 npm 官方发布包无差别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login                    # 登录 npm</span><br><span class="line">npm publish                  # 发包</span><br><span class="line">npm unpublish --force test   # 撤销发布。撤销 test 这个包，如果是在当前包的根目录下操作，可以省略包名</span><br></pre></td></tr></table></figure><p>发布包注意事项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 包的名称和版本就是你项目里 package.json 里的 name 和 version，author 字段可以显示包的作者，为空则表示匿名</span><br><span class="line">* 不能和已有的包的名字重名，发布前可通过 npm 的查找是否已存在相同名称的包（npm search xxx）</span><br><span class="line">* npm 对包名的限制：不能有大写字母/空格/下滑线（testPublish、test_publish 都会又报错）</span><br></pre></td></tr></table></figure><h2 id="使用-Docker-安装-Verdaccio"><a href="#使用-Docker-安装-Verdaccio" class="headerlink" title="使用 Docker 安装 Verdaccio"></a>使用 Docker 安装 Verdaccio</h2><p>参考 Docker 安装 Verdaccio <a href="https://verdaccio.org/docs/en/docker.html" target="_blank" rel="noopener">文档</a>。</p><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull verdaccio/verdaccio    # 拉取 Verdaccio 的 Docker Image，不指定版本下，拉取的是 latest</span><br></pre></td></tr></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><ul><li>新建宿主机目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在宿主机上新建需要挂载到的目录（路径可自选）</span><br><span class="line">mkdir /home/kpg/verdaccio</span><br><span class="line">mkdir /home/kpg/verdaccio/conf</span><br><span class="line">mkdir /home/kpg/verdaccio/storage</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 拉取配置文件 config.yaml</span><br><span class="line">cd /home/kpg/verdaccio/conf</span><br><span class="line">git clone https://github.com/verdaccio/docker-examples</span><br><span class="line">mv docker-examples/docker-local-storage-volume/conf/config.yaml config.yaml</span><br><span class="line">rm -rf docker-examples    # config.yaml 复制好后，删除这个目录</span><br></pre></td></tr></table></figure><p>注：如果没有将 config.yaml 配置文件放在 <code>/home/kpg/verdaccio/conf/</code> 目录下，会导致浏览器将访问不了，<code>docker run</code> 看不出错误，只有通过 <code>docker logs</code> 查找日志，才能发现问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps                # 找到 verdaccio container id</span><br><span class="line">docker logs containerId  # 查找日志</span><br></pre></td></tr></table></figure><ul><li>设置宿主机目录权限</li></ul><p><code>mkdir verdaccio</code> 创建的目录属主是当前宿主机用户，而每个 docker container 都会运行在自建的用户上。所以要注意挂载目录的权限，要不然 <code>npm adduser</code> 和 <code>npm install</code> 无法写入，提示 500 服务器错误，查看容器日志会有下面这样的提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs --tail 20 verdaccio</span><br><span class="line">EACCES: permission denied, open &apos;/verdaccio/conf/htpasswd&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it verdaccio sh    # 进入容器查找容器的用户 ID（进入后 Shell 前缀变成了 ~）。直接在宿主机里面 cat /etc/passwd 查找不到</span><br><span class="line">whoami                          # 查看当前用户</span><br><span class="line">cat /etc/passwd                 # 找到当前用户的 User ID (10001) 和 Group ID (65533)。docker 容器中的 uid 和 gid 和宿主机是共享的，只是没有具体名称</span><br><span class="line">exit                            # 退出容器</span><br><span class="line">chown -R 10001:65533 verdaccio  # 在宿主机下设置目录权限。-R 表示递归设置</span><br></pre></td></tr></table></figure><ul><li>挂载宿主机目录</li></ul><p>可以在启动时通过 <code>-v</code> 将宿主机目录挂载到容器内目录，也可以通过 docker-compose.yml 来配置 volumes。</p><ul><li>配置 config.yaml</li></ul><p>基本配置参考上面，storage、htpasswd 要指向容器内目录，uplinks 可以使用淘宝 npm 私仓：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">storage: /verdaccio/storage</span><br><span class="line">auth:</span><br><span class="line">  htpasswd:</span><br><span class="line">    file: /verdaccio/conf/htpasswd</span><br><span class="line">uplinks:</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>如果将启动参数放在命令中，做成脚本文件来启动会更加方便（如果用 docker-compose 启动，将参数放在 docker-compose.yml 中也很方便）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name verdaccio \</span><br><span class="line">--restart always \</span><br><span class="line">-p 4873:4873 \</span><br><span class="line">-v /home/kpg/verdaccio/conf:/verdaccio/conf \</span><br><span class="line">-v /home/kpg/verdaccio/storage:/verdaccio/storage \</span><br><span class="line">-v /home/kpg/verdaccio/plugins:/verdaccio/plugins \</span><br><span class="line">verdaccio/verdaccio</span><br></pre></td></tr></table></figure><p><code>-v</code> 用于挂载宿主机的一个目录，<code>:</code> 前面的目录是宿主机目录，后面的目录是容器内目录。</p><ul><li>一个错误</li></ul><p><code>npm publish</code> 时出现了一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">npm ERR! code E503</span><br><span class="line">npm ERR! 503 Service Unavailable - PUT http://npm.kpg123.com/sdf - one of the uplinks is down, refuse to publish</span><br></pre></td></tr></table></figure><p>查看 <a href="https://github.com/verdaccio/verdaccio/issues/78" target="_blank" rel="noopener">Issues</a> 和<a href="https://verdaccio.org/docs/en/configuration.html#offline-publish" target="_blank" rel="noopener">配置文档</a>发现，By default verdaccio does not allow to publish when the client is offline, that behavior can be overridden by setting this to true.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">publish:</span><br><span class="line">  allow_offline: true</span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>如果 nginx 直接安装在宿主机，直接 <code>/etc/nginx/conf.d</code> 下新建 nginx.conf 文件，填入以下内容即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream npm &#123;</span><br><span class="line">    server 127.0.0.1:4873;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name npm.kpg123.com;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://npm;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端 host，然后就可以通过域名访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.101 npm.kpg123.com</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Flow</title>
      <link href="/2019/04/25/Git-Flow/"/>
      <url>/2019/04/25/Git-Flow/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Git 工作流（Work Flow）是一种分支管理策略。在开发人员较少，项目不复杂时，可以采用简单的工作流，比如只有一个 Master 分支，但当项目庞大，迭代周期长，多人协作，多需求并行时，就需要更加严格的 Work Flow 来管理开发、测试、发布和热修复了。在 Git 中常见的工作流有 Git Flow、GitHub Flow、GitLab Flow。</p><a id="more"></a><p>2010 年 5 月，Vincent Driessen 在 “<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>” 中介绍了一种构建在 Git 之上的软件开发模型。通过利用 Git 创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上，实现了软件开发过程不同阶段的相互隔离。这种软件开发的活动模型被 Vincent 称为 “Git Flow”。</p><h2 id="Git-Flow-基本流程"><a href="#Git-Flow-基本流程" class="headerlink" title="Git Flow 基本流程"></a>Git Flow 基本流程</h2><p><img src="/images/engineering/git/git-flow.jpg" alt="Git Flow 流程图"></p><p>从 Git Flow 流程图可以看出，Git Flow 的核心是 Branch，通过在项目的不同阶段对 Branch 的不同操作（create、merge、rebase…）来实现一个完整的高效率的工作流程。Git Flow Branches 主要分为两大类，Main Branchs（主分支） 和 Supporting Branches（辅助分支），其中 Main Branchs 包含了 Master 和 Develop，而 Supporting Branches 包含了 Feature、Release、Hotfix 以及其他自定义分支。Main Branchs 是长期分支，存活在项目的整个生命周期中，而 Supporting branches 分支是短期分支，短期分支合并后需要删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* master -- 主分支</span><br><span class="line">* develop -- 开发分支</span><br><span class="line">* feature/* -- 功能分支</span><br><span class="line">* release/* -- 预发布分支</span><br><span class="line">* hotfix/* -- 热修复分支</span><br></pre></td></tr></table></figure><p>在实践中，需求的创建、提测、发布应由项目负责人完成，普通的开发人员只需要开发功能和改 Bug。也就是说，对于 Master、Develop 这两个公共分支，只有项目负责人有操作权限，普通开发人员只有 Feature、Release、Hotfix 三个辅助分支的操作权限，这样既保证了 Master 和 Develop 的整洁，而且普通开发人员也不需掌握 Git Flow。</p><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>主分支用于发布，存放的是最稳定的正式版本。禁止在此分支上修改代码，只接受其他分支合并（Release、Hotfix）。另外，不管是用来发布 Release 还是 Hotfix，都需要打 Tag。</p><p>注：初始化时，可使用 <code>--allow-empty</code> 参数来 commit 一个空分支（<code>git flow init</code> 就是如此），<code>git commit --allow-empty -m &quot;initial commit&quot;</code>。</p><h3 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h3><p>开发分支用于日常开发，是 Feature 和 Release 分支的基础分支，存放最新的开发版（隔夜版 Nightly，是要发布到下一个 Release 的代码）。这个分支可能包含一定的 Bug（Release 还未合并的情况下），但不影响创建新的 Feature 进行新功能的开发（但是需要注意的是，假如 feature/b 基于 feature/a 的 Develop 创建，这时候的 feature/b 不能比 feature/a 早发布，如果想早发布只能将这个 feature/b 当作一个 Hotfix 了）。</p><p>跟 Master 一样，Develop 的变动也只能是合并（Feature、Release），不能是直接修改。</p><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><p>功能分支用于开发新功能、代码重构、优化…，基于 Develop 创建，一般命名为 feature/xxx。新功能开发完成，会合并回 Develop 分支进入下一个 Release。</p><p>Feature 分支命名规则是，分支类型/分支发布时间-分支功能。比如：feature/20170401-fairy-flower，时间使用年月日命名，不足 2 位补 0。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><p>预发布分支用于预发布（测试和测试阶段的 Bug 修复）。当需要发布一个新 Release 时，可以基于 Develop 分支创建一个 Release 分支，一般命名为 release/v1.0.0（关于版本号的命名规则参考相关章节），完成 Release 后，需要合并到 Master 和 Develop。</p><p>版本就是在这个阶段确定的，所以这个分支的命名会加版本后缀。版本正式发布前可生成 Changelog 文档，然后再发布上线。</p><h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><p>热修复分支，用于修改线上 Bug（比如回归时的 Bug，或者用户反馈的 Bug）。基于 Master 创建，一般命名为 hotfix/v1.0.0，测试通过后合并到 Master 分支和 Develop 分支。</p><h2 id="Git-Flow-工具"><a href="#Git-Flow-工具" class="headerlink" title="Git Flow 工具"></a>Git Flow 工具</h2><p>一旦使用 Git Flow 模型，那么对分支的操作必然是频繁且重复的，这个时候可通过 <a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">Git flow script 工具</a>来简单化复杂的 Git 命令。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># OS X</span><br><span class="line">brew install git-flow</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">apt-get install git-flow</span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">wget -q -O - --no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash</span><br><span class="line"># Windows 上或者</span><br><span class="line">curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh</span><br><span class="line">bash gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow help          # 查看帮助</span><br><span class="line">git flow feature help  # 查看 feature 帮助</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># init</span><br><span class="line">git flow init                           # 初始化。会询问分支的命名，初始化完成后自动切换到了 develop 分支。支持 -f -d 参数</span><br><span class="line"></span><br><span class="line"># feature</span><br><span class="line">git flow feature start MYFEATURE        # 开始一个 feature。相当于 git checkout -b feature/MYFEATURE</span><br><span class="line">git flow feature publish MYFEATURE      # publish 一个 feature。相当于 git push</span><br><span class="line">git flow feature pull origin MYFEATURE  # 获取 publish 的 feature</span><br><span class="line">git flow feature finish MYFEATURE       # 完成一个 feature。该命令将 feature 分支合并入 develop 分支，并切换到 develop 删除 feature</span><br><span class="line"></span><br><span class="line"># release</span><br><span class="line">git flow release start MYRELEASE        # 开始一个 release。git flow release start v1.0.0，分支全称是 release/v1.0.0</span><br><span class="line">git flow release publish MYRELEASE      # publish 一个 release</span><br><span class="line">git flow release finish MYRELEASE       # 发布一个 release。该命令将 release 合并入 master 和 develop 并切换到 master，删除该 release，创建 tag</span><br><span class="line"></span><br><span class="line"># hotfix</span><br><span class="line">git flow hotfix start MYVERSION         # 开始一个 hotfix</span><br><span class="line">git flow hotfix finish MYVERSION        # 发布一个 hotfix</span><br></pre></td></tr></table></figure><p><code>git flow init</code> 会询问分支的命名，发布和预发布这两个分支名称采用默认的 master 和 develop 即可，而其他的分支需要填写前缀，比如 <code>feature/</code>。参数 <code>-f</code> 表示强制初始化（可用于重置 git flow 初始化配置），参数 <code>-d</code> 表示使用默认配置初始化。Git Flow 仓库配置是本地配置，换电脑后需要再次初始化配置，为保证各配置相同，最好是使用 <code>git flow init -d</code> 初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git flow init</span><br><span class="line"></span><br><span class="line">Initialized empty Git repository in /Users/tracy-xu/Desktop/test/.git/</span><br><span class="line">No branches exist yet. Base branches must be created now.</span><br><span class="line">Branch name for production releases: [master] </span><br><span class="line">Branch name for &quot;next release&quot; development: [develop] </span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [feature/] </span><br><span class="line">Release branches? [release/] </span><br><span class="line">Hotfix branches? [hotfix/] </span><br><span class="line">Support branches? [support/] </span><br><span class="line">Version tag prefix? [] version/</span><br></pre></td></tr></table></figure><p>注：Release 和 Hotfix 命令使用和 Feature 一样，只是有些细微区别，比如 <code>git flow release finish</code> 命令将会将 Release 分支合并入 Master 和 Develop 两个分支，且会打上版本号（tag 需要有 message，要不然会创建失败）。</p><p><img src="/images/engineering/git/git-flow-commands.png" alt="git-flow-commands"></p><p>附：<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">Git-Flow 备忘清单</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit Message Style Guide</title>
      <link href="/2019/04/20/Git-Commit-Message-Style-Guide/"/>
      <url>/2019/04/20/Git-Commit-Message-Style-Guide/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>在 Git 中，我们使用 <code>git commit -m &quot;xxx&quot;</code> 来提交代码，参数 <code>-m</code> 用来指定 Commit Message（提交说明），直接执行 <code>git commit</code> 会进入编辑器模式，可提交多行说明。Commit Message 应规范化，规范化的 Commit Message 能带来很多好处：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 提交说明明确，方便快速浏览和查找，比如 git log --pretty=format:%s, git log HEAD --grep feature</span><br><span class="line">* 可以直接从 Commit Message 生成 Change Log</span><br></pre></td></tr></table></figure><p>目前，社区中有很多 Commit Message 规范，本文介绍 Angular Commit Message 规范，因其合理、系统，且有配套工具，在社区中得到来广泛的应用。</p><h2 id="Angular-Commit-Message-规范"><a href="#Angular-Commit-Message-规范" class="headerlink" title="Angular Commit Message 规范"></a>Angular Commit Message 规范</h2><p><a href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-guidelines" target="_blank" rel="noopener">Angular commit message guidelines</a> 中将 Commit message 分为三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。<code>&lt;BLANK LINE&gt;</code> 指空行，各个部分必须由空行分割。为了避免自动换行影响美观，不管是哪一个部分，任何一行都不得超过 72 个字符（或 100 个字符）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs(changelog): update changelog to beta.5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fix(ivy): prevent templateOverrides from causing infinite loop (#29402)</span><br><span class="line"></span><br><span class="line">Previously, the transitive scope calculation could lead into re-compiling</span><br><span class="line">the same module multiple times. This fix ensures we cannot get into this loop.</span><br><span class="line">It should be fixed more completely (e.g. more cases) once FW-1178 is resolved.</span><br><span class="line"></span><br><span class="line">PR Close #29402</span><br></pre></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需）。</p><ul><li>type</li></ul><p>type 用于说明 Commit 的类别，只允许使用下面 9 个标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* build      # 构建过程或辅助工具的变动。影响构建系统或外部依赖关系的更改（比如：Gulp、Broccoli、NPM）</span><br><span class="line">* chore      # 其他修改，比如改变构建流程，或增加依赖库、工具等</span><br><span class="line">* ci         # 配置文件（对 CI 配置文件和脚本的更改，比如：Travis、Circle、BrowserStack、SauceLabs）</span><br><span class="line">* docs       # 文档（Documentation，比如 Readme、Changelog、Contribute 等等）</span><br><span class="line">* feat       # 新功能（Feature）</span><br><span class="line">* fix        # 修复 Bug</span><br><span class="line">* prerf      # 性能（提高性能的代码更改，比如，提升性能、体验）</span><br><span class="line">* refactor   # 重构（即不是新增功能，也不是修改 bug 的代码变动）</span><br><span class="line">* style      # 格式（不影响代码运行的变动，比如：空白、换行、分号等）</span><br><span class="line">* test       # 测试（增加测试或更正现有测试）</span><br><span class="line">* revert     # 回滚（回滚到某一个版本，带上版本号）</span><br></pre></td></tr></table></figure><p>如果 type 为 feat 和 fix，则该 Commit 将肯定出现在 Change Log 之中。其他情况（docs、chore、style、refactor、test）建议不要放入 Change Log。</p><ul><li>scope</li></ul><p>scope 用于说明 Commit 影响的范围，比如框架中的数据层、控制层、视图层，或业务中某个业务模块，视具体项目的不同而不同，比如：user 用户、pay 支付、product 产品、article 文章、core 核心、router 路由、api 接口、doc 文档…</p><ul><li>subject</li></ul><p>subject 是 Commit 目的的简短描述，不超过 50 个字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</span><br><span class="line">* 第一个字母小写</span><br><span class="line">* 结尾不加句号（.）</span><br></pre></td></tr></table></figure><p>常用表述语有：add、change、update、remove、delete。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 Commit 的详细描述，可以分成多行。有两个注意点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 使用第一人称现在时，比如使用 change 而不是 changed 或 changes</span><br><span class="line">* 应该说明代码变动的动机，以及与以前行为的对比</span><br></pre></td></tr></table></figure><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><ul><li>不兼容变动</li></ul><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>关闭 Issue 或 Pull requests</li></ul><p>在开源的项目中，如果当前 commit 针对某个 issue 或 pr，那么可以在 Footer 部分关闭这个 issue 或 pr。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fixes #21388</span><br><span class="line">PR Closes #234</span><br></pre></td></tr></table></figure><p>常用的表述语有 sclose、fix、resolve。</p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 Commit 用于撤销以前的 Commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 This reverts commit<hash>.，其中的 Hash 是被撤销 Commit 的 SHA 标识符。</hash></p><p>如果当前 Commit 与被撤销的 Commit 在同一个发布（Release）里面，那么它们都不会出现在 Change Log 里面。如果两者在不同的发布，那么当前 Commit，会出现在 Change Log 的 Reverts 小标题下面。</p><h2 id="设置-Commit-Message-Template"><a href="#设置-Commit-Message-Template" class="headerlink" title="设置 Commit Message Template"></a>设置 Commit Message Template</h2><p>通过设置全局 .gitconfig 来指定 Commit Message 模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><p>TortoiseGit 中可通过依次点击 <code>settings -&gt; Git -&gt; Edit global .gitconfig</code>，然后编辑这个全局 .gitconfig 文件，在其末尾加入 commit 字段配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    email = xxxxxx@qq.com</span><br><span class="line">    name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">    recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">    helper = manager</span><br><span class="line">[commit]</span><br><span class="line">  template = d:/commit-template</span><br></pre></td></tr></table></figure><h2 id="生成-Change-Log"><a href="#生成-Change-Log" class="headerlink" title="生成 Change Log"></a>生成 Change Log</h2><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档。如果所有 Commit Message 都符合 Angular Commit Message 规范，那么发布新版本时，可以用 <a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> 这个工具自动生成 <a href="https://github.com/angular/angular/blob/master/CHANGELOG.md" target="_blank" rel="noopener">CHANGELOG.md</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure><p>上面命令不会覆盖以前的 Change Log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动。如果想要生成所有发布的 Change Log，要运行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog-cli -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，直接运行下面的命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure><p>生成的文档包括以下三个部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* New features</span><br><span class="line">* Bug fixes</span><br><span class="line">* Breaking changes.</span><br></pre></td></tr></table></figure><p>每个部分都会罗列相关的 Commit ，并且有指向这些 Commit 的链接。当然，生成的文档允许手动修改，所以发布前，还可以添加其他内容。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>西溪湿地半日游</title>
      <link href="/2019/04/06/xxsd/"/>
      <url>/2019/04/06/xxsd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><img src="/images/jotting/482317088.jpg" alt="西西湿地"><br>[图 1] 慢生活街区店前花圃 1</p><a id="more"></a><p><img src="/images/jotting/2090297738.jpg" alt="蒋村集市"><br>[图 2] 慢生活街区店前花圃 2</p><p><img src="/images/jotting/1024445398.jpg" alt="洪园渔人码头"><br>[图 3] 洪园渔人码头</p><p><img src="/images/jotting/1131758639.jpg" alt="西西湿地"><br>[图 4] 西溪花园翠竹苑</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> jotting </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录 Date 中的两个坑</title>
      <link href="/2019/04/01/Javascript-Date-Something/"/>
      <url>/2019/04/01/Javascript-Date-Something/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="new-Date-参数-dataString-格式问题"><a href="#new-Date-参数-dataString-格式问题" class="headerlink" title="new Date 参数 dataString 格式问题"></a>new Date 参数 dataString 格式问题</h2><p>new Date(dataString) 中，参数 dataString 必须符合 ISO 8601 标准或者 RFC 2822 标准，现代主流浏览器这两个标准都支持（IE8 只支持 RFC 2822，不支持 ISO 8601）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Date(&apos;2019-01-25T09:14:10.099+00:00&apos;).getTime();    // ISO 8601 标准。返回 1548407650099</span><br><span class="line">new Date(&apos;2019/01/25 09:14:10+0000&apos;).getTime();         // RFC 2822 标准。返回 1548407650000</span><br></pre></td></tr></table></figure><p>然而，在实际工作中，后台（Java）返回的是格式既不是标准的 ISO 8601 也不是标准的 RFC 2822 格式，而是 ISO 8601 和 RFC 2822 混合格式，时区使用的是 RFC 2822 格式，比如，2019-01-25T09:14:10.099+0000，这个格式只有 Chrome 支持，其他浏览器都不支持（比如 iOS WebView、IE），执行 getTime 操作会返回 NaN：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Date(&apos;2019-01-25T09:14:10.099+0000&apos;).getTime();     // NaN</span><br></pre></td></tr></table></figure><a id="more"></a><p>对于这个问题，要么要求后端返回标准的日期字符串格式，要么前端将数据纠正（moment、data-fns 就做了处理）。</p><h2 id="setDate-的副作用"><a href="#setDate-的副作用" class="headerlink" title="setDate 的副作用"></a>setDate 的副作用</h2><p>setDate 参数如果超出了月份的合理范围，会向上个月或下个月设置，&lt;= 0 时，会设置上个月的日期，0 是最后一天，-1 是倒数第二天，以此类推，超出范围的正整数同理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                            // 2 月 28</span><br></pre></td></tr></table></figure><p>我们可以利用这个特性来获取月份的天数和判断是否是闰年：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 获取月份天数</span><br><span class="line">function getMonthDayCount(year, month) &#123;</span><br><span class="line">  return new Date(year, month, 0).getDate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMonthDayCount(2017, 10);   // 31</span><br><span class="line"></span><br><span class="line">// 获取一年中所有月份天数</span><br><span class="line">function getAllMonthDayCount(year) &#123;</span><br><span class="line">  var days = [31, new Date(year, 2, 0).getDate(), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</span><br><span class="line">  return days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAllMonthDayCount(2016);    // [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 是否是闰年</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样是不是更容易理解</span><br><span class="line">function isLeapYear(year) &#123;</span><br><span class="line">  return new Date(year, 2, 0).getDate() === 29;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isLeapYear(2000);             // true</span><br></pre></td></tr></table></figure><ul><li>副作用</li></ul><p>但是，当在同一个 Date 对象上连续执行 setDate 操作时，不单单会偏移日期，还会连续偏移月份，这会影响后面的计算，导致结果出错。在实现 Calender 组件时发现这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d.setDate(0);</span><br><span class="line">d;                    // 2 月 28</span><br><span class="line"></span><br><span class="line">d.setDate(-1);</span><br><span class="line">d;                    // 理想希望返回 2 月 27，但是返回的是 1 月 30</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离</title>
      <link href="/2018/02/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
      <url>/2018/02/03/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><ul><li>会话保持</li></ul><p>由于 http stateless</p><p>cookie, 持久化(storage 或者 spa state) + http header</p><p>注: cookie 是保存在客户端浏览器的，存在服务端的叫 session，为了安全 cookie 一般通过 sessionId 来保持会话</p><p>注: 会话是有有效期的，不单单后端，前端也需要做过期处理，道理跟前端需要验证接口字段一样，后端是为了安全，前端是为了更好的用户交互</p><ul><li>鉴权和权限控制</li></ul><p>路由的鉴权（前端路由和后端路由/接口，接口的鉴权由后端完成，ajax 响应拦截处 根据 http code 401 跳登录页即可，前端路由鉴权在路由拦截处根据路由的配置信息完成，noAuth 则放行，否则检查 token，判断 token 是否有效，无效则带上redirect跳登录页 ）、UI 的权限控制（其中关于菜单&lt;菜单可根据路由生成，路由配置中配置权限&gt;，其他的还有按钮…）</p><p>多角色需要做权限控制</p><p>权和权限控制的关系</p><p>​认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系。认证–&gt;授权–&gt;鉴权–&gt;权限控制</p><p>用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。</p><ul><li>前端路由和菜单</li></ul><p>路由的配置数据就可以描述一个菜单的结构以及数据，不需要单独配置菜单数据</p><p>UI 复用可通过导入复用或子路由复用</p><p>子路由在父组件的 router-view 中渲染，根路由在根 router-view 中渲染。</p><p>嵌套路由的目的是为了 UI 复用，</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 设计模式</title>
      <link href="/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/12/02/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>大型的 CSS 项目中，往往会遇到 CSS 结构混乱、多人协作命名冲突、没有组件化无法复用…等等问题。为了解决这些问题于是引入 CSS 设计模式，用 BEM 来解决命名空间的问题，用 SMACSS 来解决代码分层问题，用 OOCSS 来解决解构复用问题。</p><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><p>对于 CSS 选择器的命名空间，一般的做法是通过选择器嵌套来约束命名空间，但是这种方式带来了很多问题 – 嵌套层次深不但影响了性能也导致了重度的 DOM 依赖，还有最重要的是命名冲突。</p><p>一个优秀的 CSS 命名方案，应该要解决以下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 具备 NameSpace；</span><br><span class="line">* 不能与嵌套的业务样式命名冲突；</span><br><span class="line">* 独立、对上层不过度依赖；</span><br></pre></td></tr></table></figure><p>BEM 的出现解决了上述问题。</p><p>BEM 中，B 代表 Block（Component）、E 代表 Element、M 代表 Modify。规定用 <code>__</code> 连接 E，用 <code>--</code>连接 M，用 <code>-</code> 连接单词和命名前缀。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.m-page</span><br><span class="line">.m-page__item</span><br><span class="line">.m-page__item--cur</span><br><span class="line">.m-page--center</span><br></pre></td></tr></table></figure><p>注：BEM 最多只有三层，不可能存在嵌套的 Element，比如 <code>.m-page__item__anchor--cur</code>。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>SMACSS 是一个比较全面的 CSS 规范，它不但规范了命名空间，还对 CSS 进行了分层。具体到项目中，只参考它的分层。</p><h3 id="命名前缀"><a href="#命名前缀" class="headerlink" title="命名前缀"></a>命名前缀</h3><p>命名前缀用于说明 UI 类型归属，可以结合 BEM 一同使用，用于说明 Block 的类型。</p><ul><li>g-栅格</li></ul><p>简单栅格系统：用户后台 <code>g-hd</code>、<code>g-fd</code>、<code>g-bd</code>、<code>g-sd</code>、<code>g-mn</code>，前台和中间页 <code>g-head</code>、<code>g-body</code>、<code>g-foot</code>。</p><ul><li>f-原子类</li></ul><p>常用原子类：<code>f-bfc</code>、<code>f-clearfix</code>、<code>f-ellipsis</code>、<code>f-show</code>、<code>f-hide</code>、<code>f-cb</code>…。</p><p>定义原子类必须谨慎，功能性的原子类还好（<code>f-clearfix</code>、<code>f-bfc</code>），描述性的原子类必须谨慎（比如 <code>f-w100</code>）。原子类的使用场景是供后端使用的，或者前端 fix issue 时紧急使用。</p><p>原子类的缺陷：与 inline style 无异，没有做到结构与样式的分离；容易导致 class 臃肿。</p><ul><li>u-元件</li></ul><p>常用元件：<code>u-btn</code>、<code>u-ipt</code>、<code>u-select</code>、<code>u-line</code>、<code>u-link</code>…。</p><p>利用 OOCSS 来对页面元素进行抽象，是一种非常好的做法，这样可以通过继承，组合出不同的样式。但是也有导致 class 的臃肿的缺点，不过为了前者的实用性，后者的这点缺点也算不了什么。</p><ul><li>m-组件</li></ul><p>常用的 UI 组件：<code>m-tab</code>、<code>m-table</code>、<code>m-form</code>、<code>m-page</code>、<code>m-dialog</code>、<code>m-btns</code>、<code>m-select</code>、<code>m-search-box...</code>、<code>m-header</code>、<code>m-footer</code>…。</p><p>UI 的组件化也就是 HTML、CSS 的组件化。模块化、组件化的目的是封装（作用域隔离）、复用，这使得代码简洁易读易维护，按照最小组件化原则，非常有利于项目在快速迭代中的发展。</p><p>组件化原则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 组件化抽象的第一原则是复用（这也是 m 与 c 最主要的区别）；</span><br><span class="line">* 各个组件独立划分，充分解耦，遵守职责单一原则；</span><br><span class="line">* 业务 m 不能与全局 m 冲突，业务 m 要带上业务前缀（比如，m-header-mall），必要时还要加上模块前缀（比如，m-title-mall-index）；</span><br></pre></td></tr></table></figure><p>自定义组件：</p><p>当组件化不满足场景时，可对 modify 进行自定义（组件不满足场景大部分是 modify 不满足）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m-page--center</span><br><span class="line">c-choiceness-stage__carousel--junior</span><br><span class="line">c-choiceness-stage__carousel--high</span><br><span class="line">c-choiceness-stage__carousel--senior</span><br></pre></td></tr></table></figure><ul><li>c-模块</li></ul><p>整个 UI 都可以被模块化，包括业务，使用 <code>c-xx</code> 来作为命名前缀（c 指代 component，表示模块，而非 custom）。</p><p>component 和 module 的区别：component 包含 module，module 是 component 的组成部分，组件一般是可高度复用，可在整个项目或者跨项目通用的，这里的 c 其实指的是不可复用的业务模块（<code>模块 - 组件 = 不可复用的业务模块</code>），主要目的是封装，不具备 m 一样的复用能力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-login      # login 不能被复用，所以这里不能用 m-login</span><br></pre></td></tr></table></figure><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>OOCSS 只是一种思想，并没有具体的规范，用 OO 的方式来对 CSS 进行解构抽象，能够达到很好的作用域封装和复用效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.u-btn .u-btn--normal .u-btn--gray</span><br><span class="line">.m-page .m-page--center</span><br><span class="line">.m-tips .m-tips--success</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 预处理器 Sass</title>
      <link href="/2016/11/20/CSS%20%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20Sass/"/>
      <url>/2016/11/20/CSS%20%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20Sass/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Sass 是一种 CSS 预处理语言。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>Sass 的编译器实现有 Ruby Sass、LibSass、Dart Sass，这 3 代编译器都不是 JavaScript 实现的（Less、Stylus 的编译器都是 JavaScript 实现的）。</p><p>Ruby Sass 是最早的 Sass 编译器，用 Ruby 实现的，因为不能被 Node 调用，社区出现了 C++ 实现的 LibSass，在前端工作流中通过 node-sass 这个 Node Bridge 来调用。node-sass 是一个 Nodejs 环境下提供的一个 Bridge，它提供了调用 LibSass 的能力。</p><p>因为 LibSass 的维护速度跟不上 CSS 和 Sass 标准，已被官方废弃，另外 node-sass 对 node 版本有要求，而且还难以安装。vue-cli 在 5.0 后也移除了 node-sass。</p><p>Dart Sass 是用 Dart 来写的 Sass 编译器，Dart 可以编译为 JavaScript，在 npm 上包名为 sass，这是编译后的纯 JavaScript 包，纯 JavaScript 版本虽然比 Dart 版本慢，但易于集成到现有的前端工作流程中。Dart Sass 代表着未来，是被官方推荐的 Sass 编译器。</p><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><p>node-sass is a library that provides binding for Node.js to LibSass, the C version of the popular stylesheet preprocessor, Sass.</p><p><a href="https://www.jianshu.com/p/d3c577209eae" target="_blank" rel="noopener">https://www.jianshu.com/p/d3c577209eae</a></p><p><a href="https://blog.csdn.net/lzfengquan/article/details/122818098" target="_blank" rel="noopener">https://blog.csdn.net/lzfengquan/article/details/122818098</a></p><p><a href="https://blog.csdn.net/weixin_45847735/article/details/122084202" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45847735/article/details/122084202</a></p><p><a href="https://developer.51cto.com/article/698854.html" target="_blank" rel="noopener">https://developer.51cto.com/article/698854.html</a></p><p><a href="https://www.jb51.net/article/180781.htm" target="_blank" rel="noopener">https://www.jb51.net/article/180781.htm</a></p><p><a href="https://blog.csdn.net/weixin_41196185/article/details/117341722" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41196185/article/details/117341722</a></p><p><a href="https://sass-lang.com/Dart" target="_blank" rel="noopener">https://sass-lang.com/Dart</a> Sass</p><p>用 Dart Sass 代替 node-sass</p><p><a href="https://blog.csdn.net/qq_36657291/article/details/121995360" target="_blank" rel="noopener">https://blog.csdn.net/qq_36657291/article/details/121995360</a></p><p>which python3<br>which node</p><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如<code>Variables(变量)</code>，<code>Mixins</code>(混合)、<code>Nested Rules(嵌套规则)</code>、<code>Functions &amp; Operations(函数和运算)</code>等功能，让 CSS 更易维护、方便制作主题、扩充。</p><p>Less可以运行在客户端(浏览器)和服务器(如Node.js)上，不过一般都是在本地预编译。Bootstrap3就是采用了Less作为CSS预处理器。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>###常用语法</p><p>略…</p><ul><li>Less中的一些注意事项：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+             # 只能用来计算，不能用于拼接字符串</span><br><span class="line">@import “”；  # 必须是双引号，必须要有分号</span><br><span class="line">.fun(@n - 1); # 运算符的前后一定要有空格，要不然会报错，当字符串使用</span><br><span class="line">.fun();       # 必须要有分号</span><br><span class="line">@&#123;name&#125;       # 变量可以用像这样的结构（类似ruby和php），嵌入到字符串中</span><br><span class="line">@icon-font-path: &quot;fonts/&quot;;  # Less定义变量不用加&quot;&quot;，如果加&quot;&quot;表示需要转义（防止编译的时候被编译）</span><br><span class="line">避免编译      # 有时候需要输出一些不正确的css语法，或者使用一些LESS不认识的专有语法（比如微软滤镜filter等），为了避免编译器报一些不必要的错误，帮我们做了一些不必要的事情。我们可以在字符串前加上一个~，加单引号/双引号，Eg:  width:~&apos;calc(100% - 35)&apos;不加的话，会被计算出结果的（其实你是想让浏览器来计算，而不是编译器来计算）。</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2016/09/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 13:32:17 GMT+0800 (中国标准时间) --><p><a href="https://juejin.cn/post/7073640285904830471#heading-22" target="_blank" rel="noopener">https://juejin.cn/post/7073640285904830471#heading-22</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外循环，几轮冒泡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="comment">// 共进行 arr.length 轮冒泡</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 冒泡</span></span><br><span class="line">    <span class="comment">// 俩俩对比，最后一个元素后面没有元素了，所以减 1，已冒泡上去的元素无需再参与，所以减 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]]; <span class="comment">// distribute 交换数组位置</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort([<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>]));</span><br></pre></td></tr></table></figure><p>也可在原型链上扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.bubbleSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>[j] - <span class="keyword">this</span>[j + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123; <span class="comment">// 其实就是 compareFn() &gt; 0，条件为真时，才调换位置</span></span><br><span class="line">        temp = <span class="keyword">this</span>[j];</span><br><span class="line">        <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">44</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>].bubbleSort();</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2016/07/21/HTTP/"/>
      <url>/2016/07/21/HTTP/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>get 请求传 array<br><a href="https://blog.csdn.net/weixin_39548968/article/details/113020785" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39548968/article/details/113020785</a></p><a id="more"></a><ul><li></li><li><p>get、post的区别</p></li></ul><ul><li>http状态码</li></ul><p>http状态码是表示服务器对请求的响应状态，主要分为以下几个部分</p><p>1<strong>：这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束<br>2</strong>：表示请求成功，<br>3<strong>：表示重定向<br>4</strong>：表示客户端错误<br>5**：表示服务器端错误</p><p>100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收<br>200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。<br>202（Accepted），服务器已接受请求，但尚未处理。<br>204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容<br>205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>206（Partial-Content），服务器已经成功处理了部分 GET 请求。<br>301（Moved-Permanently），永久性重定向<br>302（Moved-Temporarily），暂时性重定向<br>304（Not-Modified），浏览器端缓存的资源依然有效<br>400（Bad-Reques），请求有误，当前请求无法被服务器理解。<br>401（Unauthorized），当前请求需要用户验证。<br>403（Forbidden），服务器已经理解请求，但是拒绝执行它。<br>404（Not-Found），请求的资源没有被找到<br>500（Interval Server Error），服务器内部错误<br>502（Bad GateWay），网关出错<br>503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。<br>504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p><p>cookie</p><p>cookie 是存储在浏览器端，只有 4kb，会随浏览器的请求一起发送到服务器端的，它有过期时间，到了过期时间自动会消失</p><p>跨域的复杂请求会先发一个 option 的预检请求 preflight</p><h3 id="Request-Content-Type"><a href="#Request-Content-Type" class="headerlink" title="Request Content-Type"></a>Request Content-Type</h3><p>Request Header 中的 Content-Type 用来声明参数的格式，Post/Put 等请求需要设置此字段，Get 请求一般不使用 body 传参，不需要指定 Content-Type，使用 URL 传递，数据格式：Query String Parameters（表现为 QueryString）。</p><p>Response Header 响应头是在服务端设置的，前端不用设置。</p><ul><li>application/json</li></ul><p>数据格式：Rquest Payload（表现为 Json 字符串）</p><p>大部分请求参数都是此格式，可作为默认格式</p><ul><li>application/x-www-form-urlencoded</li></ul><p>数据格式：Form Data（表现为 QueryString）<br>注：登录的接口就是用的这种类型。</p><p>数据格式需要为 QueryString。</p><p>export function updatePassword(data) {<br>return axios.put(<br>‘/user/self/password’,<br>qs.stringify(data),<br>{<br>headers: {<br>‘Content-Type’: ‘application/x-www-form-urlencoded’,<br>},<br>},<br>);<br>}</p><p>URLSearchParams 也能将一个 对象转为 QueryString。</p><p>const params = new URLSearchParams({<br>username: self.username,<br>password: self.password,<br>}).toString();</p><ul><li>multipart/form-data</li></ul><p>数据格式：Form Data</p><p>用于上传文件</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端适配方案</title>
      <link href="/2016/07/02/Adaptation-Rule/"/>
      <url>/2016/07/02/Adaptation-Rule/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>在 PC 端，除了数据可视化和中后台这样一些全屏设计场景需要适配，绝大多数的网页采用的都是固定尺寸设计，由于 1366+ 的屏幕尺寸大于常用的固定设计尺寸，网页按设计尺寸 1:1 还原即可，不需要考虑适配。而在移动端，由于屏幕尺寸大小不一，且采用全屏的设计风格，则需要做适配。</p><p>目前移动端端内主流适配方案有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 流体式/弹性式；</span><br><span class="line">* Layout Viewport Scale；</span><br><span class="line">* VW + Rem；</span><br></pre></td></tr></table></figure><a id="more"></a><p>注：适配方案还有设备独立像素和 Media Query（query 的是逻辑像素）。</p><p>抽象的设备独立像素解决的是端内高密度屏的适配（底层图形系统会根据 DPI 自动换算为物理像素），Media Query 解决的是跨端的设计风格适配，而流体、Rem、Layout Viewport Scale 解决的是端内设计要素（盒模型、字体、图片…）的适配（同一 UI 的整体缩放，没有设计上的差异）。</p><p>在设计要素适配中，“盒模型”和“字体”只需要考虑大小，而“图像”相对复杂一些，需要考虑流量、清晰度等问题，常见的解决方案有：矢量化、字体化、image-set 等。</p><h2 id="流体式"><a href="#流体式" class="headerlink" title="流体式"></a>流体式</h2><p>这是最早使用的适配方案，也是最常用的一种，特别是在响应式 UI 框架中（比如 Bootstrap）。其原理是，完美视口下，选需要兼容设备的最小宽度（一般都是 320px）来布局，垂直方向的高度和间距使用定值，水平方向用百分比、定值、flex…，最终达到“当手机屏幕变化时，横向拉伸或者填充空白的效果”。Eg：<a href="https://m.baidu.com/" target="_blank" rel="noopener">百度</a>、<a href="https://www.amazon.cn/" target="_blank" rel="noopener">亚马逊</a>。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 为完美视口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>步骤二，切图布局</li></ul><p>小往大适配，选需要兼容设备的最小尺寸还原设计稿（一般都是 iPhone5 的 320px，这是当前主流手机中的最小尺寸），当屏幕变宽时，简单的填充空白即可（如果从大到小，小分辨率设备上，就会出现滚动条）。</p><p>注：选主流中最小分辨率机型来进行设计（640 * 1334），<code>CSS 尺寸 = 视觉稿尺寸/dpr = 640/2 = 320</code>。前端在高清视觉稿下切图，使得图片兼容 Retain，在 CSS 中缩放；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;<span class="attribute">max-width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon</span> &#123;<span class="attribute">background</span>: <span class="built_in">url</span>(....) no-repeat <span class="number">0</span> <span class="number">0</span>/cover;&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 简单方便；</span><br><span class="line">* 兼容第三方组件（echarts、mintUI...）；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 还原度不精确（如果以开发规范驱动设计就不会存在这个问题） --- 在分辨率不同的设备上，页面的字体大小，内容尺寸都是一样的，不同的是，大屏的内容间的空隙比小屏的大；</span><br></pre></td></tr></table></figure><h2 id="Layout-Viewport-Scale"><a href="#Layout-Viewport-Scale" class="headerlink" title="Layout Viewport Scale"></a>Layout Viewport Scale</h2><p>设计稿、页面布局、Layout Viewport 使用统一宽度，前端按设计稿的尺寸还原，使用定值单位（px、em…），利用浏览器『自身缩放』完成适配。Eg：<a href="http://c.3g.163.com/CreditMarket/default.html" target="_blank" rel="noopener">网易新闻</a>。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>步骤一，设置 Layout Viewport 的宽度</li></ul><p>一般会设为 640。与流体式一样，这两种方案的核心都是视口的确定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=设计稿的宽度"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该方案使用固定宽度值，需要考虑主流分辨率，确定一个合适的值，既不能选大了，也不能选小了，选大了可能会使得在小分辨率屏幕下像素丢失，选小了又可能会使得在大分辨率屏幕下模糊。</p><ul><li>步骤二，缩放</li></ul><p>正常浏览器都会将 <code>Layout Viewport</code> 自动缩放至屏内（视觉视口），不能自动缩放的浏览器要手动计算 scale 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> metaEle = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>),</span><br><span class="line">    metaCon = metaEle ? metaEle.content : <span class="string">''</span>,</span><br><span class="line">    matchScale = metaCon.match(<span class="regexp">/initial\-scale=([\d\.]+)/</span>),</span><br><span class="line">    matchWidth = metaCon.match(<span class="regexp">/width=([^,\s]+)/</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metaEle &amp;&amp; !matchScale &amp;&amp; (matchWidth &amp;&amp; matchWidth[<span class="number">1</span>] != <span class="string">'device-width'</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> layoutViewportWidth = <span class="built_in">parseInt</span>(matchWidth[<span class="number">1</span>]),</span><br><span class="line">      screenWidth = screen.width;</span><br><span class="line"></span><br><span class="line">    scale = screenWidth / layoutViewportWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scale &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      metaEle.content += <span class="string">',initial-scale='</span> + scale + <span class="string">',maximum-scale='</span> + scale + <span class="string">', minimum-scale='</span> + scale + <span class="string">',user-scalable=no'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">viewport();</span><br></pre></td></tr></table></figure><p>以下面动态生成的结果为例，640 是根据设计稿定下的，0.5(1/dpr，或者 320/640) 是根据屏幕宽度动态生成的。生成的 viewport 告诉浏览器网页的布局视口使用 640px，然后把页面缩放成 50%，图片、文字等等所有元素都被缩放在手机屏幕中，这是绝对的等比例缩放。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=640,initial-scale=0.5,maximum-scale=0.5,minimum-scale=0.5,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 开发简单 --- 缩放交给浏览器，完全按视觉稿切图；</span><br><span class="line">* 还原精准 --- 绝对等比例缩放，可以精准还原视觉稿；</span><br></pre></td></tr></table></figure><ul><li>缺点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 像素丢失 --- 对于一些分辨率较低的手机，可能设备像素还未达到指定的 viewport 宽度，此时屏幕的渲染可能就不准确。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少；</span><br><span class="line">* 不兼容第三方组件和富文本数据 --- 这也是最大的问题；</span><br></pre></td></tr></table></figure><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p>“流体式”、“Layout Viewport Scale” 这两种适配方案，都存在缺陷，一个优秀的适配方案应做到以下两点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* UI 的精确还原与适配</span><br><span class="line">* 兼容第三方组件和富文本数据</span><br></pre></td></tr></table></figure><p>VW + Rem 就是这样的一个方案。其原理是，屏幕联动 html font-size vw，html font-size 联动 rem（ html font-size value = 1 rem），来做到适配。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>定义规范</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设计规范。规定设计稿分辨率，推荐采用 1X 的设计方案（即手机 375，横屏 Pad 960，而不是 2X 的 750、1920），为了方便 figma 下，导入第三方 UI 组件</span><br><span class="line">* 基准值。规定屏幕分成 10 等分（100vw/10），html font-size 为 10vw，所以 1rem = 10vm</span><br></pre></td></tr></table></figure><p>将基准值的定义为 100vw/10 = 10vw，而不是 100px（除以 19.2、12.8），这仅仅是规范，10vw 体现适配原则，容易理解，而 100px 在没有转换工具的条件下，方便了计算。</p><p>在没有转换工具的情况下，为了方便计算，我们会将 html faont-size 定义如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1920 的设计规范下还原的，base 为 1920px/19.2 = 100px，px 转 rem 除以 100 即可 */</span></span><br><span class="line"><span class="comment">/* calc(100vw/19.2) 不直接写成 10vw，是为了体现 1920 的设计规范 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">100vw</span>/<span class="number">19.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在源码里面进行转换不利于源码的维护，在现代前端开发中推荐使用工程化工具转换。</p><ul><li>使用步骤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 步骤一：定义 html font-size 基准值（一般会定为 10vw，绝大多数适配场景都是按宽度适配，如果按高度适配也可为 10vh）</span><br><span class="line">* 步骤二：开发页面。页面在设计尺寸下开发（比如，平板 1920、手机 750），开发单位为 px</span><br><span class="line">* 步骤三：px 转 rem。这一步请用工具完成，转换算法为 px/基准值（1920 设计规范下是 192，750 设计稿是 75），一般会忽略 border，因为可能变成 0px</span><br></pre></td></tr></table></figure><ul><li>兼容处理</li></ul><p>vw 不支持 Android 4.4 以下设备，这时候就需要对 vw 做兼容处理了。这里不想通过 JS 来解决此问题，本着逐渐增强，平稳退化的原则，选一个默认分辨率处理，比如手机就选 750 的分辨率：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">37.5px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">flexible</a> 就是手淘团队在 Android 4.4- 设备不支持 vw 时的一个 JS 解决方案。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(下) -- 视口</title>
      <link href="/2016/06/15/Pixel-Viewport-2/"/>
      <url>/2016/06/15/Pixel-Viewport-2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>视口（viewport）代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI（菜单栏等）。一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><a id="more"></a><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>桌面浏览器中，视口的宽度与浏览器窗口的宽度一致，浏览器窗口就是约束 CSS 布局的视口，它是所有 CSS 百分比宽度推算的根源，给 CSS 布局限制了一个最大宽度（超出部分将出现滚动条）。但是在移动端，情况就很复杂了。</p><p>在移动设备上，视口与屏幕宽度不再相关联，是完全独立的，浏览器厂商为了让传统的 PC 网页能够尽可能在移动设备上更多的展示，会把视口的宽度设置地很大（一般在 768px ~ 1024px 之间，Apple 是 980px），并且将其缩放在了屏幕（视觉视口）内。这个浏览器厂商定义的视口被称为“布局视口（Layout Viewport）”，网页的最大宽度是默认的 Layout Viewport 宽度，超出部分会出现滚动条。</p><p><img src="/images/css/layout-viewport.png" alt="layout viewport"></p><p>可通过 Meta Viewport 来设置布局视口，能设置的属性如下所示。</p><table><thead><tr><th>Name</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>width</td><td>正整数或 device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或 device-height</td><td>定义视口的高度，单位为像素</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须小于或等于 maximum-scale 设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须大于或等于 minimum-scale 设置</td></tr><tr><td>user-scalable</td><td>yes/no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=640"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS 中可通过 <code>document.documentElement.clientWidth / clientHeight</code> 获取布局视口的尺寸，CSS 中可设置 <code>html, body {width: 100%}</code>，通过测量 <code>body</code> 的宽度来验证默认布局视口大小。另外，CSS 中的媒体查询，查询的是布局视口的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 700px) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>用户在屏幕上能看到的网页区域被称为“视觉视口（Visual Viewport）” 。</p><p>视觉视口用于承载布局视口，其大小是视觉视口内 CSS 像素的总量，受浏览器缩放影响。用户可以在视觉视口中拖动或者缩放网页，来获得良好的浏览效果，如果用户缩小网站，视觉视口内 CSS 像素数量增多，视觉视口变大，看到的网站区域将变大，同理用户放大网站，视觉视口内 CSS 像素数量减少，视觉视口也变小，能看到的网站区域将缩小。不管用户如何缩放，都不会影响到布局视口的宽度。</p><p><img src="/images/css/visual-viewport.png" alt="visual viewport"></p><p><code>window.innerWidth/innerHeight</code> 可以获取视觉视口的尺寸，大小是屏幕中 CSS 像素的数量。</p><h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><p>移动设备中默认 768px ~ 1024px 尺寸的布局视口对用户不友好，忽略了手机本身的尺寸，于是引入理想视口的概念。将布局视口的宽度设为屏幕的宽度，这样的布局视口被称为“理想视口（Idea Viewport）”。理想视口是移动设备上最佳的布局视口，理想视口下开发的页面不需要缩放就能够完美显示。</p><p>JS 中可通过 <code>screen.width/height</code> 获取理想视口的尺寸（有兼容性问题，可能返回的是设备像素尺寸）。将 Meta Viewport 设置如下就可以将布局视口设为理想视口了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实践中，还会设置缩放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 推荐的写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0,viewport-fit=cover"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：<code>initial-scale</code>有一个隐藏的作用，它同时会将布局视口的尺寸设置为缩放后的尺寸，所以<code>initial-scale=1</code>与<code>width=device-width</code>的效果是一样的（不缩放又要求放进 Visual Layout 里，所以 <code>initial-scale=1</code> 与 <code>width=device-width</code> 等同）。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个像素三个视口(上) -- 像素</title>
      <link href="/2016/06/10/Pixel-Viewport-1/"/>
      <url>/2016/06/10/Pixel-Viewport-1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>像素是影像显示的基本单位，其表现为一个个小方格。在 GUI 客户端软件开发中，像素是布局的基础，对于一个客户端开发者来说理解它很重要。其实存在两种像素，<a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html" target="_blank" rel="noopener">此像素非彼像素</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 设备像素</span><br><span class="line">* 设备独立像素</span><br></pre></td></tr></table></figure><a id="more"></a><p>设计师眼中的像素是设备像素，因为要考虑设计稿中非矢量元素（图片）在程序适配中的高保真，程序员眼中的像素是设备独立像素（Web 的 px，Android 的 dp，IOS 的 pt），因为要考虑适配。PC 时代的标准屏幕中，这两个像素是相等的，我们意识不到这个问题的存在，但是在高密度屏的移动时代就需要面对它了。</p><h2 id="设备像素"><a href="#设备像素" class="headerlink" title="设备像素"></a>设备像素</h2><p>设备像素（Device Pixels）又叫物理像素（Physical Pixel），一个设备像素是屏幕上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。跟设备像素相关概念有分辨率、屏幕尺寸、像素密度，这些参数在屏幕出厂时就固定下来了。以 iPhone 5 屏幕参数为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 屏幕分辨率 -- 640 x 1136</span><br><span class="line">* 屏幕尺寸 -- 4 英寸</span><br><span class="line">* 屏幕像素密度/解析度 -- 326dpi。</span><br></pre></td></tr></table></figure><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率可以细分为屏幕分辨率（显示分辨率）、图像分辨率、视频分辨率。其中，屏幕分辨率指一个屏幕具体由多少个像素点组成。<code>640 x 1136</code> 的屏幕分辨率指的是屏幕上水平有 640 个物理像素，垂直有 1136 个物理像素。常见分辨率中 4:3 有 <code>1024 x 768</code>、16:9 有 <code>1366 × 768</code>、<code>1920 × 1080</code>、<code>2560 x 1440</code>、<code>3860 × 2160</code>, 16:10 有 <code>1920 x 1200</code>。</p><p>也可以用 K 和 P 来描述分辨率，P 代表纵向的像素个数，K 代表横向有几个 1024 个像素。分辨率为 <code>1920 x 1080</code> 的屏幕就属于 1080P 屏幕（也被称为 FHD 全高清屏幕），横向像素超过 2048 的屏幕就属于 2K 屏，横向像素超过 4096 的屏幕就属于 4K 屏。</p><p>分辨率高不代表就清晰，还与尺寸有关，同一尺寸下分辨率越高就越清晰。</p><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>屏幕尺寸指的是屏幕对角线的物理长度，单位英寸。比如 iPhone 5 的屏幕尺寸为 4 英寸，MBP 的屏幕尺寸为 13.3 英寸。</p><h3 id="像素密度"><a href="#像素密度" class="headerlink" title="像素密度"></a>像素密度</h3><p>像素密度 (Pixels Per Inch) 指的是每英寸所拥有的像素数量，可用于描述屏幕的清晰度或图片的质量，单位是 ppi。理论上 PPI 越高，单位面积的像素数量就越多，画面会更细腻丰富清晰。屏幕的 PPI 可以通过屏幕分辨率和尺寸计算得到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PPI = Math.sqrt(a ** 2 + b ** 2) / 4</span><br></pre></td></tr></table></figure><p>在桌面屏幕中，大部分的 PC 显示器和笔记本都还是普通密度的屏幕，不过像 Retina MBP（Apple 在 2012 年发布了第一款 Retina MBP）、2k 和 4k 这样一些高密度屏也很常见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 14 英寸笔记本（112ppi）</span><br><span class="line">Math.sqrt(1366 ** 2 + 768 ** 2) / 14;</span><br><span class="line">// 14 英寸笔记本（157ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 14;</span><br><span class="line">// 13.3 英寸 MBA (127ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 900 ** 2) / 13.3;</span><br><span class="line">// 23.8 英寸 PC 显示器（92ppi）</span><br><span class="line">Math.sqrt(1920 ** 2 + 1080 ** 2) / 23.8;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 13.3 英寸 MBP/Retina MBA (226ppi)</span><br><span class="line">Math.sqrt(2560 ** 2 + 1600 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K XPS (290ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2400 ** 2) / 15.6;</span><br><span class="line">// 13.5 英寸 Surface Book 3 (267ppi)</span><br><span class="line">Math.sqrt(2256 ** 2 + 1504 ** 2) / 13.3;</span><br><span class="line">// 15.6 英寸 4K ThinkPad P1 (282ppi)</span><br><span class="line">Math.sqrt(3840 ** 2 + 2160 ** 2) / 15.6;</span><br></pre></td></tr></table></figure><p>在手机屏幕中，2010 年之前的手机分辨率都普遍低，比如，iPhone 3GS、诺基亚 5230、5800，随着智能手机发展，iPhone 4 使得智能手机进入了高密度屏时代，发布会上首次提出了 Retina Display 的概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 3GS (164ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 480 ** 2) / 3.5;</span><br><span class="line">// 诺基亚 5230、5800 (223ppi)</span><br><span class="line">Math.sqrt(320 ** 2 + 640 ** 2) / 3.2;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// iPhone 4 (329ppi)</span><br><span class="line">Math.sqrt(640 ** 2 + 960 ** 2) / 3.5;</span><br><span class="line">// iPhone 11 (326ppi)</span><br><span class="line">Math.sqrt(828 ** 2 + 1792 ** 2) / 6.1;</span><br><span class="line">// 小米 10 (386ppi)</span><br><span class="line">Math.sqrt(1080 ** 2 + 2340 ** 2) / 6.67;</span><br><span class="line">// 华为 P40 Pro (440ppi)</span><br><span class="line">Math.sqrt(1200 ** 2 + 2640 ** 2) / 6.58;</span><br><span class="line">// 三星 Galaxy S20 (565ppi)</span><br><span class="line">Math.sqrt(1440 ** 2 + 3200 ** 2) / 6.2;</span><br></pre></td></tr></table></figure><p><a href="https://support.apple.com/en-us/HT202471" target="_blank" rel="noopener">Retina Display</a>（视网膜屏幕，视网膜显示器）指的是在正常视距内（iPhone 10inch，iPad 15inch）人睛不能分辨出单独像素显示效果的屏幕。为了达到这种显示效果，需要将更多的物理像素压缩进屏幕中，使屏幕成为高密度屏。</p><p>iPhone 4 发布会上，乔布斯表示当手持设备距人眼 10－12 英寸时，300ppi 是人类视力的极限，当像素密度超过 300ppi 时，人眼就无法区分出单独的像素，因此像素密度达到 329ppi 的 iPhone 4 具备非常优秀的显示功能，不会再出现颗粒感。在后来发布 The New iPad 时，Apple 更是对 Retina Display 给出了科学意义上的解释。</p><p><img src="/images/css/retina2.jpg" alt="retina display"></p><p>根据<a href="https://www.engadget.com/2012-03-01-retina-display-macs-ipads-and-hidpi-doing-the-math.html" target="_blank" rel="noopener">上图</a>中视觉成像原理，能够非常容易得出下面这个三角函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tan(α/2) = h/2d</span><br><span class="line"></span><br><span class="line"># 变形公式</span><br><span class="line">α = 2tan^(-1)(h/2d) = 2arctan(h/2d)</span><br><span class="line">h = tan(α/2)*2d</span><br></pre></td></tr></table></figure><p>其中“α”代表视角，“d”代表视距，“h”代表像素间距（或一个像素的尺寸）。在对人类视力研究中发现（斯内伦测试 Snellen Test），正常人眼能辨识所视物的最小视角（识别极限，视敏度 <a href="https://baike.baidu.com/item/%E8%A7%86%E6%95%8F%E5%BA%A6" target="_blank" rel="noopener">visual acuity</a>）是 1/60 度（1 弧分度），1 弧分度数据主要基于斯内伦视力表中 20/20 标准视力（等效于我国视力表中的 1.0）的统计样本，视力超常的（如 2.0 视力）个体无疑会有着更出色的视觉能力，能辨识所视物的最小视角会更小。</p><p>在正常视距下，当视角小于等于 1/60 度时，即可以达到 Retina Display 的显示效果。α 大小取决于 d 和 h，而显示设备的使用视距一般是固定的，所以是否是 Retina Display 取决于 h。比如，在 10inch 的视距下，需要至少 343ppi，才能达到此显示效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">angle2rad</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * (<span class="built_in">Math</span>.PI / <span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> h = <span class="built_in">Math</span>.tan(angle2rad(<span class="number">1</span> / (<span class="number">2</span> * <span class="number">60</span>))) * <span class="number">2</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ppi = <span class="number">1</span> / h;  <span class="comment">// 343</span></span><br></pre></td></tr></table></figure><p>Retina Display 是 Apple 的商标，在安卓手机中没有此叫法，安卓手机中，屏幕根据 PPI 来划分为不同的等级。PPI 在 120 - 160 之间的手机被归为低密度手机，160 - 240 被归为中密度（Medium），240 - 320 被归为高密度（High），320 - 480 以上被归为超高密度，480 - 640 被归为超超高密度，640 以上被称为超超超高密度。</p><table><thead><tr><th></th><th>ldpi</th><th>mdpi</th><th>hdpi</th><th>xhdpi</th><th>xxhdpi</th><th>xxxhdpi</th></tr></thead><tbody><tr><td>密度分界</td><td>120</td><td>160</td><td>240</td><td>320</td><td>480</td><td>640</td></tr><tr><td>常见屏幕分辨率</td><td>240 * 320</td><td>320 * 480</td><td>480 * 850</td><td>640 * 960</td><td>1080 * 1920</td><td>1440 * 2560</td></tr><tr><td>默认缩放比例</td><td>0.75</td><td>1.0</td><td>1.5</td><td>2.0</td><td>3</td><td>4</td></tr></tbody></table><p>附：点密度 DPI (Dots Per Inch) 指的是每英寸包括的点数。这里的点是一个抽象的单位，它可以是屏幕像素点，图片像素点也可以是打印机的墨点，当 DPI 来描述图片和屏幕时，等价于 PPI，描述打印机时，表示打印机每英寸可以打印的点数，打印机的 DPI 越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。另外，PPI/DPI 有时候也被称为分辨率，比如，打印分辨率、扫描分辨率。</p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><p>设备独立像素（Density-Independent Pixel）又叫逻辑像素、密度无关像素，简称为 dips，单位为 dp，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统按设备像素比转换为物理像素在屏幕上显示出来。Web 的 px、Android 的 dp、IOS 的 pt，都是对 dp 的实现，<code>1px = 1dp = 1pt</code>。</p><p>之所以使用抽象的设备独立像素而不直接使用设备像素，目的是为了适配，图形系统会自动将应用程序的抽象像素转换为适合于特定设备的物理像素。</p><h3 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h3><p>在缩放程度为 100%，某一方向上（x 轴或 y 轴）物理像素和设备独立像素的比例叫做“设备像素比” (device pixel ratio)，单位 dpr。设备像素比定义了设备独立像素和设备像素的转换关系，决定了 GUI 软件的渲染尺寸，当处理标准显示器与 HiDPI 或 Rerina 显示器之间的差异时，这很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备像素比 = 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>在 JS 中 <code>window.devicePixelRatio</code> 得到，在 CSS 中，可以通过 <code>-webkit-device-pixel-ratio</code>，<code>-webkit-min-device-pixel-ratio</code> 和 <code>-webkit-max-device-pixel-ratio</code> 进行媒体查询。</p><p>设备独立像素和设备像素间的转换由两个条件决定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 页面是否缩放</span><br><span class="line">* 设备像素比（屏幕是否为高密度或超高密度)</span><br></pre></td></tr></table></figure><p>页面放大，设备独立像素会跨越了更多的设备像素，缩小则相反。在排除页面缩放的情况下，他们的换算关系取决于设备像素比。比如，在 2dpr 的设备上，<code>1 个设备独立像素 = 4 个设备像素</code>，CSS 中的 <code>{width: 200px}</code> 需要由 800 个物理像素来显示（面积）。</p><p>在已知 dpr 和 ppi 的情况下，还可以将 dp 转为现实生活中的物理单位，比如, 在 2dpr、326ppi 下，<code>200dp = 400px = 1.23inch (400 / 326)</code>，于是 <code>1dp = 0.00615inch</code>。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Media Query</title>
      <link href="/2016/06/02/Media%20Query/"/>
      <url>/2016/06/02/Media%20Query/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>媒体查询在 CSS2 中就已经存在了，但是只能查询 meida type，CSS3 中除了能查询 media type 外，还加入了 media feature 的查询。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询包含一个“媒体类型（media type）”以及至少一个测试“媒体特性（media feature）”的表达式，表达式和媒体类型将根据实际情况计算的到 true 或者 false。如果指定的媒体类型符合当前设备并且媒体特性表达式都为真，那当前媒体查询为真，media query 为 true，对应的样式规则生效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [媒体类型] 媒体特性 &#123;&#125;    # 除非使用了 <span class="selector-tag">not</span> 或者 <span class="selector-tag">only</span> 操作符，否则 <span class="selector-tag">media</span> <span class="selector-tag">type</span> 是可选的，默认值为 <span class="selector-tag">all</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>and</td><td>逻辑与，用于连接 media type、meidia feature 用于结合多个媒体特性或媒体类型</td></tr><tr><td>,</td><td>设备列表</td></tr><tr><td>not</td><td>排除某种设备</td></tr><tr><td>only</td><td>限定某种设备类型</td></tr></tbody></table><p><code>and</code> 用于结合多个媒体特性或媒体类型到一个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* media type 为 all 时 media feature 为 min-width 700 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">700px</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可以使用 and 添加限制条件 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 and 添加 media type，限制媒体类型为显示器 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>,</code> 用于结合多个 media query ，任 一media query 为 true 时应用样式，相当于逻辑运算符中的 or。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 宽度大于 700px，或者宽度大于高度的显示器上 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">700px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation:</span> landscape) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>not</code> 用于对整个 media query 结果取反，必须位于一个 media query 的开头。另外，在逗号分隔的多个 media query 中，not 只对它作用的 media query 生效。not 不能对单个 media feature 取反，只能作用于整个 media query。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* not 将在最后求值 */</span></span><br><span class="line"><span class="comment">/* 等价于 @media not (print and (max-width:1024px))&#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> print <span class="keyword">and</span>(<span class="attribute">max-width:</span><span class="number">1024px</span>)&#123;...&#125;  # </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 多个 media query 求值 */</span></span><br><span class="line"><span class="comment">/* 求值顺序如下 @media (not (screen and (color))), print and (color) &#123;&#125; */</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> screen <span class="keyword">and</span> (color), print <span class="keyword">and</span> (color) &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>only</code> 用于向早期浏览器隐藏媒体查询，only 必须位于 media query 的开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>无法识别媒体查询的浏览器要求获得逗号分割的媒体类型列表，规范要求：它们应该在第一个不是连字符的非数字、字母之前截断每个值。所以上面的示例解释为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为没有 <code>only</code> 这样的媒体类型，所以样式表被忽略。如果不加 only，下面的示例会被解析为 <code>@media screen {}</code> 这样一来即使浏览器不知道 media query 的真正含义，样式也会应用于所有屏幕设备。</p><p>尽管存在此行为，如果希望向其他不太常用的浏览器隐藏样式，任然建议在媒体查询前面添加 only。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">600px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="媒体类型（media-type）"><a href="#媒体类型（media-type）" class="headerlink" title="媒体类型（media type）"></a>媒体类型（media type）</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td>所有设备</td></tr><tr><td>print</td><td>文档打印或打印预览模式</td></tr><tr><td>screen</td><td>彩色电脑屏幕</td></tr><tr><td>speech</td><td>阅读器</td></tr></tbody></table><p>注意：在 CSS2.1 和 CSS3 media query 中定义的 media type：tty、tv、projection、handheld、braille、embossed、aural，在<a href="https://www.w3.org/TR/mediaqueries-4/" target="_blank" rel="noopener">media queries level 4</a> 中都废弃了，不推荐使用。</p><h3 id="媒体特性（media-feature）"><a href="#媒体特性（media-feature）" class="headerlink" title="媒体特性（media feature）"></a>媒体特性（media feature）</h3><table><thead><tr><th>媒体特性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>viewport width</td></tr><tr><td>height</td><td>viewport height</td></tr><tr><td>device-width 、 device-height</td><td>设备的宽度、高度</td></tr><tr><td>aspect-ratio</td><td>viewport 的宽高比如：16/9</td></tr><tr><td>device-aspect-ratio</td><td>设备宽高比</td></tr><tr><td>orientation</td><td>宽度和高度的大小关系。landscape（横屏）、portrait（竖屏）</td></tr><tr><td>resolution</td><td>设备的分辨率</td></tr></tbody></table><p>上面是一些常见的 media feature，不是全部，media feature 的维度很多，但是最常用的是 viewport 的 width 和 height。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>在 CSS2 中，媒体查询只使用于 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签中，以 media 属性来查询，CSS3 中可以用 @media 来查询。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/reset.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:600px) and (max-width:900px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"screen"</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> url(<span class="string">"css/style.css"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">"css/reset.css"</span>) screen;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  选择器 &#123;</span><br><span class="line">    属性: 属性值;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Media-Query-常用方法"><a href="#Media-Query-常用方法" class="headerlink" title="Media Query 常用方法"></a>Media Query 常用方法</h2><ul><li>排他（exclusive）</li></ul><p>为确保在某一个条件下只有一个样式表生效，将查询条件严格划分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">401px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">801px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>覆盖（overriding）</li></ul><p>可以对元素设置相同优先级，使用样式顺序，通过覆盖，避免排他。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">400px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动优先（Mobile first）</li></ul><p>默认样式假设为移动设备宽度，然后通过 min-width 控制扩展样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span>&#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootStrap 移动优先，断点分别为 768、992、1200，这三个断点的区间对应手机、平板、桌面、大桌面。</p><ul><li>PC 优先（desktop first）</li></ul><p>默认以宽屏进行样式设置，通过 max-width 控制样式覆盖。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 过渡与动画</title>
      <link href="/2016/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
      <url>/2016/05/18/CSS3%20%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: [property duration timing-function delay]</span><br></pre></td></tr></table></figure><p>property 默认值 all，duration 和 delay 默认值 0，timing-function 默认值 ease。可使用 <code>,</code> 分割，实现多个动画，配合 duration，还可实现队列动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">display</span>: flex; <span class="attribute">width</span>: <span class="number">65px</span>; <span class="attribute">height</span>: <span class="number">40px</span>; <span class="attribute">align-items</span>: center; <span class="attribute">justify-content</span>: center; <span class="attribute">background</span>: <span class="number">#92B901</span>; <span class="attribute">font-size</span>: <span class="number">12px</span>; <span class="attribute">opacity</span>: <span class="number">0.4</span>; <span class="attribute">transition</span>: transform <span class="number">1s</span>, opacity <span class="number">1s</span>, background <span class="number">1s</span>, width <span class="number">1s</span>, height <span class="number">1s</span>, font-size <span class="number">1s</span>;&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">width</span>: <span class="number">90px</span>; <span class="attribute">height</span>: <span class="number">60px</span>; <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>); <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attribute">opacity</span>: <span class="number">1</span>; <span class="attribute">background</span>: <span class="number">#1ec7e6</span>;&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>transition 不会在页面加载时自动执行动画，它需要交互或异步去触发，比如 CSS 的伪类 <code>:hover</code>，JS 事件或 <code>setTimeout</code> 去执行动画。</p><p>开启硬件加速，可以使 transition 运行更加流畅：<code>body{transform: translate3d(0, 0, 0);}</code>；</p><h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><p>不是所有的 CSS 属性都支持 transition，<strong>属性存在中间状态，且能计算出中间状态（开始状态和结束状态是具体数值），才支持 transition</strong>。像 <code>visibility</code>、<code>display</code> 就不存在中间状态，<code>height: auto</code> 不能计算出中间状态，支持的属性常见有以下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* length/percentage: 真实的数字 如：`word-spacing`, `width`, `vertical-align`, `top`, `right`, `bottom`, `left`, `padding`, `outline-width`, `margin`, `min-width`, `min-height`, `max-width`, `max-height`, `line-height`, `height`, `border-width`, `border-spacing`, `background-position` 等；</span><br><span class="line">* number 真实的（浮点型）数值，如：`zoom`, `opacity`, `font-weight` 等；</span><br><span class="line">* color: RGB 和 Alpha 值，如：`background-color`, `border-color`, `color`, `outline-color` 等 CSS 属性；</span><br><span class="line">* shadow: x, y, blur 和 color，如：text-shadow</span><br><span class="line">* transform list</span><br></pre></td></tr></table></figure><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* ease：逐渐变慢（默认值），等同于贝塞尔曲线 (0.25, 0.1, 0.25, 1.0)；</span><br><span class="line">* linear：匀速，等同于贝塞尔曲线 (0.0, 0.0, 1.0, 1.0)；</span><br><span class="line">* ease-in：加速，等同于贝塞尔曲线 (0.42, 0, 1.0, 1.0)；</span><br><span class="line">* ease-out：减速，等同于贝塞尔曲线 (0, 0, 0.58, 1.0)；</span><br><span class="line">* ease-in-out：加速然后减速，等同于贝塞尔曲线 (0.42, 0, 0.58, 1.0)；</span><br><span class="line">* cubic-bezier (n,n,n,n)：在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。实际用到的很少，可以到工具网站中设置值 http://cubic-bezier.com；</span><br></pre></td></tr></table></figure><p>这几个贝塞尔值的区别：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"ease"</span>&gt;</span>ease<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"ease-in"</span>&gt;</span>ease-in<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"ease-out"</span>&gt;</span>ease-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"ease-in-out"</span>&gt;</span>ease-in-out<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"linear"</span>&gt;</span>linear<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> red solid; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">li</span> &#123;<span class="attribute">width</span>: <span class="number">50px</span>; <span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>; <span class="attribute">background-color</span>: red; <span class="attribute">color</span>: <span class="number">#fff</span>;&#125;</span><br><span class="line"><span class="selector-class">.ease</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease;&#125;</span><br><span class="line"><span class="selector-class">.ease-in</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in;&#125;</span><br><span class="line"><span class="selector-class">.ease-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-out;&#125;</span><br><span class="line"><span class="selector-class">.ease-in-out</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> ease-in-out;&#125;</span><br><span class="line"><span class="selector-class">.linear</span> &#123;<span class="attribute">transition</span>: all <span class="number">4s</span> linear;&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">li</span> &#123;<span class="attribute">margin-left</span>: <span class="number">500px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="transition-与-animation-区别"><a href="#transition-与-animation-区别" class="headerlink" title="transition 与 animation 区别"></a>transition 与 animation 区别</h3><p>transition 是属性过渡动画，animation 是关键帧过渡动画，两种动画触发方式不一样，属性过渡必须通过交互或者异步修改属性值，而关键帧只需要应用即可，可以在交互时，也可以不在交互时。</p><p>另外，在 CSS <code>:hover</code> 中，当鼠标移出时，属性值会恢复，发生过渡，transition 的逆向动画被触发，而 animation 关键帧动画不会 reverse，需另声明 reverse 的关键帧来实现，而且需通过事件来应用，要不然进入时会发生 reverse 动画。</p><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation: [name duration timing-function delay iteration-count direction fill-mode play-state]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* animation-name 关键帧名，默认值 none</span><br><span class="line">* animation-duration 动画时长，默认值 0</span><br><span class="line">* animation-timing-function 动画速度，默认值 ease</span><br><span class="line">* animation-delay 延迟，默认值 0</span><br><span class="line">* animation-iteration-count 播放次数，默认值 1</span><br><span class="line">* animation-direction 轮流反向播放，默认值 normal</span><br><span class="line">* animation-play-state 默认值 running（播放）、paused（暂停）</span><br><span class="line">* animation-fill-mode 默认值 none（不改变默认行为）、forwards（保持在最后一个关键帧中定义的状态）、backwards（保持在第一个关键帧中定义的状态）、both</span><br></pre></td></tr></table></figure><p>animation 属性简写至少要有名称和时长。</p><p>animation 使用时需先定义关键帧（@keyframes），在使用关键帧（animation）。关键帧中，用百分比来规定变化发生的时间，或用关键词 from 和 to，等同于 0%（动画开始） 和 100%（动画完成）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> fade &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">background</span>: <span class="number">#f00</span>; <span class="attribute">animation</span>: fade <span class="number">1s</span>;&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML 标签嵌套规则</title>
      <link href="/2016/02/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/"/>
      <url>/2016/02/15/HTML%20%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="HTML4-XHTML-嵌套规则"><a href="#HTML4-XHTML-嵌套规则" class="headerlink" title="HTML4/XHTML 嵌套规则"></a>HTML4/XHTML 嵌套规则</h2><p>在 HTML4/XHTML DTD 中，将元素的分为 inline level (行内级) 和 block level (块级) 两类。</p><ul><li>inline level</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">span、a、dfn、abbr、cite、img、label、q、u、em、i、strong、b、big、small、sub、sup、表单类；计算机输出类(tt、kbd、code、var、samp)</span><br></pre></td></tr></table></figure><ul><li>block level</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div、h1-h6、hr、ul、ol、dl、li、fieldset、address、from、table、html5 中新增的结构化语义标签、pre、blockquote、dir、menu</span><br></pre></td></tr></table></figure><a id="more"></a><p>注：HTML 中的 inline level、block level 与 CSS 中的 inline、block 意义不一样，HTML 强调的是语义和结构，而 CSS 强调的是样式。要不然无法解释：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;<span class="attribute">display</span>: block;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><ul><li>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素(另，a 不能在嵌套 a)：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">”#”</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<code>h1、h2、h3、h4、h5、h6、p、dt</code>。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML5-嵌套规则"><a href="#HTML5-嵌套规则" class="headerlink" title="HTML5 嵌套规则"></a>HTML5 嵌套规则</h2><p>在 <a href="https://html.spec.whatwg.org/multipage/dom.html#element-definitions" target="_blank" rel="noopener">HTML5 规范</a>中，已经不按 inline level 和 block level 来区分元素类型了，元素按 <a href="https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content" target="_blank" rel="noopener">Categories</a> 分类，元素的 <a href="https://html.spec.whatwg.org/multipage/dom.html#content-models" target="_blank" rel="noopener">Content Model</a> 规定了合法的元素内容类型。</p><ul><li>Categories</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Metadata 元数据信息元素 base, link, meta, noscript, script, style, template, title</span><br><span class="line">* Flow 流式元素，所有可以放在 body 标签内，构成文档内容的元素均属于 Flow 元素。除 base, link, meta, style, title 等只能放在head 标签内的元素外，剩下的均属 Flow 元素</span><br><span class="line">* Sectioning 结构元素 article, aside, nav, section</span><br><span class="line">* Heading 标题元素 h1, h2, h3, h4, h5, h6</span><br><span class="line">* Phrasing 短语元素，所有可以放在 p 标签内，构成段落内容的元素均属于 Phrasing 元素。HTML5 中的 Phrasing 元素大致就是 HTML4 中所定义的 inline level 元素。另外，所有 Phrasing 元素均属于 Flow 元素</span><br><span class="line">* Embedded 嵌入资源元素 audio, video, img, canvas, svg, iframe, embed, object, math</span><br><span class="line">* Interactive 交互元素 a, audio, video, button, details, embed, iframe, img, input, label, object, select, textarea</span><br></pre></td></tr></table></figure><ul><li>Content Model</li></ul><p>各元素都有自己的 Content Model，比如 <a href="https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-a-element" target="_blank" rel="noopener">a 元素</a>的 Content Model 为 <a href="https://html.spec.whatwg.org/multipage/dom.html#transparent-content-models" target="_blank" rel="noopener">transparent</a>，这类元素本身内部可以有任何类型的内容，是否合法要看其父元素的 Content Model 和其内容的 Categories，还有 p 元素，其内容模型为 Phrasing, 这意味着 p 元素只接受 Phrasing 元素为子元素（p 自身 Categories 类型为 Flow content，因而 p 不能嵌套 p）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p&gt;ins&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ul&gt;li&gt;h4&gt;a&gt;div 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个例子都是不合法的。</p><p><a href="https://html.spec.whatwg.org/multipage/grouping-content.html#the-p-element" target="_blank" rel="noopener">p 元素</a>的 content model 是 phrasing content，<a href="https://html.spec.whatwg.org/multipage/edits.html#the-ins-element" target="_blank" rel="noopener">ins</a> 本身属于 phrasing content 故可以嵌套；ins 元素的 content model 是 transparent，故在此时里面是否能有 a 需检查 p&gt;a 的合法性；a 元素也属于 phrasing content，故 p&gt;ins&gt;a 合法；a 元素的 content model 也是 transparent，故此时里面包含 div 的合法性向上传递，检查 ins&gt;div 又向上传递，变成检查 p&gt;div。所以，div 不属于 phrasing content，这个嵌套是不合法。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 技术文档写作规范</title>
      <link href="/2016/02/01/Markdown/"/>
      <url>/2016/02/01/Markdown/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>一级、二级、三级、四级…</p><p>不要超过三级标题</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>引用</li></ul><blockquote></blockquote><ul><li>代码</li></ul><p><code>`</code></p><ul><li>列表</li></ul><p>纯列表使用 使用 <em>，且用用 <code>`</code> 包裹，带描述的列表，列表名使用</em></p><p>中英文混排时，英文中使用半角符号，连接处空格</p><p>专有英文名词中单词首字母大写，句子中只需要第一个单词首字母大写。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 单位</title>
      <link href="/2016/01/20/CSS%20%E5%8D%95%E4%BD%8D/"/>
      <url>/2016/01/20/CSS%20%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px 是一个<a href="https://www.w3.org/TR/css3-values/#lengths" target="_blank" rel="noopener">绝对单位</a>，不相对于谁，只受平台 dpi 影响。cm、pt 之类的也都是绝对长度，但与 px 这个抽象单位不同的是它们都是物理单位，1pt 则是 1/72 英寸，而 1 英寸换算到公制是 2.54cm，在 CSS 中所有的物理单位会直接映射到像素，在 96dpi 下 <code>1in = 2.54cm = 96px</code> <code>1cm = 37.8px</code>。</p><a id="more"></a><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em 是一个相对单位，相对于当前元素的 font-size（如果当前元素没有 font-size 或者 font-size 是相对单位，则先继承父辈的字号，再计算 em）。也可以说，在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小。不管怎么样，要想计算 em 的大小，要先确定当前元素<strong>具体</strong>的 font-size。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 12px; line-height: 1.5em"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"display: inline-block; width: 4em; font-size: 3em;"</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面例子中，span 先继承父元素 font-size，再计算自身 font-size，即 <code>3em * 12px = 36px</code>，width 为 <code>4 * 36px = 144px</code>。另外，对于相对单位属性的继承，要在父辈元素先计算为具体值，再继承，div 的 line-height 为 <code>1.5em * 12px = 18px</code>，所以 span 的 line-height 为 18px，而不是直接继承 1.5em。</p><p>由于 em 相对于当前元素的字号大小，而且字号会继承，这导致不能统一管理基础变量，且依赖追溯复杂，不适合在整个页面中使用，只适用于做局部缩放的场景。</p><p>历史上，因为 IE 不支持 px 为单位的缩放，故使用 em 来做缩放。<a href="http://clagnut.com/about" target="_blank" rel="noopener">Richard Rutter</a> 在 <a href="http://clagnut.com/blog/348/" target="_blank" rel="noopener">How to size text using ems</a> 和 <a href="http://alistapart.com/article/howtosizetextincss" target="_blank" rel="noopener">How to Size Text in CSS</a> 中做过详细的介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(<span class="built_in">document</span>.querySelector(<span class="string">':root'</span>), <span class="literal">null</span>).fontSize; <span class="comment">// 16px，Chrome 上最小支持的字号为 12px</span></span><br></pre></td></tr></table></figure><p>以 <code>&lt;html&gt;</code> 的 <code>font-size</code> 为基准，浏览器默认的字号为 16px，换算为 em 即 <code>1em = 16px</code>、<code>12px = 0.75em</code>、<code>10px = 0.625em</code>，为了方便 <code>font-size</code> 的换算，可将 html 字号设为 <code>font-size: 62.5%</code>（即 <code>16px * 62.5% = 10px</code>），或者直接 <code>font-size: 10px</code>，这样 <code>1em = 10px</code>、<code>1.2em = 12px</code>、<code>1.4em = 14px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 10 ÷ 16 × 100% = 62.5%</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line">// body&gt;h1, 2.4em × 10 = 24px</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4em</span>;&#125;</span><br><span class="line"></span><br><span class="line">// body&gt;p, 1.4em × 10 = 14px</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4em</span>;&#125;</span><br></pre></td></tr></table></figure><p>随着浏览器的更新换代，这种做法早已被淹没在历史尘埃中。</p><h2 id="percent"><a href="#percent" class="headerlink" title="percent"></a>percent</h2><p>一般情况下 % 相对于包含块（containing block），在应用于字体大小时，相对于父字体大小。</p><p>包含块的确定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 对于普通定位元素就是父元素</span><br><span class="line">* 对于 position: absolute 的元素是相对于已定位的父元素（offset parent）</span><br><span class="line">* 对于 position: fixed 的元素是相对于 ViewPort（可视窗口）</span><br></pre></td></tr></table></figure><p>需要注意的是，padding、margin 如果设置了百分比，会发现左右和预期一样，用的父元素宽度的百分比，但是上下用的也是宽度百分比，而不是想象中的高度的百分比。另外，percent 在被后代元素继承时继承的是百分比计算后的值，而不是原百分比，比如 line-height 120% 和 1.2 在被继承时。</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem 相对于根元素 font-size 的单位。引入它是为了解决 em 依赖追溯困难，计算复杂的问题。而 rem 是相对于根元素 <code>&lt;html&gt;</code>，依赖简单，只需要在根元素确定一个参考值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 10 ÷ 16 × 100% = 62.5%</span><br><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">62.5%</span>;&#125;</span><br><span class="line"></span><br><span class="line"># 1.4 × 10px = 14px</span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.4rem</span>;&#125;</span><br><span class="line"></span><br><span class="line"># 2.4 × 10px = 24px</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2.4rem</span>;&#125;</span><br></pre></td></tr></table></figure><p>虽然 em、rem 相对于 font-size，但是并不单单只能应用于 font-size。另外，所有的 em、rem、percent 渲染的时候，都会被转为 px，因为<strong>px是计算机矢量图渲染成像的原理</strong>。</p><p>rem 一般用来做移动端适配。</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw 是 CSS3 引入的单位，相对于视口的宽度，视口被均分为 100 单位的 vw，1vw = 1% 窗口宽度。vh同理。常用来配合 rem 做移动端适配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>各个单位都有各自的优缺点，取决于场景，不能脱离场景谈应用。例如，em、rem、vh、vw、 Percent 这些相对单位，比较适合做尺寸联动适配。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器</title>
      <link href="/2016/01/19/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2016/01/19/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>简单选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 通配符选择器</span><br><span class="line">E 标签选择器</span><br><span class="line">类选择器</span><br><span class="line">ID 选择器</span><br></pre></td></tr></table></figure><ul><li>关系选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E F 后代选择器</span><br><span class="line">E&gt;F 子选择器</span><br><span class="line">E~F 相邻选择器</span><br><span class="line">E+F 相邻兄弟选择器</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[attr]</span><br><span class="line">[attr=val]</span><br><span class="line">[attr|=val] 开头匹配（分词）</span><br><span class="line">[attr~=val] 包含匹配（分词）</span><br><span class="line">[attr^=val] 开头匹配</span><br><span class="line">[attr$=val] 结尾匹配</span><br><span class="line">[attr*=val] 包含匹配</span><br></pre></td></tr></table></figure><ul><li>伪类选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 结构性伪类选择器</span><br><span class="line">:root</span><br><span class="line">:not</span><br><span class="line">:empty                  # E 元素中没有子节点（包含文本节点）</span><br><span class="line">:target</span><br><span class="line"></span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br><span class="line">:first-of-type</span><br><span class="line">:last-of-type</span><br><span class="line">:nth-child(n)           # 父元素中的第 n 个 E 元素</span><br><span class="line">:nth-last-child(n)      # 父元素中的第 n 个 E 元素，从后向前计算</span><br><span class="line">:nth-of-type(n)</span><br><span class="line">:nth-last-of-type(n)</span><br><span class="line"></span><br><span class="line"># UI 元素状态伪类选择器</span><br><span class="line">:link</span><br><span class="line">:visited</span><br><span class="line">:hover</span><br><span class="line">:active</span><br><span class="line">:focus</span><br><span class="line"></span><br><span class="line">:enabled</span><br><span class="line">:disabled</span><br><span class="line">:checked</span><br><span class="line">:read-only</span><br><span class="line">:read-write</span><br><span class="line"></span><br><span class="line">:required</span><br><span class="line">:optional</span><br><span class="line">:valid</span><br><span class="line">:inlvalid</span><br><span class="line">:in-range</span><br><span class="line">:out-of-range</span><br><span class="line"></span><br><span class="line">:only-of-type</span><br><span class="line">:only-child</span><br><span class="line"></span><br><span class="line">:lang</span><br></pre></td></tr></table></figure><p>注2：带 <code>type</code> 的选择器，是 type（类型）里面进行筛选的，<code>first-of-type</code>（type里面的第一个）、<code>only-of-type</code>（type里面唯一）。</p><ul><li>伪元素选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">::before 原始的开始</span><br><span class="line">::after 元素的结尾</span><br><span class="line">::first-letter 第一个字母</span><br><span class="line">::first-line 第一行</span><br><span class="line">::selecton 选中的内容</span><br></pre></td></tr></table></figure><p>伪元素表示的是并不真实存在的元素（特殊的位置），与伪类的主要区别是，伪类选择的是元素，而伪元素选择器选择的是伪元素。</p><h2 id="选择器的应用"><a href="#选择器的应用" class="headerlink" title="选择器的应用"></a>选择器的应用</h2><p>选择器可组合，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E.class &#123;&#125;</span><br><span class="line">:hover &#123;&#125;</span><br><span class="line">E:hover &#123;&#125;</span><br><span class="line">[attr] &#123;&#125;</span><br><span class="line">E[attr] &#123;&#125;</span><br><span class="line">:first-child &#123;&#125;</span><br><span class="line">E:first-child &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>,</code> 分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E,F &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>nth-child 和 not 选择器的妙用</li></ul><p>注1：n 从 1 开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:nth-child(odd)</span><br><span class="line">E:nth-child(even)</span><br><span class="line">E:nth-child(2n)</span><br></pre></td></tr></table></figure><p>选择 1 到 3 的元素并显示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(-n+3)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用 not 反选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:nth-child(-n+3))</span> &#123;&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>逗号分隔列表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:last-child)</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">","</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 a 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">"http"</span>]</span><span class="selector-pseudo">:empty</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:has() 选择器是一个关系型伪类选择器，也被称为函数型伪类选择器，它和 :is()、:not() 以及 :where()函数型选择器被称为 CSS的逻辑组合选择器 ！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 精粹</title>
      <link href="/2016/01/02/CSS%20%E7%B2%BE%E7%B2%B9/"/>
      <url>/2016/01/02/CSS%20%E7%B2%BE%E7%B2%B9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="CSS-的构成"><a href="#CSS-的构成" class="headerlink" title="CSS 的构成"></a>CSS 的构成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 选择器</span><br><span class="line">* 文字处理</span><br><span class="line">* 背景图像处理</span><br><span class="line">* 布局</span><br><span class="line">* 动画</span><br></pre></td></tr></table></figure><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="W3C-标准"><a href="#W3C-标准" class="headerlink" title="W3C 标准"></a>W3C 标准</h3><p>W3C 的标准化进程为：<code>WD --&gt; LC --&gt; CR --&gt; PR --&gt; REC</code>。</p><ul><li>关于前缀</li></ul><p>CSS 规范一般由 W3C 组织先制定草案（WD），然后浏览器厂商各自实现，稳定后再进入标准（推荐 REC）。从 WD 到 REC 有一个过程，如果浏览器厂商提前支持，会存在风险，可能会导致未来的不兼容。</p><p>有一个经典的案例，IE6 在 <code>inline-block</code> 未进入标准前就已对其支持了，当标准出来后含义却不一样。未防止这种情况的出现，于是通过加前缀私有的方式来实现未进入标准的特性。</p><p>浏览器前缀可以加在属性上，也可以加在属性值上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">rotate</span>(180<span class="selector-tag">deg</span>);</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-flex</span>;</span><br></pre></td></tr></table></figure><h3 id="可视化格式模型"><a href="#可视化格式模型" class="headerlink" title="可视化格式模型"></a>可视化格式模型</h3><ul><li>BFC</li></ul><p>注：overflow非visible都会激活BFC（不光光只有平时所用hidden），html根元素默认overflow:auto，所以默认下就已经是一个BFC环境，所有的block level元素在BFC中被格式化，呈纵向排布。</p><ul><li>IFC</li></ul><h3 id="CSS-Specificity"><a href="#CSS-Specificity" class="headerlink" title="CSS Specificity"></a>CSS Specificity</h3><h2 id="方法论和工具"><a href="#方法论和工具" class="headerlink" title="方法论和工具"></a>方法论和工具</h2><p>掌握几套方法论和一些常用工具，比如方法论：<code>OOCSS、BEM、SMACCSS、CSS Module…</code>；工具里面：<code>LESS、SASS、CSSLint、PostCSS…</code>。</p><p>CSS Modules</p><p>CSS in JS</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><ul><li>css 在逐渐改变存在的问题</li></ul><p>表达能力变强(css3 也支持了变量)<br>父选择器</p><ul><li>sass</li></ul><p>理论上计算机中所有问题都可以通过加一个中间层来解决，sass 就可以看为一个中间层(和 ts 一样)，目的是为了提高 css 的表达能力，要是在浏览器上加入 sass 引擎，浏览器也就原生支持 sass 了。</p><ul><li>模块化</li></ul><p>模块化/组件化的目的: 复用、分治(所以说并不是只有复用才会去做模块化,有些组件只是单纯的为了分治，不具备复用的能力，比如一些子组件，SidebarItem 就不能脱离子组件单纯拿出来用)。用到的方法是抽象。</p><p>css 命名: c 强调的是分治，m 强调的是复用</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局的传统解决方案，基于盒模型（margin、padding），依赖 display 属性 + position 属性 + float 属性。</p><ul><li>圣杯</li></ul><p>左右固定宽度，中间自适应，且中间放在文档流前面以优先渲染。</p><p>负 margin 的应用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;<span class="attribute">overflow</span>: hidden; <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span>, <span class="selector-class">.main</span>, <span class="selector-class">.right</span> &#123;<span class="attribute">position</span>: relative; <span class="attribute">float</span>: left; <span class="attribute">height</span>: <span class="number">130px</span>;&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">background</span>: <span class="number">#008000</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">left</span>: -<span class="number">200px</span>; <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">right</span>: -<span class="number">200px</span>; <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：这种布局的解法办法有很多，负 margin 的圣杯和双飞翼是其中一种，我认为最简洁的办法是绝对定位：<code>.center {margin: 0 200px;} .left .right 绝对定位</code>。</p><ul><li>双飞翼</li></ul><p>圣杯布局、双飞翼布局，解决的问题是一样的：左右固定宽度，中间自适应，且中间放在文档流前面以优先渲染。在解决问题的方案上，圣杯布局和双飞翼布局前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决“中间栏内容不被遮挡”问题的思路不一样。</p><p>-margin 的应用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;<span class="attribute">float</span>: left; <span class="attribute">height</span>: <span class="number">130px</span>;&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;<span class="attribute">width</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;<span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">130px</span>; <span class="attribute">background</span>: <span class="number">#008000</span>;&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;<span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#ccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;<span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">background</span>: <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>瀑布流</li></ul><p><code>float: left</code> 或 <code>position: absolute</code> 的应用。</p><ul><li>两栏等高布局</li></ul><p>Equal height columns 的解法有很多中，除负 margin 正 padding 障眼法外，table、flex、JS 也可解。</p><p>JS 的缺点是异步html数据，padding margin在firefox和ie上对正负抵消有滚动。</p><ul><li>全屏布局</li></ul><p>poition: absolute的应用。</p><ul><li>九宫格</li></ul><p>负 margin的应用。</p><ul><li>视差滚动</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Guide</title>
      <link href="/2015/07/01/Git-Guide/"/>
      <url>/2015/07/01/Git-Guide/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>已经处理：</p><p><a href="https://juejin.cn/post/6844903598522908686" target="_blank" rel="noopener">https://juejin.cn/post/6844903598522908686</a></p><p>未处理：</p><p><a href="https://www.cnblogs.com/best/p/7474442.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/best/p/7474442.html#!comments</a></p><p><a href="https://juejin.cn/post/6844904019245137927" target="_blank" rel="noopener">https://juejin.cn/post/6844904019245137927</a></p><p><a href="https://juejin.cn/post/6974184935804534815" target="_blank" rel="noopener">https://juejin.cn/post/6974184935804534815</a></p><p><a href="https://juejin.cn/post/6844903684476764168" target="_blank" rel="noopener">https://juejin.cn/post/6844903684476764168</a></p><p><a href="https://juejin.cn/post/6869519303864123399" target="_blank" rel="noopener">https://juejin.cn/post/6869519303864123399</a></p><p><a href="https://juejin.cn/post/6904524764761554951" target="_blank" rel="noopener">https://juejin.cn/post/6904524764761554951</a></p><p>内部原理：<a href="http://jingsam.github.io/archives/" target="_blank" rel="noopener">http://jingsam.github.io/archives/</a></p><p><a href="https://www.cnblogs.com/best/p/7474442.html#!comments" target="_blank" rel="noopener">https://www.cnblogs.com/best/p/7474442.html#!comments</a></p><p><a href="https://github.com/skywind3000/awesome-cheatsheets/blob/master/tools/git.txt" target="_blank" rel="noopener">https://github.com/skywind3000/awesome-cheatsheets/blob/master/tools/git.txt</a></p><p><a href="http://www.git-tower.com/learn" target="_blank" rel="noopener">http://www.git-tower.com/learn</a></p><p><a href="http://rogerdudler.github.io/git-guide/" target="_blank" rel="noopener">http://rogerdudler.github.io/git-guide/</a></p><p>官网教程：<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93</a></p><p>官网 API 文档：<a href="http://git-scm.com/docs" target="_blank" rel="noopener">http://git-scm.com/docs</a><br>中文：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a> –&gt; 廖老师@廖雪峰写的 Git 教程，墙裂推荐！！！</p><p>Git 简明指南：<a href="https://www.runoob.com/manual/git-guide/、https://www.runoob.com/manual/git-guide/" target="_blank" rel="noopener">https://www.runoob.com/manual/git-guide/、https://www.runoob.com/manual/git-guide/</a></p><p>PDF 版命令手册：<a href="https://www.runoob.com/manual/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">https://www.runoob.com/manual/github-git-cheat-sheet.pdf</a></p><p>忽略某些文件时，需要编写 .gitignore，然后将 .gitignore 放到版本库中</p><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="noopener">https://www.runoob.com/git/git-workspace-index-repo.html</a></p><p>与 github、gitbucket、gitlab、gogs</p><p>远程仓库管理系统（基于 Git）：功能一般包括，Git 版本库，问题管理，wiki</p><p>git commit 要不要归类到 分支管理 目录中</p><p>git rebase<br>git rm<br>git reset</p><p>use “git rm –cached<file>…” to unstage<br>use “git reset HEAD<file>…” to unstage</file></file></p><p>svn 是集中式的，svn commit 会直接提交到中央服务器，必须要联网</p><p><a href="https://blog.csdn.net/weixin_40005373/article/details/112191117" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40005373/article/details/112191117</a></p><p><a href="https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-cli-main.html" target="_blank" rel="noopener">https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/tsvn-cli-main.html</a></p><p><a href="https://www.runoob.com/svn/svn-commit.html" target="_blank" rel="noopener">https://www.runoob.com/svn/svn-commit.html</a></p><p>注：Git 里面没有主干 – trunk 的概念（SVN 中式区分 trunk 和 branches 的），可以将主分支 – master branches 理解为主干。</p><p>SVN 上的分支不是引用而是复制。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>分布式</li></ul><p>Git 是分布式版本控制系统，这不同于 SVN 这类集中式版本控制系统，可以完全去中心化工作，不用和中央服务器 (remote server) 进行通信，在本地即可进行全部版本控制操作，包括 commit、log、diff…，即便是离线下。</p><ul><li>快照</li></ul><p>分支在SVN中实际上是版本库中的一份copy，而git一个仓库是一个快照，所以git 切换、合并分支等操作更快速。</p><ul><li>指针</li></ul><p>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录。这个特性使 Git 的分支切换非常迅速，且创建成本非常低。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><p>Index</p></li><li><p>Object</p></li></ul><p>git三大对象类型: 数据对象(Blob Object) / 树对象(Tree Object) / 提交对象(Commit Object)</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>三大区域</li></ul><p>在 Git 项目中，存在三大区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Workspace/Working Tree/Working Directory：工作区</span><br><span class="line">Index/Stage：暂存区、索引</span><br><span class="line">Repository/Git Directory：版本库、仓库、资源库、Git 目录</span><br></pre></td></tr></table></figure><p><img src="/images/engineering/git/areas.png" alt="Git Flow 流程图"></p><p>基本的 Git 工作流程：在工作区中修改文件。<code>git add</code> 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。<code>git commit</code> 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</p><p><code>git add</code> 是让文件进入 staged，<code>git commit</code> 是让文件进入 committed。</p><p>暂存区设计目的之一，就是为了实现 add，选择性提交。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Todo……</p><p><a href="https://zhuanlan.zhihu.com/p/53750883" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53750883</a></p><p>前三个回答：<a href="https://www.zhihu.com/question/19946553/answer/29033220" target="_blank" rel="noopener">https://www.zhihu.com/question/19946553/answer/29033220</a></p><p><a href="https://zhuanlan.zhihu.com/p/96631135" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96631135</a></p><p><a href="https://zhuanlan.zhihu.com/p/98679880" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98679880</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 上使用 apt（或 yum） 安装 <code>sudo apt install git</code>，Windows 上可以从 Git 官网<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，Mac OS 上，Xcode 默认集成了 Git，如果没有安装 Xcode，可通过 Homebrew 单独安装。</p><p>另外，Windows 中要想在 CMD 中执行 Git，需要将 Git 添加到环境变量 path 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Git\bin</span><br><span class="line">C:\Program Files\Git\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git help [-a|--all] [-g|--guide] [-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]    # git help help 查看 help 命令如何使用</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 共有三级配置，优先级依次是本地配置 &gt; 全局配置 &gt; 系统配置。系统配置在 <code>/etc/gitconfig</code> 文件中（Windows 在 <code>/mingw64/etc/gitconfig</code>。Windows Git Bash 中的根目录是 Git 的安装目录），全局配置在 <code>~/.gitconfig</code> 文件中，本地配置在本地仓库的 <code>.git/config</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># cat ~/.gitconfig 如下所示</span><br><span class="line">[user]</span><br><span class="line">email = 240866271@qq.com</span><br><span class="line">name = Tracy</span><br><span class="line">[winUpdater]</span><br><span class="line">recentlySeenVersion = 2.17.0.windows.1</span><br><span class="line">[credential]</span><br><span class="line">helper = manager</span><br><span class="line">[commit]</span><br><span class="line">template = D:/commit-template</span><br></pre></td></tr></table></figure><p>注：mingw（Minimalist GNU on Windows） 是一款 Windows 上的 GNU 工具集（含 vim、ssh client…），mingw64 是其 64 位版。Windows 版 Git 自带 mingw。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list    # 查看系统配置</span><br><span class="line">git config --global --list    # 查看全局配置</span><br><span class="line">git config --local --list     # 查看 repository 配置</span><br><span class="line">git config --list             # 查看当前配置（配置信息会合并，结果是本地、全局、系统三者的合并）</span><br><span class="line">git config &lt;setting&gt;          # 查看特定配置，比如 git config user.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="设置配置信息"><a href="#设置配置信息" class="headerlink" title="设置配置信息"></a>设置配置信息</h3><p>最常见的自定义配置是用户信息（用户名和邮件地址，commit 时用）、Commit Message Template、Credential Helper。</p><ul><li>用户信息</li></ul><p>用户信息用于 commit 时标示用户身份，git log 的提交日志中可以查看，如果没有配置，在 MacOS 下会使用操作系统用户名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 姓名</span><br><span class="line">git config --global user.name &quot;Tracy&quot;</span><br><span class="line"># 邮箱</span><br><span class="line">git config --global user.email &quot;240866271@qq.com&quot;</span><br></pre></td></tr></table></figure><p>注：–global 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p><ul><li>提交模版</li></ul><p>Commit Message Template</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global commit.template /d/commit-template</span><br></pre></td></tr></table></figure><ul><li>换行</li></ul><p>由于各操作系统文本文件所使用的换行符不一样，UNIX/Linux/OS X 使用的是 LF，Windows/Dos 使用的 CRLF。Git 默认提供了一个“换行符自动转换”功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf xx   # true、input（推荐使用）、false</span><br></pre></td></tr></table></figure><p>true 表示开启自动转换，迁入时将文件换行风格转换成 Unix 风格，迁出时根据本地系统确定是否转换成 CRLF。<br>input 表示迁入的时候将换行风格转换成 Unix 风格，迁出时不做处理。<br>false 表示迁入迁出都不对换行风格进行处理。</p><ul><li>其他</li></ul><p>除了上述常用配置，还有其他的配置，比如颜色、别名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 显示颜色，会让命令输出看起来更醒目</span><br><span class="line">git config --global color.ui true</span><br><span class="line"></span><br><span class="line"># status、checkout 别名</span><br><span class="line">git config --global alias.st status            # st 就表示 status。git st 等价于 git status</span><br><span class="line">git config --global alias.co checkout          # co 就表示 checkout</span><br><span class="line"></span><br><span class="line"># unstage 别名</span><br><span class="line">git config --global alias.unstage &apos;reset HEAD&apos; # git unstage test.js 等价于 git reset HEAD test.js，可以把暂存区的修改撤销（unstage），重新放回工作区</span><br><span class="line"></span><br><span class="line"># 显示最后一次提交信息别名</span><br><span class="line">git config --global alias.last &apos;log -1&apos;        # git last 就能显示最后一次提交</span><br><span class="line"></span><br><span class="line"># log 别名</span><br><span class="line">git config --global alias.lg </span><br><span class="line">&quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line"># git init 默认分支名</span><br><span class="line">git config --global init.defaultBranch main    # 从 master 改为 main</span><br></pre></td></tr></table></figure><p>注，可直接编辑配置文件来设置配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --system -e    # 系统配置</span><br><span class="line">git config --global -e    # 全局配置</span><br><span class="line">git config -e             # 本地配置</span><br></pre></td></tr></table></figure><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 初始化仓库</span><br><span class="line">git init &lt;folder&gt;                  # 带 --bare 参数，可创建一个裸库</span><br><span class="line"></span><br><span class="line"># 将文件添加到暂存区</span><br><span class="line">git add -p &lt;file&gt;</span><br><span class="line"></span><br><span class="line"># 将暂存区文件添加到本地仓库中（会生成唯一的 hash 值作为 commit id）</span><br><span class="line">git commit -m &quot;add LICENSE&quot;        # 如果想要记述的更加详细，不加 -m 参数即可</span><br><span class="line"># 修改最后一次 commit message（如果不是最后一次，需要组合使用 rebase 命令，才能完成）</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"># 从版本库中删除文件</span><br><span class="line">git rm &lt;file&gt;                      # 删除工作区文件，并删除暂存区对应文件记录</span><br><span class="line">git rm --cached &lt;file&gt;             # 删除暂存区文件记录</span><br><span class="line"></span><br><span class="line"># 查看仓库状态</span><br><span class="line"># Git 文件的 4 种状态：untracked(未跟踪)、staged(已暂存)、unmodified/committed(已提交)、modified(已修改)，它们之间相互转换流程</span><br><span class="line">git status                         # 查看所有文件状态</span><br><span class="line">git status [filename]              # 查看指定文件状态</span><br><span class="line"></span><br><span class="line"># 比较差异（看懂 git diff）</span><br><span class="line">git diff              # 比较 workspace 与 index 的差异</span><br><span class="line">git diff HEAD         # 比较 workspace 与 local repository 中提交记录的差异，其中 HEAD 表示最新提交，HEAD^ 表示上一个提交，HEAD^^ 表示上上一个提交，依此类推，也可以用 HEAD~X 表示，X 代表 ^ 的个数</span><br><span class="line">git diff --cached/--staged     # 比较 index 与 local repositorty  的差异</span><br><span class="line">git diff hash1 hash2  # 比较两个提交记录的差异</span><br><span class="line"></span><br><span class="line"># 查看提交日志</span><br><span class="line">git log          # 可以加参数，比如 --pretty=oneline</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 版本回退</span><br><span class="line">git reset --hard HEAD^             # 当前版本 HEAD,上一个版本 HEAD^,上上个版本 HEAD^^</span><br><span class="line">git reset --hard 130f10a           # 或 HEAD~100</span><br><span class="line"></span><br><span class="line"># 把暂存区的修改撤销掉（to unstage）</span><br><span class="line">git reset HEAD filename</span><br><span class="line"></span><br><span class="line"># 查看命令记录</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"># 丢弃工作区的修改，回到最近一次 git commit 或 git add 时的状态</span><br><span class="line">git checkout -- README.md</span><br><span class="line"></span><br><span class="line"># 把误删的文件恢复到最新版本，checkout 其实用版本库里的版本替换工作区的版本</span><br><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure><p>廖雪峰时光穿梭机</p><p>这列的版本指的是提交记录。</p><p>这个也是我目前不太熟悉的地方，开发中常常需要将回退项目的操作，会退至某次提交</p><p>todo。。。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是用来进行并行作业的。<code>git init</code> 会默认创建 master 主分支。</p><p>以 dev 和 master 作为实例分支。</p><h3 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 查看分支（当前分支前面标有 × 号）</span><br><span class="line">git branch                                # 不带参数查看本地分支，-a 查看所有分支，-r 列出远程跟踪的分支（不是远程分支）</span><br><span class="line"></span><br><span class="line"># 创建分支（基于当前分支）</span><br><span class="line">git branch &lt;branch-name&gt;                  # 只创建不切换</span><br><span class="line"></span><br><span class="line"># 切换分支</span><br><span class="line">git checkout dev</span><br><span class="line"></span><br><span class="line"># 创建（基于当前分支）和切换分支</span><br><span class="line">git checkout -b dev                       # 相当于 git branch dev、git checkout dev</span><br><span class="line">git checkout --orphan dev                 # 创建一个没有任何的提交记录的空分支，但是当前分支的内容都有，可用 git rm -rf . 删除原来代码树下的所有文件</span><br><span class="line"></span><br><span class="line"># 重新命名分支</span><br><span class="line">git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 合并分支（合并指定分支到当前分支，比如当前分支是 master）</span><br><span class="line">git merge dev</span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev   # --no-ff 参数，表示禁用 Fast forward</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d dev                         # 删除已合并的本地分支（但不能删除当前分支，需要切换，才能删除）。-d -r 参数删除远程追踪分支（只是删除 git branch -r 列表中的追踪分支，并不会删除远程分支）</span><br><span class="line">git branch -D dev                         # 强行删除一个没有合并过的本地分支</span><br><span class="line"></span><br><span class="line"># 看看分支的历史提交记录</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 拉取远程仓库更新，但不合并</span><br><span class="line">git fetch                     # 默认下，git fetch 取回所有分支的更新，如果只想取回特定分支的更新，可以指定分支名，比如：git fetch origin master</span><br><span class="line"></span><br><span class="line"># 拉取远程仓库更新，且合并（git pull [远程主机名] [远程分支名]:[本地分支名]）（实质上，这等同于先做git fetch，再做git merge）</span><br><span class="line">git pull</span><br><span class="line">git pull origin dev           # 如果省略本地分支名，则表示远程分支与当前分支合并</span><br><span class="line"></span><br><span class="line"># 向远程仓库库推送更新（git push [远程主机名] [本地分支名]:[远程分支名]）（为防止冲突，push 前要先 pull）</span><br><span class="line">git push -u origin master     # 当前分支可能与多个主机存在追踪关系（tracking），所以首次要用 -u（--set-upstream）指定一个默认主机（upstream），以后可直接 git push</span><br><span class="line">git push origin master        # 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支，如果该远程分支不存在，则会被新建</span><br><span class="line">git push origin :dev          # 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支</span><br><span class="line">git push origin               # 将当前分支推送到 origin 主机的对应分支</span><br><span class="line">git push                      # 如果当前分支只有一个追踪分支，那么连主机名都可以省略</span><br><span class="line">git push --force              # --force/-f 强制推送</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">git push origin --delete dev  # 删除 origin 主机的 dev 分支。注：远程的默认分支，不能为当前将要删的目标分支，如果是，需要将默认分支切换到其他分支上，再删</span><br><span class="line"></span><br><span class="line"># 从远程库 clone，默认情况只能看到 master 分支，需要在 dev 分支，必须创建远程 origin 的 dev 分支到本地</span><br><span class="line">git checkout -b dev origin/dev</span><br><span class="line">git checkout -b branch-name origin/branch-name</span><br><span class="line">git branch --set-upstream branch-name origin/branch-name # 关联</span><br></pre></td></tr></table></figure><p>注：不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式。如果要修改这个设置，可以采用 git config 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># matching</span><br><span class="line">git config --global push.default matching</span><br><span class="line"></span><br><span class="line"># simple</span><br><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>Git 中的标签和分支有点类似，都是引用或者说指针，不过标签的位置是固定的，在给指定提交打好标签以后，它就固定于此位置，而分支的位置是会不断变动的，随着分支的向前推移或者向后回滚，都在不断变化。分支和标签的用处也不一样，分支用于并行作业，而标签用于处理发布。</p><p>Git 标签分为两种类型：轻量型（lightweight）和附注型（annotated）。轻量标签是指向特定提交对象的引用，而附注标签则是仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。建议使用附注标签，以便保留相关信息。标签名应采用统一的格式，<code>v${MajorVersion}.${MinorVersion}.${FixVersion}-${TypeLabel}</code>，其中 TypeLabel (alpha、 beta…) 可选。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看标签</span><br><span class="line">git tag                                 # 查看所有 tag</span><br><span class="line">git tag -l v1.0.*                       # 查看符合模式的 tag</span><br><span class="line">git show v1.0.0                         # 查看 tag 信息</span><br><span class="line"></span><br><span class="line"># 新建标签</span><br><span class="line">git tag v1.0.0                          # 新建轻量 tag</span><br><span class="line">git tag v1.0.0 9fceb02                  # 为某个 commit 新建 tag（一般用于后期加注标签）。用 git log --pretty=oneline --abbrev-commit 查看 commit id</span><br><span class="line">git tag -a v1.0.0 -m &quot;message&quot;          # 新建带注释的 tag（用 -a 来创建一个带备注的 tag，-m 指定说明文字）</span><br><span class="line"></span><br><span class="line"># 推送标签</span><br><span class="line">git push origin v1.0.0                  # 推送某个具体 tag</span><br><span class="line">git push origin --tags                  # 推送所有 tag</span><br><span class="line"></span><br><span class="line"># 切换标签</span><br><span class="line">git checkout v1.0.0                     # 切换方法跟分支一样</span><br><span class="line"></span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d v1.0.0                       # 删除本地某个 tag</span><br><span class="line">git push origin :refs/tags/v1.0.0   # 删除远端某个 tag</span><br></pre></td></tr></table></figure><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><p>Stash 可用在一些特殊的工作场景中，比如，需要临时修复 Bug，可以把当前工作现场储藏起来，等 Bug 修复后恢复现场后继续工作。在 Git Flow 下，Stash 基本用不到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 保存存储</span><br><span class="line">git stash</span><br><span class="line">git stash save &quot;save message&quot; # 带注释的存储</span><br><span class="line"></span><br><span class="line"># 查看存储列表</span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"># 查看存储详情</span><br><span class="line">git stash show                          # 默认查看第一个 stash，即 stash@&#123;0&#125;，可以以指定。另外，-p 参数，可以查看到具体的详情</span><br><span class="line"></span><br><span class="line"># 恢复存储</span><br><span class="line">git stash pop                           # 恢复的同时把存储也删了，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定 git stash pop stash@&#123;$num&#125;</span><br><span class="line">git stash apply                         # 恢复某个存储，但不会把存储从存储列表中删除，默认使用第一个存储，也可以指定</span><br><span class="line"></span><br><span class="line"># 删除存储</span><br><span class="line">git stash drop                          # 删除某个存储，默认使用第一个 stash，即 stash@&#123;0&#125;，也可以指定</span><br><span class="line">git stash clear                         # 删除所有存储</span><br></pre></td></tr></table></figure><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>.gitignore 配置文件用于忽略文件，不被添加到版本库中，其配置语法如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以斜杠 / 开头表示目录</span><br><span class="line">以星号 * 通配多个字符</span><br><span class="line">以问号 ? 通配单个字符</span><br><span class="line">以方括号 [] 包含单个字符的匹配列表</span><br><span class="line">以叹号 ! 表示不忽略匹配到的文件或目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 txt 结尾的文件</span><br><span class="line">*.txt</span><br><span class="line"># 忽略 doc 目录下 所有 txt 文件，不包括子目录（doc/subdir/a.txt）</span><br><span class="line">doc/*.txt</span><br><span class="line"># 忽略 doc 目录下所有 txt 的文件，包括子目录</span><br><span class="line">doc/**/*.txt</span><br><span class="line"></span><br><span class="line"># README.txt 除外</span><br><span class="line">!README.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build/ 目录下的所有文件（不管 build 是根目录还是子目录，都会被忽略）</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># 忽略根目录下的 TODOLIST 文件（不包括 subdir/TODOLIST）</span><br><span class="line">/TODOLIST</span><br></pre></td></tr></table></figure><p>注：Git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的，如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>远程中心化仓库可用来备份存储和共享协作（clone、push、pull…）。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 生成私钥和公钥证书</span><br><span class="line">ssh-keygen -t rsa -C &quot;any comment can be here&quot;</span><br><span class="line"></span><br><span class="line"># 测试证书登录是否设置成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"># 克隆远程仓库</span><br><span class="line">git clone [remote url] [local url]                    # git clone git@github.com:michaelliao/gitskills.git （GitHub 可以使用 HTTPS 和 SSH 协议）</span><br><span class="line"></span><br><span class="line"># 添加远程仓库</span><br><span class="line">git remote add [shortname] [url]                      # git remote add origin git@github.com:Windrivder/Windrivder.git</span><br><span class="line"></span><br><span class="line"># 删除远程仓库</span><br><span class="line">git remote rm [remote name]</span><br><span class="line"></span><br><span class="line"># 修改远程仓库名</span><br><span class="line">git remote rename [old remote name] [new remote name]</span><br><span class="line"></span><br><span class="line"># 要查看远程库的信息</span><br><span class="line">git remote                                            # 查看已经存在的远程仓库</span><br><span class="line">git remote -v                                         # 查看已经存在的远程仓库的详细信息</span><br></pre></td></tr></table></figure><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>SSH 可通过证书来实现免密登录，然而，这对 HTTP 协议来说是不可能的，每一个连接都是需要用户名和密码的（<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">官网文档</a>）。为了不用每次都输入用户名和密码，Git 使用 credential.help 来存储本地凭证（默认所有都不缓存，每一次连接都会询问你的用户名和密码），其所支持的选项如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache        # cache 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在 15 分钟后从内存中清除</span><br><span class="line">store        # store 模式会将凭证用明文的形式存放在磁盘中（默认在 home 目录），永不过期</span><br><span class="line">osxkeychain  # Mac 下 store 的加密版，凭证保存在用户的钥匙串中</span><br><span class="line">manager      # Windows 下 store 的加密版，凭证保存在 Windows 的凭据管理器中。在 system 级别被设置（credential.helper=manager），优先于 global 和 local</span><br></pre></td></tr></table></figure><p>可通过 Git 的帮助文档来查看我们系统支持哪种 helper。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Linux 下</span><br><span class="line">git help -a | grep credential</span><br><span class="line"># 输出结果</span><br><span class="line">credential                 remote-ftps</span><br><span class="line">credential-cache           remote-ftps</span><br><span class="line">credential-cache--daemo    remote-ftps</span><br><span class="line">credential-store           remote-ftps</span><br><span class="line"></span><br><span class="line"># Window 下（CMD 使用 findstr，PowerShell 使用 sls。或者在 C:\Program Files\Git\mingw64\libexec\git-core 目录下执行 (ls).Name | sls credential）</span><br><span class="line">git help -a | sls credential</span><br><span class="line"># 输出结果</span><br><span class="line">git-credential-manager.exe</span><br><span class="line">git-credential-store.exe</span><br><span class="line">git-credential-wincred.exe</span><br><span class="line">git-credential.exe</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看默认配置</span><br><span class="line">git config --list | grep credential</span><br></pre></td></tr></table></figure><p>Mac 默认 credential helper 是 osxkeychain，Windows 默认是 manager，而 Linux 默认不存储，需手动设置，以 store 模式为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>这样，会生成 <code>~/.git-credentials</code> 文件，用户信息会以明文保存在里面，<code>https://{userName}:{password}@github.com</code>，比如 <code>https://Tracy-xu:395083226%40gh@github.com</code>。</p><p>注：要操作一个远程仓库，首先要有 Git 服务器登录权限，然后要有项目权限（项目的所有者，或者 Collaborators – 协作者）。</p><h2 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h2><p>SSH 作为 Git 所支持通信协议其中之一，如果想通过 SSH 来使用 Git，则需要安装 SSH Server。Linux 一般都自带 SSH，而 Windows 配置起来麻烦，所以这里以 Linux 为例。</p><p>当然，在实际使用中不单单只会用到一个简单的非常底层的 Git 服务器，还有其他很多功能会使用到（比如，提供图形化界面的用户管理、SSH 管理、Log、Issue、Pull Request，甚至 Wiki 和持续集成），所以一般会使用 GitHub、GitLab、GitBucket 基于 Git 实现的 Git 仓库托管系统。</p><ol><li>安装 Git</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git                # CentOS 用 yum 带 -y 参数安装（-y 参数不用一步步询问）</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个 Git 用户，用来运行 Git 服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser git</span><br><span class="line"></span><br><span class="line"># 默认情况下 SSH 不允许空密码用户登录（可在 sshd_config 中设置，参考相关章节），所以还需给 git 这个用户设置一个密码。</span><br><span class="line">sudo passwd git</span><br></pre></td></tr></table></figure><ol start="3"><li>设置证书登录</li></ol><p>收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个（参考 Linux 相关章节。在没有像 GitHub、GitLab 这样的平台来管理 authorized_keys，管理员手动管理 authorized_keys 很麻烦）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 验证证书登录是否设置成功（如果让输入密码则没有成功，如果不让输入则设置成功）</span><br><span class="line">ssh -T git@192.168.10.140</span><br><span class="line"></span><br><span class="line"># 不让输入密码，回车后，原生的 Git Service 没有任何返回，GitHub 会有返回</span><br><span class="line">ssh -T git@github.com    </span><br><span class="line">Hi Tracy-xu! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>注：<code>~/.ssh</code> 目录在用户目录下（不同用户 <code>~</code> 下输入 <code>pwd</code>，结果会是 <code>/root</code> 或者 <code>/home/xxx</code>），修改 <code>~/.ssh/authorized_keys</code> 只对当前用户生效。另外，如果不设置证书登录，默认会使用密码登录。</p><ol start="4"><li>初始化 Git 仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选定一个目录作为 Git 仓库，假定是 /srv/sample.git，在 /srv 目录下输入命令</span><br><span class="line">sudo git init --bare sample.git</span><br><span class="line"></span><br><span class="line"># 把 owner 改为 git（如果这一步不设置，push 时会报权限不足：insufficient permission for adding an object to repository databa）</span><br><span class="line">sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>与 <code>git init</code> 不同的是，<code>git init --bare</code> 被用来创建“裸库”，裸库没有 work tree（工作区），只有 .git 目录，记录着版本历史，一般用于公共的远程中央仓库，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区。另外，服务器上的 Git 仓库通常都以 .git 结尾。</p><ol start="5"><li>禁用 Shell 登录</li></ol><p>出于安全考虑，第二步创建的 git 账户不允许登录 Shell（GitHub 就是如此，<code>ssh git@github.com</code>），只允许 Git 相关操作，所以要把 Shell 登录改为 git-shell 登录。编辑 <code>/etc/passwd</code> 文件，为 git 用户指定的 git-shell 即可（参考 Linux passwd 相关章节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line"># 改为</span><br><span class="line">git:x:1001:1001::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>还要复制一个名为 git-shell-commands 的目录，要不然 <code>ssh git@192.168.10.140</code> 时会报 fatal:Interactive git shell is not enabled 错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/git-1.8.3.1/contrib/git-shell-commands /home/git -R</span><br><span class="line">chown git /home/git/git-shell-commands/ -R</span><br><span class="line">chmod +x /home/git/git-shell-commands/help</span><br><span class="line">chmod +x /home/git/git-shell-commands/list</span><br></pre></td></tr></table></figure><p>现在，不管是开机登录，还是 su 切换用户登录，还是 SSH 远程登录，git 用户登录的都将是 git-shell，进来看到的是 <code>git&gt;</code> 而不是 <code>[root@localhost ~]#</code>。另外，不能将 git 账户登录权限改为 <code>/sbin/nologin</code>，禁用登录，要不然客户端在 clone 时会报 <code>fatal: protocol error: bad line length character: This</code> 错误。</p><ol start="6"><li>克隆远程仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@192.168.10.140:/srv/sample.git</span><br></pre></td></tr></table></figure><p>直接 clone 会提示这是一个空仓库。也可以在本地创建一个仓库，然后添加 remote 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">...</span><br><span class="line">git remote add origin ssh://git@192.168.10.140:/srv/sample.git      # clone 时可以省略 ssh:// 协议，设置地址时不可省略</span><br><span class="line">git push --set-upstream origin master                               # 可以缩写为 git push -u origin master</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> engineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JQuery 精粹</title>
      <link href="/2013/12/26/jQuery%20%E7%B2%BE%E7%B2%B9/"/>
      <url>/2013/12/26/jQuery%20%E7%B2%BE%E7%B2%B9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>运用 JQuery 写一个 alert 插件<br>例如：<br><button>alert</button><button><br>$(‘button’).alert();<br>点击按钮将直接弹出 alert()对话框</button></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
