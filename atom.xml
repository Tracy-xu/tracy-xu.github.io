<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tracy-xu&#39;Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yunguxt.cn/"/>
  <updated>2022-08-03T07:31:09.308Z</updated>
  <id>https://yunguxt.cn/</id>
  
  <author>
    <name>Tracy Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2022/08/03/Axios/"/>
    <id>https://yunguxt.cn/2022/08/03/Axios/</id>
    <published>2022-08-03T07:31:07.512Z</published>
    <updated>2022-08-03T07:31:09.308Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Axios</p><ul><li>params</li></ul><p>config 中 params 字段是与请求一起发送的 URL 参数，支持对象或 URLSearchParams 对象，Axios 会自动序列化为 QueryString，不需要手动序列化 <code>new URLSearchParams(param).toString()</code>，对于 Get 请求，就可直接传 JSON 格式参数，Axios 会处理成 QueryString。</p><p>支持 get 参数的序列化，不需要自己手动序列化，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export function getTemplateList(query) &#123;</span><br><span class="line">  return axios.get(&apos;/ces/perf/tpl&apos;, &#123;</span><br><span class="line">    params: query,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>responseType 一般默认设为 JSON，因为服务端大部分情况下返回的数据都是 JSON，如果需要（比如文件或者文本格式）也可在单个请求中设置返回数据的格式。</p><p>export function getFileCover(path) {<br>return axios.get(<code>/file/cover?path=${path}</code>, {<br>responseType: ‘text’,<br>});<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exportClazzReport(examId, clazzId) &#123;</span><br><span class="line">  return axios.get(`/goals/$&#123;examId&#125;/clazz/$&#123;clazzId&#125;/export`, &#123;</span><br><span class="line">    responseType: &apos;blob&apos;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      &apos;Content-Type&apos;: &apos;application/octet-stream&apos;, // 请求头不用吧</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>paramsSerializer</li></ul><p>URL 传数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cateIds=1&amp;cateIds=2</span><br><span class="line">quizIds[]=x&amp;quizIds[]=x</span><br></pre></td></tr></table></figure><p>自定义 axios 序列化即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getCourseList(query) &#123;</span><br><span class="line">  return axios.get(&apos;/mall/shop/courses&apos;, &#123;</span><br><span class="line">    params: query,</span><br><span class="line">    paramsSerializer(params) &#123;</span><br><span class="line">      return qs.stringify(params, &#123; arrayFormat: &apos;repeat&apos; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>也可直接作为默认序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Axios = axios.create(&#123;</span><br><span class="line">  timeout: 60000,</span><br><span class="line">  responseType: &apos;json&apos;,</span><br><span class="line">  withCredentials: false,</span><br><span class="line">  paramsSerializer(params) &#123;</span><br><span class="line">    return Qs.stringify(params, &#123; arrayFormat: &apos;repeat&apos; &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function getReply(userId, quizIds) &#123;</span><br><span class="line">  const quizIdsQueryParams = quizIds.map(item =&gt; `$&#123;encodeURIComponent(&apos;quizIds[]&apos;)&#125;=$&#123;item&#125;`).join(&apos;&amp;&apos;);</span><br><span class="line">  return axios.get(`/live/quiz/user/reply?userId=$&#123;userId&#125;&amp;$&#123;quizIdsQueryParams&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://meiyike.cn/api/user/pfm/affiches/current" target="_blank" rel="noopener">https://meiyike.cn/api/user/pfm/affiches/current</a> site 是不是这个接口 redirect 的？？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Axios&lt;/p&gt;&lt;ul&gt;&lt;li&gt;params&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;config 中 params 字段是与请求一起发送的 URL
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>函数参数的求值策略</title>
    <link href="https://yunguxt.cn/2022/08/01/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"/>
    <id>https://yunguxt.cn/2022/08/01/函数参数的求值策略/</id>
    <published>2022-07-31T16:00:00.000Z</published>
    <updated>2022-08-02T23:29:31.676Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>函数参数的<a href="https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085" target="_blank" rel="noopener">求值策略 Evaluation Strategy</a> 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。</p><a id="more"></a><p>按值传递（pass by value）是指在调用函数时将实参复制一份传递到函数中，在函数中如果对参数进行修改，将不会影响到实参。</p><p>引用传递（pass by reference）是指在调用函数时将实参的地址直接传递到函数中，在函数中对参数所进行的修改，将影响到实参。</p><p>按值传递传递的是原始值的复制，或内存地址值的复制（比如 JS 中的共享传递，C/C++ 中的指针传递）。按引用传递传递的是内存地址（不是内存地址值）。</p><h2 id="JavaScript-中参数的求值策略"><a href="#JavaScript-中参数的求值策略" class="headerlink" title="JavaScript 中参数的求值策略"></a>JavaScript 中参数的求值策略</h2><p>Javascript 中函数参数求值策略是按值传递。无论是值类型还是引用类型，都会在栈上创建副本（拷贝、复制），不同是，对于值类型而言，这个副本就是整个原始值的复制，对于引用类型，由于引用类型的实例在堆中，在栈上只有它的一个地址引用值，其副本也只是这个引用值的复制，而不是整个原始对象的复制，这种策略也被称为按共享传递（传递的是地址值，可通过引用来修改原始对象的属性，重新赋值则会断开对原始对象的引用，不影响原始对象），类似于 C 中的指针传递。按共享传递是按值传递的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">num, obj</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  obj.value = <span class="string">'hello'</span>; <span class="comment">// 只是引用类型的副作用，不能证明是引用传递</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// obj = new Object(); // 断开了对 greeting 的引用</span></span><br><span class="line">  <span class="comment">// obj.value = 'world'; // 如果是引用传递，改变形参 obj 的属性 value，也会反映在 greeting 变量中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = &#123;</span><br><span class="line">  value: <span class="string">'hello world'</span>,</span><br><span class="line">&#125;;</span><br><span class="line">change(a, greeting);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面例子的内存模型图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack（栈）         |  heap（堆）</span><br><span class="line">---------------------------------</span><br><span class="line">a 10               |</span><br><span class="line">greeting 0x01 ---&gt; |  0x01 hello world</span><br><span class="line">num 10             |  </span><br><span class="line">obj 0x01      ---&gt; |</span><br></pre></td></tr></table></figure><p>如果是按引用传递，直接传递第二格的内容即可，不需要有第四格。</p><h2 id="其他语言中参数的求值策略"><a href="#其他语言中参数的求值策略" class="headerlink" title="其他语言中参数的求值策略"></a>其他语言中参数的求值策略</h2><p>Java 中参数求值策略与 JavaScript 一样，都是按值传递（含共享传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByValue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    Greeting greeting = <span class="keyword">new</span> Greeting();</span><br><span class="line">    TestByValue testByValue = <span class="keyword">new</span> TestByValue();</span><br><span class="line">    testByValue.change(a, greeting);</span><br><span class="line">    System.out.println(a); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(greeting.value); <span class="comment">// hello</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num, Greeting greeting)</span> </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    greeting.value = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="comment">// greeting = new Greeting(); // 断开了对 greeting 的引用</span></span><br><span class="line">    <span class="comment">// greeting.value = "world";</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> </span>&#123;</span><br><span class="line">  String value = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 编译</span><br><span class="line">javac TestByValue.java </span><br><span class="line"><span class="meta">#</span> 运行</span><br><span class="line">java TestByValue</span><br></pre></td></tr></table></figure><p>PHP 既支持值传递又支持引用传递，通过 &amp; 运算符（取址运算符）实现引用传递。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">(&amp;$num)</span> </span>&#123;</span><br><span class="line">  $num = $num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> $a; <span class="comment">// 输出１</span></span><br><span class="line">change($a);</span><br><span class="line"><span class="keyword">echo</span> $a; <span class="comment">// 输出 101</span></span><br></pre></td></tr></table></figure><p>C/C++ 支持值传递（含指针传递）， 另外 C++ 还支持引用传递，通过 &amp; 取址运算符实现引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> &amp;num2, <span class="keyword">int</span> *num3)</span> </span>&#123;</span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  num2 = <span class="number">22</span>;</span><br><span class="line">  *num3 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// int num4 = 2;</span></span><br><span class="line">  <span class="comment">// num3 = &amp;num4; // 对指针变量赋值，会断开原先的引用，不会影响外面</span></span><br><span class="line">  <span class="comment">// printf("%p\n", num3); // 外面的 c 还是 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">  change(a, b, &amp;c);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 1，值传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 22，引用传递</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 33 或 3，指针传递</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面代码需使用 <code>gcc test.cpp -lstdc++ -o test</code> 作为 C++ 编译，不能使用 <code>gcc -o test test.c</code> 作为 C 编译，C 没有按引用传递，都是按值传递，通过指针传递也可实现引用传递的效果，要想通过 C 编译，需删除引用传递。</p><p>其内存图如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a 1</span><br><span class="line">b/num2 2 </span><br><span class="line">c [0x7ff7b2c49920] 3</span><br><span class="line">num1 1</span><br><span class="line">num3 [0x7ff7b2c498f8] 0x7ff7b2c49920</span><br></pre></td></tr></table></figure><p>num1 的内容是复制于 a 的原值，num2 是 b 的别名，num3 的内容是 c 的地址值，*num3 指向 c 的内容。</p><p>指针传递本质上也是值传递的方式，它所传递的是一个地址值，与 JavaScript 中的共享传递一样。C/C++ 中通过 * 指针运算符实现指针传递。</p><p>作为指针类型数据本身，其既可使用指针传递又可使用引用传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> *&amp;p)</span> </span>&#123; <span class="comment">// int *&amp;p 表示 p 是一个整型指针的别名，int *p 则会重新分配内存，创建新指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;p&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line">*p = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *b = &amp;a;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 1</span></span><br><span class="line">change(b);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">'\n'</span>; <span class="comment">// 11</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算子的求值策略"><a href="#算子的求值策略" class="headerlink" title="算子的求值策略"></a>算子的求值策略</h3><p>求值策略不但规定了函数参数的求值规则，也规定了算子的求值规则，比如赋值表达式中的 <code>=</code> 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num1 = a; <span class="comment">// 值传递</span></span><br><span class="line">  <span class="keyword">int</span> *num2; <span class="comment">// 值传递中的指针传递</span></span><br><span class="line">  num2 = &amp;b;</span><br><span class="line">  <span class="keyword">int</span> &amp;num3 = c; <span class="comment">// 引用传递</span></span><br><span class="line">  num1 = <span class="number">11</span>;</span><br><span class="line">  *num2 = <span class="number">22</span>;</span><br><span class="line">  num3 = <span class="number">33</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 22</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c); <span class="comment">// 33</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> num = a;</span><br><span class="line"><span class="keyword">const</span> obj = b; <span class="comment">// 值传递中的共享传递</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;函数参数的&lt;a href=&quot;https://baike.baidu.com/item/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/22991085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;求值策略 Evaluation Strategy&lt;/a&gt; 指的是函数调用时，实参（表达式）的求值和传值方式，主要有两种求值策略，按值传递和按引用传递。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="https://yunguxt.cn/2022/04/15/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>https://yunguxt.cn/2022/04/15/编程范式/</id>
    <published>2022-04-14T16:00:00.000Z</published>
    <updated>2022-08-03T07:17:27.583Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>正交（orthogonal）</p><p>React的设计贯彻了声明式编程</p><p>编程范式：programming paradigm</p><p>命令式（Imperative），声明式（declarative programming）），这两个是对立的。</p><p>面向过程，面向对象（Object-oriented Programming 简称 OOP），函数式（functional programming 简称 FP）</p><a id="more"></a><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>声明式编程是一种编程范式，与命令式编程相对立。</p><p>它描述目标的性质，让计算机明白目标，而非流程。声明式编程不用告诉计算机问题领域，从而避免随之而来的副作用。而命令式编程则需要用算法来明确的指出每一步该怎么做。</p><p>在计算机科学中，声明性编程是一种编程范式，它表达了计算的逻辑而没有描述其控制流程。</p><p>来自<a href="http://en.wikipedia.org/wiki/Declarative_programming" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Declarative_programming</a></p><p>简而言之，声明性语言更简单，因为它缺乏控制流的复杂性（循环，if语句等）。</p><p>函数式编程是声明式编程的一部分</p><p><a href="https://www.zhihu.com/question/28292740/answer/40336090" target="_blank" rel="noopener">https://www.zhihu.com/question/28292740/answer/40336090</a><br><a href="https://www.zhihu.com/question/19732025" target="_blank" rel="noopener">https://www.zhihu.com/question/19732025</a><br><a href="https://zhuanlan.zhihu.com/p/85491177" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/85491177</a></p><ul><li>FP</li></ul><p>不是有个 map，reduce 函数就是函数式编程。<br>不可变数据结构有么，柯里化支持吗，函数缓存有吗，隔离副作用有吗，方法可以被当成参数传递吗，尾递归优化有吗，模式匹配、函数参数收集有吗。<br>如果都没有，或者只支持其中一两个，叫个锤子的函数式编程</p><p>只能说map, reduce算是目前被大多数语言吸纳得比较广泛的FP特征</p><ul><li>OOP 与 FP 的区别</li></ul><p>OOP 和 FP 最大的区别可能是 OOP 将对象视作一等公民，而 FP 将函数视作一等公民。</p><p>但除此之外，很难说 OOP 和 FP 有什么冲突的地方，没人告诉你用了 OOP 就不能用 map、filter、reduce，<br>更何况许多编程语言同时有 OOP 和 FP 两种编程范式的特征，想写成什么样完全看心情。<br>任何允许将函数作为参数传入的语言都可以写高阶函数，任何语言也都可以写出没有副作用的函数。你要是乐意，也可以把所有循环改写成递归。</p><p>编程范式的出现是为了减少程序员的思维负担，写出适合人类理解的语言。你可以在面向对象的代码应该加入一点map, reduce来方便理解，也可以在函数式的代码里加入一些class来简化命名。如果把编程范式之间的争论变成圣战，好像用什么编程范式就得严格遵循其规则，比如用FP就从不写循环，那未免也太过分了。</p><p>目前按照我的理解，面向对象最大的问题就是其概念已经过于臃肿了。使用面向对象，你需要尝试去理解GoF的23种设计模式，去理解继承和多态，去分辨各种各样概念之间的区别还要避免误区。面向对象还搞出了UML，尝试用没人能背下来全部规则的各类图去表示各种复杂的继承关系。UML用来打个草稿或许还是个不错的工具，但还有人走火入魔要用UML生成代码，这就显得离奇了。想要掌握面向对象，你不得不与概念的海洋斗争，然后读完十几本相关领域书籍，发现自己仍旧什么也不会。</p><p>学习面向对象最幸福的时刻是当你第一次理解了什么是类，什么是继承与多态，并成功用它让自己糊成一团的过程式代码变得简单而清晰。可惜的是你并不满足于这些，你往上套了越来越多的继承，对多态的使用越来越肆无忌惮，你很快发现自己的代码又糊成了一团。</p><p>但面向对象的代码至少比起面向过程的代码可读性高了太多，并且它的结构性很强——这使得烂程序员不至于写出太烂的代码。这就是为什么还有这么多公司用Java——它是完全面向对象的，而这很大程度上保证了程序员写出了差不多的代码。面向对象的各种概念与限制使编程不那么自由，但这正是很多大型项目需要的——它不需要所有的程序员都有极高的素养，任何并不太烂的程序员都能做出一定的贡献并且不会对代码产生毁灭性的影响。Java写出的代码也许很烂，但不至于烂到无法接受。</p><p>函数式编程是不同的。它有很多概念，这些概念或许不容易理解，但它们都很扁平，至少你在学习时不会产生学习面向对象概念时那种混乱与层层嵌套的感觉。FP不需要设计模式，不需要类图，也不需要继承和多态，当你理解了函数式编程的基本概念后你可以立刻投入工作。FP很自由，你不用被各种条条框框约束也可以写出清晰的代码。但有些人理解递归尚且十分吃力，你如何让他们轻而易举地去理解高阶函数的运算？更何况FP根本不能让人写出差不多的代码，编程素养并不算高的程序员凑在一起写出的FP大型项目肯定没法看。</p><p>OOP和FP本质上都是思维模式，只是OOP更符合直觉。即使C完全不支持OOP，也可以用各种方式写出OOP的代码，而FP的思维方式更是可以用在各种语言里。</p><p>有一个很普遍的误解： 就是函数式编程和面向对象编程是对立的，其实不然这两者是正交的（不相关，没有关系，不冲突）。<br>函数式编程的函数是指数学上的函数（不是指用函数来编程）：给定输入固定的输出，没有副作用。任何语言都可以用函数式的风格，只是难易不同罢了。很多语言都支持这两种风格的编程: 比如OCaml 和 JavaScript.举一个大家熟悉的JavaScript 的例子，来自Facebook的 ImmutableJSvar Immutable = require(‘immutable’);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);</span><br><span class="line">var map2 = map1.set(&apos;b&apos;, 50);</span><br><span class="line">map1.get(&apos;b&apos;); // 2</span><br><span class="line">map2.get(&apos;b&apos;); // 50</span><br></pre></td></tr></table></figure><p>可以看到其实现是函数式的: 添加对象 不会修改原来的map 但是接口是面向对象的接口</p><p>CSS 的属性互不正交，大量的依赖与耦合难以记忆。</p><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p>Reactive Programming</p><p><a href="https://zhuanlan.zhihu.com/p/104024245" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104024245</a><br><a href="https://www.jianshu.com/p/36d85f8cafdd" target="_blank" rel="noopener">https://www.jianshu.com/p/36d85f8cafdd</a><br><a href="https://blog.csdn.net/weixin_39939012/article/details/82784432" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39939012/article/details/82784432</a><br><a href="https://zhuanlan.zhihu.com/p/240287653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/240287653</a></p><p><a href="http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf" target="_blank" rel="noopener">http://stg-tud.github.io/sedc/Lecture/ws17-18/RP1.pdf</a></p><p>Reactive Extensions (Rx)</p><p>ReactiveX</p><p>Java: RxJava<br>JavaScript: RxJS<br>C#: Rx.NET<br>C#(Unity): UniRx<br>Scala: RxScala<br>Clojure: RxClojure<br>C++: RxCpp<br>Lua: RxLua<br>Ruby: Rx.rb<br>Python: RxPY<br>Groovy: RxGroovy<br>JRuby: RxJRuby<br>Kotlin: RxKotlin<br>Swift: RxSwift<br>PHP: RxPHP</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;正交（orthogonal）&lt;/p&gt;&lt;p&gt;React的设计贯彻了声明式编程&lt;/p&gt;&lt;p&gt;编程范式：programming paradigm&lt;/p&gt;&lt;p&gt;命令式（Imperative），声明式（declarative programming）），这两个是对立的。&lt;/p&gt;&lt;p&gt;面向过程，面向对象（Object-oriented Programming 简称 OOP），函数式（functional programming 简称 FP）&lt;/p&gt;
    
    </summary>
    
      <category term="pl" scheme="https://yunguxt.cn/categories/pl/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://yunguxt.cn/2022/04/01/TypeScript/"/>
    <id>https://yunguxt.cn/2022/04/01/TypeScript/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-08-03T01:31:21.962Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>类型标注/注解：变量、函数、对象、类的类型（有些类型可通过类型推断出来，不用手动标注）</p><p>静态类型的好处：</p><a id="more"></a><ul><li>编译时类型检测（let fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push(‘8’);）</li></ul><p>可防止开发中的一些语法错误</p><ul><li>接口提示、代码补全</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">    for (let id in source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>作为 JS 的超集，TS 支持所有的 JS 数据类型，并新增了几种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Built-in types: void、any、never</span><br><span class="line">User-defined types: enum、tuple、interface、class、array</span><br></pre></td></tr></table></figure><p>在 TS 中，string 和 String 是不同的两种类型，前者是原始类型，后者是对象类型</p><p>(window as any).foo = 1;</p><p>(window as any).foo</p><p>// 声明全局变量的”类型“</p><p>// 什么要字面量</p><p>// 枚举名和枚举值是相互映射的</p><p>// 类型断言、声明文件、枚举</p><p>declare enum Directions {<br>Up,<br>Down,<br>Left,<br>Right<br>}</p><p><t>source 就是 source as T，把 source 断言成 T 类型</t></p><p>function createArray<t>(length: number, value: T): Array<t>{<br>let result: T[] = [];<br>for (let i = 0; i &lt; length; i++) {<br>result[i] = value;<br>}<br>return result;<br>}</t></t></p><p>createArray<string>(3, ‘x’); // [‘x’, ‘x’, ‘x’]</string></p><p>第一个 T 是形参，后面的是使用 T</p><p>函数类型不写，也可被推导出来<br>interface SearchFunc {<br>(source: string, subString: string): boolean;<br>}</p><p>let mySearch: SearchFunc;<br>mySearch = function(source: string, subString: string) {<br>return source.search(subString) !== -1;<br>}</p><p>泛型函数、泛型接口、泛型类<br>声明全局变量的”类型“<br>什么要字面量<br>枚举名和枚举值是相互映射的</p><p>// 类型断言、声明文件、枚举、泛型</p><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><p>TypeScript 能进行类型检测，对于代码风格的检查则需要用到 ESlint。</p><p>TypeScript 和 ESlint 没有可比性，一个是语言，一个是代码检测工具，要比也是 TSlint。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;类型标注/注解：变量、函数、对象、类的类型（有些类型可通过类型推断出来，不用手动标注）&lt;/p&gt;&lt;p&gt;静态类型的好处：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2022/03/24/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://yunguxt.cn/2022/03/24/性能优化/</id>
    <published>2022-03-24T07:27:55.860Z</published>
    <updated>2022-03-24T07:28:05.923Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>前端优化（提高网页的加载速度）</p><p>1、使用css sprites，可以有效的减少http请求数<br>2、使用缓存<br>3、压缩js，css文件，减小文件体积<br>4、使用cdn，减小服务器负担<br>5、懒加载图片<br>6、预加载css，js文件<br>7、避免dom结构的深层次嵌套<br>8、给DOM元素添加样式时，把样式放到类中，直接给元素添加类，减少重构，回流</p><p>更多详细的前端优化请看前端优化：雅虎35条或者前端性能优化—-yahoo前端性能团队总结的35条黄金定律</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前端优化（提高网页的加载速度）&lt;/p&gt;&lt;p&gt;1、使用css
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scratch 入门</title>
    <link href="https://yunguxt.cn/2022/03/02/Scratch/"/>
    <id>https://yunguxt.cn/2022/03/02/Scratch/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-08-03T02:27:40.537Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://blog.csdn.net/weixin_43405101/article/details/102314032" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43405101/article/details/102314032</a></p><p>角色的中心点（中心点是针对角色的，每个角色都有中心点，跟位置不同，中心点一般用来描述运动的基点）和角色的位置</p><p>调整造型中心点也能改变角色在舞台中的位置</p><p><a href="https://www.jbhdq.com/jiaocheng/tuwen/45555.html" target="_blank" rel="noopener">https://www.jbhdq.com/jiaocheng/tuwen/45555.html</a></p><p><a href="https://www.huihua8.com/a/jbhjc/237634.html" target="_blank" rel="noopener">https://www.huihua8.com/a/jbhjc/237634.html</a></p><p>小绿旗子是运行（运行程序）</p><p>对角色或舞台进行编程，脚本必须在角色或舞台下</p><p>脚本可不可以应用到多个角色，对多个角色进行编程</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43405101/article/details/102314032&quot;
        
      
    
    </summary>
    
      <category term="scratch" scheme="https://yunguxt.cn/categories/scratch/"/>
    
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="https://yunguxt.cn/2022/02/08/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>https://yunguxt.cn/2022/02/08/前端工程化/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-08-03T01:35:36.914Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>如果一门原生语言的抽象能力不足（比如，CSS 的表达能力不足，JS 没有类型），我们可以再抽象设计一层，比如 Sass、TypsScript<br>经过编译，再将源码编译为供实际环境执行可原生代码。</p><p>只能维护源代码。</p><a id="more"></a><p>Web 工程化</p><p><a href="https://www.zhihu.com/question/433854153" target="_blank" rel="noopener">https://www.zhihu.com/question/433854153</a><br><a href="https://www.zhihu.com/question/24558375" target="_blank" rel="noopener">https://www.zhihu.com/question/24558375</a><br><a href="https://zhuanlan.zhihu.com/p/359734011" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/359734011</a></p><p>从 Browserify + Gulp 到 Parcel，从 Webpack 到 Rollup，Vite，工程化工具琳琅满目。但很多工具的实现和设计非常复杂，甚至出现了「面向 webpack 编程」的调侃。</p><p>工程化：</p><p>静态资源(JS/Sass/Less/HTML/Image/SVG/Font/CSS/JSX/TS/Vue SFC…)的检查<br>模块加载、编译、压缩、合并、打包（顾名思义）<br>浏览器自动刷新、文件监听</p><p>Node 催生了一批自动化构建工具，像 Bower，Yeoman，Grunt 等（类似于 Java 世界中的Ant或者Maven），他们都是构建在 Nodejs 之上。</p><p>自动化是工程化的特点，模块化是工程化的功能之一。</p><p>前端自动化构建（build）工具</p><h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p>前端工程化中，常见的任务有图片压缩和 Sprite 生成，CSS 压缩，Sass、Coffee、ES6、TS、JSX、Template… 编译，JS Module Loader 和 Minify Uglify，代码 Lint，文件替换监听和版本管理，自动刷新，测试、部署…。在早期，需要手工一步步处理这些任务，Gulp 的出现就是为了将这一系列任务流程自动化。</p><p>Gulp 是 Task Runner（任务执行器），通过执行一些列由 Plugin 定义的任务，来处理完成自动化。常见的 Plugins 有：gulp-webpack、gulp-css、gulp-babel 等。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是 Module Bundler（模块打包器）。</p><p>webpack 默认支持xxx</p><p>webpack 中一切皆模块，把所有的文件(css, image, js) 都用 js 来生成依赖，最后生成一个 bundle，所以 webpack 也叫做file bundler</p><ul><li>与 RequireJS Gulp 区别</li></ul><p><a href="https://survivejs.com/webpack/appendices/comparison/" target="_blank" rel="noopener">https://survivejs.com/webpack/appendices/comparison/</a></p><p>Webpack 和 RquireJS 都是模块解决方案，不同的是 RequireJS 只是一个运行时的 JavaScript Module（AMD） Loader，而 Webpack 则是 Module Bundler，不单单只进行模块加载，还会对模块进行处理（编译、压缩合并…），而且不止支持 JavaScript 模块。</p><p>Gulp 是 Task Runner，需要具体的 Plugin 才能实现 Task，比如模块加载要 gulp-browserify 或 gulp-webpack，SASS 编译要 gulp-sass…，而 Webpack 则是 Module Bundler，Module Bundler 只是众多前端工程化任务中之一。</p><p>通过 Webpack 提供的 Loader 和 Plugin 扩展，在模块打包时能实现诸如 compile、 minify、uglify… 等一系列功能，再结合 NPM Script，使得 Webpack 彻底的代替 了 Gulp。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;如果一门原生语言的抽象能力不足（比如，CSS 的表达能力不足，JS 没有类型），我们可以再抽象设计一层，比如 Sass、TypsScript&lt;br&gt;经过编译，再将源码编译为供实际环境执行可原生代码。&lt;/p&gt;&lt;p&gt;只能维护源代码。&lt;/p&gt;
    
    </summary>
    
      <category term="engineering" scheme="https://yunguxt.cn/categories/engineering/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2022/01/24/%E8%BD%AF%E9%94%AE%E7%9B%98/"/>
    <id>https://yunguxt.cn/2022/01/24/软键盘/</id>
    <published>2022-01-24T01:22:39.347Z</published>
    <updated>2022-01-24T01:22:39.451Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/focusout_event" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Element/focusout_event</a><br><a href="https://www.cnblogs.com/ralapgao/p/10815237.html" target="_blank" rel="noopener">https://www.cnblogs.com/ralapgao/p/10815237.html</a></p><p><a href="https://www.jianshu.com/p/3d590c84e284" target="_blank" rel="noopener">https://www.jianshu.com/p/3d590c84e284</a></p><p>ios 原生的 webview 在软件盘弹起时窗口会缩小（微信 x5 特殊处理过），而 android 下窗口会顶上去</p><p>如果用到了 vh 这样的单位，在软件盘弹起时会导致页面变形，还需特殊处理，focusout 时重新计算</p><p>这个地方的是不是在进来设置一次就行了，不处理软件盘弹起来回设置？，如果要需要来回设置，ios 有不支持 resize，用 focusout 和 focusin 啊</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2022/01/24/%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/"/>
    <id>https://yunguxt.cn/2022/01/24/通用业务场景/</id>
    <published>2022-01-24T01:22:03.380Z</published>
    <updated>2022-01-24T01:22:03.551Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>场景经验</p><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><ul><li>登录</li></ul><p>登录，会话保持、刷新、过期处理</p><ul><li>ajax</li></ul><p>请求拦截和响应拦截</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;场景经验&lt;/p&gt;&lt;h3 id=&quot;业务&quot;&gt;&lt;a href=&quot;#业务&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2022/01/22/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>https://yunguxt.cn/2022/01/22/同源策略/</id>
    <published>2022-01-22T15:49:45.681Z</published>
    <updated>2022-02-17T03:54:33.128Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p><a href="https://www.secpulse.com/archives/63801.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/63801.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a><br><a href="https://blog.csdn.net/qq_28773159/article/details/104834167" target="_blank" rel="noopener">https://blog.csdn.net/qq_28773159/article/details/104834167</a><br><a href="https://www.zhihu.com/question/20138568" target="_blank" rel="noopener">https://www.zhihu.com/question/20138568</a><br><a href="https://www.cnblogs.com/wuyongyin/archive/2021/06/12/14817142.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyongyin/archive/2021/06/12/14817142.html</a><br><a href="https://blog.csdn.net/weixin_42394911/article/details/119895911" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42394911/article/details/119895911</a></p><p>同源策略</p><p>同源策略（Same-origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，它用于限制一个源加载的文档或脚本如何与另一个源加载的资源进行交互。如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 的攻击。</p><ul><li>同源</li></ul><p>所谓同源是指”协议（protocol） + 域名（host） + 端口（port）”三者相同。</p><ul><li>源的继承</li></ul><p>在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源。</p><ul><li>源的更改</li></ul><p>满足某些限制条件的情况下，页面可以通过 document.domain 来修改源（修改为当前域或其当前域的父域）。可用来处理 iframe 跨子域问题。</p><p>浏览器会根据同源策略允许或拒绝请求某些资源</p><p>页面跨域的行为主要会分为三类，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cross-origin embedding 跨域资源嵌入</span><br><span class="line">Cross-origin writes 跨域写操作</span><br><span class="line">Cross-origin reads 跨域读操作</span><br></pre></td></tr></table></figure><p>跨域资源嵌入，比如 script、link、image、video、audio、object、embed、applet、iframe、@font-face（也有浏览器不允许跨域字体）。这些请求都不带 cookie，所以是安全的。<br>跨域写操作，比如 links，重定向以及 form 表单提交。<br>跨域读操作，比如 BOM（DOM，cookie，localStorage，indexDB）、资源（Ajax，drawImage）。</p><p>在这三种行为之中，通常情况下只有 Cross-origin read 是不被允许跨域的，其余的两种是允许的。</p><p>跨域的几种形式：跨主域、跨子域、跨端口、跨协议</p><h3 id="禁止跨域"><a href="#禁止跨域" class="headerlink" title="禁止跨域"></a>禁止跨域</h3><p>其实跨域请求本身并没有任何的安全隐患， 有安全隐患的是请求 X 网站的时候会顺便带上 X 网站的 cookie</p><p>Ajax 的同源策略主要用来防止 CSRF 攻击的，<br>BOM 的同源策略第一是为了防止父或子页面内容被串改，最重要的还是安全。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS (跨源资源共享) 要服务器和浏览器同时支</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h3 id="反代"><a href="#反代" class="headerlink" title="反代"></a>反代</h3><p>proxy</p><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>用来解决 iframe 跨子域时的 BOM 访问。</p><p>利用 document.domain 实现跨域，前提条件是这两个域名必须属于同一个基础域名，而且所用的协议，端口都要一致。</p><p>否则任何域名的子级域名地址都可以对父级发起xss攻击。</p><p>只有父子级都通过显示得设置 document.domain 才能达到跨域访问资源的目的。</p><p><a href="https://juejin.cn/post/6844903767226351623" target="_blank" rel="noopener">https://juejin.cn/post/6844903767226351623</a></p><p><a href="https://blog.csdn.net/nlznlz/article/details/79506655" target="_blank" rel="noopener">https://blog.csdn.net/nlznlz/article/details/79506655</a></p><p><a href="https://www.chromestatus.com/feature/5428079583297536" target="_blank" rel="noopener">https://www.chromestatus.com/feature/5428079583297536</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/domain" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Document/domain</a></p><p><a href="https://juejin.cn/post/6844904135569965064" target="_blank" rel="noopener">https://juejin.cn/post/6844904135569965064</a></p><p><a href="https://mp.weixin.qq.com/s/tE2anhs0bZJv-9IWoFSphw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/tE2anhs0bZJv-9IWoFSphw</a></p><p>注：某一页面的 domain 默认等于 window.location.hostname。</p><h3 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h3><p>用来解决 iframe 跨域时数据通信。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;https://www.secpulse.com/archives/63801.html&quot; target=&quot;_blank&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yunguxt.cn/2021/12/27/UI-Design-Specification/"/>
    <id>https://yunguxt.cn/2021/12/27/UI-Design-Specification/</id>
    <published>2021-12-26T16:30:45.533Z</published>
    <updated>2022-02-13T01:46:07.001Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>UI 设计规范。</p><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><ul><li>颜色</li><li>文字：字体、字号、行高</li><li>icon</li></ul><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件化是标准化中最重要的部分，组件化的目的是复用。表单、表格、分页、弹框…是 GUI 软件最基本组成，UI 容易组件化，特别是风格比较固定的后台系统，而前台由于展示的多样性，前台一般都不太容易完全组件化</p><ul><li>表单</li></ul><p>表单验证：对表单各字段进行验证(必填、类型[数值型]、格式[密码、手机号、邮箱])，是前后端都要做的，前端做的目的是为了更好的交互，而后端做的目的是为了保证数据安全</p><p>输入限制：现有的 type 不但受浏览器的实现，而且不好用，比如 type=”number” 不能限制整数、正整数的需求</p><ul><li>表格</li></ul><p>合并单元格，多级表头，斜线表头，固定行和列</p><ul><li>图片</li></ul><p>缺省：onerror 处理缺省图片时，需要卸载 error 来处理缺省图片 404 时引起的死循环，但 error 不太好卸载，所以最好的解决方案是用 new Img</p><p>图片预览</p><p>轮播</p><p>压缩和EXIF 信息处理</p><ul><li>弹框</li></ul><p>原生、vue visible.sync</p><ul><li>图表</li></ul><p>维度、指标</p><ul><li><p>树</p></li><li><p>分页</p></li></ul><p>移动端分页，pc 分页，点击加载更多<br>pageSize、curPage、total<br>列表项的删除</p><ul><li>面包屑</li></ul><p>面包屑用来表示当前页面或页面中资源的路径（比如页面层级，资源查询参数层级），描述页面或资源的位置</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;UI 设计规范。&lt;/p&gt;&lt;h2 id=&quot;标准化&quot;&gt;&lt;a href=&quot;#标准化&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PWA</title>
    <link href="https://yunguxt.cn/2021/12/01/PWA/"/>
    <id>https://yunguxt.cn/2021/12/01/PWA/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2022-08-03T01:37:59.081Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>Web App Manifest<br>Service Worker<br>…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Web App Manifest&lt;br&gt;Service Worker&lt;br&gt;…&lt;/p&gt;&lt;!-- rebuild by neat
        
      
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 类型系统</title>
    <link href="https://yunguxt.cn/2021/07/26/JavaScript-Type-System/"/>
    <id>https://yunguxt.cn/2021/07/26/JavaScript-Type-System/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2022-07-25T09:56:20.953Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>类型动静态（静态类型检测），类型强弱（类型转换）。</p><p>JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo = 42; // foo is now a number</span><br><span class="line">foo = &apos;hello&apos;; // foo is now a string</span><br><span class="line">foo = true;  // foo is now a boolean</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 + &apos;&apos;;</span><br><span class="line">!!1; // 这个算隐式还是显式</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的概念：xxxx。与数据结构的关系。</p><p>JavaScript 中一共有 8 种内置（Built-In）数据类型：</p><h3 id="原始类型（Primitive-types）"><a href="#原始类型（Primitive-types）" class="headerlink" title="原始类型（Primitive types）"></a>原始类型（Primitive types）</h3><p>原始类型也被称为基本类型，表示不能再细分下去的类型，具有原子性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* string: 一串表示文本值的字符序列</span><br><span class="line">* number: 整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）</span><br><span class="line">* boolean: 包含两个值 true 和 false</span><br><span class="line">* null: 只包含一个值 null</span><br><span class="line">* undefined: 只包含一个值 undefined</span><br><span class="line">* symbol: 一种实例是唯一且不可改变的数据类型</span><br><span class="line">* bigInt</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于这些类型被存储在栈内存中，也被称为值类型。</p><p>todo… 这里应该有内存图</p><p>又由于这些类型的值是不可变的，又被称为不可变类型。</p><p>原始类型是不可变的，没有任何方法可以直接改变其值，只会生成新的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &apos;hello&apos;;</span><br><span class="line">foo.substr(1);</span><br><span class="line">foo.toLowerCase(1);</span><br><span class="line">foo[0] = 1;</span><br><span class="line">console.log(foo);  // hello</span><br><span class="line"></span><br><span class="line">// 栈内存原始空间中的值并没有改变，只是开辟了一块新空间，将变量名指向新的空间</span><br><span class="line">foo += &apos;world&apos;;</span><br><span class="line">console.log(foo); // hello world</span><br></pre></td></tr></table></figure><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* object</span><br></pre></td></tr></table></figure><p>声明一个对象通常有以下几种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;; // 字面量形式，推荐</span><br><span class="line">const foo = new Object(); // new 调用</span><br><span class="line">const foo = Object(); // 与 new 调用相同</span><br><span class="line">cosnt foo = Object.create(null); // 空对象</span><br></pre></td></tr></table></figure><p>由于 <code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>… 这些对象都是 <code>Object</code> 对象的子类，所以全部归类为 object 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.__proto__ === Object.prototype; // true</span><br></pre></td></tr></table></figure><p>按内存分配方式，由于对象类型被存储在堆内存中，也被称为引用类型。</p><p>todo… 这里应该有内存图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &apos;hello&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">const bar = foo;</span><br><span class="line">foo.msg = &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">const bar = foo;</span><br><span class="line">foo[foo.length] = foo.length + 1;</span><br></pre></td></tr></table></figure><p>又由于值是可变的，又被称为可变类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;</span><br><span class="line">  msg: &apos;hello&apos;,</span><br><span class="line">&#125;;</span><br><span class="line">foo.msg = &apos;hello world&apos;;</span><br><span class="line"></span><br><span class="line">const foo = [1, 2, 3];</span><br><span class="line">foo.push(4);</span><br><span class="line">foo.length = 0;</span><br></pre></td></tr></table></figure><ul><li>包装对象</li></ul><p>string、number、boolean 这三种原始类型值在引用属性和方法时，会通过调用 new String()、new Number() 和 new Boolean() 的方式自动转换成对象，也就是原始类型的“包装对象（Wapper object）”，一旦引用结束，便会销毁这个临时的包装对象。</p><p>不是所有的原始类型都有包装对象，null 和 undefined 就没有包装对象，访问它们的属性会报类型错误。</p><p>“JavaScript 中一切皆是对象”这是一个错误的论断，原始类型的 string、number、boolean 会转化为对应的包装对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof &apos;seymoe&apos;; // &apos;string&apos;</span><br><span class="line">typeof new String(&apos;seymoe&apos;); // &apos;object&apos;</span><br><span class="line">typeof String(&apos;seymoe&apos;); // &apos;string&apos;</span><br></pre></td></tr></table></figure><p>注：Number、String 和 Boolean 如果不作为构造函数调用（即调用时不加 new），常常用于将任意类型的值转为数值、字符串和布尔值。</p><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符被用来检测数据的类型，其返回一个表示数据类型的字符串，它能检测除 <code>null</code> 和值为 <code>function</code> 的 <code>object</code> 类型外的所有类型。</p><p>null 由于历史设计失误，typeof 返回了 object（如果从类 Java 语言的角度理解），而 function 由于很特殊（构造函数）typeof 特殊处理返回了 function，</p><p>typeof 不能检测除 function 外的 object 子类型，如果想要检测子类型，则需要使用 instanceof 或 Object.prototype.toString 方法。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Array // true</span><br><span class="line">(&#123;&#125;) instanceof Object // true</span><br><span class="line">(()=&gt;&#123;&#125;) instanceof Function // true</span><br></pre></td></tr></table></figure><p><code>instanceof</code> 用来检测类型有缺陷，首先它会检测整个原型链，另外，它不能在 iframe 中跨页面检测，因为不在同一个 <code>window</code> 对象下，原型链无法关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] instanceof Object; // true</span><br></pre></td></tr></table></figure><p><code>[].__proto__ === Array.prototype</code>，而又 <code>Array</code> 属于 <code>Object</code> 子类型，即 <code>Array.prototype.__proto__ === Object.prototype</code>，最终 <code>[].__proto__.__proto__ === Object.prototype</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">window.frames[0].foo(arr);</span><br><span class="line"></span><br><span class="line">// iframe</span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(data instanceof Array);  // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>data</code> 时的 <code>Array</code> 跟 iframe 里的 <code>Array</code> 属于不同的 <code>window</code> 对象下，不是同一个类。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><p>终极解决方案，不但能检测基本类型，还能检测 object 子类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&apos;hello&apos;); // &apos;[object String]&apos;</span><br><span class="line">Object.prototype.toString.call(1); // &apos;[object Number]&apos;</span><br><span class="line">Object.prototype.toString.call(true); // &apos;[object Boolean]&apos;</span><br><span class="line">Object.prototype.toString.call(null); // &apos;[object Null]&apos;</span><br><span class="line">Object.prototype.toString.call(undefined); // &apos;[object Undefined]&apos;</span><br><span class="line">Object.prototype.toString.call(Symbol()); // &apos;[object Symbol]&apos;</span><br><span class="line">Object.prototype.toString.call(BigInt(2)) // &quot;[object BigInt]&quot;</span><br><span class="line">Object.prototype.toString.call(&#123;&#125;); // &apos;[object Object]&apos;</span><br><span class="line">Object.prototype.toString.call([]); // &apos;[object Array]&apos;</span><br><span class="line">Object.prototype.toString.call(() =&gt; &#123;&#125;); // &apos;[object Function]&apos;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(new Date()); // &apos;[object Date]&apos;</span><br><span class="line">Object.prototype.toString.call(new RegExp());</span><br><span class="line">Object.prototype.toString.call(Math); // &apos;[object Math]&apos;</span><br><span class="line">Object.prototype.toString.call(new Set()); // &apos;[object Set]&apos;</span><br><span class="line">Object.prototype.toString.call(new WeakSet()); // &apos;[object WeakSet]&apos;</span><br><span class="line">Object.prototype.toString.call(new Map()); // &apos;[object Map]&apos;</span><br><span class="line">Object.prototype.toString.call(new WeakMap()); // &apos;[object WeakMap]&apos;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><a href="https://juejin.cn/post/6844903752332214280" target="_blank" rel="noopener">https://juejin.cn/post/6844903752332214280</a></p><h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><ul><li>toString</li></ul><p>基础类型强制转为 string 类型在规范中明确说明了，也比较符合直觉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(1); // &quot;1&quot;</span><br><span class="line">String(true); // &quot;true&quot;</span><br><span class="line">String(null); // &quot;null&quot;</span><br><span class="line">String(undefined); // &quot;undefined&quot;</span><br><span class="line">String(Symbol(&apos;hello&apos;)); // &quot;Symbol(hello)&quot;</span><br></pre></td></tr></table></figure><p>Object 类型在强制转换为 string 类型的时候，调用的是该类型原型上的 toString 方法，而 Object 的各个子类型基本都重写了 toString 方法，所以在进行 toString 操作的时候表现有差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String(&#123; a: 2 &#125;); // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2]); // &quot;1,2&quot;</span><br><span class="line">String(/reg/g); // &quot;/reg/g&quot;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2];</span><br><span class="line">arr.toString(); // &quot;1,2&quot;</span><br><span class="line">String(arr); // &quot;1,2&quot;</span><br><span class="line"></span><br><span class="line">// 重写toString</span><br><span class="line">arr.toString = function() &#123;</span><br><span class="line">  return this.join(&apos;/&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">String(arr); // &quot;1/2&quot;</span><br></pre></td></tr></table></figure><ul><li>toNumber</li></ul><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">true + 0;</span><br><span class="line">&apos;1&apos; + [&apos;hello&apos;, 1];</span><br><span class="line">&#123;&#125; + [];</span><br><span class="line">[] + &#123;&#125;;</span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line">&apos;2&apos; + &#123;&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&apos;2&apos; + obj;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true == 1;</span><br><span class="line">false === 0; // false</span><br><span class="line">false + false === 0; // true</span><br><span class="line">[] == ![];</span><br><span class="line">[undefined] == false;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/64446259" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/64446259</a><br><a href="https://juejin.cn/post/6844903870712283149" target="_blank" rel="noopener">https://juejin.cn/post/6844903870712283149</a><br><a href="https://juejin.cn/post/6844903983429976078" target="_blank" rel="noopener">https://juejin.cn/post/6844903983429976078</a><br><a href="https://juejin.cn/post/6844903854882947080" target="_blank" rel="noopener">https://juejin.cn/post/6844903854882947080</a><br><a href="https://juejin.cn/post/6844903902295359502" target="_blank" rel="noopener">https://juejin.cn/post/6844903902295359502</a><br><a href="https://juejin.cn/post/6844903937930346509" target="_blank" rel="noopener">https://juejin.cn/post/6844903937930346509</a><br><a href="https://juejin.cn/post/6971935704938971173" target="_blank" rel="noopener">https://juejin.cn/post/6971935704938971173</a><br><a href="https://juejin.cn/post/6861500194232467470" target="_blank" rel="noopener">https://juejin.cn/post/6861500194232467470</a><br><a href="https://juejin.cn/post/6918892282192068622" target="_blank" rel="noopener">https://juejin.cn/post/6918892282192068622</a><br><a href="https://juejin.cn/post/6844903682018902029" target="_blank" rel="noopener">https://juejin.cn/post/6844903682018902029</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;类型动静态（静态类型检测），类型强弱（类型转换）。&lt;/p&gt;&lt;p&gt;JavaScript 是一门动态类型（dynamically typed）且弱类型（weakly typed）语言，既不对类型进行静态检测，又允许隐式类型转换。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let foo = 42; // foo is now a number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = &amp;apos;hello&amp;apos;; // foo is now a string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo = true;  // foo is now a boolean&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10 + &amp;apos;&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;!!1; // 这个算隐式还是显式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="https://yunguxt.cn/2021/01/22/React/"/>
    <id>https://yunguxt.cn/2021/01/22/React/</id>
    <published>2021-01-21T16:00:00.000Z</published>
    <updated>2022-08-03T01:36:39.382Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>为什么 React 需要 Immutable？<br><a href="https://blog.csdn.net/KlausLily/article/details/117137249" target="_blank" rel="noopener">https://blog.csdn.net/KlausLily/article/details/117137249</a><br><a href="https://zhuanlan.zhihu.com/p/20295971" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20295971</a><br><a href="https://www.zhihu.com/question/446377023" target="_blank" rel="noopener">https://www.zhihu.com/question/446377023</a></p><a id="more"></a><p><a href="https://www.cnblogs.com/sexintercourse/p/15690013.html" target="_blank" rel="noopener">https://www.cnblogs.com/sexintercourse/p/15690013.html</a></p><p><a href="https://www.zhihu.com/question/440916294/answer/1748044978" target="_blank" rel="noopener">https://www.zhihu.com/question/440916294/answer/1748044978</a><br><a href="https://www.zhihu.com/question/475858982/answer/2029148759" target="_blank" rel="noopener">https://www.zhihu.com/question/475858982/answer/2029148759</a><br><a href="https://zhuanlan.zhihu.com/p/279600842" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/279600842</a></p><p>react 还要 immutable.js 吗</p><p>vue是否需要immutability</p><p><a href="https://www.zhihu.com/question/47171917" target="_blank" rel="noopener">https://www.zhihu.com/question/47171917</a></p><p>mobx</p><p>mobx6 开始不支持装饰器</p><p>mobx6: <a href="https://mobx.js.org/enabling-decorators.html" target="_blank" rel="noopener">https://mobx.js.org/enabling-decorators.html</a><br><a href="https://zhuanlan.zhihu.com/p/342648174" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/342648174</a></p><p>mobx4/5: <a href="https://cn.mobx.js.org/intro/overview.html" target="_blank" rel="noopener">https://cn.mobx.js.org/intro/overview.html</a><br><a href="https://www.cnblogs.com/xiaozhumaopao/p/14422260.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozhumaopao/p/14422260.html</a></p><p>React 天然和 mobx mutable 设计相违背: <a href="https://www.zhihu.com/question/328612405/answer/2073843986" target="_blank" rel="noopener">https://www.zhihu.com/question/328612405/answer/2073843986</a></p><ul><li>重要版本号</li></ul><p>react 在<br>0.13.0 加入了 ES6 classes components 支持<br>0.14.0 加入了对 Stateless functional components 支持<br>15.6.0 开始不再推荐 createClass，并在 16 开始废弃了对 createClass 的支持（如果想继续使用 createClass 方法创建组件,需要引入create-react-class<br>）<br>在 16.8 加入了 hook</p><p>0.14.8 一下升到了 15.0.0，<a href="https://reactjs.org/blog/2016/02/19/new-versioning-scheme.html" target="_blank" rel="noopener">new-versioning-scheme</a></p><p>主要目的是为了表明对稳定性的承诺（15.0.0 比 1.0.0 更适合），另外也是为了更好的利用<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver 语义化版本规范</a>灵活地在次要版本中添加新的向后兼容功能。</p><p>JSX 其实是一个 JavaScript 对象，JSX 被编译后，是一个函数调用，返回值为 JS 对象。可以用 Babel 编译 <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel 在线编译</a>后的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;img src=&quot;xxx.png&quot; /&gt;</span><br><span class="line">    &lt;p&gt;Content&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&#123; true ? 1 : 2 &#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/29711902" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29711902</a></p><p>createClass 和 es6 class<br><a href="https://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes" target="_blank" rel="noopener">https://www.newmediacampaigns.com/blog/refactoring-react-components-to-es6-classes</a><br><a href="https://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html" target="_blank" rel="noopener">https://www.w3cplus.com/react/react-es5-createclass-vs-es6-classes.html</a><br><a href="https://www.cnblogs.com/aivnfjgj/p/6507344.html" target="_blank" rel="noopener">https://www.cnblogs.com/aivnfjgj/p/6507344.html</a><br><a href="https://daveceddia.com/react-es5-createclass-vs-es6-classes/" target="_blank" rel="noopener">https://daveceddia.com/react-es5-createclass-vs-es6-classes/</a></p><p>dan 的 github<br><a href="https://github.com/gaearon" target="_blank" rel="noopener">https://github.com/gaearon</a></p><p>react 为什么要推崇函数式组件<br><a href="https://www.zhihu.com/question/343314784/answer/937174224" target="_blank" rel="noopener">https://www.zhihu.com/question/343314784/answer/937174224</a></p><ul><li>setState</li></ul><ul><li>React 全家桶搭建</li></ul><p><a href="https://juejin.cn/post/6844904055840440334" target="_blank" rel="noopener">https://juejin.cn/post/6844904055840440334</a></p><p><a href="https://umijs.org/zh-CN/docs/use-umi-ui" target="_blank" rel="noopener">https://umijs.org/zh-CN/docs/use-umi-ui</a></p><p><a href="https://juejin.cn/post/6926359111126908936" target="_blank" rel="noopener">https://juejin.cn/post/6926359111126908936</a></p><h2 id="CRA"><a href="#CRA" class="headerlink" title="CRA"></a>CRA</h2><p>cra 怎么选择 react 版本</p><h2 id="react-devtools"><a href="#react-devtools" class="headerlink" title="react-devtools"></a>react-devtools</h2><p>灰色、蓝色、红色</p><p>Edge 和 FireFox 应用商店不需要翻墙，Chrome 应用商店则需要翻墙，如果不能翻墙也可在本地打包编译。</p><ul><li>v3.3.2</li></ul><p>github 中下载 <a href="https://github.com/facebook/react-devtools/tree/v3.3.2" target="_blank" rel="noopener">v3.3.2</a> 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/react-devtools.git</span><br><span class="line">npm install --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>打包编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:extension:chrome</span><br></pre></td></tr></table></figure><p>编译成功后，会在项目的项目根目录下生成文件夹 ./shells/chrome/build/unpacked</p><p>在 chrome://extensions/ 中点击“加载已解压的扩展程序”，指定到这个目录安装即可。</p><p>注意：react-devtools v3 不支持 react 17+，报错 <code>Uncaught TypeError: Cannot read properties of undefined (reading &#39;forEach&#39;)</code></p><ul><li>v4</li></ul><p>从 v4 开始，react devtools 被合并到 <a href="https://github.com/facebook/react" target="_blank" rel="noopener">react</a> 主项目中。项目根目录 packages 目录下两个文件夹：react-devtools 和 react-devtools-extensions，前者是基于 electron 版，不但能调试 React DOM，还能调试 React Native，后者是 react-devtools 浏览器插件版。</p><p>本地编译安装，需要下载整个 react 仓库，具体操作流程如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/react.git</span><br><span class="line">yarn</span><br></pre></td></tr></table></figure><p>注意：如果报这种错 <code>@typescript-eslint/parser-v5@5.0.0-alpha.25: The engine &quot;node&quot; is incompatible</code> ，执行一下 <code>yarn config set ignore-engines true</code> 即可。</p><p>项目根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn build-for-devtools</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd packages/react-devtools-extensions/</span><br><span class="line">yarn build:chrome</span><br></pre></td></tr></table></figure><p>编译成功后，会在 packages/react-devtools-extensions/chrome 下生成 packages/react-devtools-extensions/chrome/build/unpacked 文件，浏览器插件管理中指定 unpacked 目录安装即可。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;为什么 React 需要 Immutable？&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/KlausLily/article/details/117137249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/KlausLily/article/details/117137249&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20295971&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/20295971&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/446377023&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/446377023&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>科里化</title>
    <link href="https://yunguxt.cn/2020/12/02/Currying/"/>
    <id>https://yunguxt.cn/2020/12/02/Currying/</id>
    <published>2020-12-01T16:00:00.000Z</published>
    <updated>2022-08-02T23:32:38.003Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><ul><li>版本 1</li></ul><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123; <span class="comment">// 通过手动调用的方式（即不传参数）来判断收集结束</span></span><br><span class="line">      <span class="keyword">return</span> fn(...args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currying(fn.bind(<span class="literal">null</span>, ...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须手动结束调用</span></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>版本 2</li></ul><p>这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用</p><p>有闭包的 bug</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []; <span class="comment">// 搜集参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;  <span class="comment">// 递归的中断条件，改为 arg.length === 0 更合适</span></span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args); <span class="comment">// 改为 fn(...args) 更合适</span></span><br><span class="line">    &#125;</span><br><span class="line">    args = args.concat(arg);  <span class="comment">// ?</span></span><br><span class="line">    <span class="keyword">return</span> foo;  <span class="comment">// ?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">6</span>, <span class="number">2</span>)();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li>版本 3</li></ul><p>这个版本中，被科里化的函数的形参必须要有长度</p><p><a href="https://zhuanlan.zhihu.com/p/296852112" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/296852112</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_fn</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= fn.length) &#123; <span class="comment">// 这里通过型参长度来判断是否要调用，所以add的参数不能...</span></span><br><span class="line">      <span class="keyword">return</span> fn(...args) <span class="comment">// 不需要 call，fn.call(this, ...args)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...remain</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _fn(...args, ...remain); <span class="comment">// 不需要 call，_fn.call(this, ...args, ...remain);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本中，被科里化函数的形参长度必须固定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c +d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = currying(add);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">1</span>)(<span class="number">20</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>科里话的关键是返回函数实现连式调用、参数收集、以及判断收集结束做最终调用</p><p>判断收集结束有很多办法：对比实参和形参的长度（这样被科里化的函数形参不能使用…）；判断实参的个数是否为 0（不传）；</p><p>call、apply、bind 的主要作用是绑定this上下文，另外 apply 还可以用来传 spread 数组，不过已经被 es6 spread 代替</p><p>数组求和。。。</p><p>var arr = [1, 2, 3];<br>eval(arr.join(‘+’));</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;ul&gt;&lt;li&gt;版本 1&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个版本中，对被科里化的函数没要求，缺点是需要手动结束调用&lt;/p&gt;&lt;figure
        
      
    
    </summary>
    
      <category term="javascript" scheme="https://yunguxt.cn/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue 技术要点</title>
    <link href="https://yunguxt.cn/2020/10/15/Vue/"/>
    <id>https://yunguxt.cn/2020/10/15/Vue/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2022-08-10T00:58:39.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:12 GMT+0800 (中国标准时间) --><h2 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h2><ul><li>优点</li></ul><p>渐进式：框架设计（可以直接引入使用，仅使用核心渲染功能，也可以配合构建工具，集成路由和数据管理，采用单文件组件的开发模式）<br>声明式渲染：响应式（数据驱动视图，当数据改变后，会通知视图，不是指响应式编程 Reactive Programming），不需要传统那样命令式的操作 DOM<br>组件化：<br>工程化：Vue-cli<br>全家桶？：vuex、vue-router 集中式数据管理和客户端路由</p><p>声明式渲染（Declarative View）与之相对应的是命令式渲染（Imperative View）</p><a id="more"></a><ul><li>特点</li></ul><p><a href="https://juejin.cn/post/6857669921166491662" target="_blank" rel="noopener">https://juejin.cn/post/6857669921166491662</a></p><ul><li>nextTicket</li></ul><ul><li>props</li></ul><p>props 的作用</p><p>props 的作用：<br>直接在视图或逻辑（注意响应式处理，watch、key + created/mounted）中消费；<br>初始化 data（一般命名为 initXXX，注意异步的 props，组件初始化完成，异步 props 才设置，这时组件内部会失去初始化时机，需要配合 v-if 或 key）</p><p>引用类型的 props；驱动组件逻辑（watch props，需要注意的是，如果 props 的变动早于组件的初始化，这时候是无法 watch，需要配合 created）</p><p>引用类型的副作用，有时候需要规避（比如 props 中），有时候需要利用（比如修改 v-for 列表中的某条数据）</p><p>props down 和 events up 是作为组件接口(高内聚低耦合)的存在</p><ul><li>key</li></ul><p>可用来刷新组件，配合 props 可用来做数据驱动逻辑的场景</p><ul><li>watch</li></ul><p>数据驱动逻辑</p><p>watch props，watch data</p><p>课堂内有时候 watch 不触发<br>个人感觉 watch 有些心智负担</p><ul><li>coputed</li></ul><p>依赖追踪，根据一个依赖数据，算出另一个数据<br>get、set</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>sync：语法糖<br>v-module：语法糖</p><p>组件的生命周期：4 个节点(create,mount,update,destroy)，2 个状态(before,after，怎么取名呢)，共 8 个生命周期</p><p>钩子函数：由系统调用的函数（相当于 callback，比如 data 函数）</p><p>生命周期的钩子函数：生命周期的钩子函数是钩子函数里面一类，是在生命周期某个节点调用的钩子函数</p><p>注意箭头函数词法 this 的使用，有时候需要避开，有时候又需要利用</p><p>组件间的通信：event bus 作为组件间数据通信优点就是简单，但是如果滥用，也有缺点，数据流向不明确，可读性，维护性都不好。</p><ul><li>sync</li></ul><p>sync 是 prop 和 event 的语法糖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:foo=&quot;bar&quot;</span><br><span class="line">@update:foo=&quot;(val) =&gt; bar = val&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;update:foo&apos;, val);</span><br></pre></td></tr></table></figure><p>JSX 中需要写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo=&#123; this.bar &#125;</span><br><span class="line">&#123; ...&#123; on: &#123; &apos;update:foo&apos;: (val) =&gt; &#123; this.foo = val; &#125; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p><code>:</code> 不是 JSX 语法，所以不能写为 <code>on-update:foo={ this.handleVisibleReply_Deteil }</code></p><p>sync 和 v-model 有什么区别</p><ul><li>slot</li></ul><slot name="operate" :assessment="item"></slot><template #operate="slotProps"><br><el-button v-if="showEvaluate(slotProps.assessment)" type="primary" size="mini" @click="handleOpenAssessment(slotProps.assessment)"><br>去评价<br></el-button><br><el-button v-else type="primary" size="mini" @click="handleOpenTeacherReport(slotProps.assessment)"><br>查看评价<br></el-button><br></template><template #default="slotProps"><br>…<br></template><p>v-slot:default 和 v-slot:operate 已经被废弃</p><p>jsx 中写法<br>父组件</p><p>子组件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;this.$scopedSlots.default(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line"></span><br><span class="line">            &#123;this.$scopedSlots.operate(&#123;</span><br><span class="line">                assessment: this.assessment</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>父组件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;AssessmentList</span><br><span class="line">    scopedSlots=&#123;&#123;</span><br><span class="line">        default: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">        operate: props =&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;div style=&quot;line-height: 30px;&quot;&gt;</span><br><span class="line">                    &#123;props.assessment.title&#125;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p></p><ul><li>组件风格</li></ul><p>template 组件 和 jsx 组件，tsx 组件</p><p>element-ui 以及 element-plus 组件是基于 template 风格，而 ant-design-vue、vant 则是基于 tsx 风格的（2.0 版本是基于 js/jsx 风格）</p><p><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a><br><a href="https://github.com/hujiulong/blog/issues/11" target="_blank" rel="noopener">https://github.com/hujiulong/blog/issues/11</a><br><a href="https://www.zhihu.com/question/310485097/answer/591869966" target="_blank" rel="noopener">https://www.zhihu.com/question/310485097/answer/591869966</a></p><p>jsx 组件</p><p>vue 默认支持 js/jsx 组件，比如：</p><p>Level.jsx（后缀名也可改为 js）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 1,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const Tag = `h$&#123;this.level&#125;`;</span><br><span class="line">    return &lt;Tag&gt;&#123;this.$slots.default&#125;&#123;this.message()&#125;&lt;/Tag&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    message() &#123;</span><br><span class="line">      return &lt;div&gt;我是 &#123;this.level&#125; 级标签&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>template 和 jsx 都是描述视图层的 DSL，最终都会编译伟 vdom。template 提供了插值、循环、判断，这满足了<br>一般的视图渲染要求，而 jsx 有更强的编程能力，能够使用 javascript 完整的编程能力。</p><p>有哪些东西是 template 不能做到，需要用到 jsx 的。</p><p><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a></p><p><a href="https://www.zhihu.com/question/411745998" target="_blank" rel="noopener">https://www.zhihu.com/question/411745998</a></p><ul><li><p>指令</p></li><li><p>过滤器</p></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件通常用来为 Vue 添加全局功能，比如，注册全局组件、添加实例方法、添加全局指令…，可通过 use 安装 Vue.js 插件。<br>如果插件是一个对象，必须提供 install 方法，如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p><p>Vue.use 用于安装 plugin，为第三方 plugin 提供 Vue 上下文，比如 Element-ui （他们自己没有 Vue，只能消费者提供）<br>对于本地的 plugin，因为有 Vue 环境，可以不用 use，<code>import Vue from &#39;vue&#39;</code> 即可。</p><ul><li>全局组件</li></ul><p>第三方组件库的注册方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = function install(Vue) &#123;</span><br><span class="line">  components.map(component =&gt; Vue.component(component.name, component));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般组件内部也会提供 install 方法，方便按需引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Dialog from &quot;./src/Dialog.vue&quot;;</span><br><span class="line"></span><br><span class="line">Dialog.install = function install(Vue) &#123;</span><br><span class="line">  Vue.component(Dialog.name, Dialog);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>实例方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.prototype.$xxx = xxx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>全局指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const install = (Vue) =&gt; &#123;</span><br><span class="line">  Vue.directive(&apos;default-img&apos;, async (el, binding) =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default &#123; install &#125;;</span><br></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>判断路由前进还是后退</p><p>push、replace</p><p>动态路由需要有 scope，要不然匹配范围太广，比如 <code>/:id</code></p><ul><li>路由嵌套</li></ul><p>动画、嵌套路由/子路由（各子路由可以复用父路由，以达到组件公用）</p><p>嵌套路由的目的是为了复用公共组件的引用，通过嵌套路由，就不用一个个往路由组件中引用公共组件。常见的场景有：菜单栏、头部导航…，这种结构固定的页面中。</p><p>注意：通过嵌套路由引用的组件，在与其他组件通信时又些麻烦，所以一般建议，如果有通信需求，建议还是使用手动引用。</p><ul><li>路由刷新</li></ul><p>刷新路由组件比刷页面好，不用重新加载静态资源</p><p><a href="https://www.zhihu.com/question/49863095" target="_blank" rel="noopener">https://www.zhihu.com/question/49863095</a></p><ul><li>相同路由跳转</li></ul><p>Vue Router 中，跳转同一个路由组件时，即使路由参数不同（query、path），默认下为了复用，路由组件不会被刷新，这也意味着组件的生命周期钩子不会被调用，数据不会被刷新，可使用以下方法解决：</p><p>强制刷新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view :key=&quot;$route.fullPath&quot; /&gt;</span><br></pre></td></tr></table></figure><p>通过 watch $route 或 beforeRouteUpdate 来手动刷新数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  this.$watch(</span><br><span class="line">    () =&gt; this.$route.params,</span><br><span class="line">    (toParams, previousParams) =&gt; &#123;</span><br><span class="line">      // 对路由变化做出响应...</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async beforeRouteUpdate(to, from) &#123;</span><br><span class="line">  // 对路由变化做出响应...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>路由缓存</li></ul><p>keep-alive：列表到详情</p><p>替代 keep-alive 方案</p><p>通过 store、url 等方式缓存数据，可达到 keep-alive 缓存组件一样的效果，比如列表到详情中，如果将查询参数放到 url 中，返回时还能定位到具体的查询条件</p><p>列表到详情返回时维持列表的状态除 keep-alive 外，还有两种解决方案：<br>1）新开页（缺点–回退时前面页不知道，不会刷新；新开页要重新加载资源，慢）<br>2）缓存数据（url 或 store）而不是组件（比如myk 商城课程列表页），这是一个非常不错的办法</p><p>查询参数放 url 还有一个好处是分享</p><ul><li>滚动条位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    scrollBehavior(to, from, savedPosition) &#123;</span><br><span class="line">        if (savedPosition || to.meta.keepAlive) &#123; // 浏览器前进后退按钮切换路由</span><br><span class="line">            return savedPosition;</span><br><span class="line">        &#125; else &#123; // 通过&lt;router-link&gt;切换</span><br><span class="line">            return &#123;x: 0, y: 0&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</span><br></pre></td></tr></table></figure><p>如果数据是异步的，滚动条需要异步滚动，否则滚动位置会不准确</p><p>scrollBehavior 在 mounted 后执行，</p><p>需要将滚动行为与异步行为（Ajax、路由动画）结合起来，有些麻烦，有写人处理不好队列任务，干脆用 setTimeout。。。</p><p><a href="https://juejin.cn/post/6844903634484854797" target="_blank" rel="noopener">https://juejin.cn/post/6844903634484854797</a><br><a href="https://segmentfault.com/a/1190000022054521?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022054521?utm_source=tag-newest</a><br><a href="https://github.com/quasarframework/quasar/issues/1466" target="_blank" rel="noopener">https://github.com/quasarframework/quasar/issues/1466</a><br><a href="https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js" target="_blank" rel="noopener">https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js</a></p><p><a href="https://juejin.cn/post/6844903634484854797" target="_blank" rel="noopener">https://juejin.cn/post/6844903634484854797</a></p><p>beforeRouteEnter 中提前获取数据是一种选择</p><p>beforeRouteEnter(to, from, next) {<br>getPost(to.params.id, (err, post) =&gt; {<br>next(vm =&gt; vm.setData(err, post))<br>})<br>},</p><ul><li>路由权限控制</li></ul><p>HOC<br>路由守卫</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个状态管理库（数据库），其特点是持久化、集中式、响应式。其作用有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基础数据的持久化：应用的生命周期内，用户信息、会话信息等基础信息的持久化</span><br><span class="line">跨级组件通信：通信有两种，数据和事件</span><br><span class="line">集中化管理：集中化的数据对象可以保证数据的一致性。课堂中，数据由发布、订阅、恢复产生，多点的生产，这要求统一的数据对象来保证一致性</span><br></pre></td></tr></table></figure><p>对于数据流比较简单的系统，也只有用户信息需要用到 Store。</p><p>注：对于跨级组件通信，个人更愿意用 Event Bus，临时私有数据放组件内部 State 会显得更内聚（可通过容器组件与展示组件解耦），且数据会随组件的销毁而销毁，不会像 Store 由于持久化的特性，需手动清空（比如课堂中关闭窗口时，需要手动 resetState）。</p><ul><li>使用原则</li></ul><p>mutation 不能有副作用，action 不但允许副作用，还能有返回。<br>action 的本质是发布订阅<br>mutation 中不能用异步，这样会造成状态的改变不可被 DevTools 追踪。</p><p>mutation type 常量</p><ul><li>配合 Storage</li></ul><p>由于 State 存储在内存，如果想要数据在应用生命周期外也能持久化（比如 Token），则需存 Storage。另外，Storage 不是响应式的，但可以通过 state 的 set get 实现响应式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    get msg() &#123;</span><br><span class="line">      return localStorage.msg;</span><br><span class="line">    &#125;,</span><br><span class="line">    set msg(val) &#123;</span><br><span class="line">      localStorage.msg = val;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setMsg(state, payload) &#123;</span><br><span class="line">      state.msg = payload;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>store 模式</li></ul><p>可以用 Vue.observable（vue2）、reactive（vue3） 创建一个简单的可响应数据对象来进行状态管理。</p><p>store 模式没有专业 store（vuex、pinia） 的健壮和丰富的功能，比如 vuex 就提供 time-travel 调试和插件机制。</p><p>Vue3,我决定不再使用Vuex</p><p><a href="https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">https://v3.cn.vuejs.org/guide/state-management.html#%E4%BB%8E%E9%9B%B6%E6%89%93%E9%80%A0%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86</a><br><a href="https://juejin.cn/post/6898504898380464142" target="_blank" rel="noopener">https://juejin.cn/post/6898504898380464142</a><br>使用Vue.observable()进行状态管理<br><a href="https://segmentfault.com/a/1190000019292569" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019292569</a><br><a href="https://www.jianshu.com/p/e97502f89bde" target="_blank" rel="noopener">https://www.jianshu.com/p/e97502f89bde</a><br><a href="https://www.52cik.com/2020/02/29/vue-observable.html" target="_blank" rel="noopener">https://www.52cik.com/2020/02/29/vue-observable.html</a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>代理<br>mock<br>完全版 vue</p><h2 id="nuxt"><a href="#nuxt" class="headerlink" title="nuxt"></a>nuxt</h2><p>ssr</p><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><ul><li>Vue 2 的问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* TypeScript 支持不好</span><br><span class="line">* 逻辑抽象能力不强：HOC 或 Mixin 下的逻辑抽象有缺陷，逻辑关注点如果不被分离，意味着组件逻辑难以复用和分治，且难以阅读和理解，当项目体量变大时，会变得难以维护</span><br></pre></td></tr></table></figure><p>注：对于第二点，在 Vue2 中往往通过更合理的组件颗粒度划分来进行组件抽象，以组件复用和分治来代替逻辑复用和分治。</p><p>关注点分离（UI 的关注点分离、逻辑的关注点分离）</p><p>Mixin 的缺陷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命名冲突：Mixin 很容易发生 property 名冲突</span><br><span class="line">隐式依赖：通过对 this 扩展的依赖，既不不显式，也不能被 linter</span><br><span class="line">扩展性差：可重用性是有限的：mixin 不能传递参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性</span><br></pre></td></tr></table></figure><p>HOC 的缺陷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br></pre></td></tr></table></figure><p>为了解决上述问题，Vue 3 中</p><p><a href="https://juejin.cn/post/7055224376437784589" target="_blank" rel="noopener">https://juejin.cn/post/7055224376437784589</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 TypeScript 重写 Vue，获得更好的类型支持。</span><br><span class="line">在响应式系统上，使用 Proxy 替换 Object.defineProperty。</span><br><span class="line">加入 Compositon API 来更好的抽象组件逻辑。</span><br><span class="line">优化了Virtual DOM</span><br><span class="line">更好的Tree shaking</span><br><span class="line">&lt;script setup&gt;</span><br></pre></td></tr></table></figure><ul><li>Composition API</li></ul><p>Composition API 逻辑抽象 提供了更好的代码组织和逻辑复用能力。</p><p>注意：逻辑关注点分离的目的是复用和分治，将关注点相关代码收集一起独立为 useXXX 组合式函数，然后在 <code>setup</code> 组合式 API 的入口中组合，不要把所有逻辑不加抽象、不加简化地都写在其中，这样就失去了 compostion 的意义了，代码量大很难维护，是一种反模式。</p><p>个人认为 Composition API 是对 Options API 的补充，而不是否定，如果 Geek 一点，使用 Script-Setup Sugar，可以节省很多代码量，可完全代替 Options API</p><p><a href="https://github.com/vueuse/vueuse" target="_blank" rel="noopener">https://github.com/vueuse/vueuse</a></p><p>Composition API 并不是把所有的逻辑都堆砌到 setup 中，setup 是组合入口，在这里组装 useXXX 的</p><p>可以在 src 目录下建立 composables 或 hooks 目录，将所有的 useXXX 函数放此处。</p><ul><li>Function-based API</li></ul><p>vue3 使用 Function-based API 而不是 Class API 的原因</p><p><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68477600</a><br><a href="https://zhuanlan.zhihu.com/p/68099662" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/68099662</a><br><a href="https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos" target="_blank" rel="noopener">https://stackoverflow.com/questions/61301989/vue-3-what-is-the-class-based-api-function-based-api-reactivity-api-and-compos</a><br><a href="https://www.zhihu.com/question/325397290/answer/691200893" target="_blank" rel="noopener">https://www.zhihu.com/question/325397290/answer/691200893</a><br><a href="https://zhuanlan.zhihu.com/p/133819602" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/133819602</a></p><p>如果用户钟情于 Class API，可使用 vue-class-component<br><a href="https://www.zhihu.com/question/451424245/answer/1886655211" target="_blank" rel="noopener">https://www.zhihu.com/question/451424245/answer/1886655211</a></p><p><a href="https://www.zhihu.com/question/416652570/answer/1431359551" target="_blank" rel="noopener">https://www.zhihu.com/question/416652570/answer/1431359551</a><br><a href="https://zhuanlan.zhihu.com/p/436786508" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/436786508</a><br><a href="https://www.zhihu.com/question/453332049/answer/1835420993" target="_blank" rel="noopener">https://www.zhihu.com/question/453332049/answer/1835420993</a></p><p><a href="https://blog.csdn.net/u010059669/article/details/112287552" target="_blank" rel="noopener">https://blog.csdn.net/u010059669/article/details/112287552</a><br><a href="https://zhuanlan.zhihu.com/p/126552443" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126552443</a><br><a href="https://www.zhihu.com/question/328247960" target="_blank" rel="noopener">https://www.zhihu.com/question/328247960</a><br><a href="https://zhuanlan.zhihu.com/p/181673485" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181673485</a><br><a href="https://zhuanlan.zhihu.com/p/432068658" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/432068658</a><br><a href="https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html" target="_blank" rel="noopener">https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html</a><br><a href="https://www.zhihu.com/question/271485214" target="_blank" rel="noopener">https://www.zhihu.com/question/271485214</a><br><a href="https://zhuanlan.zhihu.com/p/111715881" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111715881</a></p><p>注：react hook 一样，处理 class component 关注点分离和难以复用问题，处理 function component 没有状态。</p><p>注：Opetion API 也可以叫 Object API？</p><ul><li>底层变化</li></ul><p>Vue 3为什么要用 Proxy API 替代 DefineProperty API？</p><p>proxy和defineproperty区别</p><p><a href="https://blog.csdn.net/weixin_43443341/article/details/124041094" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43443341/article/details/124041094</a><br><a href="https://segmentfault.com/a/1190000041084082" target="_blank" rel="noopener">https://segmentfault.com/a/1190000041084082</a></p><ul><li>vue 3 的正确打开方式</li></ul><p>必须要用 script-setup sugar （vue3 兼容 option 是为了兼容，最佳实际自然是抛弃历史包袱使用 setup）<br>必须要用 TS（vue3 用 ts 重写的目的就是为了加强对 ts 的支持）<br>必须要用 provide/inject<br>必须舍弃 lifecycle hooks</p><p><a href="https://v3.cn.vuejs.org/api/sfc-script-setup.html" target="_blank" rel="noopener">https://v3.cn.vuejs.org/api/sfc-script-setup.html</a></p><ul><li>生态</li></ul><p>Vuex4 对 TypeScript 并不友好，所以我选择 Pinia<br><a href="https://www.zhihu.com/question/478752529" target="_blank" rel="noopener">https://www.zhihu.com/question/478752529</a><br><a href="https://zhuanlan.zhihu.com/p/413968851" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/413968851</a></p><p>Volar<br>&lt; setup&gt; + TS + Volar = 真香<br>Vue.js作者尤雨溪在VueConf 2021谈Vue 3 生态进展<br><a href="https://www.bilibili.com/video/BV1JK4y1G7bf" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1JK4y1G7bf</a><br>27:40 开始，可以说 Volar 是 Vetur 的继任者<br><a href="https://zhuanlan.zhihu.com/p/401160130" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/401160130</a></p><ul><li>vue-class-component</li></ul><p><a href="https://github.com/vuejs/vue-class-component" target="_blank" rel="noopener">https://github.com/vuejs/vue-class-component</a><br><a href="https://zhuanlan.zhihu.com/p/355315790" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/355315790</a><br><a href="https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/typescript.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84-Vue-%E7%BB%84%E4%BB%B6</a></p><p>注：vue-class-component匹配Vue 3的v8版本还没有正式的文档</p><p><a href="https://github.com/vuejs/vue-class-component/tree/master/example/src/components" target="_blank" rel="noopener">https://github.com/vuejs/vue-class-component/tree/master/example/src/components</a><br>注：可以是 tsx 文件 也可以是 vue 文件</p><ul><li>vue-property-decorator</li></ul><p><a href="https://github.com/kaorun343/vue-property-decorator/issues/294" target="_blank" rel="noopener">https://github.com/kaorun343/vue-property-decorator/issues/294</a><br>注：应该暂时还不支持 vue3，package.json 中的 vue-class-component 版本还是 7.0</p><p>vue class component 是vue 官方出的，vue property decorator 是社区出的<br>其中 vue class component 提供了 vue component 等等<br>vue property decorator 深度依赖了 vue class component 拓展出了很多操作符 @Prop @Emit @Inject 等等 可以说是 vue class component 的一个超集<br>正常开发的时候 你只需要使用 vue property decorator 中提供的操作符即可 不用再从vue class componen 引入vue component</p><h2 id="vue-范式"><a href="#vue-范式" class="headerlink" title="vue 范式"></a>vue 范式</h2><p>JavaScript 是一个多范式的语言，支持 Class、Object、Function。Options API、Class API、Function API 。</p><p>喜欢装饰器，Class Component，Service Class 风格的选择 Angular，喜欢纯函数，Function Component，Hooks 的选择 React，没有啥偏好的使用 Vue</p><h3 id="与-React-区别"><a href="#与-React-区别" class="headerlink" title="与 React 区别"></a>与 React 区别</h3><p><a href="https://github.com/lihongxun945/myblog/issues/21" target="_blank" rel="noopener">https://github.com/lihongxun945/myblog/issues/21</a><br><a href="https://www.jianshu.com/p/b7cd52868e95" target="_blank" rel="noopener">https://www.jianshu.com/p/b7cd52868e95</a><br><a href="https://zhuanlan.zhihu.com/p/396229611" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/396229611</a><br><a href="https://www.zhihu.com/question/309891718/answer/2282544794" target="_blank" rel="noopener">https://www.zhihu.com/question/309891718/answer/2282544794</a></p><p>响应式原理不一样<br><a href="https://blog.csdn.net/SirM2z/article/details/71195059" target="_blank" rel="noopener">https://blog.csdn.net/SirM2z/article/details/71195059</a><br><a href="https://juejin.cn/post/6844904113432444942" target="_blank" rel="noopener">https://juejin.cn/post/6844904113432444942</a></p><p>react 面试题</p><p><a href="https://juejin.cn/post/6844903857135304718" target="_blank" rel="noopener">https://juejin.cn/post/6844903857135304718</a></p><p><a href="https://juejin.cn/post/6944863057000529933" target="_blank" rel="noopener">https://juejin.cn/post/6944863057000529933</a></p><p>响应式编程不是指的 RxJS Observable 那一套吗…和依赖追踪貌似关系不太大？</p><p><a href="https://juejin.cn/post/6844904103504527374" target="_blank" rel="noopener">https://juejin.cn/post/6844904103504527374</a></p><p>目前市面上的三种框架，无非是以Vue为首的响应式ui，这种框架特定就是简单，在通常意义下运行得非常快，但大规模的依赖收集和清理会带来额外的运作成本和内存消耗。第二种就是react这类，依靠f -&gt; UI这种声明式方案来更新视图，这种的好处在于它比依赖native api的响应式框架灵活太多。最后一种就是svelte，这种东西完全就是为web component而生，特点就是傻快，但没办法做dsl转换了（没vdom）。不过因为它就作用于小范围的dom，往往在编写小页面和web component时会带来的性能会远超于使用virtual dom或者增量dom的前端三框架。</p><p><a href="https://www.zhihu.com/question/446377023/answer/1756125862" target="_blank" rel="noopener">https://www.zhihu.com/question/446377023/answer/1756125862</a></p><p>个人倾向于认为即便有了调度的细粒度控制，整体上 React 计算 diff 的成本仍然比响应式框架高很多……像 concurrent mode 宣传中那样去优化跨越多帧（譬如 50-100ms 量级）的计算，无论怎么可控，听起来都已经像是有问题的了</p><p>vue-cli3<br><a href="https://blog.csdn.net/qinyuhua93/article/details/104820902" target="_blank" rel="noopener">https://blog.csdn.net/qinyuhua93/article/details/104820902</a></p><p><a href="https://www.zhihu.com/question/471825415" target="_blank" rel="noopener">https://www.zhihu.com/question/471825415</a><br><a href="https://zhuanlan.zhihu.com/p/441467856" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/441467856</a></p><p>vue3</p><p>Naive UI<br><a href="https://www.zhihu.com/question/463736268/answer/1928879382" target="_blank" rel="noopener">https://www.zhihu.com/question/463736268/answer/1928879382</a></p><p>vuex/Pinia</p><p>Vue 3 将成为新的默认版本<br><a href="https://zhuanlan.zhihu.com/p/460055155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/460055155</a></p><p>Vite2 + Vue3 + TypeScript + Pinia<br><a href="https://zhuanlan.zhihu.com/p/441467856" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/441467856</a></p><p>升级 vue 版本<br>npm update vue -S<br>npm update vue-template-compiler -D</p><p>vue 和 vue-template-compiler，两者的版本需要同步，如果不同步项目会报错</p><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><ul><li>ref、reactive、toRef、toRefs</li></ul><p>这几个 API 设计的目的就是为了在 setup 中使用响应式数据，setup 中不能使用 data 选项，只能通过上述方式使用响应式数据。</p><p>ref：返回一个响应式且可变（官网咖啡图）的 ref 对象。既支持原始类型，也支持引用类型，当值为引用类型时，底层使用的是 reactive。在模板中可省略 value 属性（自动解包）。</p><p>reactive：返回对象的响应式副本（基于 ES6 proxy 实现，响应式转换是“深层”的——它影响所有嵌套 property）。相当于 Vue2.x 的 Vue.observable () API（vue 2 中 data 选项的底层就是 Vue.observable，这两种方式都能创建响应式数据）。reactive 只支持将引用类型响应式，不支持原始类型。</p><p>toRef：用来将断开的响应式对象（被 reactive 包裹的对象）中某一个属性包裹成 ref 对象，并保持其和原对象的引用</p><p>toRefs：toRefs 和 toRef 功能是一致的，但是可以批量创建多个 ref 对象，注意，不支持可选 prop<br>响应式对象一旦被展开，其响应式特性会丢失，可用 toRefs 来解决</p><ul><li>attrs</li></ul><p>attrs 和 props 很相似，也是基于父子通信的数据，如果传递给组件的 attribute 或者 v-on 事件监听器，没有显式地声明在所接收组件的 props 或 emits 上，那么就会被挂到 attrs 上，且透传的 attribute 会自动添加到根元素的 attribute 中。</p><p>选项式 API 中，可通过 $attrs 访问，setup 中可通过 context 访问，setup sugar（script-setup） 中可通过 useAttrs 访问。</p><ul><li>refs</li></ul><p>选项式 API 中，可通过 $refs 访问 DOM，setup 中通过 ref 或函数绑定访问 DOM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; ref=&quot;btn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">const btn = ref(null);</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">  console.log(btn.value);</span><br><span class="line">&#125;;</span><br><span class="line">return &#123;</span><br><span class="line">  btn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;handleClick&quot; :ref=&quot;refBtn&quot;&gt;btn&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">let btn = null;</span><br><span class="line">const refBtn = (el)=&gt; &#123;</span><br><span class="line">  btn = el;</span><br><span class="line">&#125;;</span><br><span class="line">    const handleClick = () =&gt; &#123;</span><br><span class="line">      console.log(btn, 11);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">  refBtn,</span><br><span class="line">  handleClick,</span><br><span class="line">&#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  &lt;li </span><br><span class="line">v-for=&quot;(item, index) in list&quot; </span><br><span class="line">:key=&quot;index&quot;</span><br><span class="line">:ref=&quot;refLi&quot;</span><br><span class="line">  &gt;</span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> setup() &#123;</span><br><span class="line">   const list = reactive([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</span><br><span class="line">const elLi = reactive([]);</span><br><span class="line">const refLi = (el) =&gt; &#123;</span><br><span class="line">  elLi.push(el);</span><br><span class="line">&#125;;</span><br><span class="line">   nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(elLi, 2222);</span><br><span class="line">   &#125;);</span><br><span class="line">return &#123;</span><br><span class="line">  list,</span><br><span class="line">     refLi,</span><br><span class="line">&#125;;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><ul><li>defineComponent</li></ul><p>TS 类型本身是图灵完备的，类型图灵不完备的是发展不出类型体操的。</p><p>类型体操自然也有他的作用，比如说 Vue 就通过了大量的类型体操才实现了 defineComponent 的类型推导，否则你面对的可能是大量的 unknown 或 any。</p><p>defineComponent 最重要的是：在TypeScript下，给予了组件 正确的参数类型推断</p><p>将一个 组件用 defineComponent 包裹，仅仅只是为了 在 ts 下做类型推断</p><p>对传递给 setup() 的参数进行类型推断</p><ul><li>emits</li></ul><p>setup 选项的 this 不指向当前实例(undefined)，只能通过 context 使用 emit（推荐使用 emits 选项来定义组件可触发的事件），setup sugar 中通过 defineEmits 的返回使用 emit</p><p>emits 或 defineEmits 用来定义组件可向其父组件触发的事件。强烈建议声明组件所 emit 的事件，这尤为重要，vue3 中移除了 .native 修饰符，任何未在 emits 中声明的事件都将默认绑定到组件的根节点上（与 .native 修饰符的作用一样），对于那些被透传的原生事件，会被触发两次，emit 一次和应用在根元素上的原生事件一次。</p><p>vue2 中，组件上的 v-on 只会监听自定义事件 (用 $emit 触发的事件)，如果要监听根元素的原生事件，可以使用 .native 修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><p>以上代码，在 Vue3 中，如果组件内部没有用 emits 声明事件，则 click 事件会被。而在 Vue2 中，click 算自定义事件，如果想成为原生事件需要加 native 修饰符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;runoob @click.native=&quot;handleClick&quot;&gt;&lt;/runoob&gt;</span><br></pre></td></tr></table></figure><ul><li>expose</li></ul><p>Vue3 新特性，如果是 options api 类型的组件，不声明 expose 时，默认暴露当前组件实例的全部内容，声明了 expose 选项，expose 数组内标记的才会暴露。（expose:[]则什么都不暴露，注意这个问题。也可以利用这个特性提高组件使用的规范。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default defineComponent(&#123;</span><br><span class="line">  expose: [&apos;nameA&apos;,...], // 可以 expose 当前实例的任何内容</span><br><span class="line">  methods: &#123;</span><br><span class="line">    nameA()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>&lt;script setup&gt;</code> setup 语法糖的情况下，默认是封闭的，需要获取当前组件里的内容的话，必须显式 expose 出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&apos;ts&apos; setup&gt;</span><br><span class="line">import &#123;ref&#125; from &apos;vue&apos;;</span><br><span class="line">let refData = ref(&apos;寒蝉鸣泣之时&apos;)</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  refData,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>TS类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref,Ref &#125; from &quot;vue&quot;;</span><br><span class="line">//&gt; defineExpose</span><br><span class="line">interface exFace &#123;</span><br><span class="line">  ex1:Ref&lt;string&gt;,</span><br><span class="line">  ex2?:number</span><br><span class="line">&#125;</span><br><span class="line">let ex1 = ref(&apos;1&apos;)</span><br><span class="line">let exObj:exFace = &#123;</span><br><span class="line">  ex1,</span><br><span class="line">&#125;</span><br><span class="line">// 源码类型: const defineExpose: (exposed?: Record&lt;string, any&gt;) =&gt; void</span><br><span class="line">defineExpose(exObj)</span><br></pre></td></tr></table></figure><ul><li>jsx</li></ul><p>在 vue3 中使用 jsx，只能通过 option api 中的 render 函数或 setup 函数返回渲染函数，<code>&lt;script setup&gt;</code> 中不可使用。</p><p>const test = {<br>render(createElement) { // vue3 中 h 函数由 Vue 提供<br>return createElement(<br>‘div’, [<br>createElement(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>};</p><p>// 组件的注册<br>// 全局注册<br>Vue.component(‘Test’, test)<br>// 局部注册<br>components: {<br>Test: test,<br>}</p><p>var test = {<br>setup() {<br>return () =&gt; {<br>return h(<br>‘div’, [<br>h(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>},</p><p>注意：cdn 模式下不能使用 jsx，只能使用 vdom，jsx 需要使用 Babel 插件来转译</p><p>const test = {<br>render(createElement) { // vue3 中 h 函数由 Vue 提供<br>return createElement(<br>‘div’, [<br>createElement(‘span’, ‘Heldlo’),<br>‘ world!’<br>]<br>);<br>}<br>};</p><p>// 组件的注册：全局注册、局部注册<br>Vue.component(‘Test’, test)</p><h2 id="script-setup"><a href="#script-setup" class="headerlink" title="script setup"></a>script setup</h2><p><code>&lt;script setup&gt;</code> 语法糖里面的代码会被编译成组件 setup() 函数的内容。</p><ul><li><code>&lt;script setup&gt;</code> 中无需 return 声明的变量、函数以及 import 引入的内容，即可在<template>使用</template></li></ul><p>标准组件<code>&lt;script&gt;</code>需要写setup函数并繁琐retrun</p><ul><li><p><code>&lt;script setup&gt;</code>引入组件将自动注册</p></li><li><p>组件通信:在<code>&lt;script setup&gt;</code>中必须使用 defineProps 和 defineEmits API 来替代 props 和 emits</p></li><li><p><code>&lt;script setup&gt;</code>需主动向父组件暴露子组件属性 ：defineExpose</p></li></ul><p>使用 <code>&lt;script setup&gt;</code> 的组件，父组件是无法通过ref 或者 $parent 获取到子组件的ref等响应数据，需要通过defineExpose 主动暴露</p><ul><li>useSlots 和 useAttrs</li></ul><p>用于在 JSX 模式下使用 slot 和 attr，SFC 模式下，在<template>通过<slot>标签就可以渲染插槽</slot></template></p><ul><li>useRoute 和 useRouter</li></ul><p>setup 里不能访问 this，不能再直接访问 this.$router 或 this.$route。（getCurrentInstance可以替代this但不推荐）<br>推荐：使用useRoute 函数和useRouter函数替代this.$route 和 this.$router</p><p>命名空间组件<br>Suspense<br>编译器宏：withDefaults<br><code>&lt;style&gt;</code> 特性<br>watchEffect 和 watch</p><h3 id="编译-html-字符串"><a href="#编译-html-字符串" class="headerlink" title="编译 html 字符串"></a>编译 html 字符串</h3><p><a href="https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js" target="_blank" rel="noopener">https://stackoverflow.com/questions/54617255/render-and-compile-string-using-vue-js</a></p><p><a href="https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components" target="_blank" rel="noopener">https://stackoverflow.com/questions/51006553/render-v-html-as-vue-components</a></p><p><a href="https://cloud.tencent.com/developer/article/1467371" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1467371</a></p><p><a href="https://www.cnblogs.com/lvonve/p/12470666.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvonve/p/12470666.html</a><br><a href="https://www.zhihu.com/question/411745998" target="_blank" rel="noopener">https://www.zhihu.com/question/411745998</a><br><a href="https://www.zhihu.com/question/436260027" target="_blank" rel="noopener">https://www.zhihu.com/question/436260027</a><br><a href="https://segmentfault.com/q/1010000023534933" target="_blank" rel="noopener">https://segmentfault.com/q/1010000023534933</a><br><a href="https://zhuanlan.zhihu.com/p/153387704" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/153387704</a></p><p>jsx 和 SFC template 只能在脚手架下才能被编译为 vdom，直接用 <code>&lt;script&gt;</code> 引入的 vue 下不能使用<br><code>&lt;script&gt;</code> 引入的 vue 下只能使用 template 选项和 render createElement 手动写 vdom</p><p>不使用脚手架，只 <code>&lt;script&gt;</code> 引入来使用 vue，会大打折扣？损失哪些功能，只能用哪些功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;,</span><br><span class="line">  components: &#123; </span><br><span class="line">    App,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p><p>意思是，要么使用完整版带 compoler 的 vue 在运行时动态编译 template，要不用 render 替换 template。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><p>注：jsx 中使用其他组件，不需要用 components 注册</p><p>vue 项目要先编译再运行：编译 —》 运行</p><p>template 和 jsx 会预编译为 vdom（能静态分析，能提就能确定dom结构），但是对于 html 字符串（首先编译器不知道该不该编译，另外字符串不一定是静态的，可能是后台返回的），不管是 slot、v-html，mustashe 插值，都是按普通字符串处理，不会被编译，要想编译 html 字符串只能使用完整版的 vue，以 template 选项或 Vue.compiler 的方式在运行时动态编译。</p><p>这样是错误的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, this.world());</span><br><span class="line">    console.log(this.world()); // vNode 是 Object</span><br><span class="line">    return &lt;div domPropsInnerHTML=&#123;str&#125;&gt;&lt;/div&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    world() &#123;</span><br><span class="line">      return &lt;span&gt;world&lt;/span&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>配置 vue-cli</li></ul><p>引入完整版 vue，有 2 种配置方法。</p><p>方法 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  runtimeCompiler:true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.resolve.alias.set(&apos;vue$&apos;,&apos;vue/dist/vue.esm.js&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后就可以这样写组件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Test.js，jsx 后缀也可以</span><br><span class="line">export default &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&lt;/div&gt;&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">      alert();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Test.jsx</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      str: &apos;&lt;div&gt;&lt;span&gt;hello&lt;/span&gt;,&lt;/div&gt;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render(h) &#123;</span><br><span class="line">    str = this.str.replace(/,/g, &apos;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&apos;);</span><br><span class="line">    const render = &#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return h(render);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  render() &#123;</span><br><span class="line">    const str = this.str.replace(/,/g, &apos;&lt;el-button @click=&quot;handleClick&quot;&gt;world&lt;/el-button&gt;&apos;);</span><br><span class="line">    const Foo = Vue.extend(&#123;</span><br><span class="line">      template: str,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert();</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &lt;Foo&gt;&lt;/Foo&gt;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Greeting /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">/* eslint-disable */</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // render(h) &#123;</span><br><span class="line">  //   return h(foo, &#123;&#125;);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    aa() &#123;</span><br><span class="line">      return &lt;div&gt;cccc&lt;/div&gt;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    cc() &#123;</span><br><span class="line">      // const html = &lt;button onClick=&#123;this.handleClick&#125;&gt;btn&lt;/button&gt;;</span><br><span class="line">      const dd = Vue.extend(&#123;</span><br><span class="line">        template: &apos;&lt;div&gt;&lt;button @click=&quot;this.handleClick&quot;&gt;btn&lt;/button&gt;&lt;/div&gt;&apos;,</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(dd, 2222);</span><br><span class="line">      // const vNode = this.aa();</span><br><span class="line">      // console.log(vNode, 232323);</span><br><span class="line">      return dd;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    &apos;Greeting&apos;: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &apos;hello world&apos;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      template: &apos;&lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;btn&lt;/button&gt;&#123;&#123;msg&#125;&#125;&lt;Bar /&gt;&lt;/div&gt;&apos;,</span><br><span class="line"></span><br><span class="line">      methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">          alert(&apos;ok&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      components: &#123;</span><br><span class="line">        &apos;Bar&apos;: &#123;</span><br><span class="line">          data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              name: &apos;bar&apos;,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          created() &#123;</span><br><span class="line">            const foo = &apos;foo&apos;;</span><br><span class="line">            this.$options.template = `&lt;div&gt;&#123;&#123;name&#125;&#125;$&#123;foo&#125;&lt;/div&gt;`;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>工作中有需要对 v-html 返回数据做数据绑定的需求，比如题干中答题，这时候要不使用原生 DOM，要不使用 vue 运行时的编译能力了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:12 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Vue-简介&quot;&gt;&lt;a href=&quot;#Vue-简介&quot; class=&quot;headerlink&quot; title=&quot;Vue 简介&quot;&gt;&lt;/a&gt;Vue 简介&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;优点&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;渐进式：框架设计（可以直接引入使用，仅使用核心渲染功能，也可以配合构建工具，集成路由和数据管理，采用单文件组件的开发模式）&lt;br&gt;声明式渲染：响应式（数据驱动视图，当数据改变后，会通知视图，不是指响应式编程 Reactive Programming），不需要传统那样命令式的操作 DOM&lt;br&gt;组件化：&lt;br&gt;工程化：Vue-cli&lt;br&gt;全家桶？：vuex、vue-router 集中式数据管理和客户端路由&lt;/p&gt;&lt;p&gt;声明式渲染（Declarative View）与之相对应的是命令式渲染（Imperative View）&lt;/p&gt;
    
    </summary>
    
      <category term="project" scheme="https://yunguxt.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>互动直播课堂前端技术设计</title>
    <link href="https://yunguxt.cn/2020/10/01/Interact-Live-Class/"/>
    <id>https://yunguxt.cn/2020/10/01/Interact-Live-Class/</id>
    <published>2020-09-30T16:00:00.000Z</published>
    <updated>2021-12-26T16:31:44.695Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>按同屏的技术实现方式来划分，课堂分为<strong>录屏课堂</strong>和<strong>指令课堂</strong>。指令课堂的操作状态需要恢复，录屏课堂中不是必须的，不管是录屏课堂还是指令课堂，互动操作（比如，聊天、点名、授权、问答…）都要通过指令实现。指令课堂适用于面对面课堂，录屏课堂适用于远程课堂。</p><p>指令同屏中可以选择同屏的内容，这样可以保护隐私。</p><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>按使用场景来划分，课堂又分为<strong>面对面课堂</strong>和<strong>远程课堂</strong>。面对面课堂作为线下课堂的补充，而远程课堂可用来替代线下课堂。</p><ul><li>基础功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 黑板（截图）</span><br><span class="line">* 音视频直播(摄像头、桌面，rtmp、hls、flv --- http cdn，rtc)</span><br><span class="line">* 学生列表（支持授权还有举手列表）</span><br><span class="line">* 授权（授权书写、语音、视频）</span><br><span class="line">* 课件（预览、上传，支持二维码上传，img、ppt、pdf、doc、media）</span><br><span class="line">* 聊天（可禁言）</span><br><span class="line">* 投票</span><br><span class="line">* 点名</span><br><span class="line">* 抽人</span><br><span class="line">* 计时器</span><br><span class="line">* 录像</span><br></pre></td></tr></table></figure><p>基础版课堂，能够满足基本的直播和白板需求，适用于远程教学、视频会议、白板等场景。</p><ul><li>K12 教学功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 问答（自由题目和备课题目）</span><br><span class="line">* 讲解题目/问答/作业</span><br></pre></td></tr></table></figure><p>注：测验的三种方式 — 问答、作业、考试。问答只能在课堂中进行，其他两种类型在课前（预习）、课中（随堂）、课后进行都可以。</p><h2 id="业务设计"><a href="#业务设计" class="headerlink" title="业务设计"></a>业务设计</h2><ul><li>登录</li></ul><p>登录</p><p>会话保持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage + http header</span><br></pre></td></tr></table></figure><p>登录刷新</p><ul><li>鉴权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口鉴权</span><br><span class="line">前端 UI 鉴权</span><br><span class="line">前端 Router 鉴权</span><br></pre></td></tr></table></figure><p>依赖于后端接口的 UI 不需要处理，但是不依赖的呢，有些（非操作类，不会触发后续请求的接口，因为这类 UI 无法通过后端接口来处理）就需要处理</p><ul><li>课堂控制</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 开始上课</span><br><span class="line">* 结束上课</span><br><span class="line">* 拖堂</span><br><span class="line">* 课堂倒计时</span><br></pre></td></tr></table></figure><ul><li>恢复</li></ul><p>恢复接口返回数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><p>课堂恢复的数据存在 Vuex。</p><ul><li>角色</li></ul><p>多角色设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 老师</span><br><span class="line">* 学生</span><br><span class="line">* 助教</span><br><span class="line">* 游客</span><br></pre></td></tr></table></figure><ul><li>授权</li></ul><p>十进制的展示和传输，二进制的语义</p><p>二进制表达的目的是为了能够组合表达，这样就能够表达多种状态</p><p>黑板：1 — 001<br>音频：2 — 010<br>视频：4 — 100 # 纯视频</p><p>判断：<br>(1xx &amp; 4) === 4</p><p>更新：<br>6 ^ 4 // 2</p><ul><li>问答</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 做题组件的设计（显示、作答、讲解）</span><br></pre></td></tr></table></figure><ul><li>讲解</li></ul><p>讲题目、讲答案、对比讲解答案、讲报告。</p><ul><li>黑板</li></ul><p>黑板配置没有做同步（老师 PC 和 老师平板），需要做吗</p><h2 id="技术设计"><a href="#技术设计" class="headerlink" title="技术设计"></a>技术设计</h2><ul><li>窗口</li></ul><p>非模态弹框被称为窗口，由于非模态的原因，就需要考虑窗口的排序</p><ul><li>同屏</li></ul><p>应用的宽高比<br>同屏与主控比</p><p>可以按提前商定宽高适配比例适配（适用于定制设备），也可以按主控的宽高比做适配。</p><p>提前商定适配尺寸，位置数据适配比例需要转化为中间比例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scale2Server(state, getters) &#123;</span><br><span class="line">  return 768 / getters.appWidth;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">scale2Client(state, getters) &#123;</span><br><span class="line">  return getters.appWidth / 768;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果按主控来适配，直接</p><ul><li>音视频直播</li></ul><p>播放器</p><p>两路流，混流。</p><p><a href="https://www.jianshu.com/p/32417d8ee5b6" target="_blank" rel="noopener">https://www.jianshu.com/p/32417d8ee5b6</a></p><ul><li>WebSocket 设计</li></ul><p>长链接实时应用熄屏</p><h3 id="Ajax-接口设计和调用"><a href="#Ajax-接口设计和调用" class="headerlink" title="Ajax 接口设计和调用"></a>Ajax 接口设计和调用</h3><ul><li>API 管理</li></ul><p>按业务模块划分，再由一个文件同意导出，方便管理。</p><ul><li>Axios 的设置</li></ul><p>Websorket 直接返回的是服务端数据，不管是成功还是错误。但是经 Axios 的 Ajax 返回被包裹了一层。</p><p>/lesson/xxx 开头的接口用的是 lesson_token，其他用的都是 lesson_access_token</p><p>其实大部分情况下，调的都是课外接口</p><ul><li>catch</li></ul><p>服务器端异常提示，统一在 Axios 响应拦截器里拦截，不需要调用接口时一个个 catch（参考 Promise 章节），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api.usHandUp().then(response =&gt; &#123;</span><br><span class="line">  this.handUpStatus = true;</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  this.$message(&#123;</span><br><span class="line">    message: error.msg,</span><br><span class="line">    type: &apos;warning&apos;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vuex-设计"><a href="#Vuex-设计" class="headerlink" title="Vuex 设计"></a>Vuex 设计</h3><h3 id="Socket-接口设计"><a href="#Socket-接口设计" class="headerlink" title="Socket 接口设计"></a>Socket 接口设计</h3><ul><li>WebSocket 库设计</li></ul><p>注：Socket 接口不一定非要用于推送，也可以当 HTTP 接口一样的用，也会有返回。</p><ul><li>数据的同步和恢复</li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>http 接口都带了 token，socket 接口没带？</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>游客快速问答的恢复</li><li>移除 Ajax 接口业务中的 catch</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;按同屏的技术实现方式来划分，课堂分为&lt;strong&gt;录屏课堂&lt;/strong&gt;和&lt;strong&gt;指令课堂&lt;/strong&gt;。指令课堂的操作状态需要恢复，录屏课堂中不是必须的，不管是录屏课堂还是指令课堂，互动操作（比如，聊天、点名、授权、问答…）都要通过指令实现。指令课堂适用于面对面课堂，录屏课堂适用于远程课堂。&lt;/p&gt;&lt;p&gt;指令同屏中可以选择同屏的内容，这样可以保护隐私。&lt;/p&gt;
    
    </summary>
    
      <category term="project" scheme="https://yunguxt.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>K12 需求概要</title>
    <link href="https://yunguxt.cn/2020/06/15/K12/"/>
    <id>https://yunguxt.cn/2020/06/15/K12/</id>
    <published>2020-06-14T16:00:00.000Z</published>
    <updated>2020-12-15T09:08:07.813Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><p>用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">个人老师</span><br><span class="line">机构学校</span><br><span class="line">培训中心</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="需求概要"><a href="#需求概要" class="headerlink" title="需求概要"></a>需求概要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 基础功能</span><br><span class="line">门户首页</span><br><span class="line">登录、注册</span><br><span class="line">用户管理</span><br><span class="line">个人、机构入驻</span><br><span class="line">消息公告</span><br><span class="line"></span><br><span class="line"># 核心业务</span><br><span class="line">资源库</span><br><span class="line">作业</span><br><span class="line">排课</span><br><span class="line">备课</span><br><span class="line">课堂</span><br><span class="line">云笔记</span><br><span class="line">阅卷</span><br><span class="line">商城</span><br><span class="line">支付</span><br><span class="line">学情</span><br><span class="line">激励</span><br><span class="line">录播</span><br><span class="line">语音测评</span><br><span class="line">乐答</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line">升学规划</span><br><span class="line"></span><br><span class="line"># 数据分析</span><br><span class="line">监控</span><br></pre></td></tr></table></figure><h2 id="资源库"><a href="#资源库" class="headerlink" title="资源库"></a>资源库</h2><p>资源库是用来备课（课堂中会用到）和做作业的。</p><ul><li>资源类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">试题</span><br><span class="line">试卷</span><br><span class="line">课件</span><br><span class="line">微课</span><br></pre></td></tr></table></figure><ul><li>试题类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单选、多选</span><br><span class="line">判读</span><br><span class="line">填空</span><br><span class="line">问答</span><br><span class="line">材料      # 复合题，由上述几种类型的子题组合而成</span><br><span class="line">完形填空   # 完形填空其实数据材料题的一种，但是由于其子题没有题干，所以独立为一种题型</span><br><span class="line">阅读理解   # 道理同完形填空</span><br></pre></td></tr></table></figure><ul><li>试题结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题干</span><br><span class="line">选项</span><br><span class="line">答案</span><br><span class="line">解析</span><br></pre></td></tr></table></figure><p>注：填空题下划线入题时是一个下划线，渲染时需要注意一下。</p><ul><li>试题出现的场景</li></ul><p>作为抽象依据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看  # 资源库</span><br><span class="line">做  # 学生（表现微试卷）</span><br><span class="line">看  # 学生做完，老师要批改（表现为试卷）</span><br></pre></td></tr></table></figure><ul><li>筛选组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学段（stage）</span><br><span class="line">学科（subject）</span><br><span class="line">教材版本（edition）</span><br><span class="line">教材章节树（chapter）</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;用户：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;个人老师&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;机构学校&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;培训中心&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="project" scheme="https://yunguxt.cn/categories/project/"/>
    
    
  </entry>
  
  <entry>
    <title>Node 面试题</title>
    <link href="https://yunguxt.cn/2020/06/01/Interview-Node/"/>
    <id>https://yunguxt.cn/2020/06/01/Interview-Node/</id>
    <published>2020-05-31T16:00:00.000Z</published>
    <updated>2022-08-11T01:03:30.877Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;!-- rebuild by neat
        
      
    
    </summary>
    
      <category term="interview" scheme="https://yunguxt.cn/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>算法面试题</title>
    <link href="https://yunguxt.cn/2020/05/10/Interview-Algorithms/"/>
    <id>https://yunguxt.cn/2020/05/10/Interview-Algorithms/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2022-08-11T06:30:17.372Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写一个函数，列出一个整数所有的分解类型，比如对于数字4，可以做拆分得到下列字符串</p><p>1111<br>112<br>121<br>13<br>211<br>22<br>31<br>4</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Decrease-and-conquer</span><br><span class="line">// f(1) = 0^f(1)=[[1]]</span><br><span class="line">// f(2) = 1^f(1) U 0^f(2) = [[1,1],[2]]</span><br><span class="line">// f(3) = 2^f(1) U 1^f(2) U 0^(3) = [[2,1],[1,1,1],[1,2],[3]]</span><br><span class="line">var resolve = (function ()&#123;</span><br><span class="line">    var table = [[],[[1]]];</span><br><span class="line">    //closure for cache</span><br><span class="line">    return function (number)&#123;</span><br><span class="line">        //recursion function</span><br><span class="line">        var callee = arguments.callee;</span><br><span class="line">        if (!table[number])&#123;</span><br><span class="line">            var arr = [];</span><br><span class="line">            for (var i=1;i&lt;number ;i++ )&#123;</span><br><span class="line">                //recursion for sub result</span><br><span class="line">                var subs = callee(number-i);</span><br><span class="line">                subs.forEach(function (sub)&#123;</span><br><span class="line">                    arr.push(sub.concat([i]));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push([number]);</span><br><span class="line">            //cache result</span><br><span class="line">            table[number] = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        return table[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>求和</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123; <span class="comment">// n &lt;= 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n + add(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><ul><li>按时间从小到大排序输出每个分数大于 60 分的人的姓名和对应分数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  A: &#123;</span><br><span class="line">    name: <span class="string">'aaa'</span>,</span><br><span class="line">    score: <span class="number">60</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2016 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  B: &#123;</span><br><span class="line">    name: <span class="string">'bbb'</span>,</span><br><span class="line">    score: <span class="number">50</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2017 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  C: &#123;</span><br><span class="line">    name: <span class="string">'ccc'</span>,</span><br><span class="line">    score: <span class="number">90</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2018 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  D: &#123;</span><br><span class="line">    name: <span class="string">'ddd'</span>,</span><br><span class="line">    score: <span class="number">80</span>,</span><br><span class="line">    time: <span class="string">'Mon May 16 2014 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  E: &#123;</span><br><span class="line">    name: <span class="string">'eee'</span>,</span><br><span class="line">    score: <span class="number">81</span>,</span><br><span class="line">    time: <span class="string">'Mon May 15 2014 18:48:34 GMT+0800 (中国标准时间)'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.values(obj)</span><br><span class="line">  .filter(<span class="function">(<span class="params">&#123; score &#125;</span>) =&gt;</span> score &gt; <span class="number">60</span>)</span><br><span class="line">  .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Date</span>(a.time).getTime() -<span class="keyword">new</span> <span class="built_in">Date</span>(b.time).getTime());</span><br></pre></td></tr></table></figure><ul><li>已知后台返回树形数据如下所示，将其处理为一个树形结构。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">56</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">81</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">74</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">76</span>, <span class="attr">parentId</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">63</span>, <span class="attr">parentId</span>: <span class="number">62</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">80</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">87</span>, <span class="attr">parentId</span>: <span class="number">86</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">62</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">86</span>, <span class="attr">parentId</span>: <span class="number">74</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>树形结构如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = &#123;</span><br><span class="line">  id: <span class="number">74</span>,</span><br><span class="line">  parentId: <span class="literal">null</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      id: <span class="number">62</span>,</span><br><span class="line">      parentId: <span class="number">74</span></span><br><span class="line">      children: [</span><br><span class="line">      ...</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findParentEl</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i].id === id) &#123;</span><br><span class="line">      <span class="keyword">return</span> data[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.parentId) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = findParentEl(el.parentId);</span><br><span class="line">  parentEl.children = [...(parentEl.children || []), el];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(root);</span><br></pre></td></tr></table></figure><p>以空间换时间，可将上面的算法时间复杂度由 O(n^2) 优化到 O(n)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> idMap = data.reduce(<span class="function">(<span class="params">acc, el, i</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[el.id] = i;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">data.forEach(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!el.parentId) &#123;</span><br><span class="line">    root = el;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parentEl = data[idMap[el.parentId]];</span><br><span class="line">  parentEl.children = [...(parentEl.children || []), el]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 17 2022 11:34:11 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;写一个函数，列出一个整数所有的分解类型，比如对于数字4，可以做拆分得到下列字符串&lt;/p&gt;&lt;p&gt;1111&lt;br&gt;112&lt;br&gt;121&lt;br&gt;13&lt;br&gt;211&lt;br&gt;22&lt;br&gt;31&lt;br&gt;4&lt;/p&gt;
    
    </summary>
    
      <category term="interview" scheme="https://yunguxt.cn/categories/interview/"/>
    
    
  </entry>
  
</feed>
