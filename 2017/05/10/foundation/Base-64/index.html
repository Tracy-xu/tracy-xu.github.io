<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Tracy-xu&#39;Blog">
    

    <!--Author-->
    
        <meta name="author" content="Tracy Xu">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Base 64 编码"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tracy-xu&#39;Blog" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Tracy-xu&#39;Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>Base 64 编码 - Tracy-xu&#39;Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/plugins/bootstrap/css/bootstrap.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom Fonts -->
    <link href="/plugins/font-awesome/css/font-awesome.min.css" type="text/css" rel="stylesheet" />

    <!-- Gallery -->
    <link href="/plugins/featherlight/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/static/katex.min.css">

<link rel="stylesheet" href="/static/hexo-math.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Tracy-xu'Blog" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    首页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    归档
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    分类
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    关于我
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav class="menu-bar">
    <a></a>
</nav>


<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2017/05/10/foundation/Base-64/">
                Base 64 编码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-05-10</span>
            
            
            
                <span class="category">
                    <a href="/categories/计算机组成原理/">计算机组成原理</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <p>Base64 是一种用 64 个可打印字符来表示任意二进制数据的二进制编码方法。可以用来处理和传输任意二进制数据。</p>
<p>Base64 最初是用在电子邮件中，为了满足电子邮件中不能直接使用非 ASCII 码字符的规定，用来传输二进制文件的。除此之外，它还可将任意不可打印的二进制数据，转化为可打印的文本编码，使用文本软件进行编辑（二进制流中有很多都是无法显示和打印的，比如 ASCII 中的控制字符，二进制文件 jpg、pad、exe 等，如果用记事本打开这些文件，会看到一堆乱码）。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Base64 编码将一个 8 位字节序列拆散为 6 位的片段，并为每个 6 位的片段分配一个字符，这个字符是 Base64 字母表中的 64 个字符之一。这 64 个输出字符都是很常见的 ASCII 字符，包括大小写字母、数字、＋ 和 &#x2F;，还使用了特殊字符 &#x3D;。</p>
<p>Base64 编码表 (The Base64 Alphabet)：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>17</td>
<td>R</td>
<td>34</td>
<td>i</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>18</td>
<td>S</td>
<td>35</td>
<td>j</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>19</td>
<td>T</td>
<td>36</td>
<td>k</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>20</td>
<td>U</td>
<td>37</td>
<td>l</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>21</td>
<td>V</td>
<td>38</td>
<td>m</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>22</td>
<td>W</td>
<td>39</td>
<td>n</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>23</td>
<td>X</td>
<td>40</td>
<td>o</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>24</td>
<td>Y</td>
<td>41</td>
<td>p</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>25</td>
<td>Z</td>
<td>42</td>
<td>q</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>26</td>
<td>a</td>
<td>43</td>
<td>r</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>27</td>
<td>b</td>
<td>44</td>
<td>s</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>28</td>
<td>c</td>
<td>45</td>
<td>t</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>29</td>
<td>d</td>
<td>46</td>
<td>u</td>
<td>63</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>30</td>
<td>e</td>
<td>47</td>
<td>v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>31</td>
<td>f</td>
<td>48</td>
<td>w</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>32</td>
<td>g</td>
<td>49</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>Q</td>
<td>33</td>
<td>h</td>
<td>50</td>
<td>y</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>还可以自己定义 64 个字符的排列顺序，这样就可以自定义 Base64 编码，不过，通常情况下没有必要。</p>
<p>注意：由于 Base64 编码用了 8 位字符来表示信息中的 6 个位，所以 Base64 编码字符串大约比原始值增加了 33%，(8 - 6) &#x2F; 6 &#x3D; 1&#x2F;3，选择 Base64 编码时要考虑一下文件的 size。另外，Base64 是一种通过查表的数据编码方法，目的是让数据符合传输协议的要求，不能将其误用于数据加密或数据校验，即使使用自定义的编码表也不行。</p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>下面是一个简单的 Base64 编码实例。在这里，三个字符组成的输入值 “Ow!” 是 Base64 编码的，得到的是 4 个字符的 Base64 编码值 “T3ch”。它是按以下方式工作的。</p>
<table>
<thead>
<tr>
<th>8 位字符</th>
<th>O</th>
<th>w</th>
<th>!</th>
</tr>
</thead>
<tbody><tr>
<td>8 位值（十六进制）</td>
<td>$4F</td>
<td>$77</td>
<td>$21</td>
</tr>
<tr>
<td>8 位值（二进制）</td>
<td>01001111</td>
<td>01110111</td>
<td>00100001</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>对上面 8 位值（二进制）进行拆分</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>6 位值（二进制）</td>
<td>010011</td>
<td>110111</td>
<td>011100</td>
<td>100001</td>
</tr>
<tr>
<td>6 位值（十进制）</td>
<td>19</td>
<td>55</td>
<td>28</td>
<td>33</td>
</tr>
<tr>
<td>Base64 字符</td>
<td>T</td>
<td>3</td>
<td>c</td>
<td>h</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 字符串 &quot;Ow!&quot; 被拆分成 3 个 8 位的字节 (0x4F、0x77、0x21)；</span><br><span class="line">* 这 3 个字节构成了一个 24 位的二进制 01001111 01110111 00100001；</span><br><span class="line">* 这些位被划分为一些 6 位的序列 010011、110111、011100、100001；</span><br><span class="line">* 每个 6 位值都表示了从 0~63 之间的一个数字，对应 Base64 字母表中的 64 个字符之一。得到的 Base64 编码字符串是 4 个字符的字符串 &quot;T3ch&quot;。然后就可以通过线路将这个字符串作为“安全的” 8 位字符传送出去，因为只用了一些移植性最好的字符（字母、数字等）；</span><br></pre></td></tr></table></figure>

<ul>
<li>用 JavaScript 描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Ow!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> binary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> binStr = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">2</span>); <span class="comment">// charCodeAt 返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数</span></span><br><span class="line">  binary.<span class="title function_">push</span>(binStr); <span class="comment">// [&#x27;1001111&#x27;, &#x27;1110111&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个正常的字节都是由 8bit 组成的，不够 8bit 需要在高位补 0，于是得到 [&#x27;01001111&#x27;, &#x27;01110111&#x27;, &#x27;00100001&#x27;]</span></span><br><span class="line"><span class="comment">// 1 把字符串按照 6 位分开，进行分割，得到 [&#x27;010011&#x27;, &#x27;110111&#x27;, &#x27;011100&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line"><span class="comment">// 2 将每一个转换为十进制分别对于 [19, 55, 28, 33];</span></span><br><span class="line"><span class="comment">// 3 将每一位数字分别对于上面提供的 Base64 对应表,得到对应的编码，分别对于 T3ch</span></span><br><span class="line"><span class="comment">// 4 最后就会得到 Base64 编码 T3ch</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符 &quot;Ow!&quot; 最后得到的 Base64 编码为&quot; T3ch&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>前提 – 确定具体的编码方案</li>
</ul>
<p>需要注意的是，ASCII 码 128 位后的字符，各个编码方案不兼容，比如汉字有 gb2312、utf-8、gbk 等，每一种编码的 Base64 对应值都不一样，是用 Base64 进行编码前，需要确定编码方案。下面以’严’的 UTF-8 为例：</p>
<p>“严”的 UTF-8 编码为 E4B8A5，写成二进制就是三字节的 “11100100 10111000 10100101”。将这个 24 位的二进制字符串，转换成四组一共 32 位的二进制值”111001 001011 100010 100101”，相应的十进制数为 57、11、34、37，它们对应的 Base64 值就为5、L、i、l。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeJS（btoa 不支持中文）</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&#x27;严&#x27;</span>);</span><br><span class="line">b.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 5Lil</span></span><br></pre></td></tr></table></figure>

<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>Base64 编码收到一个 8 位字节序列，将这个二进制序列流划分成 6 位的块。二进制序列有时不能正好平均地分为 6 位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为 24 的倍数（6 和 8 的最小公倍数）。</p>
<p>对已填充的二进制进行编码时，任何完全填充（不包括原始数据中的位）的 6 位组都有特殊的第 65 个符号 “&#x3D;” 表示。如果 6 位组是部分填充的，就将填充位设置为 0。</p>
<p>下面是一个填充实例：</p>
<table>
<thead>
<tr>
<th>输入数据</th>
<th>二进制序列（填充位以 x 表示）</th>
<th>已编码数据</th>
</tr>
</thead>
<tbody><tr>
<td>a:a</td>
<td>011000 010011 101001 100001</td>
<td>YTph</td>
</tr>
<tr>
<td>a:aa</td>
<td>011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx</td>
<td>YTphYQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>a:aaa</td>
<td>011000 010011 101001 100001 011000 010110 0001xx xxxxxx</td>
<td>YTphYWE&#x3D;</td>
</tr>
<tr>
<td>a:aaaa</td>
<td>011000 010011 101001 100001 011000 010110 000101 1000001</td>
<td>YTphYWFh</td>
</tr>
</tbody></table>
<p>初始输入字符串为 “a:a” 为 3 个字节（24 位）。24 是 6 和 8 的倍数，因此按照上面给出的例子计算。无需填充就会得到 Base64 编码为 “YTph”。</p>
<p>然而，再增加一个字符，输入字符串变为 “a:aa”，转换为二进制就会有 32 位长。而 6 和 8 的下一个公倍数为 48，因此要添加 16 位的填充码。填充的前 4 位是与数据位混合在一起的。得到的 6 位组 01xxxx，会被当作 010000、十进制中的 16，或者 Base64 编码的 Q 来处理。剩下的两个 6 位组都是填充码，用 &#x3D; 来表示。</p>
<p>‘O’ 的填充实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x27;O&#x27;.charCodeAt().toString(2);</span><br><span class="line">得到二进制（位数不够 8 位时，需要在高位补码）</span><br><span class="line">1001111 --&gt; 01001111</span><br><span class="line">-----------------------------------------</span><br><span class="line">按 6 位拆分二进制（位数不是 24 的倍数时，需要低位补码）</span><br><span class="line">010011, 11xxxx, xxxxxx, xxxxxx</span><br><span class="line">-----------------------------------------</span><br><span class="line">转为十进制</span><br><span class="line">19, 48</span><br><span class="line">-----------------------------------------</span><br><span class="line">Base64 查表结果</span><br><span class="line">Tw==</span><br></pre></td></tr></table></figure>

<h2 id="浏览器中-Base64-编码生成"><a href="#浏览器中-Base64-编码生成" class="headerlink" title="浏览器中 Base64 编码生成"></a>浏览器中 Base64 编码生成</h2><h3 id="字符的编码"><a href="#字符的编码" class="headerlink" title="字符的编码"></a>字符的编码</h3><p>Web API 中 <code>atob</code> 和 <code>btoa</code> 用来对字符进行 Base64 编码和解码。<code>btoa</code> 将二进制的字节数据（binary bytes）编码成 ASCII 字符串，<code>atob</code> 解码通过 Base64 编码的字符串数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;a:a&#x27;</span>); <span class="comment">// YTph</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">&#x27;YTph&#x27;</span>); <span class="comment">// a:a</span></span><br></pre></td></tr></table></figure>

<p>注：<code>btoa</code> 和 <code>atob</code> 分别是 Binary to ASCII 和 ASCII to binary 的缩写。b 不是 Base64 的缩写，计算机中的所有数据的本质都是二进制，我们所看到的文字、符号、图片、语音视频…，都是二进制数据在具体编码（字符编码、图像编码…）下的表现。</p>
<p>IE9 不支持 <code>atob</code> 和 <code>btoa</code>，可手动实现 Base64 编解码函数：<a target="_blank" rel="noopener" href="https://github.com/dankogai/js-base64">js-base64</a>、<a target="_blank" rel="noopener" href="https://github.com/mathiasbynens/base64">base64</a>。</p>
<ul>
<li>编码 Unicode 字符</li>
</ul>
<p><code>btoa</code> 仅仅支持 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ISO-8859-1">Latin1</a> 范围的字符（其编码范围是 <code>0x00-0xFF</code>，<code>0x00-0x7F</code> 之间完全和 ASCII 一致，<code>0x80-0x9F</code> 之间是控制字符，<code>0xA0-0xFF</code> 之间是文字符号），不能编码 Unicode 字符，对 Unicode 字符串进行编码都会触发字符越界的异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello, 中国！&#x27;</span>;</span><br><span class="line"><span class="title function_">btoa</span>(str); <span class="comment">// Uncaught DOMException: ...The string to be encoded contains characters outside of the Latin1 range.</span></span><br></pre></td></tr></table></figure>

<p>原因是这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 <code>0x00 ~ 0xFF</code> 范围，则会引发 InvalidCharacterError 异常。这只是 <code>btoa</code> 这个方法的局限，并不是 Base64 的局限，Base64 可以编码所有的二进制数据。</p>
<p>解决办法是先把 Unicode 字符串转换为 UTF-8 编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello, 中国！&#x27;</span>)); <span class="comment">// SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(<span class="string">&#x27;SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=&#x27;</span>)); <span class="comment">// Hello, 中国！</span></span><br></pre></td></tr></table></figure>

<h3 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h3><p>dataURL 是 data 类型的 URL，指含有 Base64 数据的 URL，用于在 URL 中使用二进制数据，在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2397">RFC2397</a> 中提出，完整的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:文件类型;编码方式,编码后的文件内容</span><br><span class="line">data: [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data</span><br></pre></td></tr></table></figure>

<p>比如，文本和图片的 dataURL 表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/plain;charset=UTF-8;base64,5L2g5aW977yM5Lit5paH77yB</span><br><span class="line">data:image/gif;base64,xxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>dataURL 在 <code>img src</code>、<code>background url</code>、<code>link href</code>、<code>script src</code>… 中使用。</p>
<ul>
<li>dataURL 生成</li>
</ul>
<p>Web API 中的 <code>FileReader.readAsDataURL</code> 可以将一个文件转为 dataURL，图片还可以使用 canvas 的 <code>canvas.toDataURL</code> 生成。将一个 dataURL 转为 <code>Blob</code> 或者 <code>File</code>，<a href="/rep/foundation/base64.js">dataURLtoBlob</a>、<a href="/rep/foundation/base64.js">dataURLtoFile</a>。</p>
<h2 id="URL-Safe"><a href="#URL-Safe" class="headerlink" title="URL Safe"></a>URL Safe</h2><p>由于标准的 Base64 编码可能会出现 <code>+</code>、<code>/</code>、<code>=</code> 字符，这在 URL、Cookie 中不能直接作为参数，会造成歧义，所以又有一种 “URL Safe” 的 Base64 编码，其实就是把字符 <code>+</code> 和 <code>/</code> 分别变成 <code>-</code> 和 <code>_</code>，把 <code>=</code> 去掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base64.b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd++//</span></span><br><span class="line">base64.urlsafe_b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd--__ </span></span><br><span class="line">base64.urlsafe_b64decode(<span class="string">&#x27;abcd--__&#x27;</span>) <span class="comment"># i\xb7\x1d\xfb\xef\xff</span></span><br><span class="line"></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA==&#x27;</span>) <span class="comment"># abcd</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># 出错</span></span><br><span class="line"></span><br><span class="line">safe_b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># abcd</span></span><br></pre></td></tr></table></figure>

<h2 id="Base64-的应用"><a href="#Base64-的应用" class="headerlink" title="Base64 的应用"></a>Base64 的应用</h2><h3 id="网络传输协议中"><a href="#网络传输协议中" class="headerlink" title="网络传输协议中"></a>网络传输协议中</h3><p>Base64 的用途之一就是便于用文本或二进制文件数据的传送。 在网络传输中，Base64 一般适合以下场合的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 传输信道只支持 ASCII 字符，不方便传输二进制流的场合；</span><br><span class="line">* 含有非 ASCII 字符（127 位以后字符），容易出现编码问题的场合；</span><br></pre></td></tr></table></figure>

<ul>
<li>SMTP</li>
</ul>
<p>Base64 最早就是用来邮件传输协议（SMTP）中的，是作为 MIME 多媒体电子邮件标准的一部分开发的，原因是邮件传输协议是一个文本协议，只支持 ASCII 字符（纯文本，可打印）传输，如果要传输二进制文件（比如邮件附件中的图像、声音等）和非 ASCII 字符，就需要用 Base64 将二进制文件内容和非 ASCII 字符编码为只包含 ASCII 字符的内容，并指定 MIME（多用途互联网邮件扩展类型）（详情参考 HTTP 里面相关说明）。</p>
<p>例如，正文为空，带一个名为 hello.txt 的附件，内容为<code>您好！世界！</code>。导出邮件源码，其关键部分如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIME-Version: 1.0                           # 表示当前使用MIME标准1.0版本</span><br><span class="line">Content-Type: text/plain; name=&quot;hello.txt&quot;  # 表示附件文件名为 hello.txt ，格式为纯文本</span><br><span class="line"></span><br><span class="line">Content-Transfer-Encoding: base64           # 表示附件文件内容使用 base64 编码后传输。可选值 7bit、8bit、binary、quoted-printable、base64、custom</span><br><span class="line">5oKo5aW977yM5LiW55WM77yB                    # 文件内容 您好，世界！ Base64编码后的结果</span><br></pre></td></tr></table></figure>

<p>不过，MIME 使用的不是标准 Base64 编码。</p>
<ul>
<li>HTTP</li>
</ul>
<p>HTTP 是超文本传输协议，可以传输纯文本（底层也是二进制流），也可以直接传输二进制数据流。在传输纯文本的时候，由于有些数据格式不符合协议本身的规范，这时候就需要对这些数据进行编码处理成安全格式，从而可以合法地作为首部字段和正文的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：=、空格、:、+、/、换行符...；</span><br><span class="line">非 ASCII 码：比如中文；</span><br></pre></td></tr></table></figure>

<p>当然，在 HTTP 中，URI 编码一般都会用配套的 URIencode，而不使用 Base64，除非需要编码二进制文件为 DataURL。对于 URL 的编码，请看相关章节。</p>
<p>注：HTTP 也支持 MIME，请查看相关章节。</p>
<h3 id="dataURL"><a href="#dataURL" class="headerlink" title="dataURL"></a>dataURL</h3><ul>
<li>img src、background url、link href、script src、图片预览和上传</li>
</ul>
<p>注：图片预览和上传这个需求用 Blob 更合理，Blob 通过 URL.createObjectURL 也能预览。</p>
<h3 id="X-509-公钥证书、HTTP-基本认证和摘要认证"><a href="#X-509-公钥证书、HTTP-基本认证和摘要认证" class="headerlink" title="X.509 公钥证书、HTTP 基本认证和摘要认证"></a>X.509 公钥证书、HTTP 基本认证和摘要认证</h3><p>在<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/6184913.html">基本认证</a>、<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/6189065.html">摘要认证</a></p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-about">
                <h2>About</h2>
                <p>
                    愿你走出半生，归来仍是少年
                </p>
            </div>
            
<div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-categories">
    <h2>Categories</h2>
    <p>
        
        <a class="footer-post" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
        
        <a class="footer-post" href="/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/">可视化</a>
        
        <a class="footer-post" href="/categories/%E5%B0%91%E5%84%BF%E7%BC%96%E7%A8%8B/">少儿编程</a>
        
        <a class="footer-post" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a>
        
    </p>
</div>

            <div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-search">
    <h2>Search</h2>
    <form class="site-search-form">
        <input type="text" id="local-search-input" class="st-search-input" />
    </form>
    <div id="local-search-result" class="local-search-result-cls"></div>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    Copyright©Tracy-xu'Blog. All Rights Reserved.
                </div>
            </div>
        </div>
    </div>
</footer>


<!-- After footer scripts -->
<!-- jQuery -->
<script src="/plugins/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="/plugins/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="/plugins/featherlight/featherlight.min.js"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->


<!-- 百度统计 -->
<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?ccf93dea02efa86a1adbfce533e0752f';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<!-- mermaid chart -->
<script src="https://unpkg.com/mermaid@latest/dist/mermaid.min.js"></script>
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: 'forest' });
  }
</script>


</body>

</html>
