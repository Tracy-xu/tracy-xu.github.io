<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Tracy-xu&#39;Blog">
    

    <!--Author-->
    
        <meta name="author" content="Tracy Xu">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Base 64 编码"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="Tracy-xu&#39;Blog" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Tracy-xu&#39;Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>Base 64 编码 - Tracy-xu&#39;Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/plugins/bootstrap/css/bootstrap.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom Fonts -->
    <link href="/plugins/font-awesome/css/font-awesome.min.css" type="text/css" rel="stylesheet" />

    <!-- Gallery -->
    <link href="/plugins/featherlight/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Tracy-xu'Blog" type="application/atom+xml">
</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    首页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    归档
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    分类
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    关于我
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>


<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2017/05/10/Base-64/">
                Base 64 编码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-05-10</span>
            
            
            
                <span class="category">
                    <a href="/categories/foundations/">foundations</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <p>Base64 是一种用 64 个可打印字符来表示任意二进制数据的二进制编码方法。可以用来处理和传输任意二进制数据。</p>
<p>Base64 最初是用在电子邮件中，为了满足电子邮件中不能直接使用非 ASCII 码字符的规定，用来传输二进制文件的。除此之外，它还可将任意不可打印的二进制数据，转化为可打印的文本编码，使用文本软件进行编辑（二进制流中有很多都是无法显示和打印的，比如 ASCII 中的控制字符，二进制文件 jpg、pad、exe 等，如果用记事本打开这些文件，会看到一堆乱码）。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Base64 编码将一个 8 位字节序列拆散为 6 位的片段，并为每个 6 位的片段分配一个字符，这个字符是 Base64 字母表中的 64 个字符之一。这 64 个输出字符都是很常见的 ASCII 字符，包括大小写字母、数字、＋ 和 &#x2F;，还使用了特殊字符 &#x3D;。</p>
<p>Base64 编码表 (The Base64 Alphabet)：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
<th>索引</th>
<th>对应字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>17</td>
<td>R</td>
<td>34</td>
<td>i</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>18</td>
<td>S</td>
<td>35</td>
<td>j</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>19</td>
<td>T</td>
<td>36</td>
<td>k</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>20</td>
<td>U</td>
<td>37</td>
<td>l</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>21</td>
<td>V</td>
<td>38</td>
<td>m</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>22</td>
<td>W</td>
<td>39</td>
<td>n</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>23</td>
<td>X</td>
<td>40</td>
<td>o</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>24</td>
<td>Y</td>
<td>41</td>
<td>p</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>25</td>
<td>Z</td>
<td>42</td>
<td>q</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>26</td>
<td>a</td>
<td>43</td>
<td>r</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>27</td>
<td>b</td>
<td>44</td>
<td>s</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>28</td>
<td>c</td>
<td>45</td>
<td>t</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>29</td>
<td>d</td>
<td>46</td>
<td>u</td>
<td>63</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>30</td>
<td>e</td>
<td>47</td>
<td>v</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>31</td>
<td>f</td>
<td>48</td>
<td>w</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>32</td>
<td>g</td>
<td>49</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>Q</td>
<td>33</td>
<td>h</td>
<td>50</td>
<td>y</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>还可以自己定义 64 个字符的排列顺序，这样就可以自定义 Base64 编码，不过，通常情况下完全没有必要。Base64 是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>
<p>注意：由于 Base64 编码用了 8 位字符来表示信息中的 6 个位，所以 Base64 编码字符串大约比原始值增加了 33%，(8 - 6) &#x2F; 6 &#x3D; 1&#x2F;3，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>下面是一个简单的 Base64 编码实例。在这里，三个字符组成的输入值 “Ow!” 是 Base64 编码的，得到的是 4 个字符的 Base64 编码值 “T3ch”。它是按以下方式工作的。</p>
<table>
<thead>
<tr>
<th>8 位字符</th>
<th>O</th>
<th>w</th>
<th>!</th>
</tr>
</thead>
<tbody><tr>
<td>8 位值（十六进制）</td>
<td>$4F</td>
<td>$77</td>
<td>$21</td>
</tr>
<tr>
<td>8 位值（二进制）</td>
<td>01001111</td>
<td>01110111</td>
<td>00100001</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>对上面 8 位值（二进制）进行拆分</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>6 位值（二进制）</td>
<td>010011</td>
<td>110111</td>
<td>011100</td>
<td>100001</td>
</tr>
<tr>
<td>6 位值（十进制）</td>
<td>19</td>
<td>55</td>
<td>28</td>
<td>33</td>
</tr>
<tr>
<td>Base64 字符</td>
<td>T</td>
<td>3</td>
<td>c</td>
<td>h</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 字符串 &quot;Ow!&quot; 被拆分成 3 个 8 位的字节 (0x4F、0x77、0x21)；</span><br><span class="line">* 这 3 个字节构成了一个 24 位的二进制 01001111 01110111 00100001；</span><br><span class="line">* 这些位被划分为一些 6 位的序列 010011、110111、011100、100001；</span><br><span class="line">* 每个 6 位值都表示了从 0~63 之间的一个数字，对应 Base64 字母表中的 64 个字符之一。得到的 Base64 编码字符串是 4 个字符的字符串 &quot;T3ch&quot;。然后就可以通过线路将这个字符串作为“安全的” 8 位字符传送出去，因为只用了一些移植性最好的字符（字母、数字等）；</span><br></pre></td></tr></table></figure>

<ul>
<li>用 JavaScript 描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Ow!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> binary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> binStr = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">2</span>); <span class="comment">// charCodeAt 返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数</span></span><br><span class="line">  binary.<span class="title function_">push</span>(binStr); <span class="comment">// [&#x27;1001111&#x27;, &#x27;1110111&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个正常的字节都是由 8bit 组成的，不够 8bit 需要在高位补 0，于是得到 [&#x27;01001111&#x27;, &#x27;01110111&#x27;, &#x27;00100001&#x27;]</span></span><br><span class="line"><span class="comment">// 1 把字符串按照 6 位分开，进行分割，得到 [&#x27;010011&#x27;, &#x27;110111&#x27;, &#x27;011100&#x27;, &#x27;100001&#x27;]</span></span><br><span class="line"><span class="comment">// 2 将每一个转换为十进制分别对于 [19, 55, 28, 33];</span></span><br><span class="line"><span class="comment">// 3 将每一位数字分别对于上面提供的 Base64 对应表,得到对应的编码，分别对于 T3ch</span></span><br><span class="line"><span class="comment">// 4 最后就会得到 Base64 编码 T3ch</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字符 &quot;Ow!&quot; 最后得到的 Base64 编码为&quot; T3ch&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>前提 – 确定具体的编码方案</li>
</ul>
<p>需要注意的是，ASCII 码 128 位后的字符，各个编码方案不兼容，比如汉字有 gb2312、utf-8、gbk 等，每一种编码的 Base64 对应值都不一样，是用 Base64 进行编码前，需要确定编码方案。下面以’严’的 UTF-8 为例：</p>
<p>“严”的 UTF-8 编码为 E4B8A5，写成二进制就是三字节的 “11100100 10111000 10100101”。将这个 24 位的二进制字符串，转换成四组一共 32 位的二进制值”111001 001011 100010 100101”，相应的十进制数为 57、11、34、37，它们对应的 Base64 值就为5、L、i、l。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeJS（btoa 不支持中文）</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&#x27;严&#x27;</span>);</span><br><span class="line">b.<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>); <span class="comment">// 5Lil</span></span><br></pre></td></tr></table></figure>

<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>Base64 编码收到一个 8 位字节序列，将这个二进制序列流划分成 6 位的块。二进制序列有时不能正好平均地分为 6 位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为 24 的倍数（6 和 8 的最小公倍数）。</p>
<p>对已填充的二进制进行编码时，任何完全填充（不包括原始数据中的位）的 6 位组都有特殊的第 65 个符号 “&#x3D;” 表示。如果 6 位组是部分填充的，就将填充位设置为 0。</p>
<p>下面是一个填充实例：</p>
<table>
<thead>
<tr>
<th>输入数据</th>
<th>二进制序列（填充位以 x 表示）</th>
<th>已编码数据</th>
</tr>
</thead>
<tbody><tr>
<td>a:a</td>
<td>011000 010011 101001 100001</td>
<td>YTph</td>
</tr>
<tr>
<td>a:aa</td>
<td>011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx</td>
<td>YTphYQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>a:aaa</td>
<td>011000 010011 101001 100001 011000 010110 0001xx xxxxxx</td>
<td>YTphYWE&#x3D;</td>
</tr>
<tr>
<td>a:aaaa</td>
<td>011000 010011 101001 100001 011000 010110 000101 1000001</td>
<td>YTphYWFh</td>
</tr>
</tbody></table>
<p>初始输入字符串为 “a:a” 为 3 个字节（24 位）。24 是 6 和 8 的倍数，因此按照上面给出的例子计算。无需填充就会得到 Base64 编码为 “YTph”。</p>
<p>然而，再增加一个字符，输入字符串变为 “a:aa”，转换为二进制就会有 32 位长。而 6 和 8 的下一个公倍数为 48，因此要添加 16 位的填充码。填充的前 4 位是与数据位混合在一起的。得到的 6 位组 01xxxx，会被当作 010000、十进制中的 16，或者 Base64 编码的 Q 来处理。剩下的两个 6 位组都是填充码，用 &#x3D; 来表示。</p>
<p>‘O’ 的填充实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x27;O&#x27;.charCodeAt().toString(2);</span><br><span class="line">得到二进制（位数不够 8 位时，需要在高位补码）</span><br><span class="line">1001111 --&gt; 01001111</span><br><span class="line">-----------------------------------------</span><br><span class="line">按 6 位拆分二进制（位数不是 24 的倍数时，需要低位补码）</span><br><span class="line">010011, 11xxxx, xxxxxx, xxxxxx</span><br><span class="line">-----------------------------------------</span><br><span class="line">转为十进制</span><br><span class="line">19, 48</span><br><span class="line">-----------------------------------------</span><br><span class="line">Base64 查表结果</span><br><span class="line">Tw==</span><br></pre></td></tr></table></figure>


<h2 id="JavaScript-中（前端）Base64-编码实现"><a href="#JavaScript-中（前端）Base64-编码实现" class="headerlink" title="JavaScript 中（前端）Base64 编码实现"></a>JavaScript 中（前端）Base64 编码实现</h2><h3 id="字符的编码"><a href="#字符的编码" class="headerlink" title="字符的编码"></a>字符的编码</h3><p>对于字符串来说，在 Web API 中，有两个函数分别用来 Base64 编码和解码的：atob 和 btoa。btoa 函数能够将二进制的字节数据（binary bytes）编码成 ASCII 字符串；相反地，atob 函数能够解码通过 Base64 编码的字符串数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;a:a&#x27;</span>); <span class="comment">// YTph</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">&#x27;YTph&#x27;</span>); <span class="comment">// a:a</span></span><br></pre></td></tr></table></figure>

<p>注：btoa 和 atob 分别是 Binary to ASCII 和 ASCII to binary 的缩写。b 不是 Base64 的缩写，计算机中的所有数据的本质都是二进制，我们所看到的文字、符号、图片、语音视频…，都是二进制数据在具体编码（字符编码、图像编码…）下的表现。</p>
<ul>
<li>Unicode 字符</li>
</ul>
<p>btoa 仅仅支持 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ISO-8859-1">Latin1</a> 范围的字符（其编码范围是 0x00-0xFF，0x00-0x7F 之间完全和 ASCII 一致，0x80-0x9F 之间是控制字符，0xA0-0xFF 之间是文字符号），不能编码 Unicode 字符，对 Unicode 字符串进行编码都会触发字符越界的异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello, 中国！&#x27;</span>;</span><br><span class="line"><span class="title function_">btoa</span>(str); <span class="comment">// Uncaught DOMException: ...The string to be encoded contains characters outside of the Latin1 range.</span></span><br></pre></td></tr></table></figure>

<p>原因是，由于这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 0x00 ~ 0xFF 范围，则会引发 InvalidCharacterError 异常。这只是 btoa 这个方法的局限，并不是 Base64 的局限，Base64 可以编码所有的二进制数据。</p>
<p>解决办法是，先把 Unicode 字符串转换为 UTF-8 编码。这里我们可以先将带有非 的串先用 encodeURIComponent 编码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;Hello, 中国！&#x27;</span>)); <span class="comment">// SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(<span class="string">&#x27;SGVsbG8lMkMlMjAlRTQlQjglQUQlRTUlOUIlQkQlRUYlQkMlODE=&#x27;</span>)); <span class="comment">// Hello, 中国！</span></span><br></pre></td></tr></table></figure>

<p>注意，编码的过程是先 encodeURI，再编码，那么解码的过程应该是先解码，再 decodeURI。</p>
<ul>
<li>兼容</li>
</ul>
<p>另外，IE9 不支持 atob 和 btoa，解决方案是手动实现 Base64 编解码函数：<a target="_blank" rel="noopener" href="https://github.com/dankogai/js-base64">js-base64</a>、<a target="_blank" rel="noopener" href="https://github.com/mathiasbynens/base64">base64</a>。</p>
<h3 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h3><p>dataURL 是 data 类型的 URL，指的是含有 Base64 数据的 URL，目的是在 URL 中使用二进制数据，是在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2397">RFC2397</a> 中提出的，其完整的语法定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataurl := &quot;data:&quot; [ mediatype ] [ &quot;;base64&quot; ] &quot;,&quot; data      # data:文件类型;编码方式,编码后的文件内容</span><br><span class="line">mediatype := [ type &quot;/&quot; subtype ] *( &quot;;&quot; parameter )</span><br><span class="line">data := *urlchar</span><br><span class="line">parameter := attribute &quot;=&quot; value</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 文本</span><br><span class="line">data:text/plain;charset=UTF-8;base64,5L2g5aW977yM5Lit5paH77yB</span><br><span class="line"></span><br><span class="line"># 图片</span><br><span class="line">data:image/gif;base64,xxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>dataURL 可用在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img src</span><br><span class="line">background url</span><br><span class="line">link href</span><br><span class="line">script src</span><br></pre></td></tr></table></figure>

<ul>
<li>FileReader</li>
</ul>
<p>Web API 中的 FileReader.readAsDataURL 可以将一个文件转为 dataURL。</p>
<ul>
<li>将一个 dataURL 转为 Blob 或者 File</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dataURLtoBlob</span>(<span class="params">dataURL</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataURL.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].<span class="title function_">match</span>(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="title function_">atob</span>(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = binaryString.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = binaryString.<span class="title function_">charCodeAt</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blob</span>([u8arr], &#123;<span class="attr">type</span>: mime&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dataURLtoFile</span>(<span class="params">dataURL, fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = dataURL.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].<span class="title function_">match</span>(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> binaryString = <span class="title function_">atob</span>(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> n = binaryString.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    u8arr[n] = binaryString.<span class="title function_">charCodeAt</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>([u8arr], fileName, &#123;<span class="attr">type</span>:mime&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是图片的话，其实还可以将图片放在 canvas 中，利用 canvas.toBlob 来转（img.onload 导致速度没有上面的方式快）。</p>
<h2 id="Base64-的应用"><a href="#Base64-的应用" class="headerlink" title="Base64 的应用"></a>Base64 的应用</h2><h3 id="网络传输协议中"><a href="#网络传输协议中" class="headerlink" title="网络传输协议中"></a>网络传输协议中</h3><p>Base64 的用途之一就是便于用文本或二进制文件数据的传送。 在网络传输中，Base64 一般适合以下场合的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 传输信道只支持 ASCII 字符，不方便传输二进制流的场合；</span><br><span class="line">* 含有非 ASCII 字符（127 位以后字符），容易出现编码问题的场合；</span><br></pre></td></tr></table></figure>

<ul>
<li>SMTP</li>
</ul>
<p>Base64 最早就是用来邮件传输协议（SMTP）中的，是作为 MIME 多媒体电子邮件标准的一部分开发的，原因是邮件传输协议是一个文本协议，只支持 ASCII 字符（纯文本，可打印）传输，如果要传输二进制文件（比如邮件附件中的图像、声音等）和非 ASCII 字符，就需要用 Base64 将二进制文件内容和非 ASCII 字符编码为只包含 ASCII 字符的内容，并指定 MIME（多用途互联网邮件扩展类型）（详情参考 HTTP 里面相关说明）。</p>
<p>例如，正文为空，带一个名为 hello.txt 的附件，内容为<code>您好！世界！</code>。导出邮件源码，其关键部分如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MIME-Version: 1.0                           # 表示当前使用MIME标准1.0版本</span><br><span class="line">Content-Type: text/plain; name=&quot;hello.txt&quot;  # 表示附件文件名为 hello.txt ，格式为纯文本</span><br><span class="line"></span><br><span class="line">Content-Transfer-Encoding: base64           # 表示附件文件内容使用 base64 编码后传输。可选值 7bit、8bit、binary、quoted-printable、base64、custom</span><br><span class="line">5oKo5aW977yM5LiW55WM77yB                    # 文件内容 您好，世界！ Base64编码后的结果</span><br></pre></td></tr></table></figure>

<p>不过，MIME 使用的不是标准 Base64 编码。</p>
<ul>
<li>HTTP</li>
</ul>
<p>HTTP 是超文本传输协议，可以传输纯文本（底层也是二进制流），也可以直接传输二进制数据流。在传输纯文本的时候，由于有些数据格式不符合协议本身的规范，这时候就需要对这些数据进行编码处理成安全格式，从而可以合法地作为首部字段和正文的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特殊字符：=、空格、:、+、/、换行符...；</span><br><span class="line">非 ASCII 码：比如中文；</span><br></pre></td></tr></table></figure>

<p>当然，在 HTTP 中，URI 编码一般都会用配套的 URIencode，而不使用 Base64，除非需要编码二进制文件为 DataURL。对于 URL 的编码，请看相关章节。</p>
<p>注：HTTP 也支持 MIME，请查看相关章节。</p>
<h3 id="dataURL"><a href="#dataURL" class="headerlink" title="dataURL"></a>dataURL</h3><ul>
<li>img src、background url、link href、script src、图片预览和上传</li>
</ul>
<p>注：图片预览和上传这个需求用 Blob 更合理，Blob 通过 URL.createObjectURL 也能预览。</p>
<h3 id="X-509-公钥证书、HTTP-基本认证和摘要认证"><a href="#X-509-公钥证书、HTTP-基本认证和摘要认证" class="headerlink" title="X.509 公钥证书、HTTP 基本认证和摘要认证"></a>X.509 公钥证书、HTTP 基本认证和摘要认证</h3><p>在<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/6184913.html">基本认证</a>、<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xiaohuochai/p/6189065.html">摘要认证</a></p>
<p>详情参考 HTTP 中认证相关章节。</p>
<p>数字证书签名</p>
<p>TODO。。。此节由于知识有限，没有完成，待完成。</p>
<h3 id="掩人耳目"><a href="#掩人耳目" class="headerlink" title="掩人耳目"></a>掩人耳目</h3><p>简易的掩人耳目，至少非开发人一眼看不出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;xwblearn2008@126.com&#x27;</span>); <span class="comment">// eHdibGVhcm4yMDA4QDEyNi5jb20=</span></span><br></pre></td></tr></table></figure>


<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="不能用于数据加密或数据校验"><a href="#不能用于数据加密或数据校验" class="headerlink" title="不能用于数据加密或数据校验"></a>不能用于数据加密或数据校验</h3><p>Base64 是一种数据编码方式，目的是让数据符合传输协议的要求，不能将其误用于数据加密或数据校验。标准 Base64 编码解码无需额外信息即完全可逆，即使自定义字符集设计一种类 Base64 的编码方式用于数据加密，在多数场景下也较容易破解。</p>
<p>对于数据加密应该使用专门的目前还没有有效方式快速破解的加密算法。比如：对称加密算法 AES-128-CBC，对称加密需要密钥，只要密钥没有泄露，通常难以破解。也可以使用非对称加密算法，如 RSA，利用极大整数因数分解的计算量极大这一特点，使得使用公钥加密的数据，只有使用私钥才能快速解密。</p>
<p>对于数据校验，也应该使用专门的消息认证码生成算法，如 HMAC 一种使用单向散列函数构造消息认证码的方法，其过程是不可逆的、唯一确定的，并且使用密钥来生成认证码，其目的是防止数据在传输过程中被篡改或伪造。将原始数据与认证码一起传输，数据接收端将原始数据使用相同密钥和相同算法再次生成认证码，与原有认证码进行比对，校验数据的合法性。</p>
<ul>
<li>扩展</li>
</ul>
<p>针对各大网站被脱库的问题，请问应该怎么存储用户的登录密码？</p>
<p>答案是：在注册时，根据用户设置的登录密码，生成其消息认证码，然后存储用户名和消息认证码，不存储原始密码。每次用户登录时，根据登录密码，生成消息认证码，与数据库中存储的消息认证码进行比对，以确认是否为有效用户，这样即使网站被脱库，用户的原始密码也不会泄露，不会为用户使用的其他网站带来账号风险。</p>
<p>当然，使用的消息认证码算法其哈希碰撞的概率应该极低才行，目前一般在 HMAC 算法中使用 SHA256。对于这种方式需要注意一点：防止用户使用弱密码，否则也可能会被暴力破解。现在的网站一般要求用户密码6个字符以上，并且同时有数字和大小写字母，甚至要求有特殊字符。</p>
<p>另外，也可以使用加入随机 salt 的哈希算法来存储校验用户密码。这里暂不细述。</p>
<h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3><p>Base64 编码字符串大约比原始值扩大了33%。所以，选择 Base64 编码时要考虑一下文件的 size。另外有个小技巧，在 Chrom 中，把要转化的图片直接拖入，使用控制台中的 Source 选项，可直接查看图片的 Base64 编码。</p>
<h3 id="Data-URL-不会被浏览器缓存"><a href="#Data-URL-不会被浏览器缓存" class="headerlink" title="Data URL 不会被浏览器缓存"></a>Data URL 不会被浏览器缓存</h3><p>Data URL 不会被浏览器缓存，每次访问都被下载一次。这是一个使用效率方面的问题——尤其当这个文件被整个网站大量使用的时候。</p>
<h3 id="编码-URL-参数"><a href="#编码-URL-参数" class="headerlink" title="编码 URL 参数"></a>编码 URL 参数</h3><p>由于标准的 Base64 编码后可能出现字符 + 和 &#x2F;，在 URL 中就不能直接作为参数，所以又有一种 “url safe” 的 Base64 编码，其实就是把字符 + 和 &#x2F; 分别变成 - 和 _：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">base64.b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd++//</span></span><br><span class="line">base64.urlsafe_b64encode(<span class="string">&#x27;i\xb7\x1d\xfb\xef\xff&#x27;</span>) <span class="comment"># abcd--__ </span></span><br><span class="line">base64.urlsafe_b64decode(<span class="string">&#x27;abcd--__&#x27;</span>) <span class="comment"># i\xb7\x1d\xfb\xef\xff</span></span><br></pre></td></tr></table></figure>

<p>由于 &#x3D; 字符也可能出现在 Base64 编码中，但 &#x3D; 用在 URL、Cookie 里面会造成歧义，所以，很多 Base64 编码后会把 &#x3D; 去掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA==&#x27;     # 标准 Base64</span><br><span class="line">&#x27;abcd&#x27; -&gt; &#x27;YWJjZA&#x27;       # 自动去掉 =</span><br></pre></td></tr></table></figure>

<p>去掉 &#x3D; 后怎么解码呢？因为 Base64 是把 3 个字节变为 4 个字节，所以，Base64 编码的长度永远是 4 的倍数，因此，需要加上 &#x3D; 把 Base64 字符串的长度变为 4 的倍数，就可以正常解码了。去掉 &#x3D; 的 Base64 解码函数需要手动实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pyhone</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA==&#x27;</span>) <span class="comment"># abcd</span></span><br><span class="line">base64.b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># 出错</span></span><br><span class="line"></span><br><span class="line">safe_b64decode(<span class="string">&#x27;YWJjZA&#x27;</span>) <span class="comment"># abcd</span></span><br></pre></td></tr></table></figure>

<p>注：NodeJS 中没有原生的支持，<a target="_blank" rel="noopener" href="https://github.com/joaquimserafim/base64-url">需要手动处理</a>。</p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-about">
                <h2>About</h2>
                <p>
                    享受编程和技术所带来的快乐
                </p>
            </div>
            
<div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-categories">
    <h2>Categories</h2>
    <p>
        
        <a class="footer-post" href="/categories/network/">network</a>
        
        <a class="footer-post" href="/categories/project/">project</a>
        
        <a class="footer-post" href="/categories/scratch/">scratch</a>
        
        <a class="footer-post" href="/categories/tools/">tools</a>
        
    </p>
</div>

            <div class="col-xs-12 col-sm-12 col-md-4 col-lg-4 footer-search">
    <h2>Search</h2>
    <form class="site-search-form">
        <input type="text" id="local-search-input" class="st-search-input" />
    </form>
    <div id="local-search-result" class="local-search-result-cls"></div>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    Copyright©Tracy-xu'Blog. All Rights Reserved.
                </div>
            </div>
        </div>
    </div>
</footer>


<!-- After footer scripts -->

<!-- jQuery -->
<script src="/plugins/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="/plugins/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="/plugins/featherlight/featherlight.min.js"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>
